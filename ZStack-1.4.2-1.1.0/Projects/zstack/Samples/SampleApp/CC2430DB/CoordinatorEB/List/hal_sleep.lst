##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   17/Oct/2013  21:26:03 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Components\hal\target\CC2430 #
#                          EB\hal_sleep.c                                    #
#    Command line       =  -f E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCoor #
#                          d.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TR #
#                          UE -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS       #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f    #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfig. #
#                          cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800     #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\Source\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mt\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\hal\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          hal\target\CC2430EB\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\osal\mcu #
#                          \ccsoc\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC #
#                          2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\osal\include\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨ #
#                          Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects #
#                          \zstack\Samples\SampleApp\CC2430DB\..\..\..\..\.. #
#                          \Components\stack\af\ -I                          #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\stack\nw #
#                          k\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\st #
#                          ack\sec\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\C #
#                          C2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\ #
#                          Samples\SampleApp\CC2430DB\..\..\..\..\..\Compone #
#                          nts\stack\sys\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶ #
#                          Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\stack\zdo\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\zmac\f8w #
#                          \ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\se #
#                          rvices\saddr\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Co #
#                          mponents\services\sdata\ -I                       #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          mac\high_level\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\..\..\..\..\ #
#                          Components\mac\low_level\srf03\ -I                #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\low_ #
#                          level\srf03\single_chip\ -D CC2430EB -D ZTOOL_P1  #
#                          -D MT_TASK -D MT_ZDO_FUNC -lC                     #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\CoordinatorEB\List\ -lA            #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\CoordinatorEB\List\                #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\CoordinatorEB\Obj\ -e           #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Components\hal\target\CC2430 #
#                          EB\hal_sleep.c                                    #
#    List file          =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\CoordinatorEB\List\hal_sleep.lst   #
#    Object file        =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\CoordinatorEB\Obj\hal_sleep.r51    #
#                                                                            #
#                                                                            #
##############################################################################

E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Components\hal\target\CC2430EB\hal_sleep.c
      1          /**************************************************************************************************
      2              Filename:       hal_sleep.c
      3              Revised:        $Date: 2007-05-15 15:37:47 -0700 (Tue, 15 May 2007) $
      4              Revision:       $Revision: 14304 $
      5          
      6              Description:
      7          
      8              This module contains the HAL power management procedures for the CC2430.
      9          
     10          
     11              Copyright (c) 2006 by Texas Instruments, Inc.
     12              All Rights Reserved.  Permission to use, reproduce, copy, prepare
     13              derivative works, modify, distribute, perform, display or sell this
     14              software and/or its documentation for any purpose is prohibited
     15              without the express written consent of Texas Instruments, Inc.
     16          **************************************************************************************************/
     17          
     18          /* ------------------------------------------------------------------------------------------------
     19           *                                          Includes
     20           * ------------------------------------------------------------------------------------------------
     21           */
     22          #include "hal_types.h"
     23          #include "hal_mcu.h"

   \                                 In segment SFR_AN, at 0x87
   \   unsigned char volatile __sfr PCON
   \                     PCON:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEP
   \                     SLEEP:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCON
   \                     CLKCON:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     24          #include "hal_board.h"
     25          #include "hal_sleep.h"
     26          #include "hal_led.h"
     27          #include "hal_key.h"
     28          #include "mac_api.h"
     29          #include "OSAL.h"
     30          #include "OSAL_Timers.h"
     31          #include "OSAL_Tasks.h"
     32          #include "OSAL_PwrMgr.h"
     33          #include "OnBoard.h"
     34          #include "hal_drivers.h"
     35          
     36          #if !defined (RTR_NWK) && defined (NWK_AUTO_POLL)
     37          #include "nwk_globals.h"
     38          #include "ZGlobals.h"
     39          #endif
     40          
     41          /* ------------------------------------------------------------------------------------------------
     42           *                                           Macros
     43           * ------------------------------------------------------------------------------------------------
     44           */
     45          
     46          /* 32 kHz clock source select in CLKCON */
     47          #if !defined (OSC32K_CRYSTAL_INSTALLED) || (defined (OSC32K_CRYSTAL_INSTALLED) && (OSC32K_CRYSTAL_INSTALLED == TRUE))
     48          #define OSC_32KHZ                        0x00  /* external 32 KHz xosc */
     49          #else
     50          #define OSC_32KHZ                        0x80  /* internal 32 KHz rcosc */
     51          #endif
     52          
     53          /* POWER CONSERVATION DEFINITIONS
     54           * Sleep mode H/W definitions (enabled with POWER_SAVING compile option)
     55           */
     56          #define CC2430_PM0            0  /* PM0, Clock oscillators on, voltage regulator on */
     57          #define CC2430_PM1            1  /* PM1, 32.768 kHz oscillators on, voltage regulator on */
     58          #define CC2430_PM2            2  /* PM2, 32.768 kHz oscillators on, voltage regulator off */
     59          #define CC2430_PM3            3  /* PM3, All clock oscillators off, voltage regulator off */
     60          
     61          /* HAL power management mode is set according to the power management state. The default
     62           * setting is HAL_SLEEP_OFF. The actual value is tailored to different HW platform. Both
     63           * HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections will:
     64           *   1. turn off the system clock, and
     65           *   2. halt the MCU.
     66           * HAL_SLEEP_TIMER can be woken up by sleep timer interrupt, I/O interrupt and reset.
     67           * HAL_SLEEP_DEEP can be woken up by I/O interrupt and reset.
     68           */
     69          #define HAL_SLEEP_OFF         CC2430_PM0
     70          #define HAL_SLEEP_TIMER       CC2430_PM2
     71          #define HAL_SLEEP_DEEP        CC2430_PM3
     72          
     73          /* MAX_SLEEP_TIME calculation:
     74           *   Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
     75           *   Round it to 510 seconds or 510000 ms
     76           */
     77          #define MAX_SLEEP_TIME                   510000             /* maximum time to sleep allowed by ST */
     78          
     79          /* minimum time to sleep, this macro is to:
     80           * 1. avoid thrashing in-and-out of sleep with short OSAL timer (~2ms)
     81           * 2. define minimum safe sleep period for different CC2430 revisions
     82           * AN044 - MINIMUM SLEEP PERIODS WITH PULL-DOWN RESISTOR
     83           */
     84          #if !defined (PM_MIN_SLEEP_TIME)
     85          #define PM_MIN_SLEEP_TIME                14                 /* default to minimum safe sleep time for CC2430 Rev B */
     86          #endif
     87          
     88          /* to disallow PM2/PM3 and use PM1 only set this value to false
     89           * AN044 - RESTRICT_USE_TO_PM1_ONLY
     90           */
     91          #if !defined (PM1_ONLY)
     92          #define PM1_ONLY                         FALSE              /* default to no AN044 - RESTRICT USE TO PM1 ONLY */
     93          #endif
     94          
     95          /* when a device is waken up be key interrupt, it
     96           * should stay in PM1 for PM2_HOLDOFF_TIME expecting
     97           * more key presses. When the timer is expired, the device
     98           * is allowed to go back to PM2 sleep.
     99           * AN044 - COMBINING POWER MODES
    100           */
    101          #if !defined (PM2_HOLDOFF_TIME)
    102          #define PM2_HOLDOFF_TIME                 0
    103          #endif
    104          
    105          /* Add code to set external interrupt line to output, drive the line to inactive level,
    106           * delay for 180us (30us if P1.0 or P1.1), set the line to input as close to PCON.IDLE = 1
    107           * as possible, and set the line tri-state. The following macro is using S1 key as an example.
    108           * User should tailor this macro for different interrupt line(s). On CC2430EB or CC2430DB boards,
    109           * the S1 key is mapped to P0.1. Thus 180us should be used for delays.
    110           * AN044 - DELAYING EXTERNAL INTERRUPTS
    111           */
    112          #define EXTERNAL_INTERRUPT_DELAY()          st(P0DIR |= BV(1);    /* set P0.1 output */            \
    113                                                         P0_1 = 1;          /* drive P0.1 inactive (high) */ \
    114                                                         halSleepWait(180); /* delay 180us */                \
    115                                                         P0DIR &= ~BV(1);   /* set P0.1 input */             \
    116                                                         P0INP |= BV(1);)   /* set P0.1 tri-state */
    117          
    118          /* This value is used to adjust the sleep timer compare value such that the sleep timer
    119           * compare takes into account the amount of processing time spent in function halSleep().
    120           * The first value is determined by measuring the number of sleep timer ticks it from
    121           * the beginning of the function to entering sleep mode.  The second value is determined
    122           * by measuring the number of sleep timer ticks from exit of sleep mode to the call to
    123           * osal_adjust_timers().
    124           */
    125          #define HAL_SLEEP_ADJ_TICKS   (9 + 25)
    126          
    127          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
    128          /* set CC2430 power mode; always use PM2 */
    129          #define HAL_SLEEP_SET_POWER_MODE(mode)      st( if( CHVER <= REV_D )                    \
    130                                                          {                                       \
    131                                                            HAL_SLEEP_SET_POWER_MODE_REV_D(mode); \
    132                                                          }                                       \
    133                                                          else                                    \
    134                                                          {                                       \
    135                                                            HAL_SLEEP_SET_POWER_MODE_REV_E(mode); \
    136                                                          }; )
    137          #else
    138          /* Debug: don't set power mode, just block until sleep timer interrupt */
    139          #define HAL_SLEEP_SET_POWER_MODE(mode)      st( while(halSleepInt == FALSE); \
    140                                                          halSleepInt = FALSE; )
    141          #endif
    142          
    143          /* for revision E, this sw workaround require additional code in all
    144           * ISR's that are used to wake up from PM.
    145           */
    146          #define HAL_SLEEP_SET_POWER_MODE_REV_E(mode) st( SLEEP &= ~0x03;  /* clear mode bits */               \
    147                                                           SLEEP |= mode;   /* set mode bits   */               \
    148                                                           asm("NOP");                                          \
    149                                                           asm("NOP");                                          \
    150                                                           asm("NOP");                                          \
    151                                                           if( SLEEP & 0x03 )                                   \
    152                                                           {                                                    \
    153                                                             PCON |= 0x01;  /* enable mode */                   \
    154                                                             asm("NOP");    /* first instruction after sleep*/  \
    155                                                           }; )
    156          
    157          /* for revision D and earlier */
    158          #define HAL_SLEEP_SET_POWER_MODE_REV_D(mode)   st(SLEEP &= ~0x03;  /* clear mode bits */               \
    159                                                            SLEEP |= mode;   /* set mode bits   */               \
    160                                                            PCON |= 0x01;    /* enable mode     */               \
    161                                                            asm("NOP");)     /* first instruction after sleep*/
    162          
    163          /* set main clock source to crystal (exit sleep) */
    164          #define HAL_SLEEP_SET_MAIN_CLOCK_CRYSTAL()  st(SLEEP &= ~0x04;          /* turn on both oscs */ \
    165                                                         while(!(SLEEP & 0x40));  /* wait for XOSC */     \
    166                                                         asm("NOP");                                      \
    167                                                         halSleepWait(63);        /* required for Rev B */\
    168                                                         CLKCON = (0x00 | OSC_32KHZ);   /* 32MHx XOSC */  \
    169                                                         while (CLKCON != (0x00 | OSC_32KHZ));            \
    170                                                         SLEEP |= 0x04;)          /* turn off 16MHz RC */
    171          
    172          /* set main clock source to RC oscillator (enter sleep) */
    173          #define HAL_SLEEP_SET_MAIN_CLOCK_RC()       st(SLEEP &= ~0x04;          /* turn on both oscs */     \
    174                                                         while(!(SLEEP & 0x20));  /* wait for RC osc */       \
    175                                                         asm("NOP");                                          \
    176                                                         CLKCON = (0x49 | OSC_32KHZ); /* select RC osc */     \
    177                                                         /* wait for requested settings to take effect */     \
    178                                                         while (CLKCON != (0x49 | OSC_32KHZ));                \
    179                                                         SLEEP |= 0x04;)          /* turn off XOSC */
    180          
    181          /* sleep and external interrupt port masks */
    182          #define STIE_BV                             BV(5)
    183          #define P0IE_BV                             BV(5)
    184          #define P1IE_BV                             BV(4)
    185          #define P2IE_BV                             BV(1)
    186          
    187          /* sleep timer interrupt control */
    188          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)     /* enable sleep timer interrupt */
    189          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;)    /* disable sleep timer interrupt */
    190          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(IRCON &= ~0x80;)      /* clear sleep interrupt flag */
    191          
    192          /* backup interrupt enable registers before sleep */
    193          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2) st(ien0  = IEN0;    /* backup IEN0 register */ \
    194                                                                       ien1  = IEN1;    /* backup IEN1 register */ \
    195                                                                       ien2  = IEN2;    /* backup IEN2 register */ \
    196                                                                       IEN0 &= STIE_BV; /* disable IEN0 except STIE */ \
    197                                                                       IEN1 &= P0IE_BV; /* disable IEN1 except P0IE */ \
    198                                                                       IEN2 &= (P1IE_BV|P2IE_BV);) /* disable IEN2 except P1IE, P2IE */
    199          
    200          /* restore interrupt enable registers before sleep */
    201          #define HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2) st(IEN0 = ien0;   /* restore IEN0 register */ \
    202                                                            IEN1 = ien1;   /* restore IEN1 register */ \
    203                                                            IEN2 = ien2;)  /* restore IEN2 register */
    204          
    205          /* Internal (MCU) Stack addresses. This is to check if the stack is exceeding the disappearing
    206           * RAM boundary of 0xF000. If the stack does exceed the boundary (unlikely), do not enter sleep
    207           * until the stack is back to normal.
    208           */
    209          #define CSTK_PTR _Pragma("segment=\"XSP\"") __segment_begin("XSP")
    210          
    211          /* convert msec to 320 usec units with round */
    212          #define HAL_SLEEP_MS_TO_320US(ms)           (((((uint32) (ms)) * 100) + 31) / 32)
    213          
    214          /* for optimized indexing of uint32's */
    215          #if HAL_MCU_LITTLE_ENDIAN()
    216          #define UINT32_NDX0   0
    217          #define UINT32_NDX1   1
    218          #define UINT32_NDX2   2
    219          #define UINT32_NDX3   3
    220          #else
    221          #define UINT32_NDX0   3
    222          #define UINT32_NDX1   2
    223          #define UINT32_NDX2   1
    224          #define UINT32_NDX3   0
    225          #endif
    226          
    227          /* ------------------------------------------------------------------------------------------------
    228           *                                        Local Variables
    229           * ------------------------------------------------------------------------------------------------
    230           */
    231          
    232          /* HAL power management mode is set according to the power management state.
    233           */

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    234          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
   \                     ??halPwrMgtMode:
   \   000000                DS 1
    235          
    236          /* stores the sleep timer count upon entering sleep */

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    237          static uint32 halSleepTimerStart;
   \                     ??halSleepTimerStart:
   \   000000                DS 4
    238          
    239          /* stores the accumulated sleep time */

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    240          static uint32 halAccumulatedSleepTime;
   \                     ??halAccumulatedSleepTime:
   \   000000                DS 4
    241          
    242          /* stores the deepest level the device is allowed to sleep
    243           * See AN044 - COMBINING POWER MODES
    244           */

   \                                 In segment XDATA_I, align 1, keep-with-next
    245          static uint8 halSleepLevel = CC2430_PM2;
   \                     ??halSleepLevel:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for halSleepLevel>`
   \   000001                REQUIRE __INIT_XDATA_I
    246          
    247          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    248          static bool halSleepInt = FALSE;
    249          #endif
    250          
    251          /* ------------------------------------------------------------------------------------------------
    252           *                                      Function Prototypes
    253           * ------------------------------------------------------------------------------------------------
    254           */
    255          
    256          void halSleepSetTimer(uint32 timeout);
    257          uint32 HalTimerElapsed( void );
    258          
    259          /**************************************************************************************************
    260           * @fn          halSleep
    261           *
    262           * @brief       This function is called from the OSAL task loop using and existing OSAL
    263           *              interface.  It sets the low power mode of the MAC and the CC2430.
    264           *
    265           * input parameters
    266           *
    267           * @param       osal_timeout - Next OSAL timer timeout.
    268           *
    269           * output parameters
    270           *
    271           * None.
    272           *
    273           * @return      None.
    274           **************************************************************************************************
    275           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    276          void halSleep( uint16 osal_timeout )
   \                     halSleep:
    277          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    278            uint32        timeout;
    279            uint32        macTimeout;
    280            halIntState_t intState, ien0, ien1, ien2;
    281          
    282            halAccumulatedSleepTime = 0;
   \   00000E   90....       MOV     DPTR,#__Constant_0
   \   000011   78..         MOV     R0,#?V0 + 0
   \   000013   12....       LCALL   ?L_MOV_X
   \   000016   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?L_MOV_TO_X
    283          
    284            /* get next OSAL timer expiration converted to 320 usec units */
    285            timeout = HAL_SLEEP_MS_TO_320US(osal_timeout);
   \   00001E   8E..         MOV     ?V0 + 4,R6
   \   000020   8F..         MOV     ?V0 + 5,R7
   \   000022   75..00       MOV     ?V0 + 6,#0x0
   \   000025   75..00       MOV     ?V0 + 7,#0x0
   \   000028   90....       MOV     DPTR,#__Constant_64
   \   00002B   78..         MOV     R0,#?V0 + 0
   \   00002D   12....       LCALL   ?L_MOV_X
   \   000030   78..         MOV     R0,#?V0 + 4
   \   000032   79..         MOV     R1,#?V0 + 0
   \   000034   12....       LCALL   ?L_MUL
   \   000037   90....       MOV     DPTR,#__Constant_1f
   \   00003A   78..         MOV     R0,#?V0 + 4
   \   00003C   12....       LCALL   ?L_ADD_X
   \   00003F   7405         MOV     A,#0x5
   \   000041   78..         MOV     R0,#?V0 + 4
   \   000043   12....       LCALL   ?UL_SHR
   \   000046   7401         MOV     A,#0x1
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   78..         MOV     R0,#?V0 + 4
   \   00004D   12....       LCALL   ?L_MOV_TO_X
    286            if (timeout == 0)
   \   000050   7401         MOV     A,#0x1
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   C082         PUSH    DPL
   \   000057   C083         PUSH    DPH
   \   000059   90....       MOV     DPTR,#__Constant_0
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?L_MOV_X
   \   000061   D083         POP     DPH
   \   000063   D082         POP     DPL
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?L_EQ_X
   \   00006A   90....       MOV     DPTR,#(MAC_PwrNextTimeout & 0xffff)
   \   00006D   700F         JNZ     ??halSleep_0
    287            {
    288              timeout = MAC_PwrNextTimeout();
   \   00006F                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   00006F   74..         MOV     A,#((MAC_PwrNextTimeout >> 16) & 0xff)
   \   000071   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000074   8A..         MOV     ?V0 + 0,R2
   \   000076   8B..         MOV     ?V0 + 1,R3
   \   000078   8C..         MOV     ?V0 + 2,R4
   \   00007A   8D..         MOV     ?V0 + 3,R5
   \   00007C   802A         SJMP    ??halSleep_1
    289            }
    290            else
    291            {
    292              /* get next MAC timer expiration */
    293              macTimeout = MAC_PwrNextTimeout();
   \                     ??halSleep_0:
   \   00007E                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   00007E   74..         MOV     A,#((MAC_PwrNextTimeout >> 16) & 0xff)
   \   000080   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000083   8A..         MOV     ?V0 + 0,R2
   \   000085   8B..         MOV     ?V0 + 1,R3
   \   000087   8C..         MOV     ?V0 + 2,R4
   \   000089   8D..         MOV     ?V0 + 3,R5
    294          
    295              /* get lesser of two timeouts */
    296              if ((macTimeout != 0) && (macTimeout < timeout))
   \   00008B   90....       MOV     DPTR,#__Constant_0
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?L_EQ_X
   \   000093   6041         JZ      ??halSleep_2
   \   000095   7401         MOV     A,#0x1
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   78..         MOV     R0,#?V0 + 4
   \   00009C   12....       LCALL   ?L_MOV_X
   \   00009F   78..         MOV     R0,#?V0 + 4
   \   0000A1   79..         MOV     R1,#?V0 + 0
   \   0000A3   12....       LCALL   ?UL_GT
   \   0000A6   502E         JNC     ??halSleep_2
    297              {
    298                timeout = macTimeout;
   \                     ??halSleep_1:
   \   0000A8   7401         MOV     A,#0x1
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?L_MOV_TO_X
    299              }
    300            }
    301          
    302            /* HAL_SLEEP_PM2 is entered only if the timeout is zero and
    303             * the device is a stimulated device.
    304             */
    305            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
   \   0000B2   7401         MOV     A,#0x1
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   C082         PUSH    DPL
   \   0000B9   C083         PUSH    DPH
   \   0000BB   90....       MOV     DPTR,#__Constant_0
   \   0000BE   78..         MOV     R0,#?V0 + 0
   \   0000C0   12....       LCALL   ?L_MOV_X
   \   0000C3   D083         POP     DPH
   \   0000C5   D082         POP     DPL
   \   0000C7   78..         MOV     R0,#?V0 + 0
   \   0000C9   12....       LCALL   ?L_EQ_X
   \   0000CC   7008         JNZ     ??halSleep_2
   \   0000CE   7403         MOV     A,#0x3
   \   0000D0   90....       MOV     DPTR,#??halPwrMgtMode
   \   0000D3   F0           MOVX    @DPTR,A
   \   0000D4   804F         SJMP    ??halSleep_3
   \                     ??halSleep_2:
   \   0000D6   7402         MOV     A,#0x2
   \   0000D8   90....       MOV     DPTR,#??halPwrMgtMode
   \   0000DB   F0           MOVX    @DPTR,A
   \   0000DC   90....       MOV     DPTR,#??halSleepLevel
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   C3           CLR     C
   \   0000E1   9402         SUBB    A,#0x2
   \   0000E3   5005         JNC     ??halSleep_4
    306          
    307            /* The sleep mode is also controlled by halSleepLevel which
    308             * defined the deepest level of sleep allowed. This is applied
    309             * to timer sleep only.
    310             */
    311            if ( timeout > 0 && halPwrMgtMode > halSleepLevel )
    312            {
    313              halPwrMgtMode = halSleepLevel;
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   90....       MOV     DPTR,#??halPwrMgtMode
   \   0000E9   F0           MOVX    @DPTR,A
    314            }
    315          
    316            /* Allow PM1 only.
    317             * AN044 - RESTRICT USE TO PM1 ONLY
    318             */
    319          #if defined (PM1_ONLY) && (PM1_ONLY == TRUE)
    320              if (timeout > 0)
    321              {
    322                halPwrMgtMode = CC2430_PM1;
    323              }
    324              else
    325              {
    326                /* do not allow PM3 either */
    327                return;
    328              }
    329          #endif
    330          
    331            /* DEEP sleep can only be entered when zgPollRate == 0.
    332             * This is to eliminate any possibility of entering PM3 between
    333             * two network timers.
    334             */
    335          #if !defined (RTR_NWK) && defined (NWK_AUTO_POLL)
    336            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    337                (timeout == 0 && zgPollRate == 0))
    338          #else
    339            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    340                (timeout == 0))
   \                     ??halSleep_4:
   \   0000EA   7401         MOV     A,#0x1
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   C082         PUSH    DPL
   \   0000F1   C083         PUSH    DPH
   \   0000F3   90....       MOV     DPTR,#__Constant_2d
   \   0000F6   78..         MOV     R0,#?V0 + 0
   \   0000F8   12....       LCALL   ?L_MOV_X
   \   0000FB   D083         POP     DPH
   \   0000FD   D082         POP     DPL
   \   0000FF   78..         MOV     R0,#?V0 + 0
   \   000101   12....       LCALL   ?UL_GT_X
   \   000104   501F         JNC     ??halSleep_3
   \   000106   7401         MOV     A,#0x1
   \   000108   12....       LCALL   ?XSTACK_DISP0_8
   \   00010B   C082         PUSH    DPL
   \   00010D   C083         PUSH    DPH
   \   00010F   90....       MOV     DPTR,#__Constant_0
   \   000112   78..         MOV     R0,#?V0 + 0
   \   000114   12....       LCALL   ?L_MOV_X
   \   000117   D083         POP     DPH
   \   000119   D082         POP     DPL
   \   00011B   78..         MOV     R0,#?V0 + 0
   \   00011D   12....       LCALL   ?L_EQ_X
   \   000120   6003         JZ      $+5
   \   000122   02....       LJMP    ??halSleep_5 & 0xFFFF
    341          #endif
    342            {
    343              HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??halSleep_3:
   \   000125   A2AF         MOV     C,0xa8.7
   \   000127   E4           CLR     A
   \   000128   92E0         MOV     0xE0 /* A   */.0,C
   \   00012A   85..82       MOV     DPL,?XSP + 0
   \   00012D   85..83       MOV     DPH,?XSP + 1
   \   000130   F0           MOVX    @DPTR,A
   \   000131   C2AF         CLR     0xa8.7
    344          
    345              /* one last check for active OSAL task */
    346              if (osalNextActiveTask() == NULL)
   \   000133                ; Setup parameters for call to function osalNextActiveTask
   \   000133   90....       MOV     DPTR,#(osalNextActiveTask & 0xffff)
   \   000136   74..         MOV     A,#((osalNextActiveTask >> 16) & 0xff)
   \   000138   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00013B   EA           MOV     A,R2
   \   00013C   7001         JNZ     ??halSleep_6
   \   00013E   EB           MOV     A,R3
   \                     ??halSleep_6:
   \   00013F   6003         JZ      $+5
   \   000141   02....       LJMP    ??halSleep_7 & 0xFFFF
    347              {
    348                /* always use "deep sleep" to turn off radio VREG on CC2430 */
    349                if (MAC_PwrOffReq(MAC_PWR_SLEEP_DEEP) == MAC_SUCCESS)
   \   000144                ; Setup parameters for call to function MAC_PwrOffReq
   \   000144   7902         MOV     R1,#0x2
   \   000146   90....       MOV     DPTR,#(MAC_PwrOffReq & 0xffff)
   \   000149   74..         MOV     A,#((MAC_PwrOffReq >> 16) & 0xff)
   \   00014B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00014E   E9           MOV     A,R1
   \   00014F   6003         JZ      $+5
   \   000151   02....       LJMP    ??halSleep_7 & 0xFFFF
    350                {
    351                  while ( (HAL_SLEEP_MS_TO_320US(halAccumulatedSleepTime) < timeout) || (timeout == 0) )
   \                     ??halSleep_8:
   \   000154   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   000157   78..         MOV     R0,#?V0 + 0
   \   000159   12....       LCALL   ?L_MOV_X
   \   00015C   90....       MOV     DPTR,#__Constant_64
   \   00015F   78..         MOV     R0,#?V0 + 4
   \   000161   12....       LCALL   ?L_MOV_X
   \   000164   78..         MOV     R0,#?V0 + 0
   \   000166   79..         MOV     R1,#?V0 + 4
   \   000168   12....       LCALL   ?L_MUL
   \   00016B   90....       MOV     DPTR,#__Constant_1f
   \   00016E   78..         MOV     R0,#?V0 + 0
   \   000170   12....       LCALL   ?L_ADD_X
   \   000173   7405         MOV     A,#0x5
   \   000175   78..         MOV     R0,#?V0 + 0
   \   000177   12....       LCALL   ?UL_SHR
   \   00017A   7401         MOV     A,#0x1
   \   00017C   12....       LCALL   ?XSTACK_DISP0_8
   \   00017F   78..         MOV     R0,#?V0 + 4
   \   000181   12....       LCALL   ?L_MOV_X
   \   000184   78..         MOV     R0,#?V0 + 4
   \   000186   79..         MOV     R1,#?V0 + 0
   \   000188   12....       LCALL   ?UL_GT
   \   00018B   401F         JC      ??halSleep_9
   \   00018D   7401         MOV     A,#0x1
   \   00018F   12....       LCALL   ?XSTACK_DISP0_8
   \   000192   C082         PUSH    DPL
   \   000194   C083         PUSH    DPH
   \   000196   90....       MOV     DPTR,#__Constant_0
   \   000199   78..         MOV     R0,#?V0 + 0
   \   00019B   12....       LCALL   ?L_MOV_X
   \   00019E   D083         POP     DPH
   \   0001A0   D082         POP     DPL
   \   0001A2   78..         MOV     R0,#?V0 + 0
   \   0001A4   12....       LCALL   ?L_EQ_X
   \   0001A7   6003         JZ      $+5
   \   0001A9   02....       LJMP    ??halSleep_10 & 0xFFFF
    352                  {
    353                    /* get peripherals ready for sleep */
    354                    HalKeyEnterSleep();
   \                     ??halSleep_9:
   \   0001AC                ; Setup parameters for call to function HalKeyEnterSleep
   \   0001AC   90....       MOV     DPTR,#(HalKeyEnterSleep & 0xffff)
   \   0001AF   74..         MOV     A,#((HalKeyEnterSleep >> 16) & 0xff)
   \   0001B1   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    355          
    356          #ifdef HAL_SLEEP_DEBUG_LED
    357                    HAL_TURN_OFF_LED3();
    358          #else
    359                    /* use this to turn LEDs off during sleep */
    360                    HalLedEnterSleep();
   \   0001B4                ; Setup parameters for call to function HalLedEnterSleep
   \   0001B4   90....       MOV     DPTR,#(HalLedEnterSleep & 0xffff)
   \   0001B7   74..         MOV     A,#((HalLedEnterSleep >> 16) & 0xff)
   \   0001B9   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    361          #endif
    362          
    363                    /* set main clock source to RC oscillator for Rev B and Rev D */
    364                    HAL_SLEEP_SET_MAIN_CLOCK_RC();
   \   0001BC   53BEFB       ANL     0xbe,#0xfb
   \                     ??halSleep_11:
   \   0001BF   E5BE         MOV     A,0xbe
   \   0001C1   A2E5         MOV     C,0xE0 /* A   */.5
   \   0001C3   50FA         JNC     ??halSleep_11
   \   0001C5   00           NOP
   \   0001C6   75C649       MOV     0xc6,#0x49
   \                     ??halSleep_12:
   \   0001C9   7449         MOV     A,#0x49
   \   0001CB   65C6         XRL     A,0xc6
   \   0001CD   70FA         JNZ     ??halSleep_12
   \   0001CF   43BE04       ORL     0xbe,#0x4
    365          
    366                    /* enable sleep timer interrupt */
    367                    if (timeout != 0)
   \   0001D2   7401         MOV     A,#0x1
   \   0001D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D7   C082         PUSH    DPL
   \   0001D9   C083         PUSH    DPH
   \   0001DB   90....       MOV     DPTR,#__Constant_0
   \   0001DE   78..         MOV     R0,#?V0 + 0
   \   0001E0   12....       LCALL   ?L_MOV_X
   \   0001E3   D083         POP     DPH
   \   0001E5   D082         POP     DPL
   \   0001E7   78..         MOV     R0,#?V0 + 0
   \   0001E9   12....       LCALL   ?L_EQ_X
   \   0001EC   6051         JZ      ??halSleep_13
    368                    {
    369                      if (timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ))
   \   0001EE   7401         MOV     A,#0x1
   \   0001F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F3   C082         PUSH    DPL
   \   0001F5   C083         PUSH    DPH
   \   0001F7   90....       MOV     DPTR,#__Constant_185197
   \   0001FA   78..         MOV     R0,#?V0 + 0
   \   0001FC   12....       LCALL   ?L_MOV_X
   \   0001FF   D083         POP     DPH
   \   000201   D082         POP     DPL
   \   000203   78..         MOV     R0,#?V0 + 0
   \   000205   12....       LCALL   ?UL_GT_X
   \   000208   4017         JC      ??halSleep_14
    370                      {
    371                        timeout -= HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME );
   \   00020A   90....       MOV     DPTR,#__Constant_ffe7ae6a
   \   00020D   78..         MOV     R0,#?V0 + 0
   \   00020F   12....       LCALL   ?L_MOV_X
   \   000212   7401         MOV     A,#0x1
   \   000214   12....       LCALL   ?XSTACK_DISP0_8
   \   000217   78..         MOV     R0,#?V0 + 0
   \   000219   12....       LCALL   ?L_ADD_TO_X
    372                        halSleepSetTimer(HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ));
   \   00021C                ; Setup parameters for call to function halSleepSetTimer
   \   00021C   90....       MOV     DPTR,#__Constant_185196
   \   00021F   8005         SJMP    ??halSleep_15
    373                      }
    374                      else
    375                      {
    376                        /* set sleep timer */
    377                        halSleepSetTimer(timeout);
   \                     ??halSleep_14:
   \   000221                ; Setup parameters for call to function halSleepSetTimer
   \   000221   7401         MOV     A,#0x1
   \   000223   12....       LCALL   ?XSTACK_DISP0_8
   \                     ??halSleep_15:
   \   000226   78..         MOV     R0,#?V0 + 0
   \   000228   12....       LCALL   ?L_MOV_X
   \   00022B   AA..         MOV     R2,?V0 + 0
   \   00022D   AB..         MOV     R3,?V0 + 1
   \   00022F   AC..         MOV     R4,?V0 + 2
   \   000231   AD..         MOV     R5,?V0 + 3
   \   000233   90....       MOV     DPTR,#(halSleepSetTimer & 0xffff)
   \   000236   74..         MOV     A,#((halSleepSetTimer >> 16) & 0xff)
   \   000238   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    378                      }
    379          
    380                      /* set up sleep timer interrupt */
    381                      HAL_SLEEP_TIMER_CLEAR_INT();
   \   00023B   C2C7         CLR     0xc0.7
    382                      HAL_SLEEP_TIMER_ENABLE_INT();
   \   00023D   D2AD         SETB    0xa8.5
    383                    }
    384          
    385          #ifdef HAL_SLEEP_DEBUG_LED
    386                    if (halPwrMgtMode == CC2430_PM1)
    387                    {
    388                      HAL_TURN_ON_LED1();
    389                    }
    390                    else
    391                    {
    392                      HAL_TURN_OFF_LED1();
    393                    }
    394          #endif
    395          
    396                    /* save interrupt enable registers and disable all interrupts */
    397                    HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
   \                     ??halSleep_13:
   \   00023F   E5A8         MOV     A,0xa8
   \   000241   F5..         MOV     ?V0 + 0,A
   \   000243   E5B8         MOV     A,0xb8
   \   000245   F5..         MOV     ?V0 + 1,A
   \   000247   E59A         MOV     A,0x9a
   \   000249   F5..         MOV     ?V0 + 2,A
   \   00024B   53A820       ANL     0xa8,#0x20
   \   00024E   E5A8         MOV     A,0xa8
   \   000250   53B820       ANL     0xb8,#0x20
   \   000253   E5B8         MOV     A,0xb8
   \   000255   539A12       ANL     0x9a,#0x12
   \   000258   E59A         MOV     A,0x9a
    398          
    399                    /* This is to check if the stack is exceeding the disappearing
    400                     * RAM boundary of 0xF000. If the stack does exceed the boundary
    401                     * (unlikely), do not enter sleep until the stack is back to normal.
    402                     */
    403                    if ( ((uint16)(*( __idata uint16*)(CSTK_PTR)) >= 0xF000) )
   \   00025A   78..         MOV     R0,#(SFB(XSP) & 0xff)
   \   00025C   C3           CLR     C
   \   00025D   E6           MOV     A,@R0
   \   00025E   9400         SUBB    A,#0x0
   \   000260   08           INC     R0
   \   000261   E6           MOV     A,@R0
   \   000262   94F0         SUBB    A,#-0x10
   \   000264   4053         JC      ??halSleep_16
    404                    {
    405                      HAL_EXIT_CRITICAL_SECTION(intState);
   \   000266   85..82       MOV     DPL,?XSP + 0
   \   000269   85..83       MOV     DPH,?XSP + 1
   \   00026C   E0           MOVX    A,@DPTR
   \   00026D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00026F   92AF         MOV     0xa8.7,C
    406          
    407                      /* AN044 - DELAYING EXTERNAL INTERRUPTS, do not relocate this line.
    408                       * it has to stay as close to PCON.IDLE = 1 as possible.
    409                       */
    410                      EXTERNAL_INTERRUPT_DELAY();
   \   000271   43FD02       ORL     0xfd,#0x2
   \   000274   D281         SETB    0x80.1
   \   000276                ; Setup parameters for call to function halSleepWait
   \   000276   7AB4         MOV     R2,#-0x4c
   \   000278   7B00         MOV     R3,#0x0
   \   00027A   90....       MOV     DPTR,#(halSleepWait & 0xffff)
   \   00027D   74..         MOV     A,#((halSleepWait >> 16) & 0xff)
   \   00027F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000282   53FDFD       ANL     0xfd,#0xfd
   \   000285   438F02       ORL     0x8f,#0x2
    411          
    412                      /* set CC2430 power mode */
    413                      HAL_SLEEP_SET_POWER_MODE(halPwrMgtMode);
   \   000288   90DF60       MOV     DPTR,#-0x20a0
   \   00028B   E0           MOVX    A,@DPTR
   \   00028C   C3           CLR     C
   \   00028D   9404         SUBB    A,#0x4
   \   00028F   53BEFC       ANL     0xbe,#0xfc
   \   000292   E5BE         MOV     A,0xbe
   \   000294   90....       MOV     DPTR,#??halPwrMgtMode
   \   000297   E0           MOVX    A,@DPTR
   \   000298   45BE         ORL     A,0xbe
   \   00029A   F5BE         MOV     0xbe,A
   \   00029C   4009         JC      ??halSleep_17
   \   00029E   00           NOP
   \   00029F   00           NOP
   \   0002A0   00           NOP
   \   0002A1   7403         MOV     A,#0x3
   \   0002A3   55BE         ANL     A,0xbe
   \   0002A5   6004         JZ      ??halSleep_18
   \                     ??halSleep_17:
   \   0002A7   438701       ORL     0x87,#0x1
   \   0002AA   00           NOP
    414                      /* wake up from sleep */
    415          
    416                      HAL_ENTER_CRITICAL_SECTION(intState);
   \                     ??halSleep_18:
   \   0002AB   A2AF         MOV     C,0xa8.7
   \   0002AD   E4           CLR     A
   \   0002AE   92E0         MOV     0xE0 /* A   */.0,C
   \   0002B0   85..82       MOV     DPL,?XSP + 0
   \   0002B3   85..83       MOV     DPH,?XSP + 1
   \   0002B6   F0           MOVX    @DPTR,A
   \   0002B7   C2AF         CLR     0xa8.7
    417                    }
    418          
    419                    /* restore interrupt enable registers */
    420                    HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
   \                     ??halSleep_16:
   \   0002B9   85..A8       MOV     0xa8,?V0 + 0
   \   0002BC   85..B8       MOV     0xb8,?V0 + 1
   \   0002BF   85..9A       MOV     0x9a,?V0 + 2
    421          
    422                    /* disable sleep timer interrupt */
    423                    HAL_SLEEP_TIMER_DISABLE_INT();
   \   0002C2   C2AD         CLR     0xa8.5
    424          
    425                    /* set main clock source to crystal for Rev B and Rev D only */
    426                    HAL_SLEEP_SET_MAIN_CLOCK_CRYSTAL();
   \   0002C4   53BEFB       ANL     0xbe,#0xfb
   \                     ??halSleep_19:
   \   0002C7   E5BE         MOV     A,0xbe
   \   0002C9   A2E6         MOV     C,0xE0 /* A   */.6
   \   0002CB   50FA         JNC     ??halSleep_19
   \   0002CD   00           NOP
   \   0002CE                ; Setup parameters for call to function halSleepWait
   \   0002CE   7A3F         MOV     R2,#0x3f
   \   0002D0   7B00         MOV     R3,#0x0
   \   0002D2   90....       MOV     DPTR,#(halSleepWait & 0xffff)
   \   0002D5   74..         MOV     A,#((halSleepWait >> 16) & 0xff)
   \   0002D7   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0002DA   75C600       MOV     0xc6,#0x0
   \                     ??halSleep_20:
   \   0002DD   E5C6         MOV     A,0xc6
   \   0002DF   70FC         JNZ     ??halSleep_20
   \   0002E1   43BE04       ORL     0xbe,#0x4
    427          
    428                    /* Calculate timer elasped */
    429                    halAccumulatedSleepTime += (HalTimerElapsed() / TICK_COUNT);
   \   0002E4                ; Setup parameters for call to function HalTimerElapsed
   \   0002E4   90....       MOV     DPTR,#(HalTimerElapsed & 0xffff)
   \   0002E7   74..         MOV     A,#((HalTimerElapsed >> 16) & 0xff)
   \   0002E9   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0002EC   8A..         MOV     ?V0 + 0,R2
   \   0002EE   8B..         MOV     ?V0 + 1,R3
   \   0002F0   8C..         MOV     ?V0 + 2,R4
   \   0002F2   8D..         MOV     ?V0 + 3,R5
   \   0002F4   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   0002F7   78..         MOV     R0,#?V0 + 0
   \   0002F9   12....       LCALL   ?L_ADD_TO_X
    430          
    431                    /* deduct the sleep time for the next iteration */
    432                    if ( osal_timeout > halAccumulatedSleepTime)
   \   0002FC   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   0002FF   8E..         MOV     ?V0 + 0,R6
   \   000301   8F..         MOV     ?V0 + 1,R7
   \   000303   75..00       MOV     ?V0 + 2,#0x0
   \   000306   75..00       MOV     ?V0 + 3,#0x0
   \   000309   78..         MOV     R0,#?V0 + 0
   \   00030B   12....       LCALL   ?UL_GT_X
   \   00030E   5011         JNC     ??halSleep_21
    433                    {
    434                      osal_timeout -= halAccumulatedSleepTime;
   \   000310   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   000313   78..         MOV     R0,#?V0 + 0
   \   000315   12....       LCALL   ?L_MOV_X
   \   000318   C3           CLR     C
   \   000319   EE           MOV     A,R6
   \   00031A   95..         SUBB    A,?V0 + 0
   \   00031C   FE           MOV     R6,A
   \   00031D   EF           MOV     A,R7
   \   00031E   95..         SUBB    A,?V0 + 1
   \   000320   FF           MOV     R7,A
    435                    }
    436          
    437                    /* if the remaining time is less than the PM_MIN_SLEEP_TIME
    438                     * burn the remaining time in a delay loop
    439                     * AN044 - MINIMUM SLEEP PERIODS WITH PULL-DOWN RESISTOR
    440                     */
    441                    if ( osal_timeout < PM_MIN_SLEEP_TIME )
   \                     ??halSleep_21:
   \   000321   C3           CLR     C
   \   000322   EE           MOV     A,R6
   \   000323   940E         SUBB    A,#0xe
   \   000325   EF           MOV     A,R7
   \   000326   9400         SUBB    A,#0x0
   \   000328   503F         JNC     ??halSleep_22
    442                    {
    443                      halSleepWait(osal_timeout*1000);
   \   00032A                ; Setup parameters for call to function halSleepWait
   \   00032A   EE           MOV     A,R6
   \   00032B   FA           MOV     R2,A
   \   00032C   EF           MOV     A,R7
   \   00032D   FB           MOV     R3,A
   \   00032E   EA           MOV     A,R2
   \   00032F   75F0E8       MOV     B,#-0x18
   \   000332   A4           MUL     AB
   \   000333   CA           XCH     A,R2
   \   000334   ACF0         MOV     R4,B
   \   000336   75F003       MOV     B,#0x3
   \   000339   A4           MUL     AB
   \   00033A   2C           ADD     A,R4
   \   00033B   FC           MOV     R4,A
   \   00033C   75F0E8       MOV     B,#-0x18
   \   00033F   EB           MOV     A,R3
   \   000340   A4           MUL     AB
   \   000341   2C           ADD     A,R4
   \   000342   FB           MOV     R3,A
   \   000343   90....       MOV     DPTR,#(halSleepWait & 0xffff)
   \   000346   74..         MOV     A,#((halSleepWait >> 16) & 0xff)
   \   000348   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    444                      halAccumulatedSleepTime += osal_timeout;
   \   00034B   8E..         MOV     ?V0 + 0,R6
   \   00034D   8F..         MOV     ?V0 + 1,R7
   \   00034F   75..00       MOV     ?V0 + 2,#0x0
   \   000352   75..00       MOV     ?V0 + 3,#0x0
   \   000355   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   000358   78..         MOV     R0,#?V0 + 0
   \   00035A   12....       LCALL   ?L_ADD_TO_X
    445                      osal_timeout = halAccumulatedSleepTime;
   \   00035D   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   000360   78..         MOV     R0,#?V0 + 0
   \   000362   12....       LCALL   ?L_MOV_X
   \   000365   AE..         MOV     R6,?V0 + 0
   \   000367   AF..         MOV     R7,?V0 + 1
    446                    }
    447          
    448          #ifdef HAL_SLEEP_DEBUG_LED
    449                    HAL_TURN_ON_LED3();
    450          #else
    451                    /* use this to turn LEDs back on after sleep */
    452                    HalLedExitSleep();
   \                     ??halSleep_22:
   \   000369                ; Setup parameters for call to function HalLedExitSleep
   \   000369   90....       MOV     DPTR,#(HalLedExitSleep & 0xffff)
   \   00036C   74..         MOV     A,#((HalLedExitSleep >> 16) & 0xff)
   \   00036E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    453          #endif
    454          
    455                    /* handle peripherals; exit loop if key presses */
    456                    if ( HalKeyExitSleep() )
   \   000371                ; Setup parameters for call to function HalKeyExitSleep
   \   000371   90....       MOV     DPTR,#(HalKeyExitSleep & 0xffff)
   \   000374   74..         MOV     A,#((HalKeyExitSleep >> 16) & 0xff)
   \   000376   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000379   E9           MOV     A,R1
   \   00037A   701F         JNZ     ??halSleep_10
    457                    {
    458          #if defined (PM2_HOLDOFF_TIME) && (PM2_HOLDOFF_TIME > 0)
    459                      /* The deepest sleep alowwed is PM1 until after the timer expired
    460                       * AN044 - COMBINING POWER MODES
    461                       */
    462                      halSleepLevel = CC2430_PM1;
    463                      osal_stop_timerEx (Hal_TaskID, HAL_SLEEP_TIMER_EVENT);
    464                      osal_start_timerEx (Hal_TaskID, HAL_SLEEP_TIMER_EVENT, PM2_HOLDOFF_TIME);
    465          #endif /* (PM2_HOLDOFF_TIME > 0) */
    466                      break;
    467                    }
    468          
    469                    /* exit loop if no timer active */
    470                    if ( timeout == 0 ) break;
   \   00037C   7401         MOV     A,#0x1
   \   00037E   12....       LCALL   ?XSTACK_DISP0_8
   \   000381   C082         PUSH    DPL
   \   000383   C083         PUSH    DPH
   \   000385   90....       MOV     DPTR,#__Constant_0
   \   000388   78..         MOV     R0,#?V0 + 0
   \   00038A   12....       LCALL   ?L_MOV_X
   \   00038D   D083         POP     DPH
   \   00038F   D082         POP     DPL
   \   000391   78..         MOV     R0,#?V0 + 0
   \   000393   12....       LCALL   ?L_EQ_X
   \   000396   6003         JZ      $+5
   \   000398   02....       LJMP    ??halSleep_8 & 0xFFFF
    471                  }
    472          
    473                  /* power on the MAC; blocks until completion */
    474                  MAC_PwrOnReq();
   \                     ??halSleep_10:
   \   00039B                ; Setup parameters for call to function MAC_PwrOnReq
   \   00039B   90....       MOV     DPTR,#(MAC_PwrOnReq & 0xffff)
   \   00039E   74..         MOV     A,#((MAC_PwrOnReq >> 16) & 0xff)
   \   0003A0   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    475          
    476                  /* adjust OSAL timers */
    477                  osal_adjust_timers();
   \   0003A3                ; Setup parameters for call to function osal_adjust_timers
   \   0003A3   90....       MOV     DPTR,#(osal_adjust_timers & 0xffff)
   \   0003A6   74..         MOV     A,#((osal_adjust_timers >> 16) & 0xff)
   \   0003A8   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    478          
    479                  HAL_EXIT_CRITICAL_SECTION(intState);
    480                }
    481                else
    482                {
    483                  HAL_EXIT_CRITICAL_SECTION(intState);
    484                }
    485              }
    486              else
    487              {
    488                HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??halSleep_7:
   \   0003AB   85..82       MOV     DPL,?XSP + 0
   \   0003AE   85..83       MOV     DPH,?XSP + 1
   \   0003B1   E0           MOVX    A,@DPTR
   \   0003B2   A2E0         MOV     C,0xE0 /* A   */.0
   \   0003B4   92AF         MOV     0xa8.7,C
    489              }
    490            }
    491          }
   \                     ??halSleep_5:
   \   0003B6   7405         MOV     A,#0x5
   \   0003B8   02....       LJMP    ??Subroutine0_0 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7404         MOV     A,#0x4
   \                     ??Subroutine0_0:
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005   7F08         MOV     R7,#0x8
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA
    492          
    493          /**************************************************************************************************
    494           * @fn          halSleepSetTimer
    495           *
    496           * @brief       This function sets the CC2430 sleep timer compare value.  First it reads and
    497           *              stores the value of the sleep timer; this value is used later to update OSAL
    498           *              timers.  Then the timeout value is converted from 320 usec units to 32 kHz
    499           *              period units and the compare value is set to the timeout.
    500           *
    501           * input parameters
    502           *
    503           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    504           *                        this value.
    505           *
    506           * output parameters
    507           *
    508           * None.
    509           *
    510           * @return      None.
    511           **************************************************************************************************
    512           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    513          void halSleepSetTimer(uint32 timeout)
   \                     halSleepSetTimer:
    514          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
    515            uint32 ticks;
    516          
    517            /* read the sleep timer; ST0 must be read first */
    518            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
   \   000012   E595         MOV     A,0x95
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   F0           MOVX    @DPTR,A
    519            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
   \   00001B   E596         MOV     A,0x96
   \   00001D   C0E0         PUSH    A
   \   00001F   7401         MOV     A,#0x1
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   D0E0         POP     A
   \   000026   F0           MOVX    @DPTR,A
    520            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
   \   000027   E597         MOV     A,0x97
   \   000029   C0E0         PUSH    A
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   D0E0         POP     A
   \   000032   F0           MOVX    @DPTR,A
    521            ((uint8 *) &ticks)[UINT32_NDX3] = 0;
   \   000033   7403         MOV     A,#0x3
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
    522          
    523            /* store value for later */
    524            halSleepTimerStart = ticks;
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   78..         MOV     R0,#?V0 + 4
   \   000042   12....       LCALL   ?L_MOV_X
   \   000045   90....       MOV     DPTR,#??halSleepTimerStart
   \   000048   78..         MOV     R0,#?V0 + 4
   \   00004A   12....       LCALL   ?L_MOV_TO_X
    525          
    526          
    527            /* Compute sleep timer compare value.  The ratio of 32 kHz ticks to 320 usec ticks
    528             * is 32768/3125 = 10.48576.  This is nearly 671/64 = 10.484375.
    529             */
    530            ticks += (timeout * 671) / 64;
    531          
    532            /* subtract the processing time spent in function halSleep() */
    533            ticks -= HAL_SLEEP_ADJ_TICKS;
   \   00004D   90....       MOV     DPTR,#__Constant_29f
   \   000050   78..         MOV     R0,#?V0 + 4
   \   000052   12....       LCALL   ?L_MOV_X
   \   000055   78..         MOV     R0,#?V0 + 0
   \   000057   79..         MOV     R1,#?V0 + 4
   \   000059   12....       LCALL   ?L_MUL
   \   00005C   7406         MOV     A,#0x6
   \   00005E   78..         MOV     R0,#?V0 + 0
   \   000060   12....       LCALL   ?UL_SHR
   \   000063   90....       MOV     DPTR,#__Constant_ffffffde
   \   000066   78..         MOV     R0,#?V0 + 0
   \   000068   12....       LCALL   ?L_ADD_X
   \   00006B   85..82       MOV     DPL,?XSP + 0
   \   00006E   85..83       MOV     DPH,?XSP + 1
   \   000071   78..         MOV     R0,#?V0 + 0
   \   000073   12....       LCALL   ?L_ADD_TO_X
    534          
    535            /* CC2430 Rev. B bug:  compare value must not be set higher than 0xFFFF7F */
    536            if((ticks & 0xFFFFFF) > 0xFFFF7F)
   \   000076   85..82       MOV     DPL,?XSP + 0
   \   000079   85..83       MOV     DPH,?XSP + 1
   \   00007C   C082         PUSH    DPL
   \   00007E   C083         PUSH    DPH
   \   000080   90....       MOV     DPTR,#__Constant_ffffff
   \   000083   78..         MOV     R0,#?V0 + 0
   \   000085   12....       LCALL   ?L_MOV_X
   \   000088   D083         POP     DPH
   \   00008A   D082         POP     DPL
   \   00008C   78..         MOV     R0,#?V0 + 0
   \   00008E   12....       LCALL   ?L_AND_X
   \   000091   90....       MOV     DPTR,#__Constant_ffff80
   \   000094   78..         MOV     R0,#?V0 + 4
   \   000096   12....       LCALL   ?L_MOV_X
   \   000099   78..         MOV     R0,#?V0 + 4
   \   00009B   79..         MOV     R1,#?V0 + 0
   \   00009D   12....       LCALL   ?UL_GT
   \   0000A0   4013         JC      ??halSleepSetTimer_0
    537            {
    538              ticks = 0xFFFF7F;
   \   0000A2   90....       MOV     DPTR,#__Constant_ffff7f
   \   0000A5   78..         MOV     R0,#?V0 + 0
   \   0000A7   12....       LCALL   ?L_MOV_X
   \   0000AA   85..82       MOV     DPL,?XSP + 0
   \   0000AD   85..83       MOV     DPH,?XSP + 1
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   12....       LCALL   ?L_MOV_TO_X
    539            }
    540          
    541            /* set sleep timer compare; ST0 must be written last */
    542            ST2 = ((uint8 *) &ticks)[UINT32_NDX2];
   \                     ??halSleepSetTimer_0:
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F597         MOV     0x97,A
    543            ST1 = ((uint8 *) &ticks)[UINT32_NDX1];
   \   0000BD   7401         MOV     A,#0x1
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F596         MOV     0x96,A
    544            ST0 = ((uint8 *) &ticks)[UINT32_NDX0];
   \   0000C5   85..82       MOV     DPL,?XSP + 0
   \   0000C8   85..83       MOV     DPH,?XSP + 1
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F595         MOV     0x95,A
    545          }
   \   0000CE                REQUIRE ?Subroutine0
   \   0000CE                ; // Fall through to label ?Subroutine0
    546          
    547          /**************************************************************************************************
    548           * @fn          TimerElapsed
    549           *
    550           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    551           *
    552           * input parameters
    553           *
    554           * @param       None.
    555           *
    556           * output parameters
    557           *
    558           * None.
    559           *
    560           * @return      Number of timer ticks elapsed during sleep.
    561           **************************************************************************************************
    562           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    563          uint32 TimerElapsed( void )
   \                     TimerElapsed:
    564          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    565            return ( halAccumulatedSleepTime );
   \   000005   90....       MOV     DPTR,#??halAccumulatedSleepTime
   \   000008   78..         MOV     R0,#?V0 + 0
   \   00000A   12....       LCALL   ?L_MOV_X
   \   00000D   AA..         MOV     R2,?V0 + 0
   \   00000F   AB..         MOV     R3,?V0 + 1
   \   000011   AC..         MOV     R4,?V0 + 2
   \   000013   AD..         MOV     R5,?V0 + 3
   \   000015   7F04         MOV     R7,#0x4
   \   000017   02....       LJMP    ?BANKED_LEAVE_XDATA
    566          }
    567          
    568          /**************************************************************************************************
    569           * @fn          HalTimerElapsed
    570           *
    571           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.  This function
    572           *              relies on OSAL macro TICK_COUNT to be set to 1; then ticks are calculated in
    573           *              units of msec.  (Setting TICK_COUNT to 1 avoids a costly uint32 divide.)
    574           *
    575           * input parameters
    576           *
    577           * @param       None.
    578           *
    579           * output parameters
    580           *
    581           * None.
    582           *
    583           * @return      Number of timer ticks elapsed during sleep.
    584           **************************************************************************************************
    585           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    586          uint32 HalTimerElapsed( void )
   \                     HalTimerElapsed:
    587          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    588            uint32 ticks;
    589          
    590            /* read the sleep timer; ST0 must be read first */
    591            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
   \   00000A   E595         MOV     A,0x95
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   F0           MOVX    @DPTR,A
    592            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
   \   000013   E596         MOV     A,0x96
   \   000015   C0E0         PUSH    A
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   D0E0         POP     A
   \   00001E   F0           MOVX    @DPTR,A
    593            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
   \   00001F   E597         MOV     A,0x97
   \   000021   C0E0         PUSH    A
   \   000023   7402         MOV     A,#0x2
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   D0E0         POP     A
   \   00002A   F0           MOVX    @DPTR,A
    594          
    595            /* set bit 24 to handle wraparound */
    596            ((uint8 *) &ticks)[UINT32_NDX3] = 0x01;
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   7401         MOV     A,#0x1
   \   000032   F0           MOVX    @DPTR,A
    597          
    598            /* calculate elapsed time */
    599            ticks -= halSleepTimerStart;
    600          
    601            /* add back the processing time spent in function halSleep() */
    602            ticks += HAL_SLEEP_ADJ_TICKS;
    603          
    604            /* mask off excess if no wraparound */
    605            ticks &= 0x00FFFFFF;
    606          
    607            /* Convert elapsed time in milliseconds with round.  1000/32768 = 125/4096 */
    608            return ( ((ticks * 125) + 4095) / 4096 );
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   78..         MOV     R0,#?V0 + 0
   \   00003B   12....       LCALL   ?L_MOV_X
   \   00003E   90....       MOV     DPTR,#??halSleepTimerStart
   \   000041   78..         MOV     R0,#?V0 + 0
   \   000043   12....       LCALL   ?L_SUB_X
   \   000046   90....       MOV     DPTR,#__Constant_22
   \   000049   78..         MOV     R0,#?V0 + 0
   \   00004B   12....       LCALL   ?L_ADD_X
   \   00004E   90....       MOV     DPTR,#__Constant_ffffff
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?L_AND_X
   \   000056   90....       MOV     DPTR,#__Constant_7d
   \   000059   78..         MOV     R0,#?V0 + 4
   \   00005B   12....       LCALL   ?L_MOV_X
   \   00005E   78..         MOV     R0,#?V0 + 0
   \   000060   79..         MOV     R1,#?V0 + 4
   \   000062   12....       LCALL   ?L_MUL
   \   000065   90....       MOV     DPTR,#__Constant_fff
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   12....       LCALL   ?L_ADD_X
   \   00006D   740C         MOV     A,#0xc
   \   00006F   78..         MOV     R0,#?V0 + 0
   \   000071   12....       LCALL   ?UL_SHR
   \   000074   AA..         MOV     R2,?V0 + 0
   \   000076   AB..         MOV     R3,?V0 + 1
   \   000078   AC..         MOV     R4,?V0 + 2
   \   00007A   FD           MOV     R5,A
   \   00007B   02....       LJMP    ?Subroutine0 & 0xFFFF
    609          }
    610          
    611          /**************************************************************************************************
    612           * @fn          halSleepWait
    613           *
    614           * @brief       Perform a blocking wait.
    615           *
    616           * input parameters
    617           *
    618           * @param       duration - Duration of wait in microseconds.
    619           *
    620           * output parameters
    621           *
    622           * None.
    623           *
    624           * @return      None.
    625           **************************************************************************************************
    626           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    627          void halSleepWait(uint16 duration)
   \                     halSleepWait:
    628          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8008         SJMP    ??halSleepWait_0
    629            while (duration--)
    630            {
    631              asm("NOP");
   \                     ??halSleepWait_1:
   \   000002   00           NOP
    632              asm("NOP");
   \   000003   00           NOP
    633              asm("NOP");
   \   000004   00           NOP
    634              asm("NOP");
   \   000005   00           NOP
    635              asm("NOP");
   \   000006   00           NOP
    636              asm("NOP");
   \   000007   00           NOP
    637              asm("NOP");
   \   000008   00           NOP
    638              asm("NOP");
   \   000009   00           NOP
    639            }
   \                     ??halSleepWait_0:
   \   00000A   EA           MOV     A,R2
   \   00000B   F8           MOV     R0,A
   \   00000C   EB           MOV     A,R3
   \   00000D   F9           MOV     R1,A
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   28           ADD     A,R0
   \   000011   1A           DEC     R2
   \   000012   74FF         MOV     A,#-0x1
   \   000014   39           ADDC    A,R1
   \   000015   FB           MOV     R3,A
   \   000016   E8           MOV     A,R0
   \   000017   7001         JNZ     ??halSleepWait_2
   \   000019   E9           MOV     A,R1
   \                     ??halSleepWait_2:
   \   00001A   70E6         JNZ     ??halSleepWait_1
    640          }
   \   00001C   02....       LJMP    ?BRET
    641          
    642          /**************************************************************************************************
    643           * @fn          halRestoreSleepLevel
    644           *
    645           * @brief       Restore the deepest timer sleep level.
    646           *
    647           * input parameters
    648           *
    649           * @param       None
    650           *
    651           * output parameters
    652           *
    653           *              None.
    654           *
    655           * @return      None.
    656           **************************************************************************************************
    657           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    658          void halRestoreSleepLevel( void )
   \                     halRestoreSleepLevel:
    659          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    660            halSleepLevel = CC2430_PM2;
   \   000004   7402         MOV     A,#0x2
   \   000006   90....       MOV     DPTR,#??halSleepLevel
   \   000009   F0           MOVX    @DPTR,A
    661          }
   \   00000A   D083         POP     DPH
   \   00000C   D082         POP     DPL
   \   00000E   02....       LJMP    ?BRET
    662          
    663          /**************************************************************************************************
    664           * @fn          halSleepTimerIsr
    665           *
    666           * @brief       Sleep timer ISR.
    667           *
    668           * input parameters
    669           *
    670           * None.
    671           *
    672           * output parameters
    673           *
    674           * None.
    675           *
    676           * @return      None.
    677           **************************************************************************************************
    678           */

   \                                 In segment NEAR_CODE, align 1, keep-with-next
    679          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
   \                     halSleepTimerIsr:
    680          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   C082         PUSH    DPL
   \   000006   C083         PUSH    DPH
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
    681            HAL_SLEEP_TIMER_CLEAR_INT();
   \   000008   C2C7         CLR     0xc0.7
    682          
    683            if( CHVER >= REV_E )
   \   00000A   90DF60       MOV     DPTR,#-0x20a0
   \   00000D   E0           MOVX    A,@DPTR
    684            {
    685              CLEAR_SLEEP_MODE();
    686            }
    687          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    688            halSleepInt = TRUE;
    689          #endif
    690          }
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   D0D0         POP     PSW
   \   000014   D0E0         POP     A
   \   000016   32           RETI

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_64:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_64>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_1f:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_1f>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_2d:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_2d>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_185197:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_185197>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffe7ae6a:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffe7ae6a>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_185196:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_185196>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_29f:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_29f>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffffffde:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffffffde>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffffff:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffffff>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffff80:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffff80>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffff7f:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffff7f>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_22:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_22>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_7d:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_7d>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_fff:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_fff>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment INTVEC, offset 0x2b, root
   \                     `halSleepTimerIsr??INTVEC 43`:
   \   00002B   02....       LJMP       (halSleepTimerIsr)

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for halSleepLevel>`:
   \   000000   02           DB 2

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_64>`:
   \   000000   64000000     DD 100

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_1f>`:
   \   000000   1F000000     DD 31

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_2d>`:
   \   000000   2D000000     DD 45

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_185197>`:
   \   000000   97511800     DD 1593751

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffe7ae6a>`:
   \   000000   6AAEE7FF     DD 4293373546

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_185196>`:
   \   000000   96511800     DD 1593750

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_29f>`:
   \   000000   9F020000     DD 671

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffffffde>`:
   \   000000   DEFFFFFF     DD 4294967262

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffffff>`:
   \   000000   FFFFFF00     DD 16777215

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffff80>`:
   \   000000   80FFFF00     DD 16777088

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffff7f>`:
   \   000000   7FFFFF00     DD 16777087

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_22>`:
   \   000000   22000000     DD 34

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_7d>`:
   \   000000   7D000000     DD 125

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_fff>`:
   \   000000   FF0F0000     DD 4095

   \                                 In segment XSP, align 1

   \                                 In segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   Maximum stack usage in bytes:

     Function                ISTACK PSTACK XSTACK
     --------                ------ ------ ------
     HalTimerElapsed             1      0     41
     TimerElapsed                0      0     12
     halRestoreSleepLevel        2      0      0
     halSleep                    2      0     21
       -> MAC_PwrNextTimeout     0      0     42
       -> MAC_PwrNextTimeout     0      0     42
       -> osalNextActiveTask     0      0     42
       -> MAC_PwrOffReq          0      0     42
       -> HalKeyEnterSleep       0      0     42
       -> HalLedEnterSleep       0      0     42
       -> halSleepSetTimer       0      0     42
       -> halSleepSetTimer       0      0     42
       -> halSleepWait           0      0     42
       -> halSleepWait           0      0     42
       -> HalTimerElapsed        0      0     42
       -> halSleepWait           0      0     42
       -> HalLedExitSleep        0      0     42
       -> HalKeyExitSleep        0      0     42
       -> MAC_PwrOnReq           0      0     42
       -> osal_adjust_timers     0      0     42
     halSleepSetTimer            2      0     41
     halSleepTimerIsr            4      0      0
     halSleepWait                0      0     21


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     PCON                              1
     P0INP                             1
     ST0                               1
     ST1                               1
     ST2                               1
     IEN2                              1
     SLEEP                             1
     CLKCON                            1
     P0DIR                             1
     halPwrMgtMode                     1
     halSleepTimerStart                4
     halAccumulatedSleepTime           4
     halSleepLevel                     1
     halSleep                        955
     ?Subroutine0                     10
     halSleepSetTimer                206
     TimerElapsed                     26
     HalTimerElapsed                 126
     halSleepWait                     31
     halRestoreSleepLevel             17
     halSleepTimerIsr                 23
     __Constant_0                      4
     __Constant_64                     4
     __Constant_1f                     4
     __Constant_2d                     4
     __Constant_185197                 4
     __Constant_ffe7ae6a               4
     __Constant_185196                 4
     __Constant_29f                    4
     __Constant_ffffffde               4
     __Constant_ffffff                 4
     __Constant_ffff80                 4
     __Constant_ffff7f                 4
     __Constant_22                     4
     __Constant_7d                     4
     __Constant_fff                    4
     halSleepTimerIsr??INTVEC 43       3
     ?<Initializer for halSleepLevel>
                                       1
     ?<Initializer for __Constant_0>
                                       4
     ?<Initializer for __Constant_64>
                                       4
     ?<Initializer for __Constant_1f>
                                       4
     ?<Initializer for __Constant_2d>
                                       4
     ?<Initializer for __Constant_185197>
                                       4
     ?<Initializer for __Constant_ffe7ae6a>
                                       4
     ?<Initializer for __Constant_185196>
                                       4
     ?<Initializer for __Constant_29f>
                                       4
     ?<Initializer for __Constant_ffffffde>
                                       4
     ?<Initializer for __Constant_ffffff>
                                       4
     ?<Initializer for __Constant_ffff80>
                                       4
     ?<Initializer for __Constant_ffff7f>
                                       4
     ?<Initializer for __Constant_22>
                                       4
     ?<Initializer for __Constant_7d>
                                       4
     ?<Initializer for __Constant_fff>
                                       4
     _A_P0                             1
     _A_IEN0                           1
     _A_IEN1                           1
     _A_IRCON                          1

 
 1 371 bytes in segment BANKED_CODE
     3 bytes in segment INTVEC
    23 bytes in segment NEAR_CODE
    13 bytes in segment SFR_AN
    61 bytes in segment XDATA_I
    61 bytes in segment XDATA_ID
     9 bytes in segment XDATA_Z
 
 1 395 bytes of CODE  memory (+ 63 bytes shared)
     0 bytes of DATA  memory (+ 13 bytes shared)
    10 bytes of XDATA memory (+ 60 bytes shared)

Errors: none
Warnings: none
