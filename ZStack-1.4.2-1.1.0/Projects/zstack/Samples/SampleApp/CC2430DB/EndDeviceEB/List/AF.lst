##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   17/Oct/2013  21:52:29 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  D:\Texas Instruments\ZStack-1.4.2-1.1.0\Component #
#                          s\stack\af\AF.c                                   #
#    Command line       =  -f E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wEnde #
#                          v.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR                #
#                          -DROOT=__near_func -DMAC_OPT_FFD=0 -DBLINK_LEDS   #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f    #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfig. #
#                          cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800     #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\Source\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mt\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\hal\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          hal\target\CC2430EB\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\osal\mcu #
#                          \ccsoc\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC #
#                          2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\osal\include\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨ #
#                          Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects #
#                          \zstack\Samples\SampleApp\CC2430DB\..\..\..\..\.. #
#                          \Components\stack\af\ -I                          #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\stack\nw #
#                          k\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\st #
#                          ack\sec\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\C #
#                          C2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\ #
#                          Samples\SampleApp\CC2430DB\..\..\..\..\..\Compone #
#                          nts\stack\sys\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶ #
#                          Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\stack\zdo\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\zmac\f8w #
#                          \ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\se #
#                          rvices\saddr\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Co #
#                          mponents\services\sdata\ -I                       #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          mac\high_level\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\..\..\..\..\ #
#                          Components\mac\low_level\srf03\ -I                #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\low_ #
#                          level\srf03\single_chip\ -D CC2430EB -D           #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D           #
#                          ZG_ENDDEVICE -lC E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\EndDeviceEB\List\ #
#                           -lA E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\EndDeviceEB\List\             #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\EndDeviceEB\Obj\ -e             #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          "D:\Texas Instruments\ZStack-1.4.2-1.1.0\Componen #
#                          ts\stack\af\AF.c"                                 #
#    List file          =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\List\AF.lst            #
#    Object file        =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\Obj\AF.r51             #
#                                                                            #
#                                                                            #
##############################################################################

D:\Texas Instruments\ZStack-1.4.2-1.1.0\Components\stack\af\AF.c
      1          /*********************************************************************
      2            Filename:       AF.c
      3            Revised:        $Date: 2007-05-14 17:34:18 -0700 (Mon, 14 May 2007) $
      4            Revision:       $Revision: 14296 $
      5          
      6            Description:    General Operational Framework
      7                            - Device Description helper functions
      8          
      9            Notes:
     10          
     11            If supporting KVP, then afRegister() ties endpoint to KVP only in V2.
     12            If KVP in V2,
     13          
     14            Copyright (c) 2006 by Texas Instruments, Inc.
     15            All Rights Reserved.  Permission to use, reproduce, copy, prepare
     16            derivative works, modify, distribute, perform, display or sell this
     17            software and/or its documentation for any purpose is prohibited
     18            without the express written consent of Texas Instruments, Inc.
     19          *********************************************************************/
     20          
     21          /*********************************************************************
     22           * INCLUDES
     23           */
     24          
     25          #include "OSAL.h"
     26          #include "AF.h"
     27          #include "nwk_globals.h"
     28          #include "nwk_util.h"
     29          #include "aps_groups.h"
     30          #include "ZDProfile.h"
     31          #include "aps_frag.h"
     32          
     33          #if ( AF_FLOAT_SUPPORT )
     34            #include "math.h"
     35          #endif
     36          
     37          #if defined ( MT_AF_CB_FUNC )
     38            #include "MT_AF.h"
     39          #endif
     40          
     41          /*********************************************************************
     42           * MACROS
     43           */
     44          
     45          /*********************************************************************
     46           * @fn      afSend
     47           *
     48           * @brief   Helper macro for V1 API to invoke V2 API.
     49           *
     50           * input parameters
     51           *
     52           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
     53           * @param   srcEP - Origination (i.e. respond to or ack to) End Point.
     54           * @param   cID - A valid cluster ID as specified by the Profile.
     55           * @param   len - Number of bytes of data pointed to by next param.
     56           * @param  *buf - A pointer to the data bytes to send.
     57           * @param   options - Valid bit mask of AF Tx Options as defined in AF.h.
     58           * @param  *transID - A pointer to a byte which can be modified and which will
     59           *                    be used as the transaction sequence number of the msg.
     60           *
     61           * output parameters
     62           *
     63           * @param  *transID - Incremented by one if the return value is success.
     64           *
     65           * @return  afStatus_t - See previous definition of afStatus_... types.
     66           */
     67          #if ( AF_V1_SUPPORT )
     68          #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \
     69                  afDataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \
     70                                    (cID), (len), (buf), (transID), (options), (radius) )
     71          #else
     72          #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \
     73                  AF_DataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \
     74                                    (cID), (len), (buf), (transID), (options), (radius) )
     75          #endif
     76          
     77          /*********************************************************************
     78           * CONSTANTS
     79           */
     80          
     81          /*********************************************************************
     82           * TYPEDEFS
     83           */
     84          
     85          #if ( AF_KVP_SUPPORT )
     86          typedef struct
     87          {
     88            uint16 clusterID;
     89            byte transCount;
     90            byte options;
     91            byte srcEP;
     92            afAddrType_t dstAddr;	
     93            uint16 msgLen;
     94            byte *msg;
     95          } afMultiHdr_t;
     96          #endif
     97          
     98          /*********************************************************************
     99           * GLOBAL VARIABLES
    100           */
    101          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    102          epList_t *epList;
   \                     epList:
   \   000000                DS 2
    103          
    104          /*********************************************************************
    105           * EXTERNAL VARIABLES
    106           */
    107          
    108          /*********************************************************************
    109           * EXTERNAL FUNCTIONS
    110           */
    111          
    112          /*********************************************************************
    113           * LOCAL VARIABLES
    114           */
    115          
    116          /*********************************************************************
    117           * LOCAL FUNCTIONS
    118           */
    119          
    120          #if ( AF_KVP_SUPPORT )
    121          static void afBuildKVPIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    122                          zAddrType_t *SrcAddress, uint8 LinkQuality, byte SecurityUse );
    123          #endif
    124          
    125          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    126                          zAddrType_t *SrcAddress, uint8 LinkQuality, byte SecurityUse,
    127                          uint32 timestamp );
    128          
    129          #if ( AF_KVP_SUPPORT )
    130          static afMultiHdr_t *multiInit( afAddrType_t *dstAddr,
    131                               byte srcEndPoint, uint16 clusterID, byte FrameType,
    132                               byte txOptions, bool DiscoverRoute, byte RadiusCounter );
    133          
    134          static bool multiAppend( afMultiHdr_t *hdr, byte bufLen, byte *buf,
    135                 byte CommandType, byte AttribDataType, uint16 AttribId, byte ErrorCode );
    136          
    137          static afStatus_t multiSend( afMultiHdr_t *hdr, byte *seqNum, byte radius );
    138          #endif
    139          
    140          #if ( AF_V1_SUPPORT )
    141          static afStatus_t afDataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
    142                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    143                                     uint8 options, uint8 radius );
    144          #endif
    145          
    146          static epList_t *afFindEndPointDescList( byte EndPoint );
    147          
    148          static pDescCB afGetDescCB( endPointDesc_t *epDesc );
    149          
    150          /*********************************************************************
    151           * NETWORK LAYER CALLBACKS
    152           */
    153          
    154          /*********************************************************************
    155           * PUBLIC FUNCTIONS
    156           */
    157          
    158          /*********************************************************************
    159           * @fn      afInit
    160           *
    161           * @brief   Initialization function for the AF.
    162           *
    163           * @param   none
    164           *
    165           * @return  none
    166           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    167          void afInit( void )
   \                     afInit:
    168          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    169            // Start with no endpoint defined
    170            epList = NULL;
   \   000004   90....       MOV     DPTR,#epList
   \   000007   E4           CLR     A
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   F0           MOVX    @DPTR,A
    171          }
   \   00000B   02....       LJMP    ?Subroutine30 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    172          
    173          /*********************************************************************
    174           * @fn      afRegisterExtended
    175           *
    176           * @brief   Register an Application's EndPoint description.
    177           *
    178           * @param   epDesc - pointer to the Application's endpoint descriptor.
    179           * @param   descFn - pointer to descriptor callback function
    180           *
    181           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    182           *
    183           * @return  Pointer to epList_t on success, NULL otherwise.
    184           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    185          epList_t *afRegisterExtended( endPointDesc_t *epDesc, pDescCB descFn )
   \                     afRegisterExtended:
    186          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   740E         MOV     A,#0xe
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 1,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 2,A
    187            epList_t *ep;
    188            epList_t *epSearch;
    189          
    190            ep = osal_mem_alloc( sizeof ( epList_t ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   7A0A         MOV     R2,#0xa
   \   00001B   7B00         MOV     R3,#0x0
   \   00001D   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   000020   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   000022   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    191            if ( ep )
   \   000025   EA           MOV     A,R2
   \   000026   7001         JNZ     ??afRegisterExtended_0
   \   000028   EB           MOV     A,R3
   \                     ??afRegisterExtended_0:
   \   000029   6060         JZ      ??afRegisterExtended_1
    192            {
    193              // Fill in the new list entry
    194              ep->epDesc = epDesc;
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   EE           MOV     A,R6
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   EF           MOV     A,R7
   \   000033   12....       LCALL   ?Subroutine2 & 0xFFFF
    195              #if !defined ( REFLECTOR )
    196              ep->reflectorAddr = NWK_PAN_COORD_ADDR;
   \                     ??CrossCallReturnLabel_2:
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   F0           MOVX    @DPTR,A
    197              #else
    198              ep->reflectorAddr = INVALID_NODE_ADDR;
    199              #endif
    200              // Default to allow Match Descriptor.
    201              ep->flags = eEP_AllowMatch;
   \   00003A   7401         MOV     A,#0x1
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   12....       LCALL   ?Subroutine1 & 0xFFFF
    202          #if ( AF_KVP_SUPPORT )
    203              ep->flags |= ((epDesc->endPoint == ZDO_EP) ? 0 : eEP_UsesKVP);
    204          #endif
    205              ep->pfnDescCB = descFn;
   \                     ??CrossCallReturnLabel_101:
   \   000047   E5..         MOV     A,?V0 + 0
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   E5..         MOV     A,?V0 + 1
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   E5..         MOV     A,?V0 + 2
   \   000051   12....       LCALL   ?Subroutine1 & 0xFFFF
    206              ep->nextDesc = NULL;
   \                     ??CrossCallReturnLabel_102:
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   E4           CLR     A
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   F0           MOVX    @DPTR,A
    207          
    208              // Does a list exist?
    209              if ( epList == NULL )
   \   00005B   90....       MOV     DPTR,#epList
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   7002         JNZ     ??afRegisterExtended_2
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \                     ??afRegisterExtended_2:
   \   000063   90....       MOV     DPTR,#epList
   \   000066   601E         JZ      ??afRegisterExtended_3
    210                epList = ep;  // Make this the first entry
    211              else
    212              {
    213                // Look for the end of the list
    214                epSearch = epList;
    215                while( epSearch->nextDesc != NULL )
    216                  epSearch = epSearch->nextDesc;
   \                     ??afRegisterExtended_4:
   \   000068   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   7002         JNZ     ??afRegisterExtended_5
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \                     ??afRegisterExtended_5:
   \   000078   8882         MOV     DPL,R0
   \   00007A   8983         MOV     DPH,R1
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   70E2         JNZ     ??afRegisterExtended_4
    217          
    218                // Add new entry to end of list
    219                epSearch->nextDesc = ep;
   \                     ??afRegisterExtended_3:
   \   000086   EA           MOV     A,R2
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   EB           MOV     A,R3
   \   00008A   F0           MOVX    @DPTR,A
    220              }
    221            }
    222          
    223            return ep;
   \                     ??afRegisterExtended_1:
   \   00008B                REQUIRE ?Subroutine31
   \   00008B                ; // Fall through to label ?Subroutine31
    224          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   02....       LJMP    ?Subroutine32 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   A3           INC     DPTR
   \                     ??Subroutine32_0:
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   A3           INC     DPTR
   \                     ??Subroutine25_0:
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET
    225          
    226          /*********************************************************************
    227           * @fn      afRegister
    228           *
    229           * @brief   Register an Application's EndPoint description.
    230           *
    231           * @param   epDesc - pointer to the Application's endpoint descriptor.
    232           *
    233           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    234           *
    235           * @return  afStatus_SUCCESS - Registered
    236           *          afStatus_MEM_FAIL - not enough memory to add descriptor
    237           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    238          afStatus_t afRegister( endPointDesc_t *epDesc )
   \                     afRegister:
    239          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
    240            epList_t *ep = afRegisterExtended( epDesc, NULL );
    241          
    242            return ((ep == NULL) ? afStatus_MEM_FAIL : afStatus_SUCCESS);
   \   000005                ; Setup parameters for call to function afRegisterExtended
   \   000005   75..00       MOV     ?V0 + 0,#0x0
   \   000008   75..00       MOV     ?V0 + 1,#0x0
   \   00000B   75..00       MOV     ?V0 + 2,#0x0
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000013   90....       MOV     DPTR,#(afRegisterExtended & 0xffff)
   \   000016   74..         MOV     A,#((afRegisterExtended >> 16) & 0xff)
   \   000018   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000020   EA           MOV     A,R2
   \   000021   7001         JNZ     ??afRegister_0
   \   000023   EB           MOV     A,R3
   \                     ??afRegister_0:
   \   000024   7004         JNZ     ??afRegister_1
   \   000026   7981         MOV     R1,#-0x7f
   \   000028   8002         SJMP    ??afRegister_2
   \                     ??afRegister_1:
   \   00002A   7900         MOV     R1,#0x0
   \                     ??afRegister_2:
   \   00002C   7F03         MOV     R7,#0x3
   \   00002E   02....       LJMP    ?BANKED_LEAVE_XDATA
    243          }
    244          
    245          #if ( AF_KVP_SUPPORT )
    246          /*********************************************************************
    247           * @fn      afRegisterFlags
    248           *
    249           * @brief   Register an Application's EndPoint description.
    250           *
    251           * @param   epDesc - pointer to the Application's endpoint descriptor.
    252           *
    253           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    254           *
    255           * @return  afStatus_SUCCESS - Registered
    256           *          afStatus_MEM_FAIL - not enough memory to add descriptor
    257           */
    258          afStatus_t afRegisterFlags( endPointDesc_t *epDesc, eEP_Flags flags )
    259          {
    260            epList_t *ep = afRegisterExtended( epDesc, NULL );
    261          
    262            if ( ep != NULL )
    263            {
    264              ep->flags = flags;
    265              return afStatus_SUCCESS;
    266            }
    267            else
    268            {
    269              return afStatus_MEM_FAIL;
    270            }
    271          }
    272          #endif
    273          
    274          /*********************************************************************
    275           * @fn          afDataConfirm
    276           *
    277           * @brief       This function will generate the Data Confirm back to
    278           *              the application.
    279           *
    280           * @param       endPoint - confirm end point
    281           * @param       transID - transaction ID from APSDE_DATA_REQUEST
    282           * @param       status - status of APSDE_DATA_REQUEST
    283           *
    284           * @return      none
    285           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    286          void afDataConfirm( uint8 endPoint, uint8 transID, ZStatus_t status )
   \                     afDataConfirm:
    287          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8B..         MOV     ?V0 + 1,R3
    288            endPointDesc_t *epDesc;
    289            afDataConfirm_t *msgPtr;
    290          
    291            // Find the endpoint description
    292            epDesc = afFindEndPointDesc( endPoint );
   \   000009                ; Setup parameters for call to function afFindEndPointDesc
   \   000009   90....       MOV     DPTR,#(afFindEndPointDesc & 0xffff)
   \   00000C   74..         MOV     A,#((afFindEndPointDesc >> 16) & 0xff)
   \   00000E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000011   8A..         MOV     ?V0 + 2,R2
   \   000013   8B..         MOV     ?V0 + 3,R3
   \   000015   AE..         MOV     R6,?V0 + 2
   \   000017   AF..         MOV     R7,?V0 + 3
    293            if ( epDesc == NULL )
   \   000019   EE           MOV     A,R6
   \   00001A   7001         JNZ     ??afDataConfirm_0
   \   00001C   EF           MOV     A,R7
   \                     ??afDataConfirm_0:
   \   00001D   602C         JZ      ??afDataConfirm_1
    294              return;
    295          
    296            // Determine the incoming command type
    297            msgPtr = (afDataConfirm_t *)osal_msg_allocate( sizeof(afDataConfirm_t) );
   \   00001F                ; Setup parameters for call to function osal_msg_allocate
   \   00001F   7A04         MOV     R2,#0x4
   \   000021   7B00         MOV     R3,#0x0
   \   000023   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000026   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000028   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    298            if ( msgPtr )
   \   00002B   EA           MOV     A,R2
   \   00002C   7001         JNZ     ??afDataConfirm_2
   \   00002E   EB           MOV     A,R3
   \                     ??afDataConfirm_2:
   \   00002F   601A         JZ      ??afDataConfirm_1
    299            {
    300              // Build the Data Confirm message
    301              msgPtr->hdr.event = AF_DATA_CONFIRM_CMD;
   \   000031   74FD         MOV     A,#-0x3
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   F0           MOVX    @DPTR,A
    302              msgPtr->hdr.status = status;
   \   000038   A3           INC     DPTR
   \   000039   E5..         MOV     A,?V0 + 1
   \   00003B   12....       LCALL   ?Subroutine2 & 0xFFFF
    303              msgPtr->endpoint = endPoint;
   \                     ??CrossCallReturnLabel_3:
   \   00003E   E5..         MOV     A,?V0 + 0
   \   000040   F0           MOVX    @DPTR,A
    304          #if ( AF_V1_SUPPORT )
    305              msgPtr->transID = transID;
    306          #elif ( AF_KVP_SUPPORT )
    307              {
    308                epList_t *pList = afFindEndPointDescList( endPoint );
    309                if ( pList )
    310                {
    311                  if ( pList->flags & eEP_UsesKVP )
    312                  {
    313                    msgPtr->transID = transID;
    314                  }
    315                }
    316              }
    317          #else
    318              (void)transID;
    319          #endif
    320          
    321              // send message through task message
    322              osal_msg_send( *(epDesc->task_id), (byte *)msgPtr );
   \   000041                ; Setup parameters for call to function osal_msg_send
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000048   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??afDataConfirm_1:
   \   00004B   7F04         MOV     R7,#0x4
   \   00004D   02....       LJMP    ?BANKED_LEAVE_XDATA
    323            }
    324          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000004   F9           MOV     R1,A
   \   000005   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   000008   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   00000A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    325          
    326          /*********************************************************************
    327           * @fn          afIncomingData
    328           *
    329           * @brief       Transfer a data PDU (ASDU) from the APS sub-layer to the AF.
    330           *
    331           * @param       aff  - pointer to APS frame format
    332           * @param       SrcAddress  - Source address
    333           * @param       LinkQuality - incoming message's link quality
    334           * @param       SecurityUse - Security enable/disable
    335           *
    336           * @return      none
    337           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    338          void afIncomingData( aps_FrameFormat_t *aff, zAddrType_t *SrcAddress,
   \                     afIncomingData:
    339                               uint8 LinkQuality, byte SecurityUse, uint32 timestamp )
    340          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   7407         MOV     A,#0x7
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   7406         MOV     A,#0x6
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E9           MOV     A,R1
   \   000025   F0           MOVX    @DPTR,A
   \   000026   741A         MOV     A,#0x1a
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   78..         MOV     R0,#?V0 + 0
   \   00002D   12....       LCALL   ?L_MOV_X
    341            endPointDesc_t *epDesc = NULL;
    342            uint16 epProfileID = 0xFFFF;  // Invalid Profile ID
   \   000030   7404         MOV     A,#0x4
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   74FF         MOV     A,#-0x1
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   F0           MOVX    @DPTR,A
    343            epList_t *pList;
    344            uint8 grpEp;
    345          
    346            if ( (NLME_GetProtocolVersion() != ZB_PROT_V1_0)
    347                && ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
   \   00003A                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   00003A   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   00003D   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   00003F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000042   E9           MOV     A,R1
   \   000043   6401         XRL     A,#0x1
   \   000045   604A         JZ      ??afIncomingData_0
   \   000047   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00004A   7045         JNZ     ??afIncomingData_0
    348            {
    349              // Find the first endpoint for this group
    350              grpEp = aps_FindGroupForEndpoint( aff->GroupID, APS_GROUPS_FIND_FIRST );
   \   00004C                ; Setup parameters for call to function aps_FindGroupForEndpoint
   \   00004C   79FE         MOV     R1,#-0x2
   \   00004E   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000051   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000054   E9           MOV     A,R1
   \   000055   FF           MOV     R7,A
    351              if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
   \   000056   74FE         MOV     A,#-0x2
   \   000058   6F           XRL     A,R7
   \   000059   7003         JNZ     $+5
   \   00005B   02....       LJMP    ??afIncomingData_1 & 0xFFFF
    352                return;   // No endpoint found
    353          
    354              epDesc = afFindEndPointDesc( grpEp );
   \                     ??afIncomingData_2:
   \   00005E                ; Setup parameters for call to function afFindEndPointDesc
   \   00005E   EF           MOV     A,R7
   \   00005F   F9           MOV     R1,A
   \   000060   90....       MOV     DPTR,#(afFindEndPointDesc & 0xffff)
   \   000063   74..         MOV     A,#((afFindEndPointDesc >> 16) & 0xff)
   \   000065   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000068   8A..         MOV     ?V0 + 6,R2
   \   00006A   8B..         MOV     ?V0 + 7,R3
    355              if ( epDesc == NULL )
   \   00006C   EA           MOV     A,R2
   \   00006D   7001         JNZ     ??afIncomingData_3
   \   00006F   EB           MOV     A,R3
   \                     ??afIncomingData_3:
   \   000070   7003         JNZ     $+5
   \   000072   02....       LJMP    ??afIncomingData_1 & 0xFFFF
    356                return;   // Endpoint descriptor not found
    357          
    358              pList = afFindEndPointDescList( epDesc->endPoint );
   \                     ??afIncomingData_4:
   \   000075                ; Setup parameters for call to function afFindEndPointDescList
   \   000075   85..82       MOV     DPL,?V0 + 6
   \   000078   85..83       MOV     DPH,?V0 + 7
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F9           MOV     R1,A
   \   00007D   90....       MOV     DPTR,#(??afFindEndPointDescList & 0xffff)
   \   000080   74..         MOV     A,#((??afFindEndPointDescList >> 16) & 0xff)
   \   000082   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000085   7402         MOV     A,#0x2
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   EA           MOV     A,R2
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   A3           INC     DPTR
   \   00008D   EB           MOV     A,R3
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   805C         SJMP    ??afIncomingData_5
    359            }
    360            else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
   \                     ??afIncomingData_0:
   \   000091   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000094   702D         JNZ     ??afIncomingData_6
    361            {
    362              // Set the list
    363              if ( (pList = epList) )
   \   000096   90....       MOV     DPTR,#epList
   \   000099   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00009C   7402         MOV     A,#0x2
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000A4   7402         MOV     A,#0x2
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   7002         JNZ     ??afIncomingData_7
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \                     ??afIncomingData_7:
   \   0000AE   7003         JNZ     $+5
   \   0000B0   02....       LJMP    ??afIncomingData_1 & 0xFFFF
    364              {
    365                epDesc = pList->epDesc;
   \                     ??afIncomingData_8:
   \   0000B3   7402         MOV     A,#0x2
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0000BB   F5..         MOV     ?V0 + 6,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F5..         MOV     ?V0 + 7,A
   \   0000C1   802A         SJMP    ??afIncomingData_5
    366              }
    367            }
    368            else if ( (epDesc = afFindEndPointDesc( aff->DstEndPoint )) )
   \                     ??afIncomingData_6:
   \   0000C3                ; Setup parameters for call to function afFindEndPointDesc
   \   0000C3   85..82       MOV     DPL,?XSP + 0
   \   0000C6   85..83       MOV     DPH,?XSP + 1
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   F583         MOV     DPH,A
   \   0000CD   8882         MOV     DPL,R0
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   F9           MOV     R1,A
   \   0000D3   90....       MOV     DPTR,#(afFindEndPointDesc & 0xffff)
   \   0000D6   74..         MOV     A,#((afFindEndPointDesc >> 16) & 0xff)
   \   0000D8   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000DB   8A..         MOV     ?V0 + 4,R2
   \   0000DD   8B..         MOV     ?V0 + 5,R3
   \   0000DF   A8..         MOV     R0,?V0 + 4
   \   0000E1   A9..         MOV     R1,?V0 + 5
   \   0000E3   88..         MOV     ?V0 + 6,R0
   \   0000E5   89..         MOV     ?V0 + 7,R1
   \   0000E7   E8           MOV     A,R0
   \   0000E8   7001         JNZ     ??afIncomingData_9
   \   0000EA   E9           MOV     A,R1
   \                     ??afIncomingData_9:
   \   0000EB   7088         JNZ     ??afIncomingData_4
    369            {
    370              pList = afFindEndPointDescList( epDesc->endPoint );
    371            }
    372          
    373            while ( epDesc )
   \                     ??afIncomingData_5:
   \   0000ED   E5..         MOV     A,?V0 + 6
   \   0000EF   7002         JNZ     ??afIncomingData_10
   \   0000F1   E5..         MOV     A,?V0 + 7
   \                     ??afIncomingData_10:
   \   0000F3   7003         JNZ     $+5
   \   0000F5   02....       LJMP    ??afIncomingData_1 & 0xFFFF
    374            {
    375              if ( pList->pfnDescCB )
   \   0000F8   7402         MOV     A,#0x2
   \   0000FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FD   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000100   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000103   85..82       MOV     DPL,?V0 + 6
   \   000106   85..83       MOV     DPH,?V0 + 7
   \   000109   603F         JZ      ??afIncomingData_11
    376              {
    377                uint16 *pID = (uint16 *)(pList->pfnDescCB(
    378                                           AF_DESCRIPTOR_PROFILE_ID, epDesc->endPoint ));
   \   00010B                ; Setup parameters for indirect call
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   7802         MOV     R0,#0x2
   \   00010E   FC           MOV     R4,A
   \   00010F   E8           MOV     A,R0
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   E0           MOVX    A,@DPTR
   \   000114   F9           MOV     R1,A
   \   000115   A3           INC     DPTR
   \   000116   E0           MOVX    A,@DPTR
   \   000117   F583         MOV     DPH,A
   \   000119   8982         MOV     DPL,R1
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   FA           MOV     R2,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   8982         MOV     DPL,R1
   \   000129   8A83         MOV     DPH,R2
   \   00012B   CC           XCH     A,R4
   \   00012C   FA           MOV     R2,A
   \   00012D   EC           MOV     A,R4
   \   00012E   C8           XCH     A,R0
   \   00012F   F9           MOV     R1,A
   \   000130   E8           MOV     A,R0
   \   000131   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    379                if ( pID )
   \   000134   EA           MOV     A,R2
   \   000135   7001         JNZ     ??afIncomingData_12
   \   000137   EB           MOV     A,R3
   \                     ??afIncomingData_12:
   \   000138   602B         JZ      ??CrossCallReturnLabel_8
    380                {
    381                  epProfileID = *pID;
   \   00013A   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00013D   7404         MOV     A,#0x4
   \   00013F   12....       LCALL   ?XSTACK_DISP0_8
   \   000142   12....       LCALL   ?Subroutine3 & 0xFFFF
    382                  osal_mem_free( pID );
   \                     ??CrossCallReturnLabel_5:
   \   000145   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000148   801B         SJMP    ??CrossCallReturnLabel_8
    383                }
    384              }
    385              else if ( epDesc->simpleDesc )
   \                     ??afIncomingData_11:
   \   00014A   A3           INC     DPTR
   \   00014B   A3           INC     DPTR
   \   00014C   A3           INC     DPTR
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   7002         JNZ     ??afIncomingData_13
   \   000150   A3           INC     DPTR
   \   000151   E0           MOVX    A,@DPTR
   \                     ??afIncomingData_13:
   \   000152   6011         JZ      ??CrossCallReturnLabel_8
    386              {
    387                epProfileID = epDesc->simpleDesc->AppProfId;
   \   000154   85..82       MOV     DPL,?V0 + 6
   \   000157   85..83       MOV     DPH,?V0 + 7
   \   00015A   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00015D   7404         MOV     A,#0x4
   \   00015F   12....       LCALL   ?XSTACK_DISP0_8
   \   000162   12....       LCALL   ??Subroutine4_0 & 0xFFFF
    388              }
    389          
    390              if ( (aff->ProfileID == epProfileID) ||
    391                   ((epDesc->endPoint == ZDO_EP) && (aff->ProfileID == ZDO_PROFILE_ID)) )
   \                     ??CrossCallReturnLabel_8:
   \   000165   85..82       MOV     DPL,?XSP + 0
   \   000168   85..83       MOV     DPH,?XSP + 1
   \   00016B   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00016E   7404         MOV     A,#0x4
   \   000170   12....       LCALL   ?XSTACK_DISP0_8
   \   000173   E0           MOVX    A,@DPTR
   \   000174   68           XRL     A,R0
   \   000175   7003         JNZ     ??afIncomingData_14
   \   000177   A3           INC     DPTR
   \   000178   E0           MOVX    A,@DPTR
   \   000179   69           XRL     A,R1
   \                     ??afIncomingData_14:
   \   00017A   601C         JZ      ??afIncomingData_15
   \   00017C   85..82       MOV     DPL,?V0 + 6
   \   00017F   85..83       MOV     DPH,?V0 + 7
   \   000182   E0           MOVX    A,@DPTR
   \   000183   704D         JNZ     ??afIncomingData_16
   \   000185   85..82       MOV     DPL,?XSP + 0
   \   000188   85..83       MOV     DPH,?XSP + 1
   \   00018B   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00018E   A3           INC     DPTR
   \   00018F   A3           INC     DPTR
   \   000190   A3           INC     DPTR
   \   000191   E0           MOVX    A,@DPTR
   \   000192   7002         JNZ     ??afIncomingData_17
   \   000194   A3           INC     DPTR
   \   000195   E0           MOVX    A,@DPTR
   \                     ??afIncomingData_17:
   \   000196   703A         JNZ     ??afIncomingData_16
    392              {
    393          #if ( AF_KVP_SUPPORT )
    394                if ( (FRAMETYPE_KVP == HI_UINT8(aff->asdu[0])) &&
    395                     (pList->flags & eEP_UsesKVP) )
    396                {
    397                  afBuildKVPIncoming( aff, epDesc, SrcAddress, LinkQuality, SecurityUse );
    398                }
    399                else
    400          #endif
    401                {
    402                  afBuildMSGIncoming( aff, epDesc, SrcAddress, LinkQuality, SecurityUse, timestamp );
   \                     ??afIncomingData_15:
   \   000198                ; Setup parameters for call to function afBuildMSGIncoming
   \   000198   78..         MOV     R0,#?V0 + 0
   \   00019A   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00019D   741D         MOV     A,#0x1d
   \   00019F   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A2   E0           MOVX    A,@DPTR
   \   0001A3   F5..         MOV     ?V0 + 4,A
   \   0001A5   78..         MOV     R0,#?V0 + 4
   \   0001A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001AA   740C         MOV     A,#0xc
   \   0001AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AF   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001B2   740D         MOV     A,#0xd
   \   0001B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B7   E0           MOVX    A,@DPTR
   \   0001B8   F9           MOV     R1,A
   \   0001B9   AC..         MOV     R4,?V0 + 6
   \   0001BB   AD..         MOV     R5,?V0 + 7
   \   0001BD   7407         MOV     A,#0x7
   \   0001BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C2   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0001C5   90....       MOV     DPTR,#(??afBuildMSGIncoming & 0xffff)
   \   0001C8   74..         MOV     A,#((??afBuildMSGIncoming >> 16) & 0xff)
   \   0001CA   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0001CD   7407         MOV     A,#0x7
   \   0001CF   12....       LCALL   ?DEALLOC_XSTACK8
    403                }
    404              }
    405          
    406              if ( (NLME_GetProtocolVersion() != ZB_PROT_V1_0)
    407                && ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
   \                     ??afIncomingData_16:
   \   0001D2                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   0001D2   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   0001D5   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   0001D7   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0001DA   E9           MOV     A,R1
   \   0001DB   6401         XRL     A,#0x1
   \   0001DD   6019         JZ      ??afIncomingData_18
   \   0001DF   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0001E2   7014         JNZ     ??afIncomingData_18
    408              {
    409                // Find the next endpoint for this group
    410                grpEp = aps_FindGroupForEndpoint( aff->GroupID, grpEp );
   \   0001E4                ; Setup parameters for call to function aps_FindGroupForEndpoint
   \   0001E4   EF           MOV     A,R7
   \   0001E5   F9           MOV     R1,A
   \   0001E6   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0001E9   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0001EC   E9           MOV     A,R1
   \   0001ED   FF           MOV     R7,A
    411                if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
   \   0001EE   74FE         MOV     A,#-0x2
   \   0001F0   6F           XRL     A,R7
   \   0001F1   6003         JZ      $+5
   \   0001F3   02....       LJMP    ??afIncomingData_2 & 0xFFFF
   \   0001F6   8024         SJMP    ??afIncomingData_1
    412                  return;   // No endpoint found
    413          
    414                epDesc = afFindEndPointDesc( grpEp );
    415                if ( epDesc == NULL )
    416                  return;   // Endpoint descriptor not found
    417          
    418                pList = afFindEndPointDescList( epDesc->endPoint );
    419              }
    420              else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
   \                     ??afIncomingData_18:
   \   0001F8   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   0001FB   701F         JNZ     ??afIncomingData_1
    421              {
    422                pList = pList->nextDesc;
   \   0001FD   7402         MOV     A,#0x2
   \   0001FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000202   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000205   7402         MOV     A,#0x2
   \   000207   12....       LCALL   ?XSTACK_DISP0_8
   \   00020A   12....       LCALL   ??Subroutine4_0 & 0xFFFF
    423                if ( pList )
   \                     ??CrossCallReturnLabel_9:
   \   00020D   7402         MOV     A,#0x2
   \   00020F   12....       LCALL   ?XSTACK_DISP0_8
   \   000212   E0           MOVX    A,@DPTR
   \   000213   7002         JNZ     ??afIncomingData_19
   \   000215   A3           INC     DPTR
   \   000216   E0           MOVX    A,@DPTR
   \                     ??afIncomingData_19:
   \   000217   6003         JZ      $+5
   \   000219   02....       LJMP    ??afIncomingData_8 & 0xFFFF
   \                     ??afIncomingData_1:
   \   00021C   7409         MOV     A,#0x9
   \   00021E                REQUIRE ?Subroutine33
   \   00021E                ; // Fall through to label ?Subroutine33
    424                  epDesc = pList->epDesc;
    425                else
    426                  epDesc = NULL;
    427              }
    428              else
    429                epDesc = NULL;
    430            }
    431          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   02....       LJMP    ?Subroutine32 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   64FF         XRL     A,#0xff
   \   00000E   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000009   540C         ANL     A,#0xc
   \   00000B   640C         XRL     A,#0xc
   \   00000D   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F583         MOV     DPH,A
   \   00000A   8882         MOV     DPL,R0
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FA           MOV     R2,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FB           MOV     R3,A
   \   000015   90....       MOV     DPTR,#(aps_FindGroupForEndpoint & 0xffff)
   \   000018   74..         MOV     A,#((aps_FindGroupForEndpoint >> 16) & 0xff)
   \   00001A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \                     ??Subroutine20_0:
   \   000004   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000003   EC           MOV     A,R4
   \   000004   4D           ORL     A,R5
   \   000005   4E           ORL     A,R6
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000006   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F9           MOV     R1,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \                     ??Subroutine4_0:
   \   000005   E8           MOV     A,R0
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E9           MOV     A,R1
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function osal_mem_free
   \   000005                ; Setup parameters for call to function osal_mem_free
   \   000005   90....       MOV     DPTR,#(osal_mem_free & 0xffff)
   \   000008   74..         MOV     A,#((osal_mem_free >> 16) & 0xff)
   \   00000A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \                     ??Subroutine7_0:
   \   000004   E0           MOVX    A,@DPTR
   \   000005   FA           MOV     R2,A
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FB           MOV     R3,A
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   FE           MOV     R6,A
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000003   22           RET
    432          
    433          #if ( AF_KVP_SUPPORT )
    434          /*********************************************************************
    435           * @fn          afBuildKVPIncoming
    436           *
    437           * @brief       Build the message for the app
    438           *
    439           * @param
    440           *
    441           * @return
    442           */
    443          static void afBuildKVPIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    444                           zAddrType_t *SrcAddress, uint8 LinkQuality, byte SecurityUse )
    445          {
    446            afIncomingKVPPacket_t *KVPpkt = (afIncomingKVPPacket_t *)osal_mem_alloc(
    447                                     sizeof( afIncomingKVPPacket_t ) );
    448            byte *asdu = aff->asdu;
    449            const byte total = LO_UINT8( *asdu++ );
    450            byte count;
    451          
    452            if ( KVPpkt == NULL )
    453            {
    454              return;
    455            }
    456          
    457            KVPpkt->hdr.event = ((total > 1) ? AF_INCOMING_GRP_KVP_CMD :
    458                                               AF_INCOMING_KVP_CMD );
    459            KVPpkt->clusterId = aff->ClusterID;
    460            afCopyAddress( &(KVPpkt->srcAddr), SrcAddress );
    461            KVPpkt->srcAddr.endPoint = aff->SrcEndPoint;
    462            KVPpkt->endPoint = epDesc->endPoint;
    463            KVPpkt->wasBroadcast = aff->wasBroadcast;
    464            KVPpkt->LinkQuality = LinkQuality;
    465            KVPpkt->SecurityUse = SecurityUse;
    466            KVPpkt->totalTrans = total;
    467            KVPpkt->cmd.TransSeqNumber = *asdu++;
    468          
    469            for ( count = 1; count <= total; count++ )
    470            {
    471              afIncomingKVPPacket_t *msgKVPpkt;
    472          
    473              KVPpkt->cmd.CommandType = LO_UINT8(*asdu);
    474              KVPpkt->cmd.AttribDataType = HI_UINT8(*asdu++);
    475              KVPpkt->cmd.AttribId = BUILD_UINT16( asdu[0], asdu[1] );
    476              asdu += 2;
    477          
    478              /* ErrorCode */
    479              if ((KVPpkt->cmd.CommandType == CMDTYPE_GET_RESP) ||
    480                  (KVPpkt->cmd.CommandType == CMDTYPE_SET_RESP) ||
    481                  (KVPpkt->cmd.CommandType == CMDTYPE_EVENT_RESP))
    482              {
    483                KVPpkt->cmd.ErrorCode = *asdu++;
    484              }
    485              else
    486              {
    487                KVPpkt->cmd.ErrorCode = ERRORCODE_SUCCESS;
    488              }
    489          
    490              /* DataLength */
    491              if ( (KVPpkt->cmd.CommandType == CMDTYPE_GET_ACK) ||
    492                   (KVPpkt->cmd.CommandType == CMDTYPE_SET_RESP) ||
    493                   (KVPpkt->cmd.CommandType == CMDTYPE_EVENT_RESP ) )
    494              {
    495                KVPpkt->cmd.DataLength = 0;
    496              }
    497              else if ((KVPpkt->cmd.AttribDataType == DATATYPE_CHAR_STR) ||
    498                       (KVPpkt->cmd.AttribDataType == DATATYPE_OCTET_STR))
    499              {
    500                KVPpkt->cmd.DataLength = *asdu++;
    501              }
    502              else
    503              {
    504                KVPpkt->cmd.DataLength = GetDataTypeLength( (byte)KVPpkt->cmd.AttribDataType );
    505              }
    506          
    507              msgKVPpkt = (afIncomingKVPPacket_t *)osal_msg_allocate( (short)
    508                           (sizeof( afIncomingKVPPacket_t ) + KVPpkt->cmd.DataLength) );
    509          
    510              if ( msgKVPpkt == NULL )
    511              {
    512                // Maybe not enought for an octet string, but next might be no data,
    513                // so don't return here, just continue to look at the rest.
    514                asdu += KVPpkt->cmd.DataLength;
    515                continue;
    516              }
    517          
    518              osal_memcpy( msgKVPpkt, KVPpkt, sizeof( afIncomingKVPPacket_t ) );
    519          
    520              msgKVPpkt->count = count;
    521          
    522              if ( msgKVPpkt->cmd.DataLength )
    523              {
    524                msgKVPpkt->cmd.Data = (byte *)(msgKVPpkt + 1);
    525                osal_memcpy( msgKVPpkt->cmd.Data, asdu, msgKVPpkt->cmd.DataLength );
    526                asdu += msgKVPpkt->cmd.DataLength;
    527              }
    528              else
    529              {
    530                msgKVPpkt->cmd.Data = NULL;
    531              }
    532          
    533          #if defined ( MT_AF_CB_FUNC )
    534              // If MT has subscribed for this callback, don't send as a message.
    535              if ( _afCallbackSub & CB_ID_AF_DATA_IND )
    536              {
    537                af_MTCB_IncomingData( (void *)msgKVPpkt );
    538                // Release the memory.
    539                osal_msg_deallocate( (void *)msgKVPpkt );
    540              }
    541              else
    542          #endif
    543              {
    544                osal_msg_send( *(epDesc->task_id), (uint8*)msgKVPpkt );
    545              }
    546            }
    547          
    548            osal_mem_free( KVPpkt );
    549          }
    550          #endif
    551          
    552          /*********************************************************************
    553           * @fn          afBuildMSGIncoming
    554           *
    555           * @brief       Build the message for the app
    556           *
    557           * @param
    558           *
    559           * @return      pointer to next in data buffer
    560           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    561          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
   \                     ??afBuildMSGIncoming:
    562                           zAddrType_t *SrcAddress, uint8 LinkQuality, byte SecurityUse,
    563                           uint32 timestamp )
    564          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7401         MOV     A,#0x1
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EC           MOV     A,R4
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   ED           MOV     A,R5
   \   000013   F0           MOVX    @DPTR,A
   \   000014   E9           MOV     A,R1
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   8A..         MOV     ?V0 + 6,R2
   \   00001E   8B..         MOV     ?V0 + 7,R3
   \   000020   7418         MOV     A,#0x18
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   78..         MOV     R0,#?V0 + 0
   \   000027   12....       LCALL   ?L_MOV_X
    565            afIncomingMSGPacket_t *MSGpkt;
    566          #if ( AF_V1_SUPPORT )
    567            const byte proVer = NLME_GetProtocolVersion();
    568            const byte len = sizeof( afIncomingMSGPacket_t ) +
    569                        ((proVer == ZB_PROT_V1_0) ? aff->asdu[2] : aff->asduLength);
    570            byte *asdu = aff->asdu + ((proVer == ZB_PROT_V1_0) ? 1 : 0);
    571          #else
    572            const byte len = sizeof( afIncomingMSGPacket_t ) + aff->asduLength;
    573            byte *asdu = aff->asdu;
   \   00002A   EA           MOV     A,R2
   \   00002B   240C         ADD     A,#0xc
   \   00002D   F582         MOV     DPL,A
   \   00002F   EB           MOV     A,R3
   \   000030   12....       LCALL   ??Subroutine21_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000033   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000036   7403         MOV     A,#0x3
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ??Subroutine4_0 & 0xFFFF
    574          #endif
    575            MSGpkt = (afIncomingMSGPacket_t *)osal_msg_allocate( len );
   \                     ??CrossCallReturnLabel_10:
   \   00003E                ; Setup parameters for call to function osal_msg_allocate
   \   00003E   EA           MOV     A,R2
   \   00003F   240E         ADD     A,#0xe
   \   000041   F582         MOV     DPL,A
   \   000043   EB           MOV     A,R3
   \   000044   12....       LCALL   ??Subroutine21_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000047   E0           MOVX    A,@DPTR
   \   000048   2417         ADD     A,#0x17
   \   00004A   FA           MOV     R2,A
   \   00004B   7B00         MOV     R3,#0x0
   \   00004D   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000050   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000052   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000055   8A..         MOV     ?V0 + 4,R2
   \   000057   8B..         MOV     ?V0 + 5,R3
   \   000059   AE..         MOV     R6,?V0 + 4
   \   00005B   AF..         MOV     R7,?V0 + 5
    576          
    577            if ( MSGpkt == NULL )
   \   00005D   EE           MOV     A,R6
   \   00005E   7001         JNZ     ??afBuildMSGIncoming_1
   \   000060   EF           MOV     A,R7
   \                     ??afBuildMSGIncoming_1:
   \   000061   7003         JNZ     $+5
   \   000063   02....       LJMP    ??afBuildMSGIncoming_2 & 0xFFFF
    578            {
    579              return;
    580            }
    581          
    582            MSGpkt->hdr.event = AF_INCOMING_MSG_CMD;
   \   000066   741A         MOV     A,#0x1a
   \   000068   8E82         MOV     DPL,R6
   \   00006A   8F83         MOV     DPH,R7
   \   00006C   12....       LCALL   ?Subroutine22 & 0xFFFF
    583            MSGpkt->groupId = aff->GroupID;
   \                     ??CrossCallReturnLabel_99:
   \   00006F   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000072   E8           MOV     A,R0
   \   000073   F0           MOVX    @DPTR,A
   \   000074   A3           INC     DPTR
   \   000075   E9           MOV     A,R1
   \   000076   12....       LCALL   ?Subroutine0 & 0xFFFF
    584            MSGpkt->clusterId = aff->ClusterID;
   \                     ??CrossCallReturnLabel_0:
   \   000079   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   12....       LCALL   ??Subroutine4_0 & 0xFFFF
    585            afCopyAddress( &MSGpkt->srcAddr, SrcAddress );
   \                     ??CrossCallReturnLabel_11:
   \   000081                ; Setup parameters for call to function afCopyAddress
   \   000081   7415         MOV     A,#0x15
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000089   EE           MOV     A,R6
   \   00008A   2406         ADD     A,#0x6
   \   00008C   FA           MOV     R2,A
   \   00008D   EF           MOV     A,R7
   \   00008E   3400         ADDC    A,#0x0
   \   000090   FB           MOV     R3,A
   \   000091   90....       MOV     DPTR,#(afCopyAddress & 0xffff)
   \   000094   74..         MOV     A,#((afCopyAddress >> 16) & 0xff)
   \   000096   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    586            MSGpkt->srcAddr.endPoint = aff->SrcEndPoint;
   \   000099   85..82       MOV     DPL,?V0 + 6
   \   00009C   85..83       MOV     DPH,?V0 + 7
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   0000A5   F0           MOVX    @DPTR,A
    587            MSGpkt->endPoint = epDesc->endPoint;
   \   0000A6   7401         MOV     A,#0x1
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   0000AE   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   0000B1   A3           INC     DPTR
   \   0000B2   12....       LCALL   ?Subroutine0 & 0xFFFF
    588            MSGpkt->wasBroadcast = aff->wasBroadcast;
   \                     ??CrossCallReturnLabel_1:
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   C0E0         PUSH    A
   \   0000BC   EE           MOV     A,R6
   \   0000BD   240B         ADD     A,#0xb
   \   0000BF   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   0000C2   D0E0         POP     A
   \   0000C4   F0           MOVX    @DPTR,A
    589            MSGpkt->LinkQuality = LinkQuality;
   \   0000C5   85..82       MOV     DPL,?XSP + 0
   \   0000C8   85..83       MOV     DPH,?XSP + 1
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   C0E0         PUSH    A
   \   0000CE   EE           MOV     A,R6
   \   0000CF   240C         ADD     A,#0xc
   \   0000D1   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   0000D4   D0E0         POP     A
   \   0000D6   F0           MOVX    @DPTR,A
    590            MSGpkt->SecurityUse = SecurityUse;
   \   0000D7   7417         MOV     A,#0x17
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   C0E0         PUSH    A
   \   0000DF   EE           MOV     A,R6
   \   0000E0   240D         ADD     A,#0xd
   \   0000E2   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   0000E5   D0E0         POP     A
   \   0000E7   F0           MOVX    @DPTR,A
    591            MSGpkt->timestamp = timestamp;
   \   0000E8   EE           MOV     A,R6
   \   0000E9   240E         ADD     A,#0xe
   \   0000EB   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0000EE   78..         MOV     R0,#?V0 + 0
   \   0000F0   12....       LCALL   ?L_MOV_TO_X
    592          
    593          #if ( AF_V1_SUPPORT )
    594            if ( proVer == ZB_PROT_V1_0 )
    595            {
    596              MSGpkt->cmd.TransSeqNumber = *asdu++;
    597              MSGpkt->cmd.DataLength = *asdu++;
    598            }
    599            else
    600          #endif
    601            {
    602              MSGpkt->cmd.TransSeqNumber = 0;
   \   0000F3   EE           MOV     A,R6
   \   0000F4   2412         ADD     A,#0x12
   \   0000F6   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   0000F9   E4           CLR     A
   \   0000FA   F0           MOVX    @DPTR,A
   \   0000FB   E5..         MOV     A,?V0 + 6
   \   0000FD   240E         ADD     A,#0xe
   \   0000FF   F582         MOV     DPL,A
   \   000101   E5..         MOV     A,?V0 + 7
   \   000103   12....       LCALL   ??Subroutine21_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000106   E0           MOVX    A,@DPTR
   \   000107   F8           MOV     R0,A
   \   000108   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   00010B   E8           MOV     A,R0
   \   00010C   F0           MOVX    @DPTR,A
   \   00010D   A3           INC     DPTR
   \   00010E   E4           CLR     A
   \   00010F   F0           MOVX    @DPTR,A
    603              MSGpkt->cmd.DataLength = aff->asduLength;
    604            }
    605          
    606            if ( MSGpkt->cmd.DataLength )
   \   000110   E8           MOV     A,R0
   \   000111   7001         JNZ     ??afBuildMSGIncoming_3
   \   000113   E4           CLR     A
   \                     ??afBuildMSGIncoming_3:
   \   000114   6043         JZ      ??afBuildMSGIncoming_4
    607            {
    608              MSGpkt->cmd.Data = (byte *)(MSGpkt + 1);
   \   000116   EE           MOV     A,R6
   \   000117   2415         ADD     A,#0x15
   \   000119   F8           MOV     R0,A
   \   00011A   EF           MOV     A,R7
   \   00011B   3400         ADDC    A,#0x0
   \   00011D   F9           MOV     R1,A
   \   00011E   E8           MOV     A,R0
   \   00011F   FA           MOV     R2,A
   \   000120   E9           MOV     A,R1
   \   000121   FB           MOV     R3,A
   \   000122   EE           MOV     A,R6
   \   000123   2417         ADD     A,#0x17
   \   000125   08           INC     R0
   \   000126   08           INC     R0
   \   000127   EF           MOV     A,R7
   \   000128   3400         ADDC    A,#0x0
   \   00012A   12....       LCALL   ?Subroutine4 & 0xFFFF
    609              osal_memcpy( MSGpkt->cmd.Data, asdu, MSGpkt->cmd.DataLength );
   \                     ??CrossCallReturnLabel_12:
   \   00012D                ; Setup parameters for call to function osal_memcpy
   \   00012D   7403         MOV     A,#0x3
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   E0           MOVX    A,@DPTR
   \   000133   F5..         MOV     ?V0 + 0,A
   \   000135   A3           INC     DPTR
   \   000136   E0           MOVX    A,@DPTR
   \   000137   F5..         MOV     ?V0 + 1,A
   \   000139   75..00       MOV     ?V0 + 2,#0x0
   \   00013C   78..         MOV     R0,#?V0 + 0
   \   00013E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000141   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000144   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000147   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00014A   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   00014D   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   00014F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000152   7403         MOV     A,#0x3
   \   000154   12....       LCALL   ?DEALLOC_XSTACK8
   \   000157   800A         SJMP    ??afBuildMSGIncoming_5
    610            }
    611            else
    612            {
    613              MSGpkt->cmd.Data = NULL;
   \                     ??afBuildMSGIncoming_4:
   \   000159   EE           MOV     A,R6
   \   00015A   2415         ADD     A,#0x15
   \   00015C   12....       LCALL   ??Subroutine21_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   00015F   E4           CLR     A
   \   000160   F0           MOVX    @DPTR,A
   \   000161   A3           INC     DPTR
   \   000162   F0           MOVX    @DPTR,A
    614            }
    615          
    616          #if defined ( MT_AF_CB_FUNC )
    617            // If MT has subscribed for this callback, don't send as a message.
    618            if ( _afCallbackSub & CB_ID_AF_DATA_IND )
    619            {
    620              af_MTCB_IncomingData( (void *)MSGpkt );
    621              // Release the memory.
    622              osal_msg_deallocate( (void *)MSGpkt );
    623            }
    624            else
    625          #endif
    626            {
    627              // Send message through task message.
    628              osal_msg_send( *(epDesc->task_id), (uint8 *)MSGpkt );
   \                     ??afBuildMSGIncoming_5:
   \   000163                ; Setup parameters for call to function osal_msg_send
   \   000163   EE           MOV     A,R6
   \   000164   FA           MOV     R2,A
   \   000165   EF           MOV     A,R7
   \   000166   FB           MOV     R3,A
   \   000167   7401         MOV     A,#0x1
   \   000169   12....       LCALL   ?XSTACK_DISP0_8
   \   00016C   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00016F   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000172   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    629            }
    630          }
   \                     ??afBuildMSGIncoming_2:
   \   000175   7405         MOV     A,#0x5
   \   000177   02....       LJMP    ?Subroutine33 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   EE           MOV     A,R6
   \   000001   2413         ADD     A,#0x13
   \                     ??Subroutine21_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \                     ??Subroutine21_1:
   \   000006   3400         ADDC    A,#0x0
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ??Subroutine25_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009                REQUIRE ?Subroutine32
   \   000009                ; // Fall through to label ?Subroutine32

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 6
   \   000004   85..83       MOV     DPH,?V0 + 7
   \   000007   80..         SJMP    ??Subroutine32_0

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000003   22           RET
    631          
    632          #if ( AF_KVP_SUPPORT )
    633          /*********************************************************************
    634           * @fn      multiInit
    635           *
    636           * @brief   Initialize a multi header.
    637           *
    638           * @param   none
    639           *
    640           * @return  Pointer to the new memory allocated for the afMultiHdr_t structure.
    641           */
    642          static afMultiHdr_t *multiInit( afAddrType_t *dstAddr,
    643                               byte srcEndPoint, uint16 clusterID, byte FrameType,
    644                               byte txOptions, bool DiscoverRoute, byte RadiusCounter )
    645          {
    646            afMultiHdr_t *hdr = (afMultiHdr_t *)osal_mem_alloc( sizeof( afMultiHdr_t ) );
    647          
    648            if ( hdr == NULL )
    649            {
    650              return NULL;
    651            }
    652          
    653            hdr->clusterID = clusterID;
    654            hdr->transCount = 0;
    655            hdr->options = txOptions & AF_ACK_REQUEST;
    656            hdr->options |= (DiscoverRoute) ? AF_DISCV_ROUTE : 0;
    657            hdr->srcEP = srcEndPoint;
    658            hdr->dstAddr.endPoint = dstAddr->endPoint;
    659            hdr->dstAddr.addrMode = dstAddr->addrMode;
    660            hdr->dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
    661            hdr->msgLen = 0;
    662            hdr->msg = NULL;
    663          
    664            return hdr;
    665          }
    666          
    667          /*********************************************************************
    668           * @fn      multiAppend
    669           *
    670           * @brief   Concatenate a new KVP message too a mulit-KVP message.
    671           *
    672           * @param   none
    673           *
    674           * @return  TRUE for success, FALSE otherwise.
    675           */
    676          static bool multiAppend( afMultiHdr_t *hdr, byte bufLen, byte *buf,
    677                 byte CommandType, byte AttribDataType, uint16 AttribId, byte ErrorCode )
    678          {
    679            byte len = (byte)hdr->msgLen;
    680            byte *msg = osal_mem_alloc( (short)(AF_HDR_KVP_MAX_LEN + bufLen + len) );
    681          
    682            if ( msg == NULL )
    683            {
    684              return FALSE;
    685            }
    686          
    687            if ( hdr->msg == NULL )  // Need to make space for FrameType/Count & SeqNum.
    688            {
    689              len += 5;
    690              hdr->msg = msg;
    691              msg += 2;
    692            }
    693            else                     // Need to copy existing buffer over.
    694            {
    695              len += 3;
    696              osal_memcpy( msg, hdr->msg, hdr->msgLen );
    697              osal_mem_free( hdr->msg );
    698              hdr->msg = msg;
    699              msg += hdr->msgLen;
    700            }
    701          
    702            *msg++ = BUILD_UINT8( AttribDataType, CommandType );
    703            *msg++ = LO_UINT16( AttribId);
    704            *msg++ = HI_UINT16( AttribId );
    705          
    706            if ((CommandType == CMDTYPE_GET_RESP) ||
    707                (CommandType == CMDTYPE_SET_RESP) ||
    708                (CommandType == CMDTYPE_EVENT_RESP) )
    709            {
    710              *msg++ = ErrorCode;
    711              len++;
    712            }
    713          
    714            if ( (CommandType == CMDTYPE_GET_ACK) ||
    715                 (CommandType == CMDTYPE_SET_RESP) ||
    716                 (CommandType == CMDTYPE_EVENT_RESP ) )
    717            {
    718              bufLen = 0;
    719            }
    720            else if ((AttribDataType == DATATYPE_CHAR_STR) ||
    721                     (AttribDataType == DATATYPE_OCTET_STR))
    722            {
    723              *msg++ = bufLen;
    724              len++;
    725            }
    726          
    727            if ( buf && bufLen )
    728            {
    729              osal_memcpy( msg, buf, bufLen );
    730              len += bufLen;
    731            }
    732          
    733            hdr->msgLen = len;
    734            hdr->transCount++;
    735          
    736            return TRUE;
    737          }
    738          
    739          /*********************************************************************
    740           * @fn      multiSend
    741           *
    742           * @brief   Send whatever has been buffered to send multi.
    743           *
    744           * @param   none
    745           *
    746           * @return  afStatus_t
    747           */
    748          static afStatus_t multiSend( afMultiHdr_t *hdr, byte *seqNum, byte radius )
    749          {
    750            afStatus_t stat;
    751          
    752            if ( hdr == NULL )
    753            {
    754              return afStatus_MEM_FAIL;
    755            }
    756          
    757            hdr->msg[0] = BUILD_UINT8( FRAMETYPE_KVP, hdr->transCount );
    758            hdr->msg[1] = *seqNum;
    759          
    760            stat = afSend( &hdr->dstAddr, hdr->srcEP, hdr->clusterID,
    761                            hdr->msgLen, hdr->msg, seqNum, hdr->options, radius );
    762          
    763            osal_mem_free( hdr->msg );
    764            osal_mem_free( hdr );
    765          
    766            return stat;
    767          }
    768          
    769          /*********************************************************************
    770           * @fn      afAddOrSendMessage
    771           *
    772           * @brief   Fills in the cmd format structure and sends the out-going message.
    773           *
    774           * input parameters
    775           *
    776           * @param  *dstAddr         - Full ZB destination address: Nwk Addr + End Point.
    777           * @param   srcEndPoint     - Origination (i.e. respond to or ack to) End Point.
    778           * @param   clusterID       - A valid cluster ID as specified by the Profile
    779           *          (e.g. see CLUSTERID_... defs in HomeControlLighting.h).
    780           * @param   AddOrSend       - A valid afAddOrSend_t type.
    781           * @param   FrameType       - A valid frame type (see prev def of FRAMETYPE_...)
    782           * @param  *TransSeqNumber  - A pointer to a byte which can be modified and
    783           *          which will be used as the transaction sequence number of the msg.
    784           * @param   CommandType     -
    785           *          KVP Frame Type  : A valid command type (see prev def of CMDTYPE_...)
    786           *          MSG Frame Type  : Set to 0.
    787           * @param   AttribDataType  -
    788           *          KVP Frame Type  : A valid data type (see prev def of DATATYPE_...)
    789           *          MSG Frame Type  : Set to 0.
    790           * @param   AttribId        -
    791           *          KVP Frame Type  : A valid Attribute ID as specified by the Profile.
    792           *            (e.g. see OnOffSRC_OnOff in HomeControlLighting.h).
    793           *          MSG Frame Type  : Set to 0.
    794           * @param   ErrorCode       -
    795           *          KVP Frame Type  : A valid error code (see prev def of ERRORCODE_...)
    796           *          Note: Set to 0 unless the CommandType is one of the CMDTYPE_..._ACK.
    797           *          MSG Frame Type  : Set to 0.
    798           * @param   DataLength      - Number of bytes of data pointed to by next param.
    799           *          KVP Frame Type  : This must match value expected for the
    800           *          AttributeDataType specified above or the send will fail.
    801           *          MSG Frame Type  : No restriction or checks.
    802           * @param  *Data            - A pointer to the data bytes to send.
    803           * @param   txOptions       - A valid bit mask (see prev def of APS_TX_OPTIONS_)
    804           * @param   DiscoverRoute   - Normally set to FALSE. Perhaps set to TRUE after
    805           *          receiving an AF_DATA_CONFIRM_CMD with status other than ZSuccess.
    806           * @param   RadiusCounter   - Normally set to AF_DEFAULT_RADIUS.
    807           *
    808           * output parameters
    809           *
    810           * @param  *TransSeqNumber  - Incremented by one if the return value is success.
    811           *
    812           * @return  afStatus_t      - See previous definition of afStatus_... types.
    813           */
    814          afStatus_t afAddOrSendMessage(
    815              afAddrType_t *dstAddr, byte srcEndPoint, cId_t clusterID,
    816              afAddOrSend_t AddOrSend, byte FrameType, byte *TransSeqNumber,
    817              byte CommandType, byte AttribDataType, uint16 AttribId, byte ErrorCode,
    818              byte DataLength, byte *Data,
    819              byte txOptions, byte DiscoverRoute, byte RadiusCounter )
    820          {
    821            static afMultiHdr_t *hdr;
    822            afStatus_t stat = afStatus_FAILED;
    823          
    824            if ( FrameType == FRAMETYPE_MSG )
    825            {
    826              if ( AddOrSend != SEND_MESSAGE )
    827              {
    828                return afStatus_INVALID_PARAMETER;
    829              }
    830          
    831              return afFillAndSendMessage( dstAddr, srcEndPoint, clusterID,
    832                1, FrameType, TransSeqNumber, NULL, NULL, NULL, NULL,
    833                DataLength, Data, txOptions, DiscoverRoute, RadiusCounter );
    834            }
    835          
    836            if ( FrameType != FRAMETYPE_KVP )
    837            {
    838              return afStatus_INVALID_PARAMETER;
    839            }
    840          
    841            // Cannot mix Cluster ID's in aggregation packet.
    842            if ( (hdr != NULL) && (hdr->clusterID != clusterID) )
    843            {
    844              multiSend( hdr, TransSeqNumber, RadiusCounter );
    845              hdr = NULL;
    846            }
    847          
    848            if ( hdr == NULL )
    849            {
    850              hdr = multiInit( dstAddr, srcEndPoint, clusterID, FrameType,
    851                               txOptions, DiscoverRoute, RadiusCounter );
    852              if ( hdr == NULL )
    853              {
    854                return afStatus_MEM_FAIL;
    855              }
    856            }
    857          
    858            if ( FALSE == multiAppend( hdr, (byte)DataLength, Data,
    859                                     CommandType, AttribDataType, AttribId, ErrorCode ) )
    860            {
    861              if ( hdr->msg != NULL )
    862              {
    863                multiSend( hdr, TransSeqNumber, RadiusCounter );
    864              }
    865              else
    866              {
    867                osal_mem_free( hdr );
    868              }
    869              hdr = NULL;
    870              return afStatus_MEM_FAIL;
    871            }
    872          
    873            // Only supporting up to 16 concatenated messages.
    874            if ( (AddOrSend == SEND_MESSAGE) || (hdr->transCount >= 16) )
    875            {
    876              stat = multiSend( hdr, TransSeqNumber, RadiusCounter );
    877              hdr = NULL;
    878            }
    879            else
    880            {
    881              stat = afStatus_SUCCESS;
    882              (*TransSeqNumber)++;
    883            }
    884          
    885            return stat;
    886          }
    887          #endif
    888          
    889          #if ( AF_V1_SUPPORT || AF_KVP_SUPPORT )
    890          /*********************************************************************
    891           * @fn      afFillAndSendMessage
    892           *
    893           * @brief   Fills in the cmd format structure and sends the out-going message.
    894           *
    895           * input parameters
    896           *
    897           * @param  *dstAddr         - Full ZB destination address: Nwk Addr + End Point.
    898           * @param   srcEndPoint     - Origination (i.e. respond to or ack to) End Point.
    899           * @param   clusterID       - A valid cluster ID as specified by the Profile.
    900           * @param   TransCount      - Set to 1.
    901           * @param   FrameType       - A valid frame type (see prev def of FRAMETYPE_...)
    902           * @param  *TransSeqNumber  - A pointer to a byte which can be modified and
    903           *          which will be used as the transaction sequence number of the msg.
    904           * @param   CommandType     -
    905           *          KVP Frame Type  : A valid command type (see prev def of CMDTYPE_...)
    906           *          MSG Frame Type  : Set to 0.
    907           * @param   AttribDataType  -
    908           *          KVP Frame Type  : A valid data type (see prev def of DATATYPE_...)
    909           *          MSG Frame Type  : Set to 0.
    910           * @param   AttribId        -
    911           *          KVP Frame Type  : A valid Attribute ID as specified by the Profile.
    912           *            (e.g. see OnOffSRC_OnOff in HomeControlLighting.h).
    913           *          MSG Frame Type  : Set to 0.
    914           * @param   ErrorCode       -
    915           *          KVP Frame Type  : A valid error code (see prev def of ERRORCODE_...)
    916           *          Note: Set to 0 unless the CommandType is one of the CMDTYPE_..._ACK.
    917           *          MSG Frame Type  : Set to 0.
    918           * @param   DataLength      - Number of bytes of data pointed to by next param.
    919           *          KVP Frame Type  : This must match value expected for the
    920           *          AttributeDataType specified above or the send will fail.
    921           *          MSG Frame Type  : No restriction or checks.
    922           * @param  *Data            - A pointer to the data bytes to send.
    923           * @param   txOptions       - A valid bit mask (see prev def of APS_TX_OPTIONS_)
    924           * @param   DiscoverRoute   - Normally set to FALSE. Perhaps set to TRUE after
    925           *          receiving an AF_DATA_CONFIRM_CMD with status other than ZSuccess.
    926           * @param   RadiusCounter   - Normally set to AF_DEFAULT_RADIUS.
    927           *
    928           * output parameters
    929           *
    930           * @param  *TransSeqNumber  - Incremented by one if the return value is success.
    931           *
    932           * @return  afStatus_t      - See previous definition of afStatus_... types.
    933           */
    934          afStatus_t afFillAndSendMessage (
    935            afAddrType_t *dstAddr, byte srcEndPoint, cId_t clusterID,
    936            byte TransCount, byte FrameType, byte *TransSeqNumber,
    937            byte CommandType, byte AttribDataType, uint16 AttribId, byte ErrorCode,
    938            byte DataLength, byte *Data,
    939            byte txOptions, byte DiscoverRoute, byte RadiusCounter )
    940          {
    941            const byte proVer = NLME_GetProtocolVersion();
    942            afStatus_t stat = afStatus_FAILED;
    943            byte *buf = Data;
    944          
    945          #if ( AF_KVP_SUPPORT )
    946            if ( FrameType == FRAMETYPE_KVP )
    947            {
    948              return afAddOrSendMessage( dstAddr, srcEndPoint, clusterID,
    949                SEND_MESSAGE, FrameType, TransSeqNumber,
    950                CommandType, AttribDataType, AttribId, ErrorCode,
    951                DataLength, Data, txOptions, DiscoverRoute, RadiusCounter );
    952            }
    953          #endif
    954          
    955            if ( FrameType != FRAMETYPE_MSG )
    956            {
    957              return afStatus_INVALID_PARAMETER;
    958            }
    959          
    960            if ( TransCount != 1 )
    961            {
    962              return afStatus_INVALID_PARAMETER;
    963            }
    964          
    965            if ( proVer == ZB_PROT_V1_0 )
    966            {
    967              buf = osal_mem_alloc( (short)(DataLength+3) );
    968              if ( buf == NULL )
    969              {
    970                return afStatus_MEM_FAIL;
    971              }
    972          
    973              buf[0] = BUILD_UINT8( FRAMETYPE_MSG, 1 );
    974              buf[1] = *TransSeqNumber;
    975              buf[2] = (byte)DataLength;
    976          
    977              // Copy the data portion of the packet.
    978              if ( Data && DataLength )
    979              {
    980                osal_memcpy( buf+3, Data, DataLength );
    981                DataLength += 3;
    982              }
    983              else
    984              {
    985                DataLength = 3;
    986              }
    987            }
    988          
    989            stat = afSend( dstAddr, srcEndPoint, clusterID,
    990                           DataLength, buf, TransSeqNumber, txOptions, RadiusCounter );
    991          
    992            if ( proVer == ZB_PROT_V1_0 )
    993            {
    994              osal_mem_free( buf );
    995            }
    996          
    997            return stat;
    998          }
    999          #endif
   1000          
   1001          /*********************************************************************
   1002           * @fn      AF_DataRequest
   1003           *
   1004           * @brief   Common functionality for invoking APSDE_DataReq() for both
   1005           *          KVP-Send/SendMulti and MSG-Send.
   1006           *
   1007           * input parameters
   1008           *
   1009           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
   1010           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
   1011           * @param   cID - A valid cluster ID as specified by the Profile.
   1012           * @param   len - Number of bytes of data pointed to by next param.
   1013           * @param  *buf - A pointer to the data bytes to send.
   1014           * @param  *transID - A pointer to a byte which can be modified and which will
   1015           *                    be used as the transaction sequence number of the msg.
   1016           * @param   options - Valid bit mask of Tx options.
   1017           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
   1018           *
   1019           * output parameters
   1020           *
   1021           * @param  *transID - Incremented by one if the return value is success.
   1022           *
   1023           * @return  afStatus_t - See previous definition of afStatus_... types.
   1024           */
   1025          #if ( AF_V1_SUPPORT )
   1026          static afStatus_t afDataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
   1027                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
   1028                                     uint8 options, uint8 radius )
   1029          #else

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1030          afStatus_t AF_DataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
   \                     AF_DataRequest:
   1031                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
   1032                                     uint8 options, uint8 radius )
   1033          #endif
   1034          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 28
   \   000005   74E4         MOV     A,#-0x1c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   \   000012   E9           MOV     A,R1
   \   000013   FF           MOV     R7,A
   \   000014   7433         MOV     A,#0x33
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 6,A
   1035            pDescCB pfnDescCB;
   1036            ZStatus_t stat;
   1037            APSDE_DataReq_t req;
   1038            afDataReqMTU_t mtu;
   1039          
   1040          
   1041            if ( srcEP == NULL )
   \   00001C   EC           MOV     A,R4
   \   00001D   7001         JNZ     ??AF_DataRequest_0
   \   00001F   ED           MOV     A,R5
   \                     ??AF_DataRequest_0:
   \   000020   7005         JNZ     ??AF_DataRequest_1
   1042            {
   1043              return afStatus_INVALID_PARAMETER;
   \                     ??AF_DataRequest_2:
   \   000022   7982         MOV     R1,#-0x7e
   \   000024   02....       LJMP    ??AF_DataRequest_3 & 0xFFFF
   1044            }
   1045          
   1046            // Enforce consistent values on the destination address / address mode.
   1047            if ( dstAddr->addrMode == afAddrNotPresent )
   \                     ??AF_DataRequest_1:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   7023         JNZ     ??AF_DataRequest_4
   1048            {
   1049              dstAddr->endPoint = ZDO_EP;
   \   000030   E4           CLR     A
   \   000031   8A82         MOV     DPL,R2
   \   000033   8B83         MOV     DPH,R3
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   F0           MOVX    @DPTR,A
   1050              req.dstAddr.addr.shortAddr = afGetReflector( srcEP->endPoint );
   \   000039                ; Setup parameters for call to function afGetReflector
   \   000039   8C82         MOV     DPL,R4
   \   00003B   8D83         MOV     DPH,R5
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   F9           MOV     R1,A
   \   00003F   90....       MOV     DPTR,#(afGetReflector & 0xffff)
   \   000042   74..         MOV     A,#((afGetReflector >> 16) & 0xff)
   \   000044   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000047   7402         MOV     A,#0x2
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   EA           MOV     A,R2
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   EB           MOV     A,R3
   \                     ??AF_DataRequest_5:
   \   000050   F0           MOVX    @DPTR,A
   \   000051   8056         SJMP    ??AF_DataRequest_6
   1051            }
   1052            else // Handle types: afAddr16Bit
   1053            {    //               afAddrBroadcast
   1054                 //               afAddrGroup
   1055              req.dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
   \                     ??AF_DataRequest_4:
   \   000053   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000056   7402         MOV     A,#0x2
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E8           MOV     A,R0
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E9           MOV     A,R1
   \   00005F   12....       LCALL   ?Subroutine2 & 0xFFFF
   1056          
   1057              if ( ( dstAddr->addrMode == afAddr16Bit     ) ||
   1058                   ( dstAddr->addrMode == afAddrBroadcast )    )
   \                     ??CrossCallReturnLabel_4:
   \   000062   E0           MOVX    A,@DPTR
   \   000063   6402         XRL     A,#0x2
   \   000065   600B         JZ      ??AF_DataRequest_7
   \   000067   8A82         MOV     DPL,R2
   \   000069   8B83         MOV     DPH,R3
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   640F         XRL     A,#0xf
   \   000070   7029         JNZ     ??AF_DataRequest_8
   1059              {
   1060                // Check for valid broadcast values
   1061                if( ADDR_NOT_BCAST != NLME_IsAddressBroadcast( dstAddr->addr.shortAddr )  )
   \                     ??AF_DataRequest_7:
   \   000072                ; Setup parameters for call to function NLME_IsAddressBroadcast
   \   000072   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000075   90....       MOV     DPTR,#(NLME_IsAddressBroadcast & 0xffff)
   \   000078   74..         MOV     A,#((NLME_IsAddressBroadcast >> 16) & 0xff)
   \   00007A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00007D   E9           MOV     A,R1
   \   00007E   600C         JZ      ??AF_DataRequest_9
   1062                {
   1063                  // Force mode to broadcast
   1064                  dstAddr->addrMode = afAddrBroadcast;
   \   000080   740F         MOV     A,#0xf
   \   000082   85..82       MOV     DPL,?V0 + 0
   \   000085   85..83       MOV     DPH,?V0 + 1
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   80C4         SJMP    ??AF_DataRequest_5
   1065                }
   1066                else
   1067                {
   1068                  // Address is not a valid broadcast type
   1069                  if ( dstAddr->addrMode == afAddrBroadcast )
   \                     ??AF_DataRequest_9:
   \   00008C   85..82       MOV     DPL,?V0 + 0
   \   00008F   85..83       MOV     DPH,?V0 + 1
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   640F         XRL     A,#0xf
   \   000097   7010         JNZ     ??AF_DataRequest_6
   \   000099   8087         SJMP    ??AF_DataRequest_2
   1070                  {
   1071                    return afStatus_INVALID_PARAMETER;
   1072                  }
   1073                }
   1074              }
   1075              else if ( dstAddr->addrMode != afAddrGroup )
   \                     ??AF_DataRequest_8:
   \   00009B   8A82         MOV     DPL,R2
   \   00009D   8B83         MOV     DPH,R3
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   6401         XRL     A,#0x1
   \   0000A4   6003         JZ      $+5
   \   0000A6   02....       LJMP    ??AF_DataRequest_2 & 0xFFFF
   1076              {
   1077                return afStatus_INVALID_PARAMETER;
   1078              }
   1079            }
   1080            req.dstAddr.addrMode = dstAddr->addrMode;
   \                     ??AF_DataRequest_6:
   \   0000A9   85..82       MOV     DPL,?V0 + 0
   \   0000AC   85..83       MOV     DPH,?V0 + 1
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   C0E0         PUSH    A
   \   0000B4   740A         MOV     A,#0xa
   \   0000B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B9   D0E0         POP     A
   \   0000BB   F0           MOVX    @DPTR,A
   1081            req.profileID = ZDO_PROFILE_ID;
   \   0000BC   740F         MOV     A,#0xf
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   E4           CLR     A
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   F0           MOVX    @DPTR,A
   1082          
   1083            if ( (pfnDescCB = afGetDescCB( srcEP )) )
   \   0000C5   90....       MOV     DPTR,#epList
   \   0000C8   8003         SJMP    ??AF_DataRequest_10
   \                     ??AF_DataRequest_11:
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \                     ??AF_DataRequest_10:
   \   0000CD   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000D0   E8           MOV     A,R0
   \   0000D1   7001         JNZ     ??AF_DataRequest_12
   \   0000D3   E9           MOV     A,R1
   \                     ??AF_DataRequest_12:
   \   0000D4   6047         JZ      ??AF_DataRequest_13
   \   0000D6   8882         MOV     DPL,R0
   \   0000D8   8983         MOV     DPH,R1
   \   0000DA   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000DD   E5..         MOV     A,?V0 + 2
   \   0000DF   6A           XRL     A,R2
   \   0000E0   7003         JNZ     ??AF_DataRequest_14
   \   0000E2   E5..         MOV     A,?V0 + 3
   \   0000E4   6B           XRL     A,R3
   \                     ??AF_DataRequest_14:
   \   0000E5   8882         MOV     DPL,R0
   \   0000E7   8983         MOV     DPH,R1
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   70DA         JNZ     ??AF_DataRequest_11
   \   0000F0   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0000F3   6028         JZ      ??AF_DataRequest_13
   1084            {
   1085              uint16 *pID = (uint16 *)(pfnDescCB(
   1086                                           AF_DESCRIPTOR_PROFILE_ID, srcEP->endPoint ));
   \   0000F5                ; Setup parameters for indirect call
   \   0000F5   85..82       MOV     DPL,?V0 + 2
   \   0000F8   85..83       MOV     DPH,?V0 + 3
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   FA           MOV     R2,A
   \   0000FD   09           INC     R1
   \   0000FE   09           INC     R1
   \   0000FF   8C82         MOV     DPL,R4
   \   000101   8D83         MOV     DPH,R5
   \   000103   EE           MOV     A,R6
   \   000104   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1087              if ( pID )
   \   000107   EA           MOV     A,R2
   \   000108   7001         JNZ     ??AF_DataRequest_15
   \   00010A   EB           MOV     A,R3
   \                     ??AF_DataRequest_15:
   \   00010B   6031         JZ      ??CrossCallReturnLabel_13
   1088              {
   1089                req.profileID = *pID;
   \   00010D   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000110   740F         MOV     A,#0xf
   \   000112   12....       LCALL   ?XSTACK_DISP0_8
   \   000115   12....       LCALL   ?Subroutine3 & 0xFFFF
   1090                osal_mem_free( pID );
   \                     ??CrossCallReturnLabel_6:
   \   000118   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00011B   8021         SJMP    ??CrossCallReturnLabel_13
   1091              }
   1092            }
   1093            else if ( srcEP->simpleDesc )
   \                     ??AF_DataRequest_13:
   \   00011D   85..82       MOV     DPL,?V0 + 2
   \   000120   85..83       MOV     DPH,?V0 + 3
   \   000123   A3           INC     DPTR
   \   000124   A3           INC     DPTR
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   7002         JNZ     ??AF_DataRequest_16
   \   000129   A3           INC     DPTR
   \   00012A   E0           MOVX    A,@DPTR
   \                     ??AF_DataRequest_16:
   \   00012B   6011         JZ      ??CrossCallReturnLabel_13
   1094            {
   1095              req.profileID = srcEP->simpleDesc->AppProfId;
   \   00012D   85..82       MOV     DPL,?V0 + 2
   \   000130   85..83       MOV     DPH,?V0 + 3
   \   000133   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000136   740F         MOV     A,#0xf
   \   000138   12....       LCALL   ?XSTACK_DISP0_8
   \   00013B   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   1096            }
   1097          
   1098            req.txOptions = 0;
   \                     ??CrossCallReturnLabel_13:
   \   00013E   7415         MOV     A,#0x15
   \   000140   12....       LCALL   ?XSTACK_DISP0_8
   \   000143   E4           CLR     A
   \   000144   F0           MOVX    @DPTR,A
   \   000145   A3           INC     DPTR
   \   000146   F0           MOVX    @DPTR,A
   1099          
   1100            if ( ( options & AF_ACK_REQUEST              ) &&
   1101                 ( req.dstAddr.addrMode != AddrBroadcast ) &&
   1102                 ( req.dstAddr.addrMode != AddrGroup     )    )
   \   000147   EF           MOV     A,R7
   \   000148   A2E4         MOV     C,0xE0 /* A   */.4
   \   00014A   501A         JNC     ??AF_DataRequest_17
   \   00014C   740A         MOV     A,#0xa
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   E0           MOVX    A,@DPTR
   \   000152   640F         XRL     A,#0xf
   \   000154   6010         JZ      ??AF_DataRequest_17
   \   000156   E0           MOVX    A,@DPTR
   \   000157   6401         XRL     A,#0x1
   \   000159   600B         JZ      ??AF_DataRequest_17
   1103            {
   1104              req.txOptions |=  APS_TX_OPTIONS_ACK;
   \   00015B   7415         MOV     A,#0x15
   \   00015D   12....       LCALL   ?XSTACK_DISP0_8
   \   000160   7404         MOV     A,#0x4
   \   000162   F0           MOVX    @DPTR,A
   \   000163   A3           INC     DPTR
   \   000164   E4           CLR     A
   \   000165   F0           MOVX    @DPTR,A
   1105            }
   1106          
   1107            if ( options & AF_SKIP_ROUTING )
   \                     ??AF_DataRequest_17:
   \   000166   EF           MOV     A,R7
   \   000167   A2E7         MOV     C,0xE0 /* A   */.7
   \   000169   500C         JNC     ??AF_DataRequest_18
   1108            {
   1109              req.txOptions |=  APS_TX_OPTIONS_SKIP_ROUTING;
   \   00016B   7415         MOV     A,#0x15
   \   00016D   12....       LCALL   ?XSTACK_DISP0_8
   \   000170   E0           MOVX    A,@DPTR
   \   000171   4410         ORL     A,#0x10
   \   000173   F0           MOVX    @DPTR,A
   \   000174   A3           INC     DPTR
   \   000175   E0           MOVX    A,@DPTR
   \   000176   F0           MOVX    @DPTR,A
   1110            }
   1111          
   1112            if ( options & AF_EN_SECURITY )
   \                     ??AF_DataRequest_18:
   \   000177   EF           MOV     A,R7
   \   000178   A2E6         MOV     C,0xE0 /* A   */.6
   \   00017A   5015         JNC     ??AF_DataRequest_19
   1113            {
   1114              req.txOptions |= APS_TX_OPTIONS_SECURITY_ENABLE;
   \   00017C   7415         MOV     A,#0x15
   \   00017E   12....       LCALL   ?XSTACK_DISP0_8
   \   000181   E0           MOVX    A,@DPTR
   \   000182   4401         ORL     A,#0x1
   \   000184   F0           MOVX    @DPTR,A
   \   000185   A3           INC     DPTR
   \   000186   E0           MOVX    A,@DPTR
   \   000187   F0           MOVX    @DPTR,A
   1115              mtu.aps.secure = TRUE;
   \   000188   7401         MOV     A,#0x1
   \   00018A   12....       LCALL   ?XSTACK_DISP0_8
   \   00018D   7401         MOV     A,#0x1
   \   00018F   8006         SJMP    ??AF_DataRequest_20
   1116            }
   1117            else
   1118            {
   1119              mtu.aps.secure = FALSE;
   \                     ??AF_DataRequest_19:
   \   000191   7401         MOV     A,#0x1
   \   000193   12....       LCALL   ?XSTACK_DISP0_8
   \   000196   E4           CLR     A
   \                     ??AF_DataRequest_20:
   \   000197   F0           MOVX    @DPTR,A
   1120            }
   1121          
   1122            mtu.kvp = FALSE;
   \   000198   E4           CLR     A
   \   000199   85..82       MOV     DPL,?XSP + 0
   \   00019C   85..83       MOV     DPH,?XSP + 1
   \   00019F   F0           MOVX    @DPTR,A
   1123          
   1124            req.transID       = *transID;
   \   0001A0   7431         MOV     A,#0x31
   \   0001A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A5   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0001A8   C0E0         PUSH    A
   \   0001AA   7417         MOV     A,#0x17
   \   0001AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AF   D0E0         POP     A
   \   0001B1   F0           MOVX    @DPTR,A
   1125            req.srcEP         = srcEP->endPoint;
   \   0001B2   85..82       MOV     DPL,?V0 + 2
   \   0001B5   85..83       MOV     DPH,?V0 + 3
   \   0001B8   E0           MOVX    A,@DPTR
   \   0001B9   C0E0         PUSH    A
   \   0001BB   740B         MOV     A,#0xb
   \   0001BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C0   D0E0         POP     A
   \   0001C2   F0           MOVX    @DPTR,A
   1126            req.dstEP         = dstAddr->endPoint;
   \   0001C3   85..82       MOV     DPL,?V0 + 0
   \   0001C6   85..83       MOV     DPH,?V0 + 1
   \   0001C9   A3           INC     DPTR
   \   0001CA   A3           INC     DPTR
   \   0001CB   A3           INC     DPTR
   \   0001CC   E0           MOVX    A,@DPTR
   \   0001CD   C0E0         PUSH    A
   \   0001CF   740C         MOV     A,#0xc
   \   0001D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D4   D0E0         POP     A
   \   0001D6   F0           MOVX    @DPTR,A
   1127            req.clusterID     = cID;
   \   0001D7   742B         MOV     A,#0x2b
   \   0001D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DC   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   0001DF   740D         MOV     A,#0xd
   \   0001E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E4   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   1128            req.asduLen       = len;
   \                     ??CrossCallReturnLabel_14:
   \   0001E7   742D         MOV     A,#0x2d
   \   0001E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EC   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0001EF   7411         MOV     A,#0x11
   \   0001F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F4   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   1129            req.asdu          = buf;
   \                     ??CrossCallReturnLabel_15:
   \   0001F7   742F         MOV     A,#0x2f
   \   0001F9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FC   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0001FF   7413         MOV     A,#0x13
   \   000201   12....       LCALL   ?XSTACK_DISP0_8
   \   000204   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   1130            req.discoverRoute = (uint8)((options & AF_DISCV_ROUTE) ? 1 : 0);
   \                     ??CrossCallReturnLabel_16:
   \   000207   EF           MOV     A,R7
   \   000208   A2E5         MOV     C,0xE0 /* A   */.5
   \   00020A   5004         JNC     ??AF_DataRequest_21
   \   00020C   D2F0         SETB    B.0
   \   00020E   8002         SJMP    ??AF_DataRequest_22
   \                     ??AF_DataRequest_21:
   \   000210   C2F0         CLR     B.0
   \                     ??AF_DataRequest_22:
   \   000212   A2F0         MOV     C,B.0
   \   000214   E4           CLR     A
   \   000215   92E0         MOV     0xE0 /* A   */.0,C
   \   000217   C0E0         PUSH    A
   \   000219   7418         MOV     A,#0x18
   \   00021B   12....       LCALL   ?XSTACK_DISP0_8
   \   00021E   D0E0         POP     A
   \   000220   F0           MOVX    @DPTR,A
   1131            req.radiusCounter = radius;
   \   000221   7419         MOV     A,#0x19
   \   000223   12....       LCALL   ?XSTACK_DISP0_8
   \   000226   E5..         MOV     A,?V0 + 6
   \   000228   F0           MOVX    @DPTR,A
   1132          
   1133            if (len > afDataReqMTU( &mtu ) )
   \   000229                ; Setup parameters for call to function afDataReqMTU
   \   000229   85..82       MOV     DPL,?XSP + 0
   \   00022C   85..83       MOV     DPH,?XSP + 1
   \   00022F   AA82         MOV     R2,DPL
   \   000231   AB83         MOV     R3,DPH
   \   000233   90....       MOV     DPTR,#(afDataReqMTU & 0xffff)
   \   000236   74..         MOV     A,#((afDataReqMTU >> 16) & 0xff)
   \   000238   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00023B   E9           MOV     A,R1
   \   00023C   FA           MOV     R2,A
   \   00023D   742D         MOV     A,#0x2d
   \   00023F   12....       LCALL   ?XSTACK_DISP0_8
   \   000242   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000245   C3           CLR     C
   \   000246   EA           MOV     A,R2
   \   000247   98           SUBB    A,R0
   \   000248   E4           CLR     A
   \   000249   99           SUBB    A,R1
   \   00024A   502F         JNC     ??AF_DataRequest_23
   1134            {
   1135              if (apsfSendFragmented)
   \   00024C   90....       MOV     DPTR,#apsfSendFragmented
   \   00024F   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000252   6023         JZ      ??AF_DataRequest_24
   1136              {
   1137                req.txOptions |= AF_FRAGMENTED | APS_TX_OPTIONS_ACK;
   \   000254   7415         MOV     A,#0x15
   \   000256   12....       LCALL   ?XSTACK_DISP0_8
   \   000259   E0           MOVX    A,@DPTR
   \   00025A   4405         ORL     A,#0x5
   \   00025C   F0           MOVX    @DPTR,A
   \   00025D   A3           INC     DPTR
   \   00025E   E0           MOVX    A,@DPTR
   \   00025F   F0           MOVX    @DPTR,A
   1138                stat = (*apsfSendFragmented)( &req );
   \   000260                ; Setup parameters for indirect call
   \   000260   7402         MOV     A,#0x2
   \   000262   12....       LCALL   ?XSTACK_DISP0_8
   \   000265   AA82         MOV     R2,DPL
   \   000267   AB83         MOV     R3,DPH
   \   000269   90....       MOV     DPTR,#apsfSendFragmented
   \   00026C   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   00026F   A3           INC     DPTR
   \   000270   E0           MOVX    A,@DPTR
   \   000271   8C82         MOV     DPL,R4
   \   000273   8D83         MOV     DPH,R5
   \   000275   8012         SJMP    ??AF_DataRequest_25
   1139              }
   1140              else
   1141              {
   1142                stat = afStatus_INVALID_PARAMETER;
   \                     ??AF_DataRequest_24:
   \   000277   7E82         MOV     R6,#-0x7e
   \   000279   8013         SJMP    ??AF_DataRequest_26
   1143              }
   1144            } 
   1145            else
   1146            {
   1147              stat = APSDE_DataReq( &req );
   \                     ??AF_DataRequest_23:
   \   00027B                ; Setup parameters for call to function APSDE_DataReq
   \   00027B   7402         MOV     A,#0x2
   \   00027D   12....       LCALL   ?XSTACK_DISP0_8
   \   000280   AA82         MOV     R2,DPL
   \   000282   AB83         MOV     R3,DPH
   \   000284   90....       MOV     DPTR,#(APSDE_DataReq & 0xffff)
   \   000287   74..         MOV     A,#((APSDE_DataReq >> 16) & 0xff)
   \                     ??AF_DataRequest_25:
   \   000289   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00028C   E9           MOV     A,R1
   \   00028D   FE           MOV     R6,A
   1148            }
   1149          
   1150            /*
   1151             * If this is an EndPoint-to-EndPoint message on the same device, it will not
   1152             * get added to the NWK databufs. So it will not go OTA and it will not get
   1153             * a MACCB_DATA_CONFIRM_CMD callback. Thus it is necessary to generate the
   1154             * AF_DATA_CONFIRM_CMD here. Note that APSDE_DataConfirm() only generates one
   1155             * message with the first in line TransSeqNumber, even on a multi message.
   1156             */
   1157            if ( (req.dstAddr.addrMode == Addr16Bit) &&
   1158                 (req.dstAddr.addr.shortAddr == NLME_GetShortAddr()) )
   \                     ??AF_DataRequest_26:
   \   00028E   740A         MOV     A,#0xa
   \   000290   12....       LCALL   ?XSTACK_DISP0_8
   \   000293   E0           MOVX    A,@DPTR
   \   000294   6402         XRL     A,#0x2
   \   000296   7039         JNZ     ??AF_DataRequest_27
   \   000298                ; Setup parameters for call to function NLME_GetShortAddr
   \   000298   90....       MOV     DPTR,#(NLME_GetShortAddr & 0xffff)
   \   00029B   74..         MOV     A,#((NLME_GetShortAddr >> 16) & 0xff)
   \   00029D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0002A0   8A..         MOV     ?V0 + 0,R2
   \   0002A2   8B..         MOV     ?V0 + 1,R3
   \   0002A4   A8..         MOV     R0,?V0 + 0
   \   0002A6   A9..         MOV     R1,?V0 + 1
   \   0002A8   7402         MOV     A,#0x2
   \   0002AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AD   E0           MOVX    A,@DPTR
   \   0002AE   68           XRL     A,R0
   \   0002AF   7003         JNZ     ??AF_DataRequest_28
   \   0002B1   A3           INC     DPTR
   \   0002B2   E0           MOVX    A,@DPTR
   \   0002B3   69           XRL     A,R1
   \                     ??AF_DataRequest_28:
   \   0002B4   701B         JNZ     ??AF_DataRequest_27
   1159            {
   1160              afDataConfirm( srcEP->endPoint, *transID, stat );
   \   0002B6                ; Setup parameters for call to function afDataConfirm
   \   0002B6   EE           MOV     A,R6
   \   0002B7   FB           MOV     R3,A
   \   0002B8   7431         MOV     A,#0x31
   \   0002BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BD   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0002C0   FA           MOV     R2,A
   \   0002C1   85..82       MOV     DPL,?V0 + 2
   \   0002C4   85..83       MOV     DPH,?V0 + 3
   \   0002C7   E0           MOVX    A,@DPTR
   \   0002C8   F9           MOV     R1,A
   \   0002C9   90....       MOV     DPTR,#(afDataConfirm & 0xffff)
   \   0002CC   74..         MOV     A,#((afDataConfirm >> 16) & 0xff)
   \   0002CE   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1161            }
   1162          
   1163            if ( stat == afStatus_SUCCESS )
   \                     ??AF_DataRequest_27:
   \   0002D1   EE           MOV     A,R6
   \   0002D2   700A         JNZ     ??AF_DataRequest_29
   1164            {
   1165              (*transID)++;
   \   0002D4   7431         MOV     A,#0x31
   \   0002D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D9   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0002DC   04           INC     A
   \   0002DD   F0           MOVX    @DPTR,A
   1166            }
   1167          
   1168            return (afStatus_t)stat;
   \                     ??AF_DataRequest_29:
   \   0002DE   EE           MOV     A,R6
   \   0002DF   F9           MOV     R1,A
   \                     ??AF_DataRequest_3:
   \   0002E0   741C         MOV     A,#0x1c
   \   0002E2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002E5   7F07         MOV     R7,#0x7
   \   0002E7   02....       LJMP    ?BANKED_LEAVE_XDATA
   1169          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000003   7900         MOV     R1,#0x0
   \   000005   EC           MOV     A,R4
   \   000006   4D           ORL     A,R5
   \   000007   4E           ORL     A,R6
   \   000008   22           RET
   1170          
   1171          /*********************************************************************
   1172           * @fn      afFindEndPointDescList
   1173           *
   1174           * @brief   Find the endpoint description entry from the endpoint
   1175           *          number.
   1176           *
   1177           * @param   EndPoint - Application Endpoint to look for
   1178           *
   1179           * @return  the address to the endpoint/interface description entry
   1180           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1181          static epList_t *afFindEndPointDescList( byte EndPoint )
   \                     ??afFindEndPointDescList:
   1182          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1183            epList_t *epSearch;
   1184          
   1185            // Start at the beginning
   1186            epSearch = epList;
   \   000004   90....       MOV     DPTR,#epList
   \   000007   800C         SJMP    ??afFindEndPointDescList_1
   1187          
   1188            // Look through the list until the end
   1189            while ( epSearch )
   1190            {
   1191              // Is there a match?
   1192              if ( epSearch->epDesc->endPoint == EndPoint )
   1193              {
   1194                return ( epSearch );
   1195              }
   1196              else
   1197                epSearch = epSearch->nextDesc;  // Next entry
   \                     ??afFindEndPointDescList_2:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \                     ??afFindEndPointDescList_1:
   \   000015   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000018   EA           MOV     A,R2
   \   000019   7001         JNZ     ??afFindEndPointDescList_3
   \   00001B   EB           MOV     A,R3
   \                     ??afFindEndPointDescList_3:
   \   00001C   600C         JZ      ??afFindEndPointDescList_4
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   \   000022   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000025   69           XRL     A,R1
   \   000026   70E1         JNZ     ??afFindEndPointDescList_2
   \   000028   8004         SJMP    ??afFindEndPointDescList_5
   1198            }
   1199          
   1200            return ( (epList_t *)NULL );
   \                     ??afFindEndPointDescList_4:
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7B00         MOV     R3,#0x0
   \                     ??afFindEndPointDescList_5:
   \   00002E   02....       LJMP    ?Subroutine30 & 0xFFFF
   1201          }
   1202          
   1203          /*********************************************************************
   1204           * @fn      afFindEndPointDesc
   1205           *
   1206           * @brief   Find the endpoint description entry from the endpoint
   1207           *          number.
   1208           *
   1209           * @param   EndPoint - Application Endpoint to look for
   1210           *
   1211           * @return  the address to the endpoint/interface description entry
   1212           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1213          endPointDesc_t *afFindEndPointDesc( byte EndPoint )
   \                     afFindEndPointDesc:
   1214          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1215            epList_t *epSearch;
   1216          
   1217            // Look for the endpoint
   1218            epSearch = afFindEndPointDescList( EndPoint );
   \   000005                ; Setup parameters for call to function afFindEndPointDescList
   \   000005   90....       MOV     DPTR,#(??afFindEndPointDescList & 0xffff)
   \   000008   74..         MOV     A,#((??afFindEndPointDescList >> 16) & 0xff)
   \   00000A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   1219          
   1220            if ( epSearch )
   \   000011   E582         MOV     A,DPL
   \   000013   7002         JNZ     ??afFindEndPointDesc_0
   \   000015   E583         MOV     A,DPH
   \                     ??afFindEndPointDesc_0:
   \   000017   6005         JZ      ??afFindEndPointDesc_1
   1221              return ( epSearch->epDesc );
   \   000019   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00001C   8004         SJMP    ??afFindEndPointDesc_2
   1222            else
   1223              return ( (endPointDesc_t *)NULL );
   \                     ??afFindEndPointDesc_1:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??afFindEndPointDesc_2:
   \   000022   02....       LJMP    ?Subroutine34 & 0xFFFF
   1224          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1225          
   1226          /*********************************************************************
   1227           * @fn      afFindSimpleDesc
   1228           *
   1229           * @brief   Find the Simple Descriptor from the endpoint number.
   1230           *
   1231           * @param   EP - Application Endpoint to look for.
   1232           *
   1233           * @return  Non-zero to indicate that the descriptor memory must be freed.
   1234           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1235          byte afFindSimpleDesc( SimpleDescriptionFormat_t **ppDesc, byte EP )
   \                     afFindSimpleDesc:
   1236          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   \   000009   E9           MOV     A,R1
   \   00000A   FF           MOV     R7,A
   1237            epList_t *epItem = afFindEndPointDescList( EP );
   \   00000B                ; Setup parameters for call to function afFindEndPointDescList
   \   00000B   90....       MOV     DPTR,#(??afFindEndPointDescList & 0xffff)
   \   00000E   74..         MOV     A,#((??afFindEndPointDescList >> 16) & 0xff)
   \   000010   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000013   8A..         MOV     ?V0 + 0,R2
   1238            byte rtrn = FALSE;
   \   000015   75..00       MOV     ?V0 + 4,#0x0
   1239          
   1240            if ( epItem )
   \   000018   EA           MOV     A,R2
   \   000019   7001         JNZ     ??afFindSimpleDesc_0
   \   00001B   EB           MOV     A,R3
   \                     ??afFindSimpleDesc_0:
   \   00001C   604E         JZ      ??afFindSimpleDesc_1
   1241            {
   1242              if ( epItem->pfnDescCB )
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00002A   6027         JZ      ??afFindSimpleDesc_2
   1243              {
   1244                *ppDesc = epItem->pfnDescCB( AF_DESCRIPTOR_SIMPLE, EP );
   \   00002C                ; Setup parameters for indirect call
   \   00002C   EF           MOV     A,R7
   \   00002D   FA           MOV     R2,A
   \   00002E   09           INC     R1
   \   00002F   85..82       MOV     DPL,?V0 + 0
   \   000032   8B83         MOV     DPH,R3
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   8C82         MOV     DPL,R4
   \   00003E   8D83         MOV     DPH,R5
   \   000040   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000043   85..82       MOV     DPL,?V0 + 2
   \   000046   85..83       MOV     DPH,?V0 + 3
   \   000049   EA           MOV     A,R2
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   EB           MOV     A,R3
   \   00004D   F0           MOVX    @DPTR,A
   1245                rtrn = TRUE;
   \   00004E   75..01       MOV     ?V0 + 4,#0x1
   \   000051   8023         SJMP    ??afFindSimpleDesc_3
   1246              }
   1247              else
   1248              {
   1249                *ppDesc = epItem->epDesc->simpleDesc;
   \                     ??afFindSimpleDesc_2:
   \   000053   8A82         MOV     DPL,R2
   \   000055   8B83         MOV     DPH,R3
   \   000057   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000060   85..82       MOV     DPL,?V0 + 2
   \   000063   85..83       MOV     DPH,?V0 + 3
   \   000066   E8           MOV     A,R0
   \   000067   F0           MOVX    @DPTR,A
   \   000068   A3           INC     DPTR
   \   000069   E9           MOV     A,R1
   \   00006A   8009         SJMP    ??afFindSimpleDesc_4
   1250              }
   1251            }
   1252            else
   1253            {
   1254              *ppDesc = NULL;
   \                     ??afFindSimpleDesc_1:
   \   00006C   85..82       MOV     DPL,?V0 + 2
   \   00006F   85..83       MOV     DPH,?V0 + 3
   \   000072   E4           CLR     A
   \   000073   F0           MOVX    @DPTR,A
   \   000074   A3           INC     DPTR
   \                     ??afFindSimpleDesc_4:
   \   000075   F0           MOVX    @DPTR,A
   1255            }
   1256          
   1257            return rtrn;
   \                     ??afFindSimpleDesc_3:
   \   000076   A9..         MOV     R1,?V0 + 4
   \   000078   02....       LJMP    ?Subroutine31 & 0xFFFF
   1258          }
   1259          
   1260          /*********************************************************************
   1261           * @fn      afGetDescCB
   1262           *
   1263           * @brief   Get the Descriptor callback function.
   1264           *
   1265           * @param   epDesc - pointer to the endpoint descriptor
   1266           *
   1267           * @return  function pointer or NULL
   1268           */
   1269          static pDescCB afGetDescCB( endPointDesc_t *epDesc )
   1270          {
   1271            epList_t *epSearch;
   1272          
   1273            // Start at the beginning
   1274            epSearch = epList;
   1275          
   1276            // Look through the list until the end
   1277            while ( epSearch )
   1278            {
   1279              // Is there a match?
   1280              if ( epSearch->epDesc == epDesc )
   1281              {
   1282                return ( epSearch->pfnDescCB );
   1283              }
   1284              else
   1285                epSearch = epSearch->nextDesc;  // Next entry
   1286            }
   1287          
   1288            return ( (pDescCB)NULL );
   1289          }
   1290          
   1291          /*********************************************************************
   1292           * @fn      afGetReflector
   1293           *
   1294           * @brief   Get the Reflector's address for an endpoint.
   1295           *
   1296           * @param   EndPoint - Application Endpoint to look for
   1297           *
   1298           * @return  shortAddr of the reflector for the endpoint
   1299           *              0xFFFF if not found.
   1300           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1301          uint16 afGetReflector( byte EndPoint )
   \                     afGetReflector:
   1302          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1303            epList_t *epSearch;
   1304          
   1305            // Look for the endpoint
   1306            epSearch = afFindEndPointDescList( EndPoint );
   \   000005                ; Setup parameters for call to function afFindEndPointDescList
   \   000005   90....       MOV     DPTR,#(??afFindEndPointDescList & 0xffff)
   \   000008   74..         MOV     A,#((??afFindEndPointDescList >> 16) & 0xff)
   \   00000A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   1307          
   1308            if ( epSearch )
   \   000011   E582         MOV     A,DPL
   \   000013   7002         JNZ     ??afGetReflector_0
   \   000015   E583         MOV     A,DPH
   \                     ??afGetReflector_0:
   \   000017   6007         JZ      ??afGetReflector_1
   1309            {
   1310              //-------------------------------------------------------------------------
   1311              #if !defined ( REFLECTOR )
   1312              //-------------------------------------------------------------------------
   1313              return ( epSearch->reflectorAddr );
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   00001E   8004         SJMP    ??afGetReflector_2
   1314              //-------------------------------------------------------------------------
   1315              #else
   1316              //-------------------------------------------------------------------------
   1317              if ( epSearch->reflectorAddr == INVALID_NODE_ADDR )
   1318              {
   1319                return ( NLME_GetShortAddr() );
   1320              }
   1321              else
   1322              {
   1323                return ( epSearch->reflectorAddr );
   1324              }
   1325              //-------------------------------------------------------------------------
   1326              #endif
   1327              //-------------------------------------------------------------------------
   1328            }
   1329            else
   1330            {
   1331              return ( INVALID_NODE_ADDR );
   \                     ??afGetReflector_1:
   \   000020   7AFE         MOV     R2,#-0x2
   \   000022   7BFF         MOV     R3,#-0x1
   \                     ??afGetReflector_2:
   \   000024   80..         SJMP    ?Subroutine34
   1332            }
   1333          }
   1334          
   1335          /*********************************************************************
   1336           * @fn      afSetReflector
   1337           *
   1338           * @brief   Set the reflector address for the endpoint.
   1339           *
   1340           * @param   EndPoint - Application Endpoint to look for
   1341           * @param   reflectorAddr - new address
   1342           *
   1343           * @return  TRUE if success, FALSE if endpoint not fount
   1344           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1345          uint8 afSetReflector( byte EndPoint, uint16 reflectorAddr )
   \                     afSetReflector:
   1346          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1347            epList_t *epSearch;
   1348          
   1349            // Look for the endpoint
   1350            epSearch = afFindEndPointDescList( EndPoint );
   \   000009                ; Setup parameters for call to function afFindEndPointDescList
   \   000009   90....       MOV     DPTR,#(??afFindEndPointDescList & 0xffff)
   \   00000C   74..         MOV     A,#((??afFindEndPointDescList >> 16) & 0xff)
   \   00000E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   1351          
   1352            if ( epSearch )
   \   000015   E582         MOV     A,DPL
   \   000017   7002         JNZ     ??afSetReflector_0
   \   000019   E583         MOV     A,DPH
   \                     ??afSetReflector_0:
   \   00001B   600B         JZ      ??afSetReflector_1
   1353            {
   1354              epSearch->reflectorAddr = reflectorAddr;
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   EE           MOV     A,R6
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   EF           MOV     A,R7
   \   000023   F0           MOVX    @DPTR,A
   1355              return ( TRUE );
   \   000024   7901         MOV     R1,#0x1
   \   000026   8002         SJMP    ??afSetReflector_2
   1356            }
   1357            else
   1358              return ( FALSE );
   \                     ??afSetReflector_1:
   \   000028   7900         MOV     R1,#0x0
   \                     ??afSetReflector_2:
   \   00002A                REQUIRE ?Subroutine34
   \   00002A                ; // Fall through to label ?Subroutine34
   1359          }
   1360          
   1361          /*********************************************************************
   1362           * @fn      afDataReqMTU
   1363           *
   1364           * @brief   Get the Data Request MTU(Max Transport Unit).
   1365           *
   1366           * @param   fields - afDataReqMTU_t
   1367           *
   1368           * @return  uint8(MTU)
   1369           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1370          uint8 afDataReqMTU( afDataReqMTU_t* fields )
   \                     afDataReqMTU:
   1371          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1372            uint8 len;
   1373            uint8 hdr;
   1374            uint8 version;
   1375          
   1376            if ( fields->kvp == TRUE )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6401         XRL     A,#0x1
   \   000010   7005         JNZ     ??afDataReqMTU_0
   1377            {
   1378              hdr = AF_HDR_KVP_MAX_LEN;
   \   000012   75..08       MOV     ?V0 + 0,#0x8
   \   000015   8015         SJMP    ??afDataReqMTU_1
   1379            }
   1380            else
   1381            {
   1382              version = NLME_GetProtocolVersion();
   1383          
   1384              if ( version == ZB_PROT_V1_0 )
   \                     ??afDataReqMTU_0:
   \   000017                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   000017   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   00001A   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   00001C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001F   E9           MOV     A,R1
   \   000020   6401         XRL     A,#0x1
   \   000022   7005         JNZ     ??afDataReqMTU_2
   1385              {
   1386                hdr = AF_HDR_V1_0_MAX_LEN;
   \   000024   75..03       MOV     ?V0 + 0,#0x3
   \   000027   8003         SJMP    ??afDataReqMTU_1
   1387              }
   1388              else
   1389              {
   1390                hdr = AF_HDR_V1_1_MAX_LEN;
   \                     ??afDataReqMTU_2:
   \   000029   75..00       MOV     ?V0 + 0,#0x0
   1391              }
   1392            }
   1393          
   1394            len = (uint8)(APSDE_DataReqMTU(&fields->aps) - hdr);
   \                     ??afDataReqMTU_1:
   \   00002C                ; Setup parameters for call to function APSDE_DataReqMTU
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   A3           INC     DPTR
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   \   000035   90....       MOV     DPTR,#(APSDE_DataReqMTU & 0xffff)
   \   000038   74..         MOV     A,#((APSDE_DataReqMTU >> 16) & 0xff)
   \   00003A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00003D   E9           MOV     A,R1
   \   00003E   C3           CLR     C
   \   00003F   95..         SUBB    A,?V0 + 0
   \   000041   F9           MOV     R1,A
   1395          
   1396            return len;
   \   000042                REQUIRE ?Subroutine35
   \   000042                ; // Fall through to label ?Subroutine35
   1397          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1398          
   1399          /*********************************************************************
   1400           * @fn      afGetMatch
   1401           *
   1402           * @brief   Set the allow response flag.
   1403           *
   1404           * @param   ep - Application Endpoint to look for
   1405           * @param   action - true - allow response, false - no response
   1406           *
   1407           * @return  TRUE allow responses, FALSE no response
   1408           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1409          uint8 afGetMatch( uint8 ep )
   \                     afGetMatch:
   1410          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1411            epList_t *epSearch;
   1412          
   1413            // Look for the endpoint
   1414            epSearch = afFindEndPointDescList( ep );
   \   000005                ; Setup parameters for call to function afFindEndPointDescList
   \   000005   90....       MOV     DPTR,#(??afFindEndPointDescList & 0xffff)
   \   000008   74..         MOV     A,#((??afFindEndPointDescList >> 16) & 0xff)
   \   00000A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   1415          
   1416            if ( epSearch )
   \   000011   E582         MOV     A,DPL
   \   000013   7002         JNZ     ??afGetMatch_0
   \   000015   E583         MOV     A,DPH
   \                     ??afGetMatch_0:
   \   000017   600D         JZ      ??afGetMatch_1
   1417            {
   1418              if ( epSearch->flags & eEP_AllowMatch )
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000020   5004         JNC     ??afGetMatch_1
   1419                return ( TRUE );
   \   000022   7901         MOV     R1,#0x1
   \   000024   8002         SJMP    ??afGetMatch_2
   1420              else
   1421                return ( FALSE );
   \                     ??afGetMatch_1:
   \   000026   7900         MOV     R1,#0x0
   \                     ??afGetMatch_2:
   \   000028   80..         SJMP    ?Subroutine34
   1422            }
   1423            else
   1424              return ( FALSE );
   1425          }
   1426          
   1427          /*********************************************************************
   1428           * @fn      afSetMatch
   1429           *
   1430           * @brief   Set the allow response flag.
   1431           *
   1432           * @param   ep - Application Endpoint to look for
   1433           * @param   action - true - allow response, false - no response
   1434           *
   1435           * @return  TRUE if success, FALSE if endpoint not found
   1436           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1437          uint8 afSetMatch( uint8 ep, uint8 action )
   \                     afSetMatch:
   1438          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   1439            epList_t *epSearch;
   1440          
   1441            // Look for the endpoint
   1442            epSearch = afFindEndPointDescList( ep );
   \   000007                ; Setup parameters for call to function afFindEndPointDescList
   \   000007   90....       MOV     DPTR,#(??afFindEndPointDescList & 0xffff)
   \   00000A   74..         MOV     A,#((??afFindEndPointDescList >> 16) & 0xff)
   \   00000C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   1443          
   1444            if ( epSearch )
   \   000013   E582         MOV     A,DPL
   \   000015   7002         JNZ     ??afSetMatch_0
   \   000017   E583         MOV     A,DPH
   \                     ??afSetMatch_0:
   \   000019   6014         JZ      ??afSetMatch_1
   1445            {
   1446              if ( action )
   \   00001B   EE           MOV     A,R6
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   6005         JZ      ??afSetMatch_2
   1447              {
   1448                epSearch->flags |= eEP_AllowMatch;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E0         SETB    0xE0 /* A   */.0
   \   000025   8003         SJMP    ??afSetMatch_3
   1449              }
   1450              else
   1451              {
   1452                epSearch->flags &= ~eEP_AllowMatch;
   \                     ??afSetMatch_2:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E0         CLR     0xE0 /* A   */.0
   \                     ??afSetMatch_3:
   \   00002A   F0           MOVX    @DPTR,A
   1453              }
   1454              return ( TRUE );
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   8002         SJMP    ??afSetMatch_4
   1455            }
   1456            else
   1457              return ( FALSE );
   \                     ??afSetMatch_1:
   \   00002F   7900         MOV     R1,#0x0
   \                     ??afSetMatch_4:
   \   000031   02....       LJMP    ?Subroutine34 & 0xFFFF
   1458          }
   1459          
   1460          /*********************************************************************
   1461           * @fn      afNumEndPoints
   1462           *
   1463           * @brief   Returns the number of endpoints defined (including 0)
   1464           *
   1465           * @param   none
   1466           *
   1467           * @return  number of endpoints
   1468           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1469          byte afNumEndPoints( void )
   \                     afNumEndPoints:
   1470          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1471            epList_t *epSearch;
   1472            byte endpoints;
   1473          
   1474            // Start at the beginning
   1475            epSearch = epList;
   \   000004   90....       MOV     DPTR,#epList
   \   000007   12....       LCALL   ?Subroutine19 & 0xFFFF
   1476            endpoints = 0;
   \                     ??CrossCallReturnLabel_55:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   8010         SJMP    ??afNumEndPoints_0
   1477          
   1478            while ( epSearch )
   1479            {
   1480              endpoints++;
   \                     ??afNumEndPoints_1:
   \   00000E   09           INC     R1
   1481              epSearch = epSearch->nextDesc;
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00001A   8A82         MOV     DPL,R2
   \   00001C   8B83         MOV     DPH,R3
   1482            }
   \                     ??afNumEndPoints_0:
   \   00001E   E582         MOV     A,DPL
   \   000020   7002         JNZ     ??afNumEndPoints_2
   \   000022   E583         MOV     A,DPH
   \                     ??afNumEndPoints_2:
   \   000024   70E8         JNZ     ??afNumEndPoints_1
   1483          
   1484            return ( endpoints );
   \   000026                REQUIRE ?Subroutine30
   \   000026                ; // Fall through to label ?Subroutine30
   1485          }
   1486          
   1487          /*********************************************************************
   1488           * @fn      afEndPoints
   1489           *
   1490           * @brief   Fills in the passed in buffer with the endpoint (numbers).
   1491           *          Use afNumEndPoints to find out how big a buffer to supply.
   1492           *
   1493           * @param   epBuf - pointer to mem used
   1494           *
   1495           * @return  void
   1496           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1497          void afEndPoints( byte *epBuf, byte skipZDO )
   \                     afEndPoints:
   1498          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FC           MOV     R4,A
   1499            epList_t *epSearch;
   1500            byte endPoint;
   1501          
   1502            // Start at the beginning
   1503            epSearch = epList;
   \   000006   90....       MOV     DPTR,#epList
   \   000009   802B         SJMP    ??afEndPoints_0
   1504          
   1505            while ( epSearch )
   1506            {
   1507              endPoint = epSearch->epDesc->endPoint;
   \                     ??afEndPoints_1:
   \   00000B   8882         MOV     DPL,R0
   \   00000D   8983         MOV     DPH,R1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FD           MOV     R5,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F583         MOV     DPH,A
   \   000015   8D82         MOV     DPL,R5
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FD           MOV     R5,A
   1508          
   1509              if ( !skipZDO || endPoint != 0 )
   \   000019   EC           MOV     A,R4
   \   00001A   6003         JZ      ??afEndPoints_2
   \   00001C   ED           MOV     A,R5
   \   00001D   600B         JZ      ??afEndPoints_3
   1510                *epBuf++ = endPoint;
   \                     ??afEndPoints_2:
   \   00001F   ED           MOV     A,R5
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   AA82         MOV     R2,DPL
   \   000028   AB83         MOV     R3,DPH
   1511          
   1512              epSearch = epSearch->nextDesc;
   \                     ??afEndPoints_3:
   \   00002A   8882         MOV     DPL,R0
   \   00002C   8983         MOV     DPH,R1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \                     ??afEndPoints_0:
   \   000036   12....       LCALL   ??Subroutine20_0 & 0xFFFF
   1513            }
   \                     ??CrossCallReturnLabel_67:
   \   000039   E8           MOV     A,R0
   \   00003A   7001         JNZ     ??afEndPoints_4
   \   00003C   E9           MOV     A,R1
   \                     ??afEndPoints_4:
   \   00003D   70CC         JNZ     ??afEndPoints_1
   1514          }
   \   00003F   80..         SJMP    ?Subroutine30
   1515          
   1516          /*********************************************************************
   1517           * Semi-Precision fuctions
   1518           */
   1519          
   1520          #if ( AF_FLOAT_SUPPORT )
   1521          /*********************************************************************
   1522           * @fn      afCnvtSP_uint16
   1523           *
   1524           * @brief   Converts uint16 to semi-precision structure format
   1525           *
   1526           * @param   sp - semi-precision structure format
   1527           *
   1528           * @return  16 bit value for semiprecision.
   1529           */
   1530          uint16 afCnvtSP_uint16( afSemiPrecision_t sp )
   1531          {
   1532            return ( ((sp.sign & 0x0001) << 15)
   1533                        | ((sp.exponent & 0x001F) << 10)
   1534                        | (sp.mantissa & 0x03FF) );
   1535          }
   1536          
   1537          /*********************************************************************
   1538           * @fn      afCnvtuint16_SP
   1539           *
   1540           * @brief   Converts uint16 to semi-precision structure format
   1541           *
   1542           * @param   rawSP - Raw representation of SemiPrecision
   1543           *
   1544           * @return  SemiPrecision conversion.
   1545           */
   1546          afSemiPrecision_t afCnvtuint16_SP( uint16 rawSP )
   1547          {
   1548            afSemiPrecision_t sp = {0,0,0};
   1549          
   1550            sp.sign = ((rawSP >> 15) & 0x0001);
   1551            sp.exponent = ((rawSP >> 10) & 0x001F);
   1552            sp.mantissa = (rawSP & 0x03FF);
   1553            return ( sp );
   1554          }
   1555          
   1556          /*********************************************************************
   1557           * @fn      afCnvtFloat_SP
   1558           *
   1559           * @brief   Converts float to semi-precision structure format
   1560           *
   1561           * @param   f - float value to convert from
   1562           *
   1563           * NOTE: This function will convert to the closest possible
   1564           *       representation in a 16 bit format.  Meaning that
   1565           *       the number may not be exact.  For example, 10.7 will
   1566           *       convert to 10.69531, because .7 is a repeating binary
   1567           *       number.  The mantissa for afSemiPrecision_t is 10 bits
   1568           *       and .69531 is the 10 bit representative of .7.
   1569           *
   1570           * @return  SemiPrecision conversion.
   1571           */
   1572          afSemiPrecision_t afCnvtFloat_SP( float f )
   1573          {
   1574            afSemiPrecision_t sp = {0,0,0};
   1575            unsigned long mantissa;
   1576            unsigned int oldexp;
   1577            int tempexp;
   1578            float calcMant;
   1579            unsigned long *uf;
   1580          
   1581            if ( f < 0 )
   1582            {
   1583              sp.sign = 1;
   1584              f = f * -1;
   1585            }
   1586            else
   1587              sp.sign = 0;
   1588          
   1589            if ( f == 0 )
   1590            {
   1591              sp.exponent = (unsigned int)0;
   1592              sp.mantissa = (unsigned int)0;
   1593            }
   1594            else
   1595            {
   1596              uf = (void*)&f;
   1597          
   1598              mantissa = *uf & 0x7fffff;
   1599              oldexp = (unsigned int)((*uf >> 23) & 0xff);
   1600              tempexp = oldexp - 127;
   1601          
   1602              calcMant = (float)((float)(mantissa) / (float)(0x800000));
   1603              mantissa = (unsigned long)(calcMant * 1024);
   1604          
   1605              sp.exponent = (unsigned int)(tempexp + 15);
   1606              sp.mantissa = (unsigned int)(mantissa);
   1607            }
   1608          
   1609            return ( sp );
   1610          }
   1611          
   1612          /*********************************************************************
   1613           * @fn      afCnvtSP_Float
   1614           *
   1615           * @brief   Converts semi-precision structure format to float
   1616           *
   1617           * @param   sp - afSemiPrecision format to convert from
   1618           *
   1619           * @return  float
   1620           */
   1621          float afCnvtSP_Float( afSemiPrecision_t sp )
   1622          {
   1623            float a, b, c;
   1624          
   1625            if ( sp.exponent == 0 && sp.mantissa == 0 )
   1626            {
   1627              a = 0;
   1628              b = 0;
   1629            }
   1630            else
   1631            {
   1632              a = (float)((float)1 + (float)((float)(sp.mantissa)/1024));
   1633          
   1634          #if defined( __MWERKS__ )
   1635              b = powf( 2.0, (float)((float)sp.exponent - 15.0) );
   1636          #else
   1637              b = (float)pow( 2.0, sp.exponent - 15 );
   1638          #endif
   1639            }
   1640          
   1641            if ( sp.sign )
   1642              c = a * b * -1;
   1643            else
   1644              c = a * b;
   1645          
   1646            return ( c );
   1647          }
   1648          #endif
   1649          
   1650          #if ( AF_KVP_SUPPORT )
   1651          /*********************************************************************
   1652           * @fn      GetDataTypeLength
   1653           *
   1654           * @brief   Return the length of the datatype in length
   1655           *
   1656           * @param   DataType
   1657           *
   1658           * @return  byte
   1659           */
   1660          byte GetDataTypeLength( byte DataType )
   1661          {
   1662            switch (DataType)
   1663            {
   1664              case DATATYPE_INT8:
   1665              case DATATYPE_UINT8:
   1666                return 1;
   1667          
   1668              case DATATYPE_INT16:
   1669              case DATATYPE_UINT16:
   1670              case DATATYPE_SEMIPREC:
   1671                return 2;
   1672          
   1673              case DATATYPE_ABS_TIME:
   1674              case DATATYPE_REL_TIME:
   1675                return 4;
   1676          
   1677              default:
   1678                return 0;
   1679            }
   1680          }
   1681          #endif
   1682          

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1683          void afCopyAddress ( afAddrType_t *afAddr, zAddrType_t *zAddr )
   \                     afCopyAddress:
   1684          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1685            afAddr->addrMode = (afAddrMode_t)zAddr->addrMode;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   F0           MOVX    @DPTR,A
   1686            afAddr->addr.shortAddr = zAddr->addr.shortAddr;
   \   000019   8C82         MOV     DPL,R4
   \   00001B   8D83         MOV     DPH,R5
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   12....       LCALL   ?Subroutine4 & 0xFFFF
   1687          }
   \                     ??CrossCallReturnLabel_17:
   \   000024   02....       LJMP    ?Subroutine35 & 0xFFFF
   1688          
   1689          /*********************************************************************
   1690          *********************************************************************/
   1691          

   Maximum stack usage in bytes:

     Function                      ISTACK PSTACK XSTACK
     --------                      ------ ------ ------
     AF_DataRequest                    1      0     52
       -> afGetReflector               0      0     86
       -> NLME_IsAddressBroadcast      0      0     86
       -> osal_mem_free                0      0     86
       -> afDataReqMTU                 0      0     86
       -> APSDE_DataReq                0      0     86
       -> NLME_GetShortAddr            0      0     86
       -> afDataConfirm                0      0     86
     afBuildMSGIncoming                1      0     56
       -> osal_msg_allocate            0      0     42
       -> afCopyAddress                0      0     42
       -> osal_memcpy                  0      0     48
       -> osal_msg_send                0      0     42
     afCopyAddress                     1      0     30
     afDataConfirm                     1      0     55
       -> afFindEndPointDesc           0      0     24
       -> osal_msg_allocate            0      0     24
       -> osal_msg_send                0      0     24
     afDataReqMTU                      0      0     52
       -> NLME_GetProtocolVersion      0      0     18
       -> APSDE_DataReqMTU             0      0     18
     afEndPoints                       3      0      0
     afFindEndPointDesc                0      0     35
       -> afFindEndPointDescList       0      0     20
     afFindEndPointDescList            2      0     25
     afFindSimpleDesc                  0      0     14
       -> afFindEndPointDescList       0      0     28
     afGetMatch                        0      0     10
       -> afFindEndPointDescList       0      0     20
     afGetReflector                    0      0     53
       -> afFindEndPointDescList       0      0     20
     afIncomingData                    1      0     37
       -> NLME_GetProtocolVersion      0      0     50
       -> aps_FindGroupForEndpoint     0      0     50
       -> afFindEndPointDesc           0      0     50
       -> afFindEndPointDescList       0      0     50
       -> afFindEndPointDesc           0      0     50
       -> osal_mem_free                0      0     50
       -> afBuildMSGIncoming           0      0     64
       -> NLME_GetProtocolVersion      0      0     50
       -> aps_FindGroupForEndpoint     0      0     50
     afInit                            2      0      0
     afNumEndPoints                    2      0      0
     afRegister                        0      0     14
       -> afRegisterExtended           0      0     28
     afRegisterExtended                1      0     28
       -> osal_mem_alloc               0      0     28
     afSetMatch                        0      0     10
       -> afFindEndPointDescList       0      0     20
     afSetReflector                    0      0     10
       -> afFindEndPointDescList       0      0     20


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     epList                    2
     afInit                   14
     ?Subroutine30             7
     afRegisterExtended      139
     ?Subroutine31             5
     ?Subroutine1              8
     ?Subroutine2              8
     ?Subroutine32             6
     ?Subroutine25             7
     ?Subroutine19             8
     afRegister               49
     afDataConfirm            80
     ?Subroutine8             11
     ?Subroutine23             5
     ?Subroutine28             9
     afIncomingData          542
     ?Subroutine33             8
     ?Subroutine14             4
     ?Subroutine24             6
     ?Subroutine13            15
     ?Subroutine11            14
     ?Subroutine6             27
     ?Subroutine5              9
     ?Subroutine29             6
     ?Subroutine20             8
     ?Subroutine18             7
     ?Subroutine12             4
     ?Subroutine9             10
     ?Subroutine4             11
     ?Subroutine3             11
     ?Subroutine7             10
     ?Subroutine27             7
     ?Subroutine26             4
     afBuildMSGIncoming      378
     ?Subroutine21            11
     ?Subroutine17            10
     ?Subroutine10             9
     ?Subroutine0              6
     ?Subroutine22             9
     ?Subroutine15             4
     AF_DataRequest          746
     ?Subroutine16             9
     afFindEndPointDescList   49
     afFindEndPointDesc       37
     ?Subroutine34             5
     afFindSimpleDesc        123
     afGetReflector           38
     afSetReflector           42
     afDataReqMTU             66
     ?Subroutine35             5
     afGetMatch               42
     afSetMatch               52
     afNumEndPoints           38
     afEndPoints              65
     afCopyAddress            39

 
 2 842 bytes in segment BANKED_CODE
     2 bytes in segment XDATA_Z
 
 2 842 bytes of CODE  memory
     2 bytes of XDATA memory

Errors: none
Warnings: none
