##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   17/Oct/2013  21:52:35 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  D:\Texas Instruments\ZStack-1.4.2-1.1.0\Component #
#                          s\stack\zdo\ZDApp.c                               #
#    Command line       =  -f E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wEnde #
#                          v.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR                #
#                          -DROOT=__near_func -DMAC_OPT_FFD=0 -DBLINK_LEDS   #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f    #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfig. #
#                          cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800     #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\Source\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mt\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\hal\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          hal\target\CC2430EB\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\osal\mcu #
#                          \ccsoc\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC #
#                          2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\osal\include\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨ #
#                          Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects #
#                          \zstack\Samples\SampleApp\CC2430DB\..\..\..\..\.. #
#                          \Components\stack\af\ -I                          #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\stack\nw #
#                          k\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\st #
#                          ack\sec\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\C #
#                          C2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\ #
#                          Samples\SampleApp\CC2430DB\..\..\..\..\..\Compone #
#                          nts\stack\sys\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶ #
#                          Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\stack\zdo\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\zmac\f8w #
#                          \ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\se #
#                          rvices\saddr\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Co #
#                          mponents\services\sdata\ -I                       #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          mac\high_level\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\..\..\..\..\ #
#                          Components\mac\low_level\srf03\ -I                #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\low_ #
#                          level\srf03\single_chip\ -D CC2430EB -D           #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D           #
#                          ZG_ENDDEVICE -lC E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\EndDeviceEB\List\ #
#                           -lA E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\EndDeviceEB\List\             #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\EndDeviceEB\Obj\ -e             #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          "D:\Texas Instruments\ZStack-1.4.2-1.1.0\Componen #
#                          ts\stack\zdo\ZDApp.c"                             #
#    List file          =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\List\ZDApp.lst         #
#    Object file        =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\Obj\ZDApp.r51          #
#                                                                            #
#                                                                            #
##############################################################################

D:\Texas Instruments\ZStack-1.4.2-1.1.0\Components\stack\zdo\ZDApp.c
      1          /*********************************************************************
      2              Filename:       ZDApp.c
      3              Revised:        $Date: 2007-05-31 15:56:04 -0700 (Thu, 31 May 2007) $
      4              Revision:       $Revision: 14490 $
      5          
      6              Description:
      7          
      8                This file contains the interface to the Zigbee Device Application.
      9                This is the Application part that the use can change. This also
     10                contains the Task functions.
     11          
     12              Notes:
     13          
     14              Copyright (c) 2006 by Texas Instruments, Inc.
     15              All Rights Reserved.  Permission to use, reproduce, copy, prepare
     16              derivative works, modify, distribute, perform, display or sell this
     17              software and/or its documentation for any purpose is prohibited
     18              without the express written consent of Texas Instruments, Inc.
     19          *********************************************************************/
     20          
     21          /*********************************************************************
     22           * INCLUDES
     23           */
     24          #include "ZComDef.h"
     25          #include "ZMac.h"
     26          #include "OSAL.h"
     27          #include "OSAL_Tasks.h"
     28          #include "OSAL_PwrMgr.h"
     29          #include "OSAL_Nv.h"
     30          #include "AF.h"
     31          #include "APSMEDE.h"
     32          #include "NLMEDE.h"
     33          #include "AddrMgr.h"
     34          #include "ZDCache.h"
     35          #include "ZDProfile.h"
     36          #include "ZDObject.h"
     37          #include "ZDConfig.h"
     38          #include "ZDSecMgr.h"
     39          #include "ZDApp.h"
     40          #include "DebugTrace.h"
     41          #include "nwk_util.h"
     42          #include "OnBoard.h"

   \                                 In segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1
     43          #include "ZGlobals.h"
     44          
     45          #if   ( SECURE != 0  )
     46            #include "ssp.h"
     47          #endif
     48          
     49          #if defined( MT_ZDO_FUNC )
     50            #include "MT_ZDO.h"
     51          #endif
     52          
     53          /* HAL */
     54          #include "hal_led.h"
     55          #include "hal_lcd.h"
     56          #include "hal_key.h"
     57          
     58          #if defined( MT_MAC_FUNC ) || defined( MT_MAC_CB_FUNC )
     59            #error "ERROR! MT_MAC functionalities should be disabled on ZDO devices"
     60          #endif
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          #if !defined( NWK_START_DELAY )
     69            #define NWK_START_DELAY             100   // in milliseconds
     70          #endif
     71          
     72          #if !defined( EXTENDED_JOINING_RANDOM_MASK )
     73            #define EXTENDED_JOINING_RANDOM_MASK 0x007F
     74          #endif
     75          
     76          #if !defined( BEACON_REQUEST_DELAY )
     77            #define BEACON_REQUEST_DELAY        100   // in milliseconds
     78          #endif
     79          
     80          #if !defined( BEACON_REQ_DELAY_MASK )
     81            #define BEACON_REQ_DELAY_MASK       0x007F
     82          #endif
     83          
     84          #if defined (AUTO_SOFT_START)
     85            #define MAX_RESUME_RETRY            3
     86            #define NUM_DISC_ATTEMPTS           3
     87          #else
     88            #define MAX_RESUME_RETRY            1
     89          #endif
     90          
     91          #define MAX_DEVICE_UNAUTH_TIMEOUT   5000  // 5 seconds
     92          
     93          // Beacon Order Settings (see NLMEDE.h)
     94          #define DEFAULT_BEACON_ORDER        BEACON_ORDER_NO_BEACONS
     95          #define DEFAULT_SUPERFRAME_ORDER    DEFAULT_BEACON_ORDER
     96          
     97          #if ( SECURE != 0 )
     98            #if !defined( MAX_NWK_FRAMECOUNTER_CHANGES )
     99              // The number of times the frame counter can change before
    100              // saving to NV
    101              #define MAX_NWK_FRAMECOUNTER_CHANGES    1000
    102            #endif
    103          #endif
    104          
    105          // Leave control bits
    106          #define ZDAPP_LEAVE_CTRL_INIT 0
    107          #define ZDAPP_LEAVE_CTRL_SET  1
    108          #define ZDAPP_LEAVE_CTRL_RA   2
    109          
    110          // Standard time to update NWK NV data
    111          #define ZDAPP_UPDATE_NWK_NV_TIME 100
    112          
    113          // Address Manager Stub Implementation
    114          #define ZDApp_NwkWriteNVRequest AddrMgrWriteNVRequest
    115          
    116          /*********************************************************************
    117           * TYPEDEFS
    118           */
    119          
    120          /*********************************************************************
    121           * GLOBAL VARIABLES
    122           */
    123          
    124          #if defined( LCD_SUPPORTED )
    125            byte MatchRsps = 0;
    126          #endif
    127          

   \                                 In segment XDATA_I, align 1, keep-with-next
    128          byte zdoDiscCounter = 1;
   \                     zdoDiscCounter:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zdoDiscCounter>`
   \   000001                REQUIRE __INIT_XDATA_I
    129          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    130          zAddrType_t ZDAppNwkAddr;
   \                     ZDAppNwkAddr:
   \   000000                DS 9
    131          
    132          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
    133            byte zdappMgmtNwkDiscRspTransSeq;
    134            byte zdappMgmtNwkDiscReqInProgress = FALSE;
    135            zAddrType_t zdappMgmtNwkDiscRspAddr;
    136            byte zdappMgmtNwkDiscStartIndex;
    137            byte zdappMgmtSavedNwkState;
    138          #endif
    139          
    140          #if ( SECURE != 0 )
    141            uint16 nwkFrameCounterChanges = 0;
    142          #endif
    143          
    144          #if defined ( SOFT_START )
    145            static uint8 softStartAllowCoord = TRUE;
    146          #endif
    147          

   \                                 In segment XDATA_I, align 1, keep-with-next
    148          uint8 continueJoining = TRUE;
   \                     continueJoining:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for continueJoining>`
   \   000001                REQUIRE __INIT_XDATA_I
    149          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    150          byte  _tmpRejoinState;
   \                     _tmpRejoinState:
   \   000000                DS 1
    151          
    152          /*********************************************************************
    153           * EXTERNAL VARIABLES
    154           */
    155          
    156          /*********************************************************************
    157           * EXTERNAL FUNCTIONS
    158           */
    159          
    160          /*********************************************************************
    161           * LOCAL FUNCTIONS
    162           */
    163          
    164          void ZDApp_NetworkStartEvt( void );
    165          void ZDApp_DeviceAuthEvt( void );
    166          void ZDApp_SaveNetworkStateEvt( void );
    167          
    168          uint8 ZDApp_ReadNetworkRestoreState( void );
    169          uint8 ZDApp_RestoreNetworkState( void );
    170          void ZDAppDetermineDeviceType( void );
    171          void ZDAppSetupProtoVersion( void );
    172          void ZDApp_InitUserDesc( void );
    173          void ZDAppCheckForHoldKey( void );
    174          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr );
    175          void ZDApp_ProcessNetworkJoin( void );
    176          void ZDApp_SetCoordAddress( byte endPoint, byte dstEP );
    177          void ZDApp_SendNewDstAddr( byte dstEP, zAddrType_t *dstAddr,
    178                         cId_t clusterID, byte removeFlag, byte task_id, byte endpoint );
    179          
    180          #if ( SECURE != 0 )
    181            void ZDApp_SaveNwkKey( void );
    182            byte ZDApp_RestoreNwkKey( void );
    183          #endif
    184          
    185          void ZDApp_SendMsg( byte taskID, byte cmd, byte len, byte *buf );
    186          
    187          #if defined ( ZDO_BIND_UNBIND_RESPONSE ) && !defined ( REFLECTOR )
    188            extern void ZDApp_AppBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
    189                                byte SrcEndPoint, cId_t ClusterID, byte *DstAddress,
    190                                byte DstEndPoint, byte SecurityUse, uint8 Type );
    191          #endif
    192          
    193          void ZDApp_ResetTimerStart( uint16 delay );
    194          void ZDApp_ResetTimerCancel( void );
    195          void ZDApp_LeaveCtrlInit( void );
    196          void ZDApp_LeaveCtrlSet( uint8 ra );
    197          uint8 ZDApp_LeaveCtrlBypass( void );
    198          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay );
    199          void ZDApp_LeaveReset( uint8 ra );
    200          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
    201                                  uint8 removeChildren );
    202          void ZDApp_NodeProfileSync( ZDO_NetworkDiscoveryCfm_t* cfm );
    203          
    204          /*********************************************************************
    205           * LOCAL VARIABLES
    206           */
    207          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    208          byte ZDAppTaskID;
   \                     ZDAppTaskID:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    209          byte nwkStatus;
   \                     nwkStatus:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    210          endPointDesc_t *ZDApp_AutoFindMode_epDesc = (endPointDesc_t *)NULL;
   \                     ZDApp_AutoFindMode_epDesc:
   \   000000                DS 2

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    211          uint8 ZDApp_LeaveCtrl;
   \                     ZDApp_LeaveCtrl:
   \   000000                DS 1
    212          
    213          #if defined( HOLD_AUTO_START )
    214            devStates_t devState = DEV_HOLD;
    215          #else

   \                                 In segment XDATA_I, align 1, keep-with-next
    216            devStates_t devState = DEV_INIT;
   \                     devState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for devState>`
   \   000001                REQUIRE __INIT_XDATA_I
    217          #endif
    218          
    219          #if defined( ZDO_COORDINATOR ) && !defined( SOFT_START )
    220            // Set the default to coodinator
    221            devStartModes_t devStartMode = MODE_HARD;
    222          #else

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    223            devStartModes_t devStartMode = MODE_JOIN;     // Assume joining
   \                     devStartMode:
   \   000000                DS 1
    224            //devStartModes_t devStartMode = MODE_RESUME; // if already "directly joined"
    225                                  // to parent. Set to make the device do an Orphan scan.
    226          #endif
    227          
    228          #if defined ( ZDO_IEEEADDR_REQUEST )
    229            static byte ZDApp_IEEEAddrRsp_TaskID = 0;  // Initialized to NO TASK
    230          #endif
    231          
    232          #if defined ( ZDO_NWKADDR_REQUEST )
    233            static byte ZDApp_NwkAddrRsp_TaskID = 0;  // Initialized to NO TASK
    234          #endif
    235          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    236          static byte ZDApp_MatchDescRsp_TaskID = 0;  // Initialized to NO TASK
   \                     ??ZDApp_MatchDescRsp_TaskID:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    237          static byte ZDApp_EndDeviceAnnounce_TaskID = 0;  // Initialized to NO TASK
   \                     ??ZDApp_EndDeviceAnnounce_TaskID:
   \   000000                DS 1
    238          
    239          #if defined ( ZDO_BIND_UNBIND_REQUEST )
    240            static byte ZDApp_BindUnbindRsp_TaskID = TASK_NO_TASK;
    241          #endif
    242          
    243          #if defined ( ZDO_BIND_UNBIND_RESPONSE ) && !defined ( REFLECTOR )
    244            static byte ZDApp_BindReq_TaskID = 0;  // Initialized to NO TASK
    245          #endif
    246          
    247          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && !defined ( REFLECTOR )
    248            static byte ZDApp_MgmtBindReq_TaskID = 0;  // Initialized to NO TASK
    249          #endif
    250          
    251          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    252            static uint8 retryCnt;
   \                     ??retryCnt:
   \   000000                DS 1
    253          #endif
    254          
    255          // a little awkward -- this is will hold the list of versions that are legal given other
    256          // constraints such as NV value, macro values etc. list used in ZDO_NetworkDiscoveryConfirmCB()
    257          // when a joining device is deciding which network to join.

   \                                 In segment XDATA_I, align 1, keep-with-next
    258          static byte sPVerList[] = {ZB_PROT_V1_1, ZB_PROT_V1_0};
   \                     ??sPVerList:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for sPVerList>`
   \   000002                REQUIRE __INIT_XDATA_I
    259          

   \                                 In segment XDATA_I, align 1, keep-with-next
    260          endPointDesc_t ZDApp_epDesc =
   \                     ZDApp_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for ZDApp_epDesc>`
   \   000006                REQUIRE __INIT_XDATA_I
    261          {
    262            ZDO_EP,
    263            &ZDAppTaskID,
    264            (SimpleDescriptionFormat_t *)NULL,  // No Simple description for ZDO
    265            (afNetworkLatencyReq_t)0            // No Network Latency req
    266          };
    267          
    268          /*********************************************************************
    269           * @fn      ZDApp_Init
    270           *
    271           * @brief   ZDApp Initialization function.
    272           *
    273           * @param   task_id - ZDApp Task ID
    274           *
    275           * @return  None
    276           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    277          void ZDApp_Init( byte task_id )
   \                     ZDApp_Init:
    278          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    279            uint8 capabilities;
    280          
    281            // Save the task ID
    282            ZDAppTaskID = task_id;
   \   000009   E9           MOV     A,R1
   \   00000A   90....       MOV     DPTR,#ZDAppTaskID
   \   00000D   F0           MOVX    @DPTR,A
    283          
    284            // Initialize the ZDO global device short address storage
    285            ZDAppNwkAddr.addrMode = Addr16Bit;
   \   00000E   7402         MOV     A,#0x2
   \   000010   90....       MOV     DPTR,#(ZDAppNwkAddr + 8)
   \   000013   F0           MOVX    @DPTR,A
    286            ZDAppNwkAddr.addr.shortAddr = INVALID_NODE_ADDR;
   \   000014   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000017   74FE         MOV     A,#-0x2
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   74FF         MOV     A,#-0x1
   \   00001D   F0           MOVX    @DPTR,A
    287            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
   \   00001E                ; Setup parameters for call to function NLME_GetExtAddr
   \   00001E   90....       MOV     DPTR,#(NLME_GetExtAddr & 0xffff)
   \   000021   74..         MOV     A,#((NLME_GetExtAddr >> 16) & 0xff)
   \   000023   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    288          
    289            // Check for manual "Hold Auto Start"
    290            ZDAppCheckForHoldKey();
   \   000026                ; Setup parameters for call to function ZDAppCheckForHoldKey
   \   000026   90....       MOV     DPTR,#(ZDAppCheckForHoldKey & 0xffff)
   \   000029   74..         MOV     A,#((ZDAppCheckForHoldKey >> 16) & 0xff)
   \   00002B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    291          
    292            // Initialize ZDO items and setup the device - type of device to create.
    293            ZDO_Init();
   \   00002E                ; Setup parameters for call to function ZDO_Init
   \   00002E   90....       MOV     DPTR,#(ZDO_Init & 0xffff)
   \   000031   74..         MOV     A,#((ZDO_Init >> 16) & 0xff)
   \   000033   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    294          
    295            // Register the endpoint description with the AF
    296            // This task doesn't have a Simple description, but we still need
    297            // to register the endpoint.
    298            afRegister( (endPointDesc_t *)&ZDApp_epDesc );
   \   000036                ; Setup parameters for call to function afRegister
   \   000036   7A..         MOV     R2,#(ZDApp_epDesc & 0xff)
   \   000038   7B..         MOV     R3,#((ZDApp_epDesc >> 8) & 0xff)
   \   00003A   90....       MOV     DPTR,#(afRegister & 0xffff)
   \   00003D   74..         MOV     A,#((afRegister >> 16) & 0xff)
   \   00003F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    299          
    300          #if defined( ZDO_USERDESC_RESPONSE )
    301            ZDApp_InitUserDesc();
    302          #endif // ZDO_USERDESC_RESPONSE
    303          
    304          #if defined( ZDO_CACHE )
    305            ZDCacheInit();
    306          #endif
    307          
    308            // Setup the Zigbee Network Protocol Version
    309            ZDAppSetupProtoVersion();
   \   000042                ; Setup parameters for call to function ZDAppSetupProtoVersion
   \   000042   90....       MOV     DPTR,#(ZDAppSetupProtoVersion & 0xffff)
   \   000045   74..         MOV     A,#((ZDAppSetupProtoVersion >> 16) & 0xff)
   \   000047   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    310          
    311            // set broadcast address mask to support broadcast filtering
    312            NLME_GetRequest(nwkCapabilityInfo, 0, &capabilities);
   \   00004A                ; Setup parameters for call to function NLME_GetRequest
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   7A00         MOV     R2,#0x0
   \   000056   7B00         MOV     R3,#0x0
   \   000058   798F         MOV     R1,#-0x71
   \   00005A   90....       MOV     DPTR,#(NLME_GetRequest & 0xffff)
   \   00005D   74..         MOV     A,#((NLME_GetRequest >> 16) & 0xff)
   \   00005F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    313            NLME_SetBroadcastFilter( capabilities );
   \   000062                ; Setup parameters for call to function NLME_SetBroadcastFilter
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F9           MOV     R1,A
   \   00006A   90....       MOV     DPTR,#(NLME_SetBroadcastFilter & 0xffff)
   \   00006D   74..         MOV     A,#((NLME_SetBroadcastFilter >> 16) & 0xff)
   \   00006F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    314          
    315            // Start the device?
    316            if ( devState != DEV_HOLD )
   \   000072   90....       MOV     DPTR,#devState
   \   000075   E0           MOVX    A,@DPTR
   \   000076   600B         JZ      ??ZDApp_Init_0
    317            {
    318              ZDOInitDevice( 0 );
   \   000078                ; Setup parameters for call to function ZDOInitDevice
   \   000078   7A00         MOV     R2,#0x0
   \   00007A   7B00         MOV     R3,#0x0
   \   00007C   90....       MOV     DPTR,#(ZDOInitDevice & 0xffff)
   \   00007F   74..         MOV     A,#((ZDOInitDevice >> 16) & 0xff)
   \   000081   800F         SJMP    ??ZDApp_Init_1
    319            }
    320            else
    321            {
    322              // Blink LED to indicate HOLD_START
    323              HalLedBlink ( HAL_LED_4, 0, 50, 500 );
   \                     ??ZDApp_Init_0:
   \   000083                ; Setup parameters for call to function HalLedBlink
   \   000083   7CF4         MOV     R4,#-0xc
   \   000085   7D01         MOV     R5,#0x1
   \   000087   7B32         MOV     R3,#0x32
   \   000089   7A00         MOV     R2,#0x0
   \   00008B   7908         MOV     R1,#0x8
   \   00008D   90....       MOV     DPTR,#(HalLedBlink & 0xffff)
   \   000090   74..         MOV     A,#((HalLedBlink >> 16) & 0xff)
   \                     ??ZDApp_Init_1:
   \   000092   02....       LJMP    ?Subroutine23 & 0xFFFF
    324            }
    325          } /* ZDO_Init() */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000003   7401         MOV     A,#0x1
   \   000005   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine23_0:
   \   000008   D083         POP     DPH
   \   00000A   D082         POP     DPL
   \   00000C   02....       LJMP    ?BRET
    326          
    327          /*********************************************************************
    328           * @fn      ZDApp_event_loop()
    329           *
    330           * @brief   Main event loop for Zigbee device objects task. This function
    331           *          should be called at periodic intervals.
    332           *
    333           * @param   task_id - Task ID
    334           * @param   events  - Bitmap of events
    335           *
    336           * @return  none
    337           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    338          UINT16 ZDApp_event_loop( byte task_id, UINT16 events )
   \                     ZDApp_event_loop:
    339          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    340            uint8 *msg_ptr;
    341          
    342            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   5F           ANL     A,R7
   \   00000C   F9           MOV     R1,A
   \   00000D   E4           CLR     A
   \   00000E   7001         JNZ     ??ZDApp_event_loop_0
   \   000010   E9           MOV     A,R1
   \                     ??ZDApp_event_loop_0:
   \   000011   703F         JNZ     ??ZDApp_event_loop_1
    343            {
    344              while ( (msg_ptr = osal_msg_receive( ZDAppTaskID )) )
    345              {
    346                ZDApp_ProcessOSALMsg( (osal_event_hdr_t *)msg_ptr );
    347          
    348                // Release the memory
    349                osal_msg_deallocate( msg_ptr );
    350              }
    351          
    352              // Return unprocessed events
    353              return (events ^ SYS_EVENT_MSG);
    354            }
    355          
    356            if ( events & ZDO_NETWORK_INIT )
   \   000013   EE           MOV     A,R6
   \   000014   A2E0         MOV     C,0xE0 /* A   */.0
   \   000016   5058         JNC     ??ZDApp_event_loop_2
    357            {
    358              // Initialize apps and start the network
    359              devState = DEV_INIT;
   \   000018   7401         MOV     A,#0x1
   \   00001A   90....       MOV     DPTR,#devState
   \   00001D   F0           MOVX    @DPTR,A
    360              ZDO_StartDevice( (uint8)ZDO_Config_Node_Descriptor.LogicalType, devStartMode,
    361                               DEFAULT_BEACON_ORDER, DEFAULT_SUPERFRAME_ORDER );
   \   00001E                ; Setup parameters for call to function ZDO_StartDevice
   \   00001E   7C0F         MOV     R4,#0xf
   \   000020   7B0F         MOV     R3,#0xf
   \   000022   90....       MOV     DPTR,#devStartMode
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FA           MOV     R2,A
   \   000027   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   5407         ANL     A,#0x7
   \   00002D   F9           MOV     R1,A
   \   00002E   90....       MOV     DPTR,#(ZDO_StartDevice & 0xffff)
   \   000031   74..         MOV     A,#((ZDO_StartDevice >> 16) & 0xff)
   \   000033   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    362          
    363              // Return unprocessed events
    364              return (events ^ ZDO_NETWORK_INIT);
   \   000036   7401         MOV     A,#0x1
   \                     ??ZDApp_event_loop_3:
   \   000038   6E           XRL     A,R6
   \   000039   FA           MOV     R2,A
   \   00003A   EF           MOV     A,R7
   \                     ??ZDApp_event_loop_4:
   \   00003B   FB           MOV     R3,A
   \   00003C   8074         SJMP    ??ZDApp_event_loop_5
    365            }
   \                     ??ZDApp_event_loop_6:
   \   00003E                ; Setup parameters for call to function ZDApp_ProcessOSALMsg
   \   00003E   90....       MOV     DPTR,#(ZDApp_ProcessOSALMsg & 0xffff)
   \   000041   74..         MOV     A,#((ZDApp_ProcessOSALMsg >> 16) & 0xff)
   \   000043   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000046                ; Setup parameters for call to function osal_msg_deallocate
   \   000046   AA..         MOV     R2,?V0 + 0
   \   000048   AB..         MOV     R3,?V0 + 1
   \   00004A   90....       MOV     DPTR,#(osal_msg_deallocate & 0xffff)
   \   00004D   74..         MOV     A,#((osal_msg_deallocate >> 16) & 0xff)
   \   00004F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_event_loop_1:
   \   000052                ; Setup parameters for call to function osal_msg_receive
   \   000052   90....       MOV     DPTR,#ZDAppTaskID
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F9           MOV     R1,A
   \   000057   90....       MOV     DPTR,#(osal_msg_receive & 0xffff)
   \   00005A   74..         MOV     A,#((osal_msg_receive >> 16) & 0xff)
   \   00005C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00005F   8A..         MOV     ?V0 + 0,R2
   \   000061   8B..         MOV     ?V0 + 1,R3
   \   000063   EA           MOV     A,R2
   \   000064   7001         JNZ     ??ZDApp_event_loop_7
   \   000066   EB           MOV     A,R3
   \                     ??ZDApp_event_loop_7:
   \   000067   70D5         JNZ     ??ZDApp_event_loop_6
   \   000069   EE           MOV     A,R6
   \   00006A   FA           MOV     R2,A
   \   00006B   7480         MOV     A,#-0x80
   \                     ??ZDApp_event_loop_8:
   \   00006D   6F           XRL     A,R7
   \   00006E   80CB         SJMP    ??ZDApp_event_loop_4
    366          
    367          #if defined (RTR_NWK)
    368            if ( events & ZDO_NETWORK_START )
    369            {
    370              ZDApp_NetworkStartEvt();
    371          
    372              // Return unprocessed events
    373              return (events ^ ZDO_NETWORK_START);
    374            }
    375          #endif  //RTR_NWK
    376          
    377          #if defined ( RTR_NWK )
    378            if ( events & ZDO_ROUTER_START )
    379            {
    380              if ( nwkStatus == ZSuccess )
    381              {
    382                if ( devState == DEV_END_DEVICE )
    383                  devState = DEV_ROUTER;
    384          
    385                osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
    386              }
    387              else
    388              {
    389                // remain as end device!!
    390              }
    391              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    392          
    393              // Return unprocessed events
    394              return (events ^ ZDO_ROUTER_START);
    395            }
    396          #endif  // RTR
    397          
    398            if ( events & ZDO_STATE_CHANGE_EVT )
   \                     ??ZDApp_event_loop_2:
   \   000070   5410         ANL     A,#0x10
   \   000072   6011         JZ      ??ZDApp_event_loop_9
    399            {
    400              ZDO_UpdateNwkStatus( devState );
   \   000074                ; Setup parameters for call to function ZDO_UpdateNwkStatus
   \   000074   90....       MOV     DPTR,#devState
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F9           MOV     R1,A
   \   000079   90....       MOV     DPTR,#(ZDO_UpdateNwkStatus & 0xffff)
   \   00007C   74..         MOV     A,#((ZDO_UpdateNwkStatus >> 16) & 0xff)
   \   00007E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    401          
    402              // Return unprocessed events
    403              return (events ^ ZDO_STATE_CHANGE_EVT);
   \   000081   7410         MOV     A,#0x10
   \   000083   80B3         SJMP    ??ZDApp_event_loop_3
    404            }
    405          
    406            if ( events & ZDO_COMMAND_CNF )
   \                     ??ZDApp_event_loop_9:
   \   000085   EE           MOV     A,R6
   \   000086   5408         ANL     A,#0x8
   \   000088   6006         JZ      ??ZDApp_event_loop_10
    407            {
    408              // User defined logic
    409          
    410              // Return unprocessed events
    411              return (events ^ ZDO_COMMAND_CNF);
   \   00008A   7408         MOV     A,#0x8
   \   00008C   6E           XRL     A,R6
   \   00008D   FA           MOV     R2,A
   \   00008E   8022         SJMP    ??ZDApp_event_loop_5
    412            }
    413          
    414          #if defined( ZDSECMGR_SECURE ) && defined( RTR_NWK )
    415            if ( events & ZDO_NEW_DEVICE )
    416            {
    417              // process the new device event
    418              if ( ZDSecMgrNewDeviceEvent() == TRUE )
    419              {
    420                osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 1000 );
    421              }
    422          
    423              // Return unprocessed events
    424              return (events ^ ZDO_NEW_DEVICE);
    425            }
    426          #endif  // ZDSECMGR_SECURE && RTR
    427          
    428          #if defined ( ZDSECMGR_COMMERCIAL )
    429            if ( events & ZDO_SECMGR_EVENT )
    430            {
    431              ZDSecMgrEvent();
    432          
    433              // Return unprocessed events
    434              return (events ^ ZDO_SECMGR_EVENT);
    435            }
    436          #endif // defined( ZDSECMGR_COMMERCIAL )
    437          
    438          #if   ( SECURE != 0  )
    439            if ( events & ZDO_DEVICE_AUTH )
    440            {
    441              ZDApp_DeviceAuthEvt();
    442          
    443              // Return unprocessed events
    444              return (events ^ ZDO_DEVICE_AUTH);
    445            }
    446          #endif  // SECURE
    447          
    448            if ( events & ZDO_NWK_UPDATE_NV )
   \                     ??ZDApp_event_loop_10:
   \   000090   7402         MOV     A,#0x2
   \   000092   5F           ANL     A,R7
   \   000093   F9           MOV     R1,A
   \   000094   E4           CLR     A
   \   000095   7001         JNZ     ??ZDApp_event_loop_11
   \   000097   E9           MOV     A,R1
   \                     ??ZDApp_event_loop_11:
   \   000098   6004         JZ      ??ZDApp_event_loop_12
    449            {
    450              ZDApp_SaveNetworkStateEvt();
    451          
    452              // Return unprocessed events
    453              return (events ^ ZDO_NWK_UPDATE_NV);
   \   00009A   7402         MOV     A,#0x2
   \   00009C   80CF         SJMP    ??ZDApp_event_loop_8
    454            }
    455          
    456          #if ( SECURE != 0  )
    457            if ( events & ZDO_FRAMECOUNTER_CHANGE )
    458            {
    459              if ( nwkFrameCounterChanges++ > MAX_NWK_FRAMECOUNTER_CHANGES )
    460                ZDApp_SaveNwkKey();
    461          
    462              // Return unprocessed events
    463              return (events ^ ZDO_FRAMECOUNTER_CHANGE);
    464            }
    465          #endif
    466          
    467            if ( events & ZDO_DEVICE_RESET )
   \                     ??ZDApp_event_loop_12:
   \   00009E   EE           MOV     A,R6
   \   00009F   5404         ANL     A,#0x4
   \   0000A1   600B         JZ      ??ZDApp_event_loop_13
    468            {
    469              // The device has been in the UNAUTH state, so reset
    470              // Note: there will be no return from this call
    471              SystemReset();
   \   0000A3   C2AF         CLR     0xa8.7
   \   0000A5   75C9AB       MOV     0xc9,#-0x55
   \   0000A8   75C95B       MOV     0xc9,#0x5b
   \                     ??ZDApp_event_loop_14:
   \   0000AB   00           NOP
   \   0000AC   80FD         SJMP    ??ZDApp_event_loop_14
    472            }
    473          
    474            // Discard or make more handlers
    475            return 0;
   \                     ??ZDApp_event_loop_13:
   \   0000AE   7A00         MOV     R2,#0x0
   \   0000B0   7B00         MOV     R3,#0x0
   \                     ??ZDApp_event_loop_5:
   \   0000B2   02....       LJMP    ??Subroutine24_1 & 0xFFFF
    476          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7402         MOV     A,#0x2
   \                     ??Subroutine24_0:
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine24_1:
   \   000005   7F02         MOV     R7,#0x2
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA
    477          
    478          /*********************************************************************
    479           * Application Functions
    480           */
    481          
    482          /*********************************************************************
    483           * @fn      ZDOInitDevice
    484           *
    485           * @brief   Start the device in the network.  This function will read
    486           *   ZCD_NV_STARTUP_OPTION (NV item) to determine whether or not to
    487           *   restore the network state of the device.
    488           *
    489           * @param   startDelay - timeDelay to start device (in milliseconds).
    490           *      There is a jitter added to this delay:
    491           *              ((NWK_START_DELAY + startDelay)
    492           *              + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK))
    493           *
    494           * NOTE:    If the application would like to force a "new" join, the
    495           *          application should set the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    496           *          bit in the ZCD_NV_STARTUP_OPTION NV item before calling
    497           *          this function. "new" join means to not restore the network
    498           *          state of the device. Use zgWriteStartupOptions() to set these
    499           *          options.
    500           *
    501           * @return
    502           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    503           *          restored.
    504           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was initialized.
    505           *          This could mean that ZCD_NV_STARTUP_OPTION said to not restore, or
    506           *          it could mean that there was no network state to restore.
    507           *    ZDO_INITDEV_LEAVE_NOT_STARTED - Before the reset, a network leave was issued
    508           *          with the rejoin option set to TRUE.  So, the device was not
    509           *          started in the network (one time only).  The next time this
    510           *          function is called it will start.
    511           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    512          uint8 ZDOInitDevice( uint16 startDelay )
   \                     ZDOInitDevice:
    513          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
    514            uint8 networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    515            uint16 extendedDelay = 0;
    516          
    517            devState = DEV_INIT;    // Remove the Hold state
   \   000015   7401         MOV     A,#0x1
   \   000017   90....       MOV     DPTR,#devState
   \   00001A   F0           MOVX    @DPTR,A
    518          
    519            // Initialize leave control logic
    520            ZDApp_LeaveCtrlInit();
   \   00001B                ; Setup parameters for call to function ZDApp_LeaveCtrlInit
   \   00001B   90....       MOV     DPTR,#(ZDApp_LeaveCtrlInit & 0xffff)
   \   00001E   74..         MOV     A,#((ZDApp_LeaveCtrlInit >> 16) & 0xff)
   \   000020   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    521          
    522            // Check leave control reset settings
    523            ZDApp_LeaveCtrlStartup( &devState, &startDelay );
   \   000023                ; Setup parameters for call to function ZDApp_LeaveCtrlStartup
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   AC82         MOV     R4,DPL
   \   00002B   AD83         MOV     R5,DPH
   \   00002D   7A..         MOV     R2,#(devState & 0xff)
   \   00002F   7B..         MOV     R3,#((devState >> 8) & 0xff)
   \   000031   90....       MOV     DPTR,#(ZDApp_LeaveCtrlStartup & 0xffff)
   \   000034   74..         MOV     A,#((ZDApp_LeaveCtrlStartup >> 16) & 0xff)
   \   000036   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    524          
    525            // Leave may make the hold state come back
    526            if ( devState == DEV_HOLD )
   \   000039   90....       MOV     DPTR,#devState
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   7004         JNZ     ??ZDOInitDevice_0
    527              return ( ZDO_INITDEV_LEAVE_NOT_STARTED );   // Don't join - (one time).
   \   00003F   7902         MOV     R1,#0x2
   \   000041   802F         SJMP    ??ZDOInitDevice_1
    528          
    529          #if defined ( NV_RESTORE )
    530            // Get Keypad directly to see if a reset nv is needed.
    531            // Hold down the SW_BYPASS_NV key (defined in OnBoard.h)
    532            // while booting to skip past NV Restore.
    533            if ( HalKeyRead() == SW_BYPASS_NV )
    534              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    535            else
    536            {
    537              // Determine if NV should be restored
    538              networkStateNV = ZDApp_ReadNetworkRestoreState();
    539            }
    540          
    541            if ( networkStateNV == ZDO_INITDEV_RESTORED_NETWORK_STATE )
    542            {
    543              networkStateNV = ZDApp_RestoreNetworkState();
    544            }
    545            else
    546            {
    547              // Wipe out the network state in NV
    548              NLME_InitNV();
    549              NLME_SetDefaultNV();
    550              ZDAppSetupProtoVersion();
    551            }
    552          #endif
    553          
    554            if ( networkStateNV == ZDO_INITDEV_NEW_NETWORK_STATE )
    555            {
    556              ZDAppDetermineDeviceType();
    557          
    558              // Only delay if joining network - not restoring network state
    559              extendedDelay = (uint16)((NWK_START_DELAY + startDelay)
    560                        + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK));
   \                     ??ZDOInitDevice_0:
   \   000043                ; Setup parameters for call to function osal_rand
   \   000043   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   000046   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   000048   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00004B   8A..         MOV     ?V0 + 0,R2
   \   00004D   A8..         MOV     R0,?V0 + 0
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   747F         MOV     A,#0x7f
   \   000057   58           ANL     A,R0
   \   000058   F8           MOV     R0,A
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   28           ADD     A,R0
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   3400         ADDC    A,#0x0
   \   000060   F9           MOV     R1,A
   \   000061   7464         MOV     A,#0x64
   \   000063   28           ADD     A,R0
   \   000064   FA           MOV     R2,A
   \   000065   E4           CLR     A
   \   000066   39           ADDC    A,R1
   \   000067   FB           MOV     R3,A
    561            }
    562          
    563            // Trigger the network start
    564            ZDApp_NetworkInit( extendedDelay );
   \   000068                ; Setup parameters for call to function ZDApp_NetworkInit
   \   000068   90....       MOV     DPTR,#(ZDApp_NetworkInit & 0xffff)
   \   00006B   74..         MOV     A,#((ZDApp_NetworkInit >> 16) & 0xff)
   \   00006D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    565          
    566            return ( networkStateNV );
   \   000070   7901         MOV     R1,#0x1
   \                     ??ZDOInitDevice_1:
   \   000072   02....       LJMP    ?Subroutine24 & 0xFFFF
    567          }
    568          
    569          /*********************************************************************
    570           * @fn      ZDApp_ReadNetworkRestoreState
    571           *
    572           * @brief   Read the ZCD_NV_STARTUP_OPTION NV Item to state whether
    573           *          or not to restore the network state.
    574           *          If the read value has the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    575           *          bit set return the ZDO_INITDEV_NEW_NETWORK_STATE.
    576           *
    577           * @param   none
    578           *
    579           * @return  ZDO_INITDEV_NEW_NETWORK_STATE
    580           *          or ZDO_INITDEV_RESTORED_NETWORK_STATE based on whether or
    581           *          not ZCD_STARTOPT_DEFAULT_NETWORK_STATE bit is set in
    582           *          ZCD_NV_STARTUP_OPTION
    583           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    584          uint8 ZDApp_ReadNetworkRestoreState( void )
   \                     ZDApp_ReadNetworkRestoreState:
    585          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    586            uint8 networkStateNV = ZDO_INITDEV_RESTORED_NETWORK_STATE;
   \   000005   7E00         MOV     R6,#0x0
    587          
    588            // Look for the New Network State option.
    589            if ( zgReadStartupOptions() & ZCD_STARTOPT_DEFAULT_NETWORK_STATE )
   \   000007                ; Setup parameters for call to function zgReadStartupOptions
   \   000007   90....       MOV     DPTR,#(zgReadStartupOptions & 0xffff)
   \   00000A   74..         MOV     A,#((zgReadStartupOptions >> 16) & 0xff)
   \   00000C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000F   E9           MOV     A,R1
   \   000010   A2E1         MOV     C,0xE0 /* A   */.1
   \   000012   5001         JNC     ??ZDApp_ReadNetworkRestoreState_0
    590            {
    591              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
   \   000014   0E           INC     R6
    592            }
    593          
    594            return ( networkStateNV );
   \                     ??ZDApp_ReadNetworkRestoreState_0:
   \   000015   EE           MOV     A,R6
   \   000016   F9           MOV     R1,A
   \   000017   80..         SJMP    ??Subroutine25_0
    595          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine25_0:
   \   000003   7F01         MOV     R7,#0x1
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    596          
    597          /*********************************************************************
    598           * @fn      ZDAppDetermineDeviceType()
    599           *
    600           * @brief   Determines the type of device to start.  Right now
    601           *          this only works with the SOFT_START feature.  So it doesn't
    602           *          support the end device type.
    603           *
    604           *          Looks at zgDeviceLogicalType and determines what type of
    605           *          device to start.  The types are:
    606           *            ZG_DEVICETYPE_COORDINATOR
    607           *            ZG_DEVICETYPE_ROUTER
    608           *            ZG_DEVICETYPE_ENDDEVICE - not supported yet.
    609           *            ZG_DEVICETYPE_SOFT - looks for coordinator, if one doesn't
    610           *               exist, becomes one.  This option is should only be used
    611           *               if the system is manually configured and you are insured
    612           *               that the first device is started before all the other
    613           *               devices are started.
    614           *
    615           * @param   none
    616           *
    617           * @return  none
    618           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    619          void ZDAppDetermineDeviceType( void )
   \                     ZDAppDetermineDeviceType:
    620          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    621            if ( zgDeviceLogicalType == ZG_DEVICETYPE_ENDDEVICE )
   \   000000   02....       LJMP    ?BRET
    622              return;
    623          
    624          #if defined ( SOFT_START )
    625            if ( zgDeviceLogicalType == ZG_DEVICETYPE_COORDINATOR )
    626            {
    627              devStartMode = MODE_HARD;     // Start as a coordinator
    628              ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
    629            }
    630            else
    631            {
    632              if ( zgDeviceLogicalType == ZG_DEVICETYPE_ROUTER )
    633              {
    634                softStartAllowCoord = FALSE;  // Don't allow coord to start
    635                continueJoining = TRUE;
    636              }
    637              devStartMode = MODE_JOIN;     // Assume joining
    638            }
    639          #endif // SOFT_START
    640          }
    641          
    642          /*********************************************************************
    643           * @fn      ZDApp_NetworkStartEvt()
    644           *
    645           * @brief   Process the Network Start Event
    646           *
    647           * @param   none
    648           *
    649           * @return  none
    650           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    651          void ZDApp_NetworkStartEvt( void )
   \                     ZDApp_NetworkStartEvt:
    652          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    653            if ( nwkStatus == ZSuccess )
   \   000004   90....       MOV     DPTR,#nwkStatus
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7017         JNZ     ??ZDApp_NetworkStartEvt_0
    654            {
    655              // Successfully started a ZigBee network
    656              if ( devState == DEV_COORD_STARTING )
   \   00000A   90....       MOV     DPTR,#devState
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6408         XRL     A,#0x8
   \   000010   7003         JNZ     ??ZDApp_NetworkStartEvt_1
    657              {
    658                devState = DEV_ZB_COORD;
   \   000012   7409         MOV     A,#0x9
   \   000014   F0           MOVX    @DPTR,A
    659          
    660          #if ( SECURE != 0 )
    661                // Initialize keys
    662                SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
    663                SSP_SwitchNwkKey( 0 );
    664          #endif
    665              }
    666          
    667              osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
   \                     ??ZDApp_NetworkStartEvt_1:
   \   000015                ; Setup parameters for call to function osal_pwrmgr_device
   \   000015   7900         MOV     R1,#0x0
   \   000017   90....       MOV     DPTR,#(osal_pwrmgr_device & 0xffff)
   \   00001A   74..         MOV     A,#((osal_pwrmgr_device >> 16) & 0xff)
   \   00001C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    668              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00001F                ; Setup parameters for call to function osal_set_event
   \   00001F   8039         SJMP    ??ZDApp_NetworkStartEvt_2
    669            }
    670            else
    671            {
    672              // Try again with a higher energy threshold !!
    673              if ( ( NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT ) < 0xff )
   \                     ??ZDApp_NetworkStartEvt_0:
   \   000021                ; Setup parameters for call to function NLME_GetEnergyThreshold
   \   000021   90....       MOV     DPTR,#(NLME_GetEnergyThreshold & 0xffff)
   \   000024   74..         MOV     A,#((NLME_GetEnergyThreshold >> 16) & 0xff)
   \   000026   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000029   E9           MOV     A,R1
   \   00002A   F8           MOV     R0,A
   \   00002B   7410         MOV     A,#0x10
   \   00002D   28           ADD     A,R0
   \   00002E   F8           MOV     R0,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   94FF         SUBB    A,#-0x1
   \   000036   E9           MOV     A,R1
   \   000037   9400         SUBB    A,#0x0
   \   000039   C3           CLR     C
   \   00003A   65D0         XRL     A,PSW
   \   00003C   33           RLC     A
   \   00003D   5015         JNC     ??ZDApp_NetworkStartEvt_3
    674              {
    675                NLME_SetEnergyThreshold( (uint8)(NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT) );
   \   00003F                ; Setup parameters for call to function NLME_SetEnergyThreshold
   \   00003F                ; Setup parameters for call to function NLME_GetEnergyThreshold
   \   00003F   74..         MOV     A,#((NLME_GetEnergyThreshold >> 16) & 0xff)
   \   000041   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000044   E9           MOV     A,R1
   \   000045   2410         ADD     A,#0x10
   \   000047   F9           MOV     R1,A
   \   000048   90....       MOV     DPTR,#(NLME_SetEnergyThreshold & 0xffff)
   \   00004B   74..         MOV     A,#((NLME_SetEnergyThreshold >> 16) & 0xff)
   \   00004D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    676                osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   \   000050                ; Setup parameters for call to function osal_set_event
   \   000050   7A01         MOV     R2,#0x1
   \   000052   8008         SJMP    ??ZDApp_NetworkStartEvt_4
    677              }
    678              else
    679              {
    680                // Failed to start network. Enter a dormant state (until user intervenes)
    681                devState = DEV_INIT;
   \                     ??ZDApp_NetworkStartEvt_3:
   \   000054   7401         MOV     A,#0x1
   \   000056   90....       MOV     DPTR,#devState
   \   000059   F0           MOVX    @DPTR,A
    682                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00005A                ; Setup parameters for call to function osal_set_event
   \                     ??ZDApp_NetworkStartEvt_2:
   \   00005A   7A10         MOV     R2,#0x10
   \                     ??ZDApp_NetworkStartEvt_4:
   \   00005C   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00005F   02....       LJMP    ??Subroutine29_0 & 0xFFFF
    683              }
    684            }
    685          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   90....       MOV     DPTR,#ZDAppTaskID
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F9           MOV     R1,A
   \   000007   90....       MOV     DPTR,#(osal_set_event & 0xffff)
   \   00000A   74..         MOV     A,#((osal_set_event >> 16) & 0xff)
   \   00000C   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??Subroutine29_0:
   \   000003   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000006   02....       LJMP    ??Subroutine23_0 & 0xFFFF
    686          
    687          #if ( SECURE != 0 )
    688          /*********************************************************************
    689           * @fn      ZDApp_DeviceAuthEvt()
    690           *
    691           * @brief   Process the Device Authentic Event
    692           *
    693           * @param   none
    694           *
    695           * @return  none
    696           */
    697          void ZDApp_DeviceAuthEvt( void )
    698          {
    699            // received authentication from trust center
    700            if ( devState == DEV_END_DEVICE_UNAUTH )
    701            {
    702              // Stop the reset timer so it doesn't reset
    703              ZDApp_ResetTimerCancel();
    704          
    705              devState = DEV_END_DEVICE;
    706              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    707          
    708              // Set the Power Manager Device
    709          #if defined ( POWER_SAVING )
    710              osal_pwrmgr_device( PWRMGR_BATTERY );
    711          #endif
    712          
    713          #if defined ( RTR_NWK )
    714              if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
    715              {
    716                // NOTE: first two parameters are not used, see NLMEDE.h for details
    717                NLME_StartRouterRequest( 0, 0, false );
    718              }
    719          #endif  // RTR
    720          
    721                // Notify to save info into NV
    722              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 100 );
    723          
    724              // Save off the security
    725              ZDApp_SaveNwkKey();
    726          
    727          #if defined ( ZDO_ENDDEVICE_ANNCE_GENERATE )
    728              ZDP_EndDeviceAnnce( ZDAppNwkAddr.addr.shortAddr, saveExtAddr,
    729                                 ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
    730          #endif
    731            }
    732            else
    733            {
    734              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
    735            }
    736          }
    737          #endif
    738          
    739          /*********************************************************************
    740           * @fn      ZDApp_SaveNetworkStateEvt()
    741           *
    742           * @brief   Process the Save the Network State Event
    743           *
    744           * @param   none
    745           *
    746           * @return  none
    747           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    748          void ZDApp_SaveNetworkStateEvt( void )
   \                     ZDApp_SaveNetworkStateEvt:
    749          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    750          #if defined ( NV_RESTORE )
    751           #if defined ( NV_TURN_OFF_RADIO )
    752            // Turn off the radio's receiver during an NV update
    753            byte RxOnIdle;
    754            byte x = false;
    755            ZMacGetReq( ZMacRxOnIdle, &RxOnIdle );
    756            ZMacSetReq( ZMacRxOnIdle, &x );
    757           #endif
    758          
    759            // Update the Network State in NV
    760            NLME_UpdateNV( NWK_NV_NIB_ENABLE        |
    761                           NWK_NV_DEVICELIST_ENABLE |
    762                           NWK_NV_BINDING_ENABLE    |
    763                           NWK_NV_ADDRMGR_ENABLE );
    764          
    765            // Reset the NV startup option to resume from NV by
    766            // clearing the "New" join option.
    767            zgWriteStartupOptions( FALSE, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
    768          
    769           #if defined ( NV_TURN_OFF_RADIO )
    770            ZMacSetReq( ZMacRxOnIdle, &RxOnIdle );
    771           #endif
    772          #endif  // NV_RESTORE
    773          }
   \   000000   02....       LJMP    ?BRET
    774          
    775          /*********************************************************************
    776           * @fn      ZDApp_RestoreNetworkState()
    777           *
    778           * @brief   This function will restore the network state of the
    779           *          device if the network state is stored in NV.
    780           *
    781           * @param   none
    782           *
    783           * @return
    784           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    785           *          restored.
    786           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was not used.
    787           *          This could mean that zgStartupOption said to not restore, or
    788           *          it could mean that there was no network state to restore.
    789           *
    790           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    791          uint8 ZDApp_RestoreNetworkState( void )
   \                     ZDApp_RestoreNetworkState:
    792          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    793            byte nvStat;
    794          #if ( SECURE != 0 )
    795            nwkActiveKeyItems keyItems;
    796          #endif
    797          
    798            // Initialize NWK NV items
    799            nvStat = NLME_InitNV();
   \   000005                ; Setup parameters for call to function NLME_InitNV
   \   000005   90....       MOV     DPTR,#(NLME_InitNV & 0xffff)
   \   000008   74..         MOV     A,#((NLME_InitNV >> 16) & 0xff)
   \   00000A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000D   E9           MOV     A,R1
   \   00000E   FE           MOV     R6,A
    800          
    801            if ( nvStat != NV_OPER_FAILED )
   \   00000F   7410         MOV     A,#0x10
   \   000011   6E           XRL     A,R6
   \   000012   6032         JZ      ??ZDApp_RestoreNetworkState_0
    802            {
    803              if ( NLME_RestoreFromNV() )
   \   000014                ; Setup parameters for call to function NLME_RestoreFromNV
   \   000014   90....       MOV     DPTR,#(NLME_RestoreFromNV & 0xffff)
   \   000017   74..         MOV     A,#((NLME_RestoreFromNV >> 16) & 0xff)
   \   000019   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001C   E9           MOV     A,R1
   \   00001D   602E         JZ      ??ZDApp_RestoreNetworkState_1
    804              {
    805                // Are we a coordinator
    806                ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
   \   00001F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00001F   90....       MOV     DPTR,#(NLME_GetShortAddr & 0xffff)
   \   000022   74..         MOV     A,#((NLME_GetShortAddr >> 16) & 0xff)
   \   000024   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000027   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00002A   EA           MOV     A,R2
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   EB           MOV     A,R3
   \   00002E   F0           MOVX    @DPTR,A
    807                if ( ZDAppNwkAddr.addr.shortAddr == 0 )
   \   00002F   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000032   E0           MOVX    A,@DPTR
   \   000033   7002         JNZ     ??ZDApp_RestoreNetworkState_2
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \                     ??ZDApp_RestoreNetworkState_2:
   \   000037   7007         JNZ     ??ZDApp_RestoreNetworkState_3
    808                {
    809                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   \   000039   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   54F8         ANL     A,#0xf8
   \   00003F   F0           MOVX    @DPTR,A
    810                }
    811                devStartMode = MODE_RESUME;
   \                     ??ZDApp_RestoreNetworkState_3:
   \   000040   7401         MOV     A,#0x1
   \   000042   90....       MOV     DPTR,#devStartMode
   \   000045   F0           MOVX    @DPTR,A
    812              }
    813              else
    814                nvStat = NV_ITEM_UNINIT;
    815          
    816          #if   ( SECURE != 0  )
    817              nwkFrameCounterChanges = 0;
    818              osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
    819              osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
    820          
    821            #if defined ( ZDO_COORDINATOR )
    822              ZDApp_RestoreNwkKey();
    823            #endif // ZDO_COORDINATOR
    824          #endif // SECURE
    825          
    826              // The default for RxOnWhenIdle is true for RTR_NWK and false for end devices
    827              // [setup in the NLME_RestoreFromNV()].  Change it here if you want something
    828              // other than default.
    829            }
    830          
    831            if ( nvStat == ZSUCCESS )
   \                     ??ZDApp_RestoreNetworkState_0:
   \   000046   EE           MOV     A,R6
   \   000047   7004         JNZ     ??ZDApp_RestoreNetworkState_1
    832              return ( ZDO_INITDEV_RESTORED_NETWORK_STATE );
   \   000049   7900         MOV     R1,#0x0
   \   00004B   8002         SJMP    ??ZDApp_RestoreNetworkState_4
    833            else
    834              return ( ZDO_INITDEV_NEW_NETWORK_STATE );
   \                     ??ZDApp_RestoreNetworkState_1:
   \   00004D   7901         MOV     R1,#0x1
   \                     ??ZDApp_RestoreNetworkState_4:
   \   00004F   02....       LJMP    ??Subroutine25_0 & 0xFFFF
    835          }
    836          
    837          /*********************************************************************
    838           * @fn      ZDAppSetupProtoVersion()
    839           *
    840           * @brief   Setup the Network Protocol version
    841           *
    842           * NOTES:
    843           *   Take care of setting initial protocol value if we're possibly a
    844           *   Coordinator.
    845           *
    846           *   If DEF_PROTO_VERS macro is not defined get version
    847           *   from NV. if the NV version isn't valid default to Version 1.1.
    848           *
    849           *   if DEF_PROTO_VERS macro is defined respect it.
    850           *
    851           *   This initialization section works for End Devices as well.
    852           *
    853           *   There are two chores: make sure that if we're the Coordinator we start
    854           *   the correct network version, and set things up so that if we're a
    855           *   joining device we join the correct network. In both cases this init
    856           *   function runs so take care of both cases here.
    857           *
    858           * @param   none
    859           *
    860           * @return  none
    861           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    862          void ZDAppSetupProtoVersion( void )
   \                     ZDAppSetupProtoVersion:
    863          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    864            uint8 restore = 1;  // update NV or not: could save a flash erase cycle
    865          
    866          #if !defined ( DEF_PROTO_VERS )
    867            uint8 protoVer = NLME_GetProtocolVersion(); // get  protocol version from NV
   \   000009                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   000009   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   00000C   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   00000E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000011   E9           MOV     A,R1
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   F0           MOVX    @DPTR,A
    868          
    869            // it is possible that it is uninitialized.
    870            if ((protoVer != ZB_PROT_V1_0) && (protoVer != ZB_PROT_V1_1))
   \   000019   6401         XRL     A,#0x1
   \   00001B   6019         JZ      ??ZDAppSetupProtoVersion_0
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6402         XRL     A,#0x2
   \   000020   6014         JZ      ??ZDAppSetupProtoVersion_0
    871            {
    872              // NV value not valid. 'protoVer' must be set.
    873          
    874              // For Coordinator behavior
    875              // CUSTOMER NOTE: change the following to default the started network
    876              // to a protocol version other than 1.1
    877              protoVer = ZB_PROT_V1_1;
   \   000022   7402         MOV     A,#0x2
   \   000024   F0           MOVX    @DPTR,A
    878            }
    879            else
    880            {
    881              // NV valid. 'protoVer' is valid.
    882              restore = 0;  // no need to update NV
    883          
    884              // For joining device behavior. Respect the NV version by making
    885              // all entries in the version array the same as the NV value.
    886              osal_memset(sPVerList, protoVer, sizeof(sPVerList));
    887            }
    888          #else
    889            // macro defined. respect it.
    890          
    891            // don't compile if defined to an illegal value.
    892            #if (DEF_PROTO_VERS != ZB_PROT_V1_0) && (DEF_PROTO_VERS != ZB_PROT_V1_1)
    893              #error  No legal value for default protocol version
    894            #endif
    895            uint8 protoVer = DEF_PROTO_VERS;
    896          
    897            // For joining device behavior. respect the NV version by making
    898            // all entries in the version array the same as the macro value.
    899            osal_memset(sPVerList, protoVer, sizeof(sPVerList));
    900          #endif   // DEF_PROTO_VERS
    901          
    902            // if we are or can be the Coordinator then we must update
    903            // it here. if we're going to be a joining device setting will be done in the
    904            // confirm callback if necessary.
    905            if (restore)
    906            {
    907              // we need to set NV to a (possibly) new value
    908              NLME_SetRequest(nwkProtocolVersion, 0, &protoVer);
   \   000025                ; Setup parameters for call to function NLME_SetRequest
   \   000025   AC82         MOV     R4,DPL
   \   000027   AD83         MOV     R5,DPH
   \   000029   7A00         MOV     R2,#0x0
   \   00002B   7B00         MOV     R3,#0x0
   \   00002D   7998         MOV     R1,#-0x68
   \   00002F   90....       MOV     DPTR,#(NLME_SetRequest & 0xffff)
   \   000032   74..         MOV     A,#((NLME_SetRequest >> 16) & 0xff)
   \   000034   800D         SJMP    ??ZDAppSetupProtoVersion_1
    909            }
   \                     ??ZDAppSetupProtoVersion_0:
   \   000036                ; Setup parameters for call to function osal_memset
   \   000036   7C02         MOV     R4,#0x2
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7A..         MOV     R2,#(??sPVerList & 0xff)
   \   00003C   7B..         MOV     R3,#((??sPVerList >> 8) & 0xff)
   \   00003E   90....       MOV     DPTR,#(osal_memset & 0xffff)
   \   000041   74..         MOV     A,#((osal_memset >> 16) & 0xff)
   \                     ??ZDAppSetupProtoVersion_1:
   \   000043   02....       LJMP    ?Subroutine23 & 0xFFFF
    910          }
    911          
    912          /*********************************************************************
    913           * @fn      ZDApp_InitUserDesc()
    914           *
    915           * @brief   Initialize the User Descriptor, the descriptor is read from NV
    916           *          when needed.  If you want to initialize the User descriptor to
    917           *          something other than all zero, do it here.
    918           *
    919           * @param   none
    920           *
    921           * @return  none
    922           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    923          void ZDApp_InitUserDesc( void )
   \                     ZDApp_InitUserDesc:
    924          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    925            UserDescriptorFormat_t ZDO_DefaultUserDescriptor;
    926          
    927            // Initialize the User Descriptor, the descriptor is read from NV
    928            // when needed.  If you want to initialize the User descriptor to something
    929            // other than all zero, do it here.
    930            osal_memset( &ZDO_DefaultUserDescriptor, 0, sizeof( UserDescriptorFormat_t ) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C11         MOV     R4,#0x11
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   90....       MOV     DPTR,#(osal_memset & 0xffff)
   \   00001D   74..         MOV     A,#((osal_memset >> 16) & 0xff)
   \   00001F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    931            if ( ZSUCCESS == osal_nv_item_init( ZCD_NV_USERDESC,
    932                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
   \   000022                ; Setup parameters for call to function osal_nv_item_init
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   8582..       MOV     ?V0 + 0,DPL
   \   00002B   8583..       MOV     ?V0 + 1,DPH
   \   00002E   78..         MOV     R0,#?V0 + 0
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   7C11         MOV     R4,#0x11
   \   000035   7D00         MOV     R5,#0x0
   \   000037   7A81         MOV     R2,#-0x7f
   \   000039   7B00         MOV     R3,#0x0
   \   00003B   90....       MOV     DPTR,#(osal_nv_item_init & 0xffff)
   \   00003E   74..         MOV     A,#((osal_nv_item_init >> 16) & 0xff)
   \   000040   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   E9           MOV     A,R1
   \   000049   7038         JNZ     ??ZDApp_InitUserDesc_0
    933            {
    934              if ( ZSUCCESS == osal_nv_read( ZCD_NV_USERDESC, 0,
    935                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
   \   00004B                ; Setup parameters for call to function osal_nv_read
   \   00004B   78..         MOV     R0,#?V0 + 0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   75..11       MOV     ?V0 + 0,#0x11
   \   000053   75..00       MOV     ?V0 + 1,#0x0
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7C00         MOV     R4,#0x0
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7A81         MOV     R2,#-0x7f
   \   000061   7B00         MOV     R3,#0x0
   \   000063   90....       MOV     DPTR,#(osal_nv_read & 0xffff)
   \   000066   74..         MOV     A,#((osal_nv_read >> 16) & 0xff)
   \   000068   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00006B   7404         MOV     A,#0x4
   \   00006D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000070   E9           MOV     A,R1
   \   000071   7010         JNZ     ??ZDApp_InitUserDesc_0
    936              {
    937                if ( ZDO_DefaultUserDescriptor.len != 0 )
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   6007         JZ      ??ZDApp_InitUserDesc_0
    938                {
    939                  ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   \   00007C   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   D2E4         SETB    0xE0 /* A   */.4
   \   000082   F0           MOVX    @DPTR,A
    940                }
    941              }
    942            }
    943          }
   \                     ??ZDApp_InitUserDesc_0:
   \   000083   7411         MOV     A,#0x11
   \   000085   02....       LJMP    ??Subroutine24_0 & 0xFFFF
    944          
    945          /*********************************************************************
    946           * @fn      ZDAppCheckForHoldKey()
    947           *
    948           * @brief   Check for key to set the device into Hold Auto Start
    949           *
    950           * @param   none
    951           *
    952           * @return  none
    953           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    954          void ZDAppCheckForHoldKey( void )
   \                     ZDAppCheckForHoldKey:
    955          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    956          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    957            // Get Keypad directly to see if a HOLD_START is needed.
    958            // Hold down the SW_BYPASS_START key (see OnBoard.h)
    959            // while booting to avoid starting up the device.
    960            if ( HalKeyRead () == SW_BYPASS_START)
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   90....       MOV     DPTR,#(HalKeyRead & 0xffff)
   \   000007   74..         MOV     A,#((HalKeyRead >> 16) & 0xff)
   \   000009   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000C   E9           MOV     A,R1
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7005         JNZ     ??ZDAppCheckForHoldKey_0
    961            {
    962              // Change the device state to HOLD on start up
    963              devState = DEV_HOLD;
   \   000011   E4           CLR     A
   \   000012   90....       MOV     DPTR,#devState
   \   000015   F0           MOVX    @DPTR,A
    964            }
    965          #endif // HAL_KEY
    966          }
   \                     ??ZDAppCheckForHoldKey_0:
   \   000016   02....       LJMP    ??Subroutine23_0 & 0xFFFF
    967          
    968          /*********************************************************************
    969           * @fn      ZDApp_ProcessOSALMsg()
    970           *
    971           * @brief   Process the incoming task message.
    972           *
    973           * @param   msgPtr - message to process
    974           *
    975           * @return  none
    976           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    977          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr )
   \                     ZDApp_ProcessOSALMsg:
    978          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    979            // Data Confirmation message fields
    980            byte sentEP;       // This should always be 0
    981            byte sentStatus;
    982            afDataConfirm_t *afDataConfirm;
    983          
    984            switch ( msgPtr->event )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for ZDApp_ProcessOSALMsg>_0`:
   \   000011   00           DB        0
   \   000012   04           DB        4
   \   000013   01           DB        1
   \   000014   ....         DW        ??ZDApp_ProcessOSALMsg_0
   \   000016   02           DB        2
   \   000017   ....         DW        ??ZDApp_ProcessOSALMsg_1
   \   000019   03           DB        3
   \   00001A   ....         DW        ??ZDApp_ProcessOSALMsg_2
   \   00001C   1A           DB        26
   \   00001D   ....         DW        ??ZDApp_ProcessOSALMsg_3
   \   00001F   ....         DW        ??ZDApp_ProcessOSALMsg_4
    985            {
    986              // Incoming ZDO Message
    987              case AF_INCOMING_MSG_CMD:
    988                ZDP_IncomingData( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??ZDApp_ProcessOSALMsg_3:
   \   000021                ; Setup parameters for call to function ZDP_IncomingData
   \   000021   90....       MOV     DPTR,#(ZDP_IncomingData & 0xffff)
   \   000024   74..         MOV     A,#((ZDP_IncomingData >> 16) & 0xff)
   \   000026   02....       LJMP    ??CrossCallReturnLabel_52 & 0xFFFF
    989                break;
    990          
    991              case AF_DATA_CONFIRM_CMD:
    992                // This message is received as a confirmation of a data packet sent.
    993                // The status is of ZStatus_t type [defined in NLMEDE.h]
    994                // The message fields are defined in AF.h
    995                afDataConfirm = (afDataConfirm_t *)msgPtr;
    996                sentEP = afDataConfirm->endpoint;
    997                sentStatus = afDataConfirm->hdr.status;
    998          
    999                // Action taken when confirmation is received.
   1000                /* Put code here */
   1001          #if !defined ( RTR_NWK )
   1002                if ( sentStatus == ZMacNoACK )
   1003                {
   1004                  //ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_REQ, sizeof(osal_event_hdr_t), NULL );
   1005                }
   1006          #else
   1007               (void)sentStatus;
   1008          #endif
   1009                break;
   1010          
   1011              case ZDO_NWK_DISC_CNF:
   1012                if (devState != DEV_NWK_DISC)
   \                     ??ZDApp_ProcessOSALMsg_0:
   \   000029   90....       MOV     DPTR,#devState
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   6402         XRL     A,#0x2
   \   00002F   6003         JZ      $+5
   \   000031   02....       LJMP    ??ZDApp_ProcessOSALMsg_4 & 0xFFFF
   1013                {
   1014                }
   1015          #if !defined ( ZDO_COORDINATOR ) || defined ( SOFT_START )
   1016            #if defined ( MANAGED_SCAN )
   1017                else if ( (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status == ZDO_SUCCESS) && (zdoDiscCounter > NUM_DISC_ATTEMPTS) )
   1018            #else
   1019                else if ( (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status == ZDO_SUCCESS) && (zdoDiscCounter++ > NUM_DISC_ATTEMPTS) )
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6003         JZ      $+5
   \   00003C   02....       LJMP    ??ZDApp_ProcessOSALMsg_5 & 0xFFFF
   \   00003F   90....       MOV     DPTR,#zdoDiscCounter
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FA           MOV     R2,A
   \   000044   7401         MOV     A,#0x1
   \   000046   2A           ADD     A,R2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   EA           MOV     A,R2
   \   000049   C3           CLR     C
   \   00004A   9403         SUBB    A,#0x3
   \   00004C   5003         JNC     $+5
   \   00004E   02....       LJMP    ??ZDApp_ProcessOSALMsg_5 & 0xFFFF
   1020            #endif
   1021                {
   1022                  if ( devStartMode == MODE_JOIN )
   \   000051   90....       MOV     DPTR,#devStartMode
   \   000054   E0           MOVX    A,@DPTR
   \   000055   704B         JNZ     ??ZDApp_ProcessOSALMsg_6
   1023                  {
   1024                    devState = DEV_NWK_JOINING;
   \   000057   7403         MOV     A,#0x3
   \   000059   90....       MOV     DPTR,#devState
   \   00005C   F0           MOVX    @DPTR,A
   1025          
   1026                    ZDApp_NodeProfileSync((ZDO_NetworkDiscoveryCfm_t *)msgPtr);
   \   00005D                ; Setup parameters for call to function ZDApp_NodeProfileSync
   \   00005D   EE           MOV     A,R6
   \   00005E   FA           MOV     R2,A
   \   00005F   90....       MOV     DPTR,#(ZDApp_NodeProfileSync & 0xffff)
   \   000062   74..         MOV     A,#((ZDApp_NodeProfileSync >> 16) & 0xff)
   \   000064   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1027          
   1028                    if ( NLME_JoinRequest( ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->extendedPANID,
   1029                         BUILD_UINT16( ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdLSB, ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdMSB ),
   1030                         ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->logicalChannel,
   1031                         ZDO_Config_Node_Descriptor.CapabilityFlags ) != ZSuccess )
   \   000067                ; Setup parameters for call to function NLME_JoinRequest
   \   000067   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   00006A   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FC           MOV     R4,A
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FB           MOV     R3,A
   \   000085   E4           CLR     A
   \   000086   2C           ADD     A,R4
   \   000087   EB           MOV     A,R3
   \   000088   3400         ADDC    A,#0x0
   \   00008A   FD           MOV     R5,A
   \   00008B   EE           MOV     A,R6
   \   00008C   2406         ADD     A,#0x6
   \   00008E   FA           MOV     R2,A
   \   00008F   EF           MOV     A,R7
   \   000090   3400         ADDC    A,#0x0
   \   000092   FB           MOV     R3,A
   \   000093   90....       MOV     DPTR,#(NLME_JoinRequest & 0xffff)
   \   000096   74..         MOV     A,#((NLME_JoinRequest >> 16) & 0xff)
   \   000098   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00009B   7401         MOV     A,#0x1
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A0   8012         SJMP    ??ZDApp_ProcessOSALMsg_7
   1032                    {
   1033                      ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1034                          + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1035                    }
   1036                  }
   1037                  else if ( devStartMode == MODE_REJOIN )
   \                     ??ZDApp_ProcessOSALMsg_6:
   \   0000A2   6403         XRL     A,#0x3
   \   0000A4   701F         JNZ     ??ZDApp_ProcessOSALMsg_8
   1038                  {
   1039                    devState = DEV_NWK_REJOIN;
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   90....       MOV     DPTR,#devState
   \   0000AB   F0           MOVX    @DPTR,A
   1040                    if ( NLME_ReJoinRequest() != ZSuccess )
   \   0000AC                ; Setup parameters for call to function NLME_ReJoinRequest
   \   0000AC   90....       MOV     DPTR,#(NLME_ReJoinRequest & 0xffff)
   \   0000AF   74..         MOV     A,#((NLME_ReJoinRequest >> 16) & 0xff)
   \   0000B1   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_ProcessOSALMsg_7:
   \   0000B4   E9           MOV     A,R1
   \   0000B5   600E         JZ      ??ZDApp_ProcessOSALMsg_8
   1041                    {
   1042                      ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1043                          + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   \   0000B7                ; Setup parameters for call to function ZDApp_NetworkInit
   \   0000B7                ; Setup parameters for call to function osal_rand
   \   0000B7   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   0000BA   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   0000BC   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000BF   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0000C2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1044                    }
   1045                  }
   1046          
   1047                  if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   \                     ??ZDApp_ProcessOSALMsg_8:
   \   0000C5   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   A2E3         MOV     C,0xE0 /* A   */.3
   \   0000CB   5070         JNC     ??ZDApp_ProcessOSALMsg_4
   1048                  {
   1049                    // The receiver is on, turn network layer polling off.
   1050                    NLME_SetPollRate( 0 );
   \   0000CD                ; Setup parameters for call to function NLME_SetPollRate
   \   0000CD   7A00         MOV     R2,#0x0
   \   0000CF   7B00         MOV     R3,#0x0
   \   0000D1   90....       MOV     DPTR,#(NLME_SetPollRate & 0xffff)
   \   0000D4   74..         MOV     A,#((NLME_SetPollRate >> 16) & 0xff)
   \   0000D6   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1051                    NLME_SetQueuedPollRate( 0 );
   \   0000D9                ; Setup parameters for call to function NLME_SetQueuedPollRate
   \   0000D9   7A00         MOV     R2,#0x0
   \   0000DB   7B00         MOV     R3,#0x0
   \   0000DD   90....       MOV     DPTR,#(NLME_SetQueuedPollRate & 0xffff)
   \   0000E0   74..         MOV     A,#((NLME_SetQueuedPollRate >> 16) & 0xff)
   \   0000E2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1052                    NLME_SetResponseRate( 0 );
   \   0000E5                ; Setup parameters for call to function NLME_SetResponseRate
   \   0000E5   7A00         MOV     R2,#0x0
   \   0000E7   7B00         MOV     R3,#0x0
   \   0000E9   90....       MOV     DPTR,#(NLME_SetResponseRate & 0xffff)
   \   0000EC   74..         MOV     A,#((NLME_SetResponseRate >> 16) & 0xff)
   \   0000EE   804A         SJMP    ??CrossCallReturnLabel_52
   1053                  }
   1054                }
   1055                else
   1056                {
   1057          #if defined ( SOFT_START ) && !defined ( VIRTKEY_SOFT_START )
   1058            #if defined ( MANAGED_SCAN )
   1059                  if ( (softStartAllowCoord)
   1060                      && (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status != ZDO_SUCCESS )
   1061                        && (zdoDiscCounter > NUM_DISC_ATTEMPTS) )
   1062            #else
   1063                  if ( (softStartAllowCoord)
   1064                      && (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status != ZDO_SUCCESS )
   1065                        && (zdoDiscCounter++ > NUM_DISC_ATTEMPTS) )
   1066            #endif
   1067                  {
   1068                    ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   1069                    devStartMode = MODE_HARD;
   1070                  }
   1071                  else if ( continueJoining == FALSE )
   1072                  {
   1073                    devState = DEV_HOLD;
   1074                    osal_stop_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT );
   1075                    break;    // Don't init
   1076                  }
   1077          #endif
   1078            #if defined ( MANAGED_SCAN )
   1079                  ZDApp_NetworkInit( MANAGEDSCAN_DELAY_BETWEEN_SCANS );
   1080            #else
   1081                  if ( continueJoining )
   \                     ??ZDApp_ProcessOSALMsg_5:
   \   0000F0   90....       MOV     DPTR,#continueJoining
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   6047         JZ      ??ZDApp_ProcessOSALMsg_4
   1082                  {
   1083                    ZDApp_NetworkInit( (uint16)(BEACON_REQUEST_DELAY
   1084                        + ((uint16)(osal_rand()& BEACON_REQ_DELAY_MASK))) );
   \   0000F6                ; Setup parameters for call to function ZDApp_NetworkInit
   \   0000F6                ; Setup parameters for call to function osal_rand
   \   0000F6   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   0000F9   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   0000FB   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000FE   8A..         MOV     ?V0 + 0,R2
   \   000100   74FF         MOV     A,#-0x1
   \   000102   55..         ANL     A,?V0 + 0
   \   000104   F8           MOV     R0,A
   \   000105   7464         MOV     A,#0x64
   \   000107   28           ADD     A,R0
   \   000108   FA           MOV     R2,A
   \   000109   E4           CLR     A
   \   00010A   3400         ADDC    A,#0x0
   \   00010C   FB           MOV     R3,A
   \   00010D   90....       MOV     DPTR,#(ZDApp_NetworkInit & 0xffff)
   \   000110   74..         MOV     A,#((ZDApp_NetworkInit >> 16) & 0xff)
   \   000112   8026         SJMP    ??CrossCallReturnLabel_52
   1085                  }
   1086            #endif
   1087                }
   1088          #endif  // !ZDO_COORDINATOR
   1089                break;
   1090          
   1091          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )
   1092              case ZDO_NWK_JOIN_IND:
   1093                ZDApp_ProcessNetworkJoin();
   \                     ??ZDApp_ProcessOSALMsg_1:
   \   000114                ; Setup parameters for call to function ZDApp_ProcessNetworkJoin
   \   000114   90....       MOV     DPTR,#(ZDApp_ProcessNetworkJoin & 0xffff)
   \   000117   74..         MOV     A,#((ZDApp_ProcessNetworkJoin >> 16) & 0xff)
   \   000119   801F         SJMP    ??CrossCallReturnLabel_52
   1094                break;
   1095          
   1096              case ZDO_NWK_JOIN_REQ:
   1097                retryCnt = 0;
   \                     ??ZDApp_ProcessOSALMsg_2:
   \   00011B   E4           CLR     A
   \   00011C   90....       MOV     DPTR,#??retryCnt
   \   00011F   F0           MOVX    @DPTR,A
   1098                devStartMode = MODE_RESUME;
   \   000120   7401         MOV     A,#0x1
   \   000122   90....       MOV     DPTR,#devStartMode
   \   000125   F0           MOVX    @DPTR,A
   1099                _tmpRejoinState = true;
   \   000126   90....       MOV     DPTR,#_tmpRejoinState
   \   000129   F0           MOVX    @DPTR,A
   1100                zgDefaultStartingScanDuration = BEACON_ORDER_60_MSEC;
   \   00012A   7402         MOV     A,#0x2
   \   00012C   90....       MOV     DPTR,#zgDefaultStartingScanDuration
   \   00012F   12....       LCALL   ?Subroutine2 & 0xFFFF
   1101                ZDApp_NetworkInit( 0 );
   \                     ??CrossCallReturnLabel_57:
   \   000132   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1102          
   1103                // indicate state change to apps
   1104                devState = DEV_INIT;
   \   000135   7401         MOV     A,#0x1
   \   000137   12....       LCALL   ?Subroutine0 & 0xFFFF
   1105                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \                     ??CrossCallReturnLabel_52:
   \   00013A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1106                break;
   1107          #endif  // !ZDO_COORDINATOR
   1108          
   1109          #if defined ( ZDSECMGR_SECURE )
   1110            #if defined ( ZDSECMGR_COMMERCIAL )
   1111                  case ZDO_ESTABLISH_KEY_CFM:
   1112                    ZDSecMgrEstablishKeyCfm
   1113                      ( (ZDO_EstablishKeyCfm_t*)msgPtr );
   1114                    break;
   1115            #endif
   1116          
   1117            #if defined ( ZDSECMGR_COMMERCIAL )
   1118              #if !defined ( ZDO_COORDINATOR ) || defined ( SOFT_START )
   1119                  case ZDO_ESTABLISH_KEY_IND:
   1120                    ZDSecMgrEstablishKeyInd
   1121                      ( (ZDO_EstablishKeyInd_t*)msgPtr );
   1122                    break;
   1123              #endif
   1124            #endif
   1125          
   1126            #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
   1127                  case ZDO_TRANSPORT_KEY_IND:
   1128                    ZDSecMgrTransportKeyInd
   1129                      ( (ZDO_TransportKeyInd_t*)msgPtr );
   1130                    break;
   1131            #endif
   1132          
   1133            #if defined ( ZDO_COORDINATOR )
   1134                  case ZDO_UPDATE_DEVICE_IND:
   1135                    ZDSecMgrUpdateDeviceInd
   1136                      ( (ZDO_UpdateDeviceInd_t*)msgPtr );
   1137                    break;
   1138            #endif
   1139          
   1140            #if defined ( RTR_NWK )
   1141              #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
   1142                  case ZDO_REMOVE_DEVICE_IND:
   1143                    ZDSecMgrRemoveDeviceInd
   1144                      ( (ZDO_RemoveDeviceInd_t*)msgPtr );
   1145                    break;
   1146              #endif
   1147            #endif
   1148          
   1149            #if defined ( ZDSECMGR_COMMERCIAL )
   1150              #if defined ( ZDO_COORDINATOR )
   1151                  case ZDO_REQUEST_KEY_IND:
   1152                    ZDSecMgrRequestKeyInd
   1153                      ( (ZDO_RequestKeyInd_t*)msgPtr );
   1154                    break;
   1155              #endif
   1156            #endif
   1157          
   1158            #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
   1159                  case ZDO_SWITCH_KEY_IND:
   1160                    ZDSecMgrSwitchKeyInd
   1161                      ( (ZDO_SwitchKeyInd_t*)msgPtr );
   1162                    break;
   1163            #endif
   1164          
   1165          #endif // defined ( ZDSECMGR_SECURE )
   1166          
   1167              default:
   1168                break;
   1169            }
   1170          
   1171            (void)sentEP;
   1172          }
   \                     ??ZDApp_ProcessOSALMsg_4:
   \   00013D   02....       LJMP    ??Subroutine24_1 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   8A..         MOV     ?V0 + 0,R2
   \   000002   747F         MOV     A,#0x7f
   \   000004   55..         ANL     A,?V0 + 0
   \   000006   F8           MOV     R0,A
   \   000007   7464         MOV     A,#0x64
   \   000009   28           ADD     A,R0
   \   00000A   FA           MOV     R2,A
   \   00000B                REQUIRE ?Subroutine27
   \   00000B                ; // Fall through to label ?Subroutine27

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   90....       MOV     DPTR,#(ZDApp_NetworkInit & 0xffff)
   \   000005   74..         MOV     A,#((ZDApp_NetworkInit >> 16) & 0xff)
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   90....       MOV     DPTR,#devState
   \   000003   F0           MOVX    @DPTR,A
   \   000004                ; Setup parameters for call to function osal_set_event
   \   000004                ; Setup parameters for call to function osal_set_event
   \   000004   7A10         MOV     R2,#0x10
   \   000006   80..         SJMP    ?Subroutine26

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??Subroutine10_0:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F5..         MOV     ?V0 + 0,A
   \   000006   78..         MOV     R0,#?V0 + 0
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F9           MOV     R1,A
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDApp_NetworkInit
   \   000001                ; Setup parameters for call to function ZDApp_NetworkInit
   \   000001   7A00         MOV     R2,#0x0
   \   000003   02....       LJMP    ?Subroutine27 & 0xFFFF
   1173          
   1174          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )
   1175          /*********************************************************************
   1176           * @fn      ZDApp_ProcessNetworkJoin()
   1177           *
   1178           * @brief
   1179           *
   1180           *   Save off the Network key information.
   1181           *
   1182           * @param   none
   1183           *
   1184           * @return  none
   1185           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1186          void ZDApp_ProcessNetworkJoin( void )
   \                     ZDApp_ProcessNetworkJoin:
   1187          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1188            if ( (devState == DEV_NWK_JOINING) ||
   1189                ((devState == DEV_NWK_ORPHAN)  &&
   1190                 (ZDO_Config_Node_Descriptor.LogicalType == NODETYPE_ROUTER)) )
   \   00000A   90....       MOV     DPTR,#devState
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6403         XRL     A,#0x3
   \   000010   6015         JZ      ??ZDApp_ProcessNetworkJoin_0
   \   000012   E0           MOVX    A,@DPTR
   \   000013   640A         XRL     A,#0xa
   \   000015   6003         JZ      $+5
   \   000017   02....       LJMP    ??ZDApp_ProcessNetworkJoin_1 & 0xFFFF
   \   00001A   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   5407         ANL     A,#0x7
   \   000020   6401         XRL     A,#0x1
   \   000022   6003         JZ      $+5
   \   000024   02....       LJMP    ??ZDApp_ProcessNetworkJoin_2 & 0xFFFF
   1191            {
   1192              // Result of a Join attempt by this device.
   1193              if ( nwkStatus == ZSuccess )
   \                     ??ZDApp_ProcessNetworkJoin_0:
   \   000027   90....       MOV     DPTR,#nwkStatus
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   7011         JNZ     ??ZDApp_ProcessNetworkJoin_3
   1194              {
   1195                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00002D                ; Setup parameters for call to function osal_set_event
   \   00002D   7A10         MOV     R2,#0x10
   \   00002F   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000032   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1196          
   1197          #if defined ( POWER_SAVING )
   1198                osal_pwrmgr_device( PWRMGR_BATTERY );
   1199          #endif
   1200          
   1201          #if   ( SECURE != 0  )
   1202                if ( _NIB.SecurityLevel && (ZDApp_RestoreNwkKey() == false ) )
   1203                {
   1204                  // wait for auth from trust center!!
   1205                  devState = DEV_END_DEVICE_UNAUTH;
   1206          
   1207                  // Start the reset timer for MAX UNAUTH time
   1208                  ZDApp_ResetTimerStart( MAX_DEVICE_UNAUTH_TIMEOUT );
   1209                }
   1210                else
   1211          #endif  // SECURE
   1212                {
   1213          #if defined ( RTR_NWK )
   1214                  if ( devState == DEV_NWK_ORPHAN
   1215                      && ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1216                  {
   1217                    // Change NIB state to router for restore
   1218                    _NIB.nwkState = NWK_ROUTER;
   1219                  }
   1220          #endif
   1221                  devState = DEV_END_DEVICE;
   \   000035   7406         MOV     A,#0x6
   \   000037   90....       MOV     DPTR,#devState
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   02....       LJMP    ??ZDApp_ProcessNetworkJoin_4 & 0xFFFF
   1222          #if defined ( RTR_NWK )
   1223                  // NOTE: first two parameters are not used, see NLMEDE.h for details
   1224            #if !defined (AUTO_SOFT_START)
   1225                  if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1226                  {
   1227                    NLME_StartRouterRequest( 0, 0, false );
   1228                  }
   1229            #endif // AUTO_SOFT_START
   1230          #endif  // RTR
   1231          
   1232          #if defined ( ZDO_ENDDEVICE_ANNCE_GENERATE )
   1233                  ZDP_EndDeviceAnnce( ZDAppNwkAddr.addr.shortAddr, saveExtAddr,
   1234                                     ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
   1235          #endif
   1236                }
   1237              }
   1238              else
   1239              {
   1240                if ( (devStartMode == MODE_RESUME) && (++retryCnt >= MAX_RESUME_RETRY) )
   \                     ??ZDApp_ProcessNetworkJoin_3:
   \   00003E   90....       MOV     DPTR,#devStartMode
   \   000041   E0           MOVX    A,@DPTR
   \   000042   6401         XRL     A,#0x1
   \   000044   7036         JNZ     ??ZDApp_ProcessNetworkJoin_5
   \   000046   90....       MOV     DPTR,#??retryCnt
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   04           INC     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   602E         JZ      ??ZDApp_ProcessNetworkJoin_5
   1241                {
   1242                  if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   \   00004E   90....       MOV     DPTR,#(_NIB + 33)
   \   000051   E0           MOVX    A,@DPTR
   \   000052   64FF         XRL     A,#0xff
   \   000054   7004         JNZ     ??ZDApp_ProcessNetworkJoin_6
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_6:
   \   00005A   600E         JZ      ??ZDApp_ProcessNetworkJoin_7
   \   00005C   90....       MOV     DPTR,#(_NIB + 33)
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   64FE         XRL     A,#0xfe
   \   000062   7004         JNZ     ??ZDApp_ProcessNetworkJoin_8
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_8:
   \   000068   7006         JNZ     ??ZDApp_ProcessNetworkJoin_9
   1243                    devStartMode = MODE_JOIN;
   \                     ??ZDApp_ProcessNetworkJoin_7:
   \   00006A   E4           CLR     A
   \   00006B   90....       MOV     DPTR,#devStartMode
   \   00006E   800B         SJMP    ??ZDApp_ProcessNetworkJoin_10
   1244                  else
   1245                  {
   1246                    devStartMode = MODE_REJOIN;
   \                     ??ZDApp_ProcessNetworkJoin_9:
   \   000070   7403         MOV     A,#0x3
   \   000072   90....       MOV     DPTR,#devStartMode
   \   000075   F0           MOVX    @DPTR,A
   1247                    _tmpRejoinState = true;
   \   000076   7401         MOV     A,#0x1
   \   000078   90....       MOV     DPTR,#_tmpRejoinState
   \                     ??ZDApp_ProcessNetworkJoin_10:
   \   00007B   F0           MOVX    @DPTR,A
   1248                  }
   1249                }
   1250          
   1251                if ( (NLME_GetShortAddr() != INVALID_NODE_ADDR) ||
   1252                     (_NIB.nwkDevAddress != INVALID_NODE_ADDR) )
   \                     ??ZDApp_ProcessNetworkJoin_5:
   \   00007C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007C   90....       MOV     DPTR,#(NLME_GetShortAddr & 0xffff)
   \   00007F   74..         MOV     A,#((NLME_GetShortAddr >> 16) & 0xff)
   \   000081   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000084   8A..         MOV     ?V0 + 0,R2
   \   000086   8B..         MOV     ?V0 + 1,R3
   \   000088   74FE         MOV     A,#-0x2
   \   00008A   65..         XRL     A,?V0 + 0
   \   00008C   7004         JNZ     ??ZDApp_ProcessNetworkJoin_11
   \   00008E   74FF         MOV     A,#-0x1
   \   000090   65..         XRL     A,?V0 + 1
   \                     ??ZDApp_ProcessNetworkJoin_11:
   \   000092   700E         JNZ     ??ZDApp_ProcessNetworkJoin_12
   \   000094   90....       MOV     DPTR,#(_NIB + 20)
   \   000097   E0           MOVX    A,@DPTR
   \   000098   64FE         XRL     A,#0xfe
   \   00009A   7004         JNZ     ??ZDApp_ProcessNetworkJoin_13
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_13:
   \   0000A0   6022         JZ      ??ZDApp_ProcessNetworkJoin_14
   1253                {
   1254                  uint16 addr = INVALID_NODE_ADDR;
   \                     ??ZDApp_ProcessNetworkJoin_12:
   \   0000A2   85..82       MOV     DPL,?XSP + 0
   \   0000A5   85..83       MOV     DPH,?XSP + 1
   \   0000A8   74FE         MOV     A,#-0x2
   \   0000AA   F0           MOVX    @DPTR,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   74FF         MOV     A,#-0x1
   \   0000AE   F0           MOVX    @DPTR,A
   1255                  // Invalidate nwk addr so end device does not use in its data reqs.
   1256                  _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   \   0000AF   90....       MOV     DPTR,#(_NIB + 20)
   \   0000B2   74FE         MOV     A,#-0x2
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   74FF         MOV     A,#-0x1
   \   0000B8   12....       LCALL   ?Subroutine1 & 0xFFFF
   1257                  ZMacSetReq( ZMacShortAddress, (byte *)&addr );
   \                     ??CrossCallReturnLabel_0:
   \   0000BB   AA82         MOV     R2,DPL
   \   0000BD   AB83         MOV     R3,DPH
   \   0000BF   7953         MOV     R1,#0x53
   \   0000C1   12....       LCALL   ZMacSetReq & 0xFFFF
   1258                }
   1259          
   1260                zdoDiscCounter = 1;
   \                     ??ZDApp_ProcessNetworkJoin_14:
   \   0000C4   7401         MOV     A,#0x1
   \   0000C6   90....       MOV     DPTR,#zdoDiscCounter
   \   0000C9   807E         SJMP    ??ZDApp_ProcessNetworkJoin_15
   \   0000CB                ; Setup parameters for call to function ZDApp_NetworkInit
   \   0000CB                ; Setup parameters for call to function osal_rand
   1261          
   1262          //      ZDApp_NetworkInit( (uint16)
   1263          //                         ((NWK_START_DELAY * (osal_rand() & 0x0F)) +
   1264          //                          (NWK_START_DELAY * 5)) );
   1265                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1266                     + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1267              }
   1268            }
   1269            else if ( devState == DEV_NWK_ORPHAN || devState == DEV_NWK_REJOIN )
   \                     ??ZDApp_ProcessNetworkJoin_1:
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   6404         XRL     A,#0x4
   \   0000CE   6003         JZ      $+5
   \   0000D0   02....       LJMP    ??ZDApp_ProcessNetworkJoin_4 & 0xFFFF
   1270            {
   1271              // results of an orphaning attempt by this device
   1272              if (nwkStatus == ZSuccess)
   \                     ??ZDApp_ProcessNetworkJoin_2:
   \   0000D3   90....       MOV     DPTR,#nwkStatus
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   7033         JNZ     ??ZDApp_ProcessNetworkJoin_16
   1273              {
   1274          #if ( SECURE != 0 )
   1275                ZDApp_RestoreNwkKey();
   1276          #endif
   1277                devState = DEV_END_DEVICE;
   \   0000D9   7406         MOV     A,#0x6
   \   0000DB   12....       LCALL   ?Subroutine0 & 0xFFFF
   1278                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \                     ??CrossCallReturnLabel_53:
   \   0000DE   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1279                // setup Power Manager Device
   1280          #if defined ( POWER_SAVING )
   1281                osal_pwrmgr_device( PWRMGR_BATTERY );
   1282          #endif
   1283          
   1284                if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   \   0000E1   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   A2E3         MOV     C,0xE0 /* A   */.3
   \   0000E7   506F         JNC     ??ZDApp_ProcessNetworkJoin_4
   1285                {
   1286                  // The receiver is on, turn network layer polling off.
   1287                  NLME_SetPollRate( 0 );
   \   0000E9                ; Setup parameters for call to function NLME_SetPollRate
   \   0000E9   7A00         MOV     R2,#0x0
   \   0000EB   7B00         MOV     R3,#0x0
   \   0000ED   90....       MOV     DPTR,#(NLME_SetPollRate & 0xffff)
   \   0000F0   74..         MOV     A,#((NLME_SetPollRate >> 16) & 0xff)
   \   0000F2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1288                  NLME_SetQueuedPollRate( 0 );
   \   0000F5                ; Setup parameters for call to function NLME_SetQueuedPollRate
   \   0000F5   7A00         MOV     R2,#0x0
   \   0000F7   7B00         MOV     R3,#0x0
   \   0000F9   90....       MOV     DPTR,#(NLME_SetQueuedPollRate & 0xffff)
   \   0000FC   74..         MOV     A,#((NLME_SetQueuedPollRate >> 16) & 0xff)
   \   0000FE   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1289                  NLME_SetResponseRate( 0 );
   \   000101                ; Setup parameters for call to function NLME_SetResponseRate
   \   000101   7A00         MOV     R2,#0x0
   \   000103   7B00         MOV     R3,#0x0
   \   000105   90....       MOV     DPTR,#(NLME_SetResponseRate & 0xffff)
   \   000108   74..         MOV     A,#((NLME_SetResponseRate >> 16) & 0xff)
   \   00010A   8049         SJMP    ??CrossCallReturnLabel_60
   1290                }
   1291          
   1292          #if defined ( ZDO_ENDDEVICE_ANNCE_GENERATE )
   1293                ZDP_EndDeviceAnnce( ZDAppNwkAddr.addr.shortAddr, saveExtAddr,
   1294                                   ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
   1295          #endif
   1296          
   1297              }
   1298              else
   1299              {
   1300                if ( (devStartMode == MODE_RESUME) && (++retryCnt >= MAX_RESUME_RETRY) )
   \                     ??ZDApp_ProcessNetworkJoin_16:
   \   00010C   90....       MOV     DPTR,#devStartMode
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   6401         XRL     A,#0x1
   \   000112   7036         JNZ     ??ZDApp_ProcessNetworkJoin_17
   \   000114   90....       MOV     DPTR,#??retryCnt
   \   000117   E0           MOVX    A,@DPTR
   \   000118   04           INC     A
   \   000119   F0           MOVX    @DPTR,A
   \   00011A   602E         JZ      ??ZDApp_ProcessNetworkJoin_17
   1301                {
   1302                  if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   \   00011C   90....       MOV     DPTR,#(_NIB + 33)
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   64FF         XRL     A,#0xff
   \   000122   7004         JNZ     ??ZDApp_ProcessNetworkJoin_18
   \   000124   A3           INC     DPTR
   \   000125   E0           MOVX    A,@DPTR
   \   000126   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_18:
   \   000128   600E         JZ      ??ZDApp_ProcessNetworkJoin_19
   \   00012A   90....       MOV     DPTR,#(_NIB + 33)
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   64FE         XRL     A,#0xfe
   \   000130   7004         JNZ     ??ZDApp_ProcessNetworkJoin_20
   \   000132   A3           INC     DPTR
   \   000133   E0           MOVX    A,@DPTR
   \   000134   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_20:
   \   000136   7006         JNZ     ??ZDApp_ProcessNetworkJoin_21
   1303                    devStartMode = MODE_JOIN;
   \                     ??ZDApp_ProcessNetworkJoin_19:
   \   000138   E4           CLR     A
   \   000139   90....       MOV     DPTR,#devStartMode
   \   00013C   800B         SJMP    ??ZDApp_ProcessNetworkJoin_15
   1304                  else
   1305                  {
   1306                    devStartMode = MODE_REJOIN;
   \                     ??ZDApp_ProcessNetworkJoin_21:
   \   00013E   7403         MOV     A,#0x3
   \   000140   90....       MOV     DPTR,#devStartMode
   \   000143   F0           MOVX    @DPTR,A
   1307                    _tmpRejoinState = true;
   \   000144   7401         MOV     A,#0x1
   \   000146   90....       MOV     DPTR,#_tmpRejoinState
   \                     ??ZDApp_ProcessNetworkJoin_15:
   \   000149   F0           MOVX    @DPTR,A
   1308                  }
   1309                }
   1310          
   1311                // setup a retry for later...
   1312                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1313                     + (osal_rand()& EXTENDED_JOINING_RANDOM_MASK)) );
   \                     ??ZDApp_ProcessNetworkJoin_17:
   \   00014A                ; Setup parameters for call to function ZDApp_NetworkInit
   \   00014A                ; Setup parameters for call to function osal_rand
   \   00014A   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   00014D   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   00014F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000152   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000155   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1314              }
   1315            }
   1316            else
   1317            {
   1318              // this is an error case!!
   1319            }
   1320          }
   \                     ??ZDApp_ProcessNetworkJoin_4:
   \   000158   02....       LJMP    ?Subroutine24 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZMacSetReq
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001                ; Setup parameters for call to function ZDApp_SendMsg
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET
   1321          #endif // !ZDO_COORDINATOR
   1322          
   1323          #if ( SECURE != 0 )
   1324          /*********************************************************************
   1325           * @fn      ZDApp_SaveNwkKey()
   1326           *
   1327           * @brief   Save off the Network key information.
   1328           *
   1329           * @param   none
   1330           *
   1331           * @return  none
   1332           */
   1333          void ZDApp_SaveNwkKey( void )
   1334          {
   1335            nwkActiveKeyItems keyItems;
   1336          
   1337            SSP_ReadNwkActiveKey( &keyItems );
   1338            keyItems.frameCounter++;
   1339          
   1340            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1341                          (void *)&keyItems );
   1342          
   1343            nwkFrameCounterChanges = 0;
   1344          }
   1345          
   1346          /*********************************************************************
   1347           * @fn      ZDApp_ResetNwkKey()
   1348           *
   1349           * @brief   Reset the Network key information in NV.
   1350           *
   1351           * @param   none
   1352           *
   1353           * @return  none
   1354           */
   1355          void ZDApp_ResetNwkKey( void )
   1356          {
   1357            nwkActiveKeyItems keyItems;
   1358          
   1359            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   1360            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1361                          (void *)&keyItems );
   1362          }
   1363          #endif
   1364          
   1365          #if ( SECURE != 0 )
   1366          /*********************************************************************
   1367           * @fn      ZDApp_RestoreNwkKey()
   1368           *
   1369           * @brief
   1370           *
   1371           *   Save off the Network key information.
   1372           *
   1373           * @param   none
   1374           *
   1375           * @return  true if restored from NV, false if not
   1376           */
   1377          byte ZDApp_RestoreNwkKey( void )
   1378          {
   1379            nwkActiveKeyItems keyItems;
   1380            byte ret = false;
   1381          
   1382            if ( osal_nv_read( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), (void*)&keyItems )
   1383                == ZSUCCESS )
   1384            {
   1385              if ( keyItems.frameCounter > 0 )
   1386              {
   1387                // Restore the key information
   1388                keyItems.frameCounter += MAX_NWK_FRAMECOUNTER_CHANGES;
   1389                SSP_WriteNwkActiveKey( &keyItems );
   1390                ret = true;
   1391              }
   1392              nwkFrameCounterChanges = MAX_NWK_FRAMECOUNTER_CHANGES; // Force a save for the first
   1393            }
   1394            return ( ret );
   1395          }
   1396          #endif
   1397          
   1398          /*********************************************************************
   1399           * @fn      ZDApp_SendEndDeviceBindReq()
   1400           *
   1401           * @brief
   1402           *
   1403           *   This function will look up the endpoint description
   1404           *   and send an End Device Bind Request message.
   1405           *
   1406           * @param  endPoint - Endpoint to auto find
   1407           *
   1408           * @return  none
   1409           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1410          void ZDApp_SendEndDeviceBindReq( byte endPoint )
   \                     ZDApp_SendEndDeviceBindReq:
   1411          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   1412          #if defined ( ZDO_ENDDEVICEBIND_REQUEST )
   1413            zAddrType_t dstAddr;
   1414            SimpleDescriptionFormat_t *sDesc;
   1415            byte free;
   1416          #if defined( LCD_SUPPORTED )
   1417             afStatus_t stat;
   1418          #endif
   1419          
   1420            if ( (endPoint == ZDO_EP) || (endPoint > MAX_ENDPOINTS) )
   \   00000C   7003         JNZ     $+5
   \   00000E   02....       LJMP    ??ZDApp_SendEndDeviceBindReq_0 & 0xFFFF
   \   000011   C3           CLR     C
   \   000012   94F1         SUBB    A,#-0xf
   \   000014   4003         JC      $+5
   \   000016   02....       LJMP    ??ZDApp_SendEndDeviceBindReq_0 & 0xFFFF
   1421            {
   1422              return;   // Can't do for ZDO
   1423            }
   1424          
   1425            HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   000019                ; Setup parameters for call to function HalLedSet
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7908         MOV     R1,#0x8
   \   00001D   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000020   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000022   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1426          
   1427            free = afFindSimpleDesc( &sDesc, endPoint );
   \   000025                ; Setup parameters for call to function afFindSimpleDesc
   \   000025   EF           MOV     A,R7
   \   000026   F9           MOV     R1,A
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   90....       MOV     DPTR,#(afFindSimpleDesc & 0xffff)
   \   000034   74..         MOV     A,#((afFindSimpleDesc >> 16) & 0xff)
   \   000036   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000039   E9           MOV     A,R1
   \   00003A   FE           MOV     R6,A
   1428            if ( sDesc != NULL )
   \   00003B   85..82       MOV     DPL,?XSP + 0
   \   00003E   85..83       MOV     DPH,?XSP + 1
   \   000041   E0           MOVX    A,@DPTR
   \   000042   7002         JNZ     ??ZDApp_SendEndDeviceBindReq_1
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \                     ??ZDApp_SendEndDeviceBindReq_1:
   \   000046   7003         JNZ     $+5
   \   000048   02....       LJMP    ??ZDApp_SendEndDeviceBindReq_0 & 0xFFFF
   1429            {
   1430              dstAddr.addrMode = Addr16Bit;
   \   00004B   740A         MOV     A,#0xa
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   7402         MOV     A,#0x2
   \   000052   F0           MOVX    @DPTR,A
   1431              dstAddr.addr.shortAddr = 0;   // Zigbee Coordinator
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   E4           CLR     A
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   F0           MOVX    @DPTR,A
   1432          
   1433          #if defined( LCD_SUPPORTED )
   1434              stat =
   1435          #endif
   1436              ZDP_EndDeviceBindReq( &dstAddr,
   1437          #if defined ( REFLECTOR  )
   1438                          // We have a reflector, so tell the coordinator to send
   1439                          // binding messages this way
   1440                          NLME_GetShortAddr(),
   1441          #else
   1442                          // tell the coordinator to store if available
   1443                          NWK_PAN_COORD_ADDR,
   1444          #endif
   1445                          endPoint,sDesc->AppProfId,
   1446                          sDesc->AppNumOutClusters, sDesc->pAppOutClusterList,
   1447                          sDesc->AppNumInClusters, sDesc->pAppInClusterList,
   1448                          0 );
   \   00005A                ; Setup parameters for call to function ZDP_EndDeviceBindReq
   \   00005A   F5..         MOV     ?V0 + 0,A
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000061   7401         MOV     A,#0x1
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000069   A3           INC     DPTR
   \   00006A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00006D   7403         MOV     A,#0x3
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000075   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000078   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007B   7404         MOV     A,#0x4
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000083   A3           INC     DPTR
   \   000084   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000087   7406         MOV     A,#0x6
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00008F   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000092   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000095   7407         MOV     A,#0x7
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   12....       LCALL   ??Subroutine9_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00009D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000A0   EF           MOV     A,R7
   \   0000A1   F9           MOV     R1,A
   \   0000A2   7C00         MOV     R4,#0x0
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   740B         MOV     A,#0xb
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   90....       MOV     DPTR,#(ZDP_EndDeviceBindReq & 0xffff)
   \   0000B2   74..         MOV     A,#((ZDP_EndDeviceBindReq >> 16) & 0xff)
   \   0000B4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000B7   7409         MOV     A,#0x9
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   1449          
   1450              if ( free )
   \   0000BC   EE           MOV     A,R6
   \   0000BD   6013         JZ      ??ZDApp_SendEndDeviceBindReq_0
   1451              {
   1452                osal_mem_free( sDesc );
   \   0000BF                ; Setup parameters for call to function osal_mem_free
   \   0000BF   85..82       MOV     DPL,?XSP + 0
   \   0000C2   85..83       MOV     DPH,?XSP + 1
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   FA           MOV     R2,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   FB           MOV     R3,A
   \   0000CA   90....       MOV     DPTR,#(osal_mem_free & 0xffff)
   \   0000CD   74..         MOV     A,#((osal_mem_free >> 16) & 0xff)
   \   0000CF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_SendEndDeviceBindReq_0:
   \   0000D2   740B         MOV     A,#0xb
   \   0000D4   02....       LJMP    ?Subroutine25 & 0xFFFF
   1453              }
   1454          
   1455          #if defined( LCD_SUPPORTED )
   1456              if ( stat == ZSuccess )
   1457              {
   1458                HalLcdWriteScreen( "End Device Bind", "Sent" );
   1459              }
   1460              else
   1461              {
   1462                HalLcdWriteScreen( "End Device Bind", "Not Sent" );
   1463              }
   1464          #endif
   1465            }
   1466            else
   1467            {
   1468          #if defined( LCD_SUPPORTED )
   1469              HalLcdWriteScreen( "End Device Bind", "EP not found" );
   1470          #endif
   1471            }
   1472          #endif // ZDO_ENDDEVICEBIND_REQUEST
   1473          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \                     ??Subroutine9_0:
   \   000003   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
   1474          
   1475          /*********************************************************************
   1476           * @fn      ZDApp_AutoFindDestination()
   1477           *
   1478           * @brief
   1479           *
   1480           *   This function will try to find the Input Match for this device's
   1481           *   (endpoint passed in) outputs.
   1482           *
   1483           * @param  endPoint - Endpoint to auto find
   1484           * @param  task_id  - task ID override, if NULL use endpoint desc's
   1485           *                    task_id
   1486           *
   1487           * @return  none
   1488           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1489          void ZDApp_AutoFindDestinationEx( byte endPoint, uint8 *task_id )
   \                     ZDApp_AutoFindDestinationEx:
   1490          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   1491          #if defined ( ZDO_MATCH_REQUEST )
   1492            zAddrType_t dstAddr;
   1493            SimpleDescriptionFormat_t *sDesc;
   1494            endPointDesc_t *tmpDesc;
   1495          #if defined( LCD_SUPPORTED )
   1496            afStatus_t stat;
   1497          #endif
   1498          
   1499            if ( endPoint == ZDO_EP )
   \   000010   7003         JNZ     $+5
   \   000012   02....       LJMP    ??ZDApp_AutoFindDestinationEx_0 & 0xFFFF
   1500              return;   // Can't do for ZDO
   1501          
   1502            HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   000015                ; Setup parameters for call to function HalLedSet
   \   000015   7A00         MOV     R2,#0x0
   \   000017   7908         MOV     R1,#0x8
   \   000019   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   00001C   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   00001E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1503          
   1504            tmpDesc = afFindEndPointDesc( endPoint );
   \   000021                ; Setup parameters for call to function afFindEndPointDesc
   \   000021   EE           MOV     A,R6
   \   000022   F9           MOV     R1,A
   \   000023   90....       MOV     DPTR,#(afFindEndPointDesc & 0xffff)
   \   000026   74..         MOV     A,#((afFindEndPointDesc >> 16) & 0xff)
   \   000028   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00002B   8A..         MOV     ?V0 + 2,R2
   \   00002D   8B..         MOV     ?V0 + 3,R3
   \   00002F   AE..         MOV     R6,?V0 + 2
   \   000031   AF..         MOV     R7,?V0 + 3
   1505            if ( tmpDesc )
   \   000033   EE           MOV     A,R6
   \   000034   7001         JNZ     ??ZDApp_AutoFindDestinationEx_1
   \   000036   EF           MOV     A,R7
   \                     ??ZDApp_AutoFindDestinationEx_1:
   \   000037   7003         JNZ     $+5
   \   000039   02....       LJMP    ??ZDApp_AutoFindDestinationEx_0 & 0xFFFF
   1506            {
   1507              if ( ZDApp_AutoFindMode_epDesc == NULL )
   \   00003C   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   7002         JNZ     ??ZDApp_AutoFindDestinationEx_2
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \                     ??ZDApp_AutoFindDestinationEx_2:
   \   000044   7014         JNZ     ??ZDApp_AutoFindDestinationEx_3
   1508              {
   1509                ZDApp_AutoFindMode_epDesc = (endPointDesc_t *)osal_mem_alloc( sizeof ( endPointDesc_t ) );
   \   000046                ; Setup parameters for call to function osal_mem_alloc
   \   000046   7A06         MOV     R2,#0x6
   \   000048   7B00         MOV     R3,#0x0
   \   00004A   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   00004D   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   00004F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000052   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   000055   EA           MOV     A,R2
   \   000056   F0           MOVX    @DPTR,A
   \   000057   A3           INC     DPTR
   \   000058   EB           MOV     A,R3
   \   000059   F0           MOVX    @DPTR,A
   1510              }
   1511          
   1512              if ( ZDApp_AutoFindMode_epDesc )
   \                     ??ZDApp_AutoFindDestinationEx_3:
   \   00005A   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   7002         JNZ     ??ZDApp_AutoFindDestinationEx_4
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \                     ??ZDApp_AutoFindDestinationEx_4:
   \   000062   7003         JNZ     $+5
   \   000064   02....       LJMP    ??ZDApp_AutoFindDestinationEx_0 & 0xFFFF
   1513              {
   1514                osal_memcpy( ZDApp_AutoFindMode_epDesc, tmpDesc, sizeof( endPointDesc_t ) );
   \   000067                ; Setup parameters for call to function osal_memcpy
   \   000067   8E..         MOV     ?V0 + 4,R6
   \   000069   8F..         MOV     ?V0 + 5,R7
   \   00006B   75..00       MOV     ?V0 + 6,#0x0
   \   00006E   78..         MOV     R0,#?V0 + 4
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000073   7C06         MOV     R4,#0x6
   \   000075   7D00         MOV     R5,#0x0
   \   000077   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FA           MOV     R2,A
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   FB           MOV     R3,A
   \   00007F   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000082   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   000084   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000087   7403         MOV     A,#0x3
   \   000089   12....       LCALL   ?DEALLOC_XSTACK8
   1515                if ( task_id )
   \   00008C   E5..         MOV     A,?V0 + 0
   \   00008E   7002         JNZ     ??ZDApp_AutoFindDestinationEx_5
   \   000090   E5..         MOV     A,?V0 + 1
   \                     ??ZDApp_AutoFindDestinationEx_5:
   \   000092   600A         JZ      ??ZDApp_AutoFindDestinationEx_6
   1516                {
   1517                  // Override the Task ID, if needed.
   1518                  ZDApp_AutoFindMode_epDesc->task_id = task_id;
   \   000094   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000097   E5..         MOV     A,?V0 + 0
   \   000099   F0           MOVX    @DPTR,A
   \   00009A   A3           INC     DPTR
   \   00009B   E5..         MOV     A,?V0 + 1
   \   00009D   F0           MOVX    @DPTR,A
   1519                }
   1520          
   1521                sDesc = ZDApp_AutoFindMode_epDesc->simpleDesc;
   \                     ??ZDApp_AutoFindDestinationEx_6:
   \   00009E   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F8           MOV     R0,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F9           MOV     R1,A
   \   0000A8   E8           MOV     A,R0
   \   0000A9   FA           MOV     R2,A
   \   0000AA   E9           MOV     A,R1
   \   0000AB   FB           MOV     R3,A
   1522          
   1523                // This message is sent to everyone
   1524                dstAddr.addrMode = AddrBroadcast;
   \   0000AC   7408         MOV     A,#0x8
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   740F         MOV     A,#0xf
   \   0000B3   12....       LCALL   ?Subroutine1 & 0xFFFF
   1525                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
   \                     ??CrossCallReturnLabel_1:
   \   0000B6   74FF         MOV     A,#-0x1
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   F0           MOVX    @DPTR,A
   1526          
   1527            #if defined( LCD_SUPPORTED )
   1528                stat =
   1529            #endif
   1530                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR, sDesc->AppProfId,
   1531                                  sDesc->AppNumOutClusters, sDesc->pAppOutClusterList,
   1532                                  sDesc->AppNumInClusters, sDesc->pAppInClusterList, 0 );
   \   0000BB                ; Setup parameters for call to function ZDP_MatchDescReq
   \   0000BB   75..00       MOV     ?V0 + 0,#0x0
   \   0000BE   78..         MOV     R0,#?V0 + 0
   \   0000C0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C3   8A82         MOV     DPL,R2
   \   0000C5   8B83         MOV     DPH,R3
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D1   8A82         MOV     DPL,R2
   \   0000D3   8B83         MOV     DPH,R3
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0000DE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E1   8A82         MOV     DPL,R2
   \   0000E3   8B83         MOV     DPH,R3
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000F2   8A82         MOV     DPL,R2
   \   0000F4   8B83         MOV     DPH,R3
   \   0000F6   A3           INC     DPTR
   \   0000F7   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000FA   8A82         MOV     DPL,R2
   \   0000FC   8B83         MOV     DPH,R3
   \   0000FE   A3           INC     DPTR
   \   0000FF   A3           INC     DPTR
   \   000100   A3           INC     DPTR
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   A3           INC     DPTR
   \   000105   A3           INC     DPTR
   \   000106   A3           INC     DPTR
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F9           MOV     R1,A
   \   000109   7CFF         MOV     R4,#-0x1
   \   00010B   7DFF         MOV     R5,#-0x1
   \   00010D   7408         MOV     A,#0x8
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   AA82         MOV     R2,DPL
   \   000114   AB83         MOV     R3,DPH
   \   000116   90....       MOV     DPTR,#(ZDP_MatchDescReq & 0xffff)
   \   000119   74..         MOV     A,#((ZDP_MatchDescReq >> 16) & 0xff)
   \   00011B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00011E   7408         MOV     A,#0x8
   \   000120   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??ZDApp_AutoFindDestinationEx_0:
   \   000123   7409         MOV     A,#0x9
   \   000125   12....       LCALL   ?DEALLOC_XSTACK8
   \   000128   7F07         MOV     R7,#0x7
   \   00012A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1533          
   1534            #if defined( LCD_SUPPORTED )
   1535                if ( stat == ZSuccess )
   1536                {
   1537                  HalLcdWriteScreen( "Auto Find", "Sent" );
   1538                  MatchRsps = 0;
   1539                }
   1540                else
   1541                {
   1542                  HalLcdWriteScreen( "Auto Find", "Not Sent" );
   1543                }
   1544            #endif
   1545              }
   1546            }
   1547            else
   1548            {
   1549          #if defined( LCD_SUPPORTED )
   1550              HalLcdWriteScreen( "Auto Find", "EP not found" );
   1551          #endif
   1552            }
   1553          #endif // ZDO_MATCH_REQUEST
   1554          }
   1555          
   1556          /*********************************************************************
   1557           * @fn      ZDApp_ResetTimerStart
   1558           *
   1559           * @brief   Start the reset timer.
   1560           *
   1561           * @param   delay - delay time(ms) before reset
   1562           *
   1563           * @return  none
   1564           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1565          void ZDApp_ResetTimerStart( uint16 delay )
   \                     ZDApp_ResetTimerStart:
   1566          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1567            // Start the rest timer
   1568            osal_start_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET, delay );
   \   000004                ; Setup parameters for call to function osal_start_timerEx
   \   000004   EA           MOV     A,R2
   \   000005   FC           MOV     R4,A
   \   000006   EB           MOV     A,R3
   \   000007   FD           MOV     R5,A
   \   000008   7A04         MOV     R2,#0x4
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00000F   02....       LJMP    ??Subroutine29_0 & 0xFFFF
   1569          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7C64         MOV     R4,#0x64
   \   000002   7D00         MOV     R5,#0x0
   \                     ??Subroutine5_0:
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7B02         MOV     R3,#0x2
   \                     ??Subroutine5_1:
   \   000008   90....       MOV     DPTR,#ZDAppTaskID
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   90....       MOV     DPTR,#(osal_start_timerEx & 0xffff)
   \   000010   74..         MOV     A,#((osal_start_timerEx >> 16) & 0xff)
   \   000012   22           RET
   1570          
   1571          /*********************************************************************
   1572           * @fn      ZDApp_ResetTimerCancel
   1573           *
   1574           * @brief   Cancel the reset timer.
   1575           *
   1576           * @param   none
   1577           *
   1578           * @return  none
   1579           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1580          void ZDApp_ResetTimerCancel( void )
   \                     ZDApp_ResetTimerCancel:
   1581          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1582            // Cancel the reset timer
   1583            osal_stop_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET );
   \   000004                ; Setup parameters for call to function osal_stop_timerEx
   \   000004   7A04         MOV     R2,#0x4
   \   000006   7B00         MOV     R3,#0x0
   \   000008   90....       MOV     DPTR,#ZDAppTaskID
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   90....       MOV     DPTR,#(osal_stop_timerEx & 0xffff)
   \   000010   74..         MOV     A,#((osal_stop_timerEx >> 16) & 0xff)
   \   000012   02....       LJMP    ??Subroutine29_0 & 0xFFFF
   1584          }
   1585          
   1586          /*********************************************************************
   1587           * @fn      ZDApp_LeaveCtrlInit
   1588           *
   1589           * @brief   Initialize the leave control logic.
   1590           *
   1591           * @param   none
   1592           *
   1593           * @return  none
   1594           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1595          void ZDApp_LeaveCtrlInit( void )
   \                     ZDApp_LeaveCtrlInit:
   1596          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1597            uint8 status;
   1598          
   1599          
   1600            // Initialize control state
   1601            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   \   000005   12....       LCALL   ?Subroutine3 & 0xFFFF
   1602          
   1603            status = osal_nv_item_init( ZCD_NV_LEAVE_CTRL,
   1604                                        sizeof(ZDApp_LeaveCtrl),
   1605                                        &ZDApp_LeaveCtrl );
   1606          
   1607            if ( status == ZSUCCESS )
   \                     ??CrossCallReturnLabel_4:
   \   000008   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000B   7C01         MOV     R4,#0x1
   \   00000D   7D00         MOV     R5,#0x0
   \   00000F   7A85         MOV     R2,#-0x7b
   \   000011   7B00         MOV     R3,#0x0
   \   000013   90....       MOV     DPTR,#(osal_nv_item_init & 0xffff)
   \   000016   74..         MOV     A,#((osal_nv_item_init >> 16) & 0xff)
   \   000018   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000020   E9           MOV     A,R1
   \   000021   7025         JNZ     ??ZDApp_LeaveCtrlInit_0
   1608            {
   1609              // Read saved control
   1610              osal_nv_read( ZCD_NV_LEAVE_CTRL,
   1611                            0,
   1612                            sizeof( uint8 ),
   1613                            &ZDApp_LeaveCtrl);
   \   000023                ; Setup parameters for call to function osal_nv_read
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   75..01       MOV     ?V0 + 0,#0x1
   \   00002B   75..00       MOV     ?V0 + 1,#0x0
   \   00002E   78..         MOV     R0,#?V0 + 0
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   7C00         MOV     R4,#0x0
   \   000035   7D00         MOV     R5,#0x0
   \   000037   7A85         MOV     R2,#-0x7b
   \   000039   7B00         MOV     R3,#0x0
   \   00003B   90....       MOV     DPTR,#(osal_nv_read & 0xffff)
   \   00003E   74..         MOV     A,#((osal_nv_read >> 16) & 0xff)
   \   000040   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000043   7404         MOV     A,#0x4
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   1614            }
   1615          }
   \                     ??ZDApp_LeaveCtrlInit_0:
   \   000048   80..         SJMP    ??Subroutine24_1

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E4           CLR     A
   \   000001   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005                ; Setup parameters for call to function osal_nv_write
   \   000005   75....       MOV     ?V0 + 0,#(ZDApp_LeaveCtrl & 0xff)
   \   000008   75....       MOV     ?V0 + 1,#((ZDApp_LeaveCtrl >> 8) & 0xff)
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   22           RET
   1616          
   1617          /*********************************************************************
   1618           * @fn      ZDApp_LeaveCtrlSet
   1619           *
   1620           * @brief   Set the leave control logic.
   1621           *
   1622           * @param   ra - reassociate flag
   1623           *
   1624           * @return  none
   1625           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1626          void ZDApp_LeaveCtrlSet( uint8 ra )
   \                     ZDApp_LeaveCtrlSet:
   1627          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1628            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_SET;
   \   000005   7401         MOV     A,#0x1
   \   000007   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   00000A   F0           MOVX    @DPTR,A
   1629          
   1630            if ( ra == TRUE )
   \   00000B   69           XRL     A,R1
   \   00000C   7003         JNZ     ??ZDApp_LeaveCtrlSet_0
   1631            {
   1632              ZDApp_LeaveCtrl |= ZDAPP_LEAVE_CTRL_RA;
   \   00000E   7403         MOV     A,#0x3
   \   000010   F0           MOVX    @DPTR,A
   1633            }
   1634          
   1635            // Write the leave control
   1636            osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1637                           0,
   1638                           sizeof( uint8 ),
   1639                           &ZDApp_LeaveCtrl);
   \                     ??ZDApp_LeaveCtrlSet_0:
   \   000011                ; Setup parameters for call to function osal_nv_write
   \   000011   75....       MOV     ?V0 + 0,#(ZDApp_LeaveCtrl & 0xff)
   \   000014   75....       MOV     ?V0 + 1,#((ZDApp_LeaveCtrl >> 8) & 0xff)
   \   000017   78..         MOV     R0,#?V0 + 0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   75..01       MOV     ?V0 + 0,#0x1
   \   00001F   75..00       MOV     ?V0 + 1,#0x0
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   7C00         MOV     R4,#0x0
   \   000029   7D00         MOV     R5,#0x0
   \   00002B   7A85         MOV     R2,#-0x7b
   \   00002D   7B00         MOV     R3,#0x0
   \   00002F   90....       MOV     DPTR,#(osal_nv_write & 0xffff)
   \   000032   74..         MOV     A,#((osal_nv_write >> 16) & 0xff)
   \   000034   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000037   7404         MOV     A,#0x4
   \   000039   80..         SJMP    ??Subroutine24_0
   1640          }
   1641          
   1642          /*********************************************************************
   1643           * @fn      ZDApp_LeaveCtrlBypass
   1644           *
   1645           * @brief   Check if NV restore should be skipped during a leave reset.
   1646           *
   1647           * @param   none
   1648           *
   1649           * @return  uint8 - (TRUE bypass:FALSE do not bypass)
   1650           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1651          uint8 ZDApp_LeaveCtrlBypass( void )
   \                     ZDApp_LeaveCtrlBypass:
   1652          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1653            uint8 bypass;
   1654          
   1655            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   1656            {
   1657              bypass = TRUE;
   1658            }
   1659            else
   1660            {
   1661              bypass = FALSE;
   1662            }
   1663          
   1664            return bypass;
   \   000004   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   000007   E0           MOVX    A,@DPTR
   \   000008   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000A   E4           CLR     A
   \   00000B   92E0         MOV     0xE0 /* A   */.0,C
   \   00000D   F9           MOV     R1,A
   \   00000E   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   1665          }
   1666          
   1667          /*********************************************************************
   1668           * @fn      ZDApp_LeaveCtrlStartup
   1669           *
   1670           * @brief   Check for startup conditions during a leave reset.
   1671           *
   1672           * @param   state      - devState_t determined by leave control logic
   1673           * @param   startDelay - startup delay
   1674           *
   1675           * @return  none
   1676           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1677          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay )
   \                     ZDApp_LeaveCtrlStartup:
   1678          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1679            *startDelay = 0;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   1680          
   1681            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   \   00000D   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   000010   E0           MOVX    A,@DPTR
   \   000011   A2E0         MOV     C,0xE0 /* A   */.0
   \   000013   503C         JNC     ??ZDApp_LeaveCtrlStartup_0
   1682            {
   1683              if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_RA )
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   500C         JNC     ??ZDApp_LeaveCtrlStartup_1
   1684              {
   1685                *startDelay = 5000;
   \   000019   8C82         MOV     DPL,R4
   \   00001B   8D83         MOV     DPH,R5
   \   00001D   7488         MOV     A,#-0x78
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   7413         MOV     A,#0x13
   \   000023   8005         SJMP    ??ZDApp_LeaveCtrlStartup_2
   1686              }
   1687              else
   1688              {
   1689                *state = DEV_HOLD;
   \                     ??ZDApp_LeaveCtrlStartup_1:
   \   000025   E4           CLR     A
   \   000026   8A82         MOV     DPL,R2
   \   000028   8B83         MOV     DPH,R3
   \                     ??ZDApp_LeaveCtrlStartup_2:
   \   00002A   F0           MOVX    @DPTR,A
   1690              }
   1691          
   1692              // Set leave control to initialized state
   1693              ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   \   00002B   12....       LCALL   ?Subroutine3 & 0xFFFF
   1694          
   1695              // Write initialized control
   1696              osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1697                            0,
   1698                            sizeof( uint8 ),
   1699                            &ZDApp_LeaveCtrl);
   \                     ??CrossCallReturnLabel_5:
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   75..01       MOV     ?V0 + 0,#0x1
   \   000034   75..00       MOV     ?V0 + 1,#0x0
   \   000037   78..         MOV     R0,#?V0 + 0
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   7C00         MOV     R4,#0x0
   \   00003E   7D00         MOV     R5,#0x0
   \   000040   7A85         MOV     R2,#-0x7b
   \   000042   7B00         MOV     R3,#0x0
   \   000044   90....       MOV     DPTR,#(osal_nv_write & 0xffff)
   \   000047   74..         MOV     A,#((osal_nv_write >> 16) & 0xff)
   \   000049   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00004C   7404         MOV     A,#0x4
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   1700            }
   1701          }
   \                     ??ZDApp_LeaveCtrlStartup_0:
   \   000051   02....       LJMP    ??Subroutine24_1 & 0xFFFF
   1702          
   1703          /*********************************************************************
   1704           * @fn      ZDApp_LeaveReset
   1705           *
   1706           * @brief   Setup a device reset due to a leave indication/confirm.
   1707           *
   1708           * @param   ra - reassociate flag
   1709           *
   1710           * @return  none
   1711           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1712          void ZDApp_LeaveReset( uint8 ra )
   \                     ZDApp_LeaveReset:
   1713          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1714            ZDApp_LeaveCtrlSet( ra );
   \   000004                ; Setup parameters for call to function ZDApp_LeaveCtrlSet
   \   000004   90....       MOV     DPTR,#(ZDApp_LeaveCtrlSet & 0xffff)
   \   000007   74..         MOV     A,#((ZDApp_LeaveCtrlSet >> 16) & 0xff)
   \   000009   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1715          
   1716            ZDApp_ResetTimerStart( 5000 );
   \   00000C                ; Setup parameters for call to function ZDApp_ResetTimerStart
   \   00000C   7A88         MOV     R2,#-0x78
   \   00000E   7B13         MOV     R3,#0x13
   \   000010   90....       MOV     DPTR,#(ZDApp_ResetTimerStart & 0xffff)
   \   000013   74..         MOV     A,#((ZDApp_ResetTimerStart >> 16) & 0xff)
   \   000015   80..         SJMP    ??Subroutine29_0
   1717          }
   1718          
   1719          /*********************************************************************
   1720           * @fn      ZDApp_LeaveUpdate
   1721           *
   1722           * @brief   Update local device data related to leaving device.
   1723           *
   1724           * @param   nwkAddr        - NWK address of leaving device
   1725           * @param   extAddr        - EXT address of leaving device
   1726           * @param   removeChildren - remove children of leaving device
   1727           *
   1728           * @return  none
   1729           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1730          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
   \                     ZDApp_LeaveUpdate:
   1731                                  uint8 removeChildren )
   1732          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EC           MOV     A,R4
   \   000005   FA           MOV     R2,A
   \   000006   ED           MOV     A,R5
   \   000007   FB           MOV     R3,A
   1733            /*
   1734            AddrMgrEntry_t entry;
   1735            */
   1736          
   1737          
   1738            // Remove if child
   1739            NLME_RemoveChild( extAddr, removeChildren );
   \   000008                ; Setup parameters for call to function NLME_RemoveChild
   \   000008   90....       MOV     DPTR,#(NLME_RemoveChild & 0xffff)
   \   00000B   74..         MOV     A,#((NLME_RemoveChild >> 16) & 0xff)
   \   00000D   80..         SJMP    ??Subroutine29_0
   1740          
   1741            /*
   1742            // Set NWK address to invalid
   1743            entry.user    = ADDRMGR_USER_DEFAULT;
   1744            entry.nwkAddr = INVALID_NODE_ADDR;
   1745            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   1746            AddrMgrEntryUpdate( &entry );
   1747          
   1748            // Check
   1749            if ( removeChildren == TRUE )
   1750            {
   1751              // Set index to INVALID_NODE_ADDR to start search
   1752              entry.index = INVALID_NODE_ADDR;
   1753          
   1754              // Get first entry
   1755              AddrMgrEntryGetNext( &entry );
   1756          
   1757              // Remove all descendents
   1758              while ( entry.index != INVALID_NODE_ADDR )
   1759              {
   1760                // Check NWK address allocation algorithm
   1761                if ( RTG_ANCESTOR( entry.nwkAddr, thisAddr ) != 0 )
   1762                {
   1763                  // Set NWK address to invalid
   1764                  entry.nwkAddr = INVALID_NODE_ADDR;
   1765                  AddrMgrEntryUpdate( &entry );
   1766                }
   1767          
   1768                // Get next entry
   1769                AddrMgrEntryGetNext( &entry );
   1770              }
   1771            }
   1772            */
   1773          }
   1774          
   1775          /*********************************************************************
   1776           * CALLBACK FUNCTIONS
   1777           */
   1778          
   1779          #if defined ( ZDO_COORDINATOR )
   1780          /*********************************************************************
   1781           * @fn      ZDApp_EndDeviceBindReqCB()
   1782           *
   1783           * @brief
   1784           *
   1785           *   Called by ZDO when an End Device Bind Request message is received.
   1786           *
   1787           * @param  bindReq  - binding request information
   1788           * @param  SecurityUse - Security enable/disable
   1789           *
   1790           * @return  none
   1791           */
   1792          void ZDApp_EndDeviceBindReqCB( ZDEndDeviceBind_t *bindReq )
   1793          {
   1794          #if defined ( COORDINATOR_BINDING )
   1795            if ( bindReq->localCoordinator == 0x0000 )
   1796            {
   1797              ZDO_DoEndDeviceBind( bindReq );
   1798            }
   1799            else
   1800          #endif // COORDINATOR_BINDING
   1801            {
   1802              ZDO_MatchEndDeviceBind( bindReq );
   1803            }
   1804          #if defined( LCD_SUPPORTED )
   1805            HalLcdWriteScreen( "End Device Bind", "Rcvd" );
   1806          #endif
   1807          }
   1808          #endif // ZDO_COORDINATOR
   1809          
   1810          #if !defined ( REFLECTOR ) && defined ( ZDO_BIND_UNBIND_RESPONSE )
   1811          /*********************************************************************
   1812           * @fn      ZDApp_AppBindReq()
   1813           *
   1814           * @brief
   1815           *
   1816           *   Called to send an App Bind Request message.
   1817           *
   1818           * @param  SrcAddr     - Source address ( who sent the message )
   1819           * @param  SrcAddress  - Source Address (64 bit)
   1820           * @param  SrcEndPoint - Source endpoint
   1821           * @param  ClusterID   - Cluster ID
   1822           * @param  DstAddress  - Destination Address (64 bit)
   1823           * @param  DstEndPoint - Destination endpoint
   1824           * @param  SecurityUse - Security enable/disable
   1825           *
   1826           * @return  none
   1827           */
   1828          void ZDApp_AppBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
   1829                                byte SrcEndPoint, cId_t ClusterID, byte *DstAddress,
   1830                                byte DstEndPoint, byte SecurityUse, uint8 Type )
   1831          {
   1832            ZDO_BindReq_t *pBindReq;
   1833          
   1834            if ( ZDApp_BindReq_TaskID )
   1835            {
   1836              // Send the IEEE Address response structure to the registered task
   1837              pBindReq = (ZDO_BindReq_t *)osal_msg_allocate( sizeof( ZDO_BindReq_t ) );
   1838              if ( pBindReq )
   1839              {
   1840                pBindReq->event_hdr.event = Type;
   1841          
   1842                // Build the structure
   1843                pBindReq->hdr.srcAddr = SrcAddr->addr.shortAddr;
   1844                pBindReq->hdr.transSeq = TransSeq;
   1845                pBindReq->hdr.SecurityUse = SecurityUse;
   1846          
   1847                osal_cpyExtAddr( pBindReq->srcAddr, SrcAddress );
   1848                pBindReq->srcEP = SrcEndPoint;
   1849                pBindReq->clusterID = ClusterID;
   1850                osal_cpyExtAddr( pBindReq->dstAddr, DstAddress );
   1851                pBindReq->dstEP = DstEndPoint;
   1852          
   1853                osal_msg_send( ZDApp_BindReq_TaskID, (uint8 *)pBindReq );
   1854              }
   1855            }
   1856          }
   1857          #endif // !REFLECTOR && ZDO_BIND_UNBIND_RESPONSE
   1858          
   1859          #if defined ( REFLECTOR ) || defined ( ZDO_BIND_UNBIND_RESPONSE )
   1860          /*********************************************************************
   1861           * @fn      ZDApp_BindReqCB()
   1862           *
   1863           * @brief
   1864           *
   1865           *   Called by ZDO when a Bind Request message is received.
   1866           *
   1867           * @param  SrcAddr     - Source address ( who sent the message )
   1868           * @param  SrcAddress  - Source Address (64 bit)
   1869           * @param  SrcEndPoint - Source endpoint
   1870           * @param  ClusterID   - Cluster ID
   1871           * @param  DstAddress  - Destination Address (64 bit)
   1872           * @param  DstEndPoint - Destination endpoint
   1873           * @param  SecurityUse - Security enable/disable
   1874           *
   1875           * @return  none
   1876           */
   1877          void ZDApp_BindReqCB( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
   1878                                byte SrcEndPoint, cId_t ClusterID, zAddrType_t *DstAddress,
   1879                                byte DstEndPoint, byte SecurityUse )
   1880          {
   1881          #if defined ( REFLECTOR )
   1882            zAddrType_t SourceAddr;       // Binding Source addres
   1883            byte bindStat;
   1884          
   1885            SourceAddr.addrMode = Addr64Bit;
   1886            osal_cpyExtAddr( SourceAddr.addr.extAddr, SrcAddress );
   1887          
   1888            if ( DstAddress->addrMode != Addr64Bit &&
   1889                   DstAddress->addrMode != AddrGroup )
   1890            {
   1891              bindStat = ZDP_NOT_SUPPORTED;
   1892            }
   1893          
   1894            else
   1895            { // Check source endpoints
   1896              if ( SrcEndPoint == 0 || SrcEndPoint > MAX_ENDPOINTS )
   1897              {
   1898                bindStat = ZDP_INVALID_EP;
   1899              }
   1900              // Check the destination endpoints for ext address mode
   1901              else if ( ( DstAddress->addrMode == Addr64Bit ) &&
   1902                      ( DstEndPoint == 0 || DstEndPoint > MAX_ENDPOINTS ) )
   1903              {
   1904                bindStat = ZDP_INVALID_EP;
   1905              }
   1906          
   1907              else
   1908              {
   1909          #if defined ( ZDO_NWKADDR_REQUEST )
   1910                {
   1911                  uint16 nwkAddr;
   1912          
   1913                  // Check for the source address
   1914                  if ( APSME_LookupNwkAddr( SrcAddress, &nwkAddr ) == FALSE )
   1915                  {
   1916                    ZDP_NwkAddrReq( SrcAddress, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   1917                  }
   1918          
   1919                  // Check for the destination address
   1920                  if ( DstAddress->addrMode == Addr64Bit )
   1921                  {
   1922                    if ( APSME_LookupNwkAddr( DstAddress->addr.extAddr, &nwkAddr ) == FALSE )
   1923                    {
   1924                      ZDP_NwkAddrReq( DstAddress->addr.extAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   1925                    }
   1926                  }
   1927                }
   1928          #endif
   1929          
   1930                if ( APSME_BindRequest( &SourceAddr, SrcEndPoint, ClusterID,
   1931                               DstAddress, DstEndPoint ) == ZSuccess )
   1932                {
   1933                  bindStat = ZDP_SUCCESS;
   1934                  // Notify to save info into NV
   1935                  osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
   1936                }
   1937                else
   1938                  bindStat = ZDP_TABLE_FULL;
   1939              }
   1940            }
   1941            // Send back a response message
   1942            ZDP_BindRsp( TransSeq, SrcAddr, bindStat, SecurityUse );
   1943          
   1944          #else  // must be ZDO_BIND_UNBIND_RESPONSE
   1945          
   1946            ZDApp_AppBindReq( TransSeq, SrcAddr, SrcAddress, SrcEndPoint, ClusterID,
   1947                              DstAddress->addr.extAddr, DstEndPoint, SecurityUse, ZDO_BIND_REQUEST );
   1948          
   1949          #endif // REFLECTOR
   1950          }
   1951          #endif // REFLECTOR OR ZDO_BIND_UNBIND_RESPONSE
   1952          
   1953          #if defined ( REFLECTOR ) || defined ( ZDO_BIND_UNBIND_RESPONSE )
   1954          /*********************************************************************
   1955           * @fn      ZDApp_UnbindReqCB()
   1956           *
   1957           * @brief
   1958           *
   1959           *   Called by ZDO when an Unbind Request message is received.
   1960           *
   1961           * @param  SrcAddr  - Source address
   1962           * @param  SrcAddress - Source Address (64 bit)
   1963           * @param  SrcEndPoint - Source endpoint
   1964           * @param  ClusterID - Cluster ID
   1965           * @param  DstAddress - Destination Address (64 bit)
   1966           * @param  DstEndPoint - Destination endpoint
   1967           * @param  SecurityUse - Security enable/disable
   1968           *
   1969           * @return  none
   1970           */
   1971          void ZDApp_UnbindReqCB( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
   1972                                  byte SrcEndPoint, cId_t ClusterID, zAddrType_t *DstAddress,
   1973                                  byte DstEndPoint, byte SecurityUse )
   1974          {
   1975          #if defined ( REFLECTOR )
   1976            zAddrType_t SourceAddr;       // Binding Source addres
   1977            byte bindStat;
   1978          
   1979            SourceAddr.addrMode = Addr64Bit;
   1980            osal_cpyExtAddr( SourceAddr.addr.extAddr, SrcAddress );
   1981          
   1982            // Check endpoints
   1983            if ( SrcEndPoint == 0 || SrcEndPoint > MAX_ENDPOINTS ||
   1984                 DstEndPoint == 0 || DstEndPoint > MAX_ENDPOINTS )
   1985            {
   1986              bindStat = ZDP_INVALID_EP;
   1987            }
   1988          
   1989            else
   1990            {
   1991              if ( APSME_UnBindRequest( &SourceAddr, SrcEndPoint, ClusterID,
   1992                                       DstAddress, DstEndPoint ) == ZSuccess )
   1993              {
   1994                bindStat = ZDP_SUCCESS;
   1995          
   1996                // Notify to save info into NV
   1997                osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
   1998              }
   1999              else
   2000                bindStat = ZDP_NO_ENTRY;
   2001            }
   2002          
   2003            // Send back a response message
   2004            ZDP_UnbindRsp( TransSeq, SrcAddr, bindStat, SecurityUse );
   2005          
   2006          #else // Must be ZDO_BIND_UNBIND_RESPONSE
   2007          
   2008            ZDApp_AppBindReq( TransSeq, SrcAddr, SrcAddress, SrcEndPoint, ClusterID,
   2009                              DstAddress->addr.extAddr, DstEndPoint, SecurityUse, ZDO_UNBIND_REQUEST );
   2010          
   2011          #endif // ZDO_BIND_UNBIND_RESPONSE
   2012          }
   2013          #endif // REFLECTOR OR ZDO_BIND_UNBIND_RESPONSE
   2014          
   2015          /*********************************************************************
   2016           * @fn      ZDApp_SendNewDstAddr()
   2017           *
   2018           * @brief
   2019           *
   2020           *   Used to send an OSAL message to an application that contains a
   2021           *   new destination address
   2022           *
   2023           * @param  dstEP  - Destination endpoint
   2024           * @param  dstAddr - response status
   2025           * @param  clusterID - relavent cluster for this dst address
   2026           * @param  removeFlag - false if add, true to remove
   2027           * @param  task_id - What task to send it to
   2028           * @param  endpoint - who the new address is for
   2029           *
   2030           * @return  none
   2031           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2032          void ZDApp_SendNewDstAddr( byte dstEP, zAddrType_t *dstAddr,
   \                     ZDApp_SendNewDstAddr:
   2033                             cId_t clusterID, byte removeFlag, byte task_id, byte endpoint )
   2034          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 2,R1
   \   000017   EC           MOV     A,R4
   \   000018   FE           MOV     R6,A
   \   000019   ED           MOV     A,R5
   \   00001A   FF           MOV     R7,A
   \   00001B   7412         MOV     A,#0x12
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 7,A
   \   000023   7413         MOV     A,#0x13
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 3,A
   \   00002B   7414         MOV     A,#0x14
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F5..         MOV     ?V0 + 6,A
   2035            byte bufLen;
   2036            ZDO_NewDstAddr_t *msgPtr;
   2037          
   2038            // Send the address to the task
   2039            bufLen = sizeof(ZDO_NewDstAddr_t);
   2040          
   2041            msgPtr = (ZDO_NewDstAddr_t *)osal_msg_allocate( bufLen );
   \   000033                ; Setup parameters for call to function osal_msg_allocate
   \   000033   7A10         MOV     R2,#0x10
   \   000035   7B00         MOV     R3,#0x0
   \   000037   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   00003A   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   00003C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00003F   8A..         MOV     ?V0 + 4,R2
   \   000041   8B..         MOV     ?V0 + 5,R3
   2042            if ( msgPtr )
   \   000043   EA           MOV     A,R2
   \   000044   7001         JNZ     ??ZDApp_SendNewDstAddr_0
   \   000046   EB           MOV     A,R3
   \                     ??ZDApp_SendNewDstAddr_0:
   \   000047   6067         JZ      ??ZDApp_SendNewDstAddr_1
   2043            {
   2044              msgPtr->hdr.event = ZDO_NEW_DSTADDR;
   \   000049   74D0         MOV     A,#-0x30
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   8B83         MOV     DPH,R3
   \   00004F   F0           MOVX    @DPTR,A
   2045              msgPtr->dstAddrDstEP = dstEP;
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   E5..         MOV     A,?V0 + 2
   \   000054   12....       LCALL   ?Subroutine1 & 0xFFFF
   2046              osal_memcpy(&msgPtr->dstAddr, dstAddr, sizeof( zAddrType_t ) );
   \                     ??CrossCallReturnLabel_2:
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F5..         MOV     ?V0 + 0,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F5..         MOV     ?V0 + 1,A
   \   00005E   75..00       MOV     ?V0 + 2,#0x0
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000066   7C09         MOV     R4,#0x9
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   EA           MOV     A,R2
   \   00006B   2403         ADD     A,#0x3
   \   00006D   0A           INC     R2
   \   00006E   0A           INC     R2
   \   00006F   0A           INC     R2
   \   000070   EB           MOV     A,R3
   \   000071   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000074   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   2047              msgPtr->dstAddrClusterIDLSB = LO_UINT16( clusterID );
   \   00007C   E5..         MOV     A,?V0 + 4
   \   00007E   240C         ADD     A,#0xc
   \   000080   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000083   EE           MOV     A,R6
   \   000084   F0           MOVX    @DPTR,A
   2048              msgPtr->dstAddrClusterIDMSB = HI_UINT16( clusterID );
   \   000085   E5..         MOV     A,?V0 + 4
   \   000087   240D         ADD     A,#0xd
   \   000089   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00008C   EF           MOV     A,R7
   \   00008D   F0           MOVX    @DPTR,A
   2049              msgPtr->dstAddrRemove = removeFlag;
   \   00008E   E5..         MOV     A,?V0 + 4
   \   000090   240E         ADD     A,#0xe
   \   000092   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000095   E5..         MOV     A,?V0 + 7
   \   000097   F0           MOVX    @DPTR,A
   2050              msgPtr->dstAddrEP = endpoint;
   \   000098   E5..         MOV     A,?V0 + 4
   \   00009A   240F         ADD     A,#0xf
   \   00009C   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00009F   E5..         MOV     A,?V0 + 6
   \   0000A1   F0           MOVX    @DPTR,A
   2051          
   2052              osal_msg_send( task_id, (uint8 *)msgPtr );
   \   0000A2                ; Setup parameters for call to function osal_msg_send
   \   0000A2   AA..         MOV     R2,?V0 + 4
   \   0000A4   AB..         MOV     R3,?V0 + 5
   \   0000A6   A9..         MOV     R1,?V0 + 3
   \   0000A8   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   0000AB   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   0000AD   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2053            }
   2054          }
   \                     ??ZDApp_SendNewDstAddr_1:
   \   0000B0   7402         MOV     A,#0x2
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5                REQUIRE ?Subroutine28
   \   0000B5                ; // Fall through to label ?Subroutine28

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FB           MOV     R3,A
   \   000003   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000006   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   F582         MOV     DPL,A
   \   000002   E5..         MOV     A,?V0 + 5
   \                     ??Subroutine16_0:
   \   000004   3400         ADDC    A,#0x0
   \   000006   F583         MOV     DPH,A
   \   000008   22           RET
   2055          
   2056          /*********************************************************************
   2057           * @fn      ZDApp_SendEventMsg()
   2058           *
   2059           * @brief
   2060           *
   2061           *   Sends a Network Join message
   2062           *
   2063           * @param  cmd - command ID
   2064           * @param  len - length (in bytes) of the buf field
   2065           * @param  buf - buffer for the rest of the message.
   2066           *
   2067           * @return  none
   2068           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2069          void ZDApp_SendEventMsg( byte cmd, byte len, byte *buf )
   \                     ZDApp_SendEventMsg:
   2070          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2071            ZDApp_SendMsg( ZDAppTaskID, cmd, len, buf );
   \   000004                ; Setup parameters for call to function ZDApp_SendMsg
   \   000004   EA           MOV     A,R2
   \   000005   FB           MOV     R3,A
   \   000006   E9           MOV     A,R1
   \   000007   FA           MOV     R2,A
   \   000008   02....       LJMP    ?Subroutine29 & 0xFFFF
   2072          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV     DPTR,#ZDAppTaskID
   \                     ??Subroutine6_0:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   90....       MOV     DPTR,#(ZDApp_SendMsg & 0xffff)
   \   000008   74..         MOV     A,#((ZDApp_SendMsg >> 16) & 0xff)
   \   00000A   22           RET
   2073          
   2074          /*********************************************************************
   2075           * @fn      ZDApp_SendMsg()
   2076           *
   2077           * @brief   Sends a OSAL message
   2078           *
   2079           * @param  taskID - Where to send the message
   2080           * @param  cmd - command ID
   2081           * @param  len - length (in bytes) of the buf field
   2082           * @param  buf - buffer for the rest of the message.
   2083           *
   2084           * @return  none
   2085           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2086          void ZDApp_SendMsg( byte taskID, byte cmd, byte len, byte *buf )
   \                     ZDApp_SendMsg:
   2087          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8A..         MOV     ?V0 + 3,R2
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 6,R4
   \   00000D   8D..         MOV     ?V0 + 7,R5
   2088            osal_event_hdr_t *msgPtr;
   2089          
   2090            // Send the address to the task
   2091            msgPtr = (osal_event_hdr_t *)osal_msg_allocate( len );
   \   00000F                ; Setup parameters for call to function osal_msg_allocate
   \   00000F   FA           MOV     R2,A
   \   000010   7B00         MOV     R3,#0x0
   \   000012   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000015   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000017   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001A   8A..         MOV     ?V0 + 4,R2
   \   00001C   8B..         MOV     ?V0 + 5,R3
   2092            if ( msgPtr )
   \   00001E   EA           MOV     A,R2
   \   00001F   7001         JNZ     ??ZDApp_SendMsg_0
   \   000021   EB           MOV     A,R3
   \                     ??ZDApp_SendMsg_0:
   \   000022   6041         JZ      ??ZDApp_SendMsg_1
   2093            {
   2094              if ( (len > 0) && (buf != NULL) )
   \   000024   EF           MOV     A,R7
   \   000025   6027         JZ      ??ZDApp_SendMsg_2
   \   000027   E5..         MOV     A,?V0 + 6
   \   000029   7002         JNZ     ??ZDApp_SendMsg_3
   \   00002B   E5..         MOV     A,?V0 + 7
   \                     ??ZDApp_SendMsg_3:
   \   00002D   601F         JZ      ??ZDApp_SendMsg_2
   2095                osal_memcpy( msgPtr, buf, len );
   \   00002F                ; Setup parameters for call to function osal_memcpy
   \   00002F   85....       MOV     ?V0 + 0,?V0 + 6
   \   000032   85....       MOV     ?V0 + 1,?V0 + 7
   \   000035   75..00       MOV     ?V0 + 2,#0x0
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00003D   EF           MOV     A,R7
   \   00003E   FC           MOV     R4,A
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000044   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   000046   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000049   7403         MOV     A,#0x3
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   2096          
   2097              msgPtr->event = cmd;
   \                     ??ZDApp_SendMsg_2:
   \   00004E   85..82       MOV     DPL,?V0 + 4
   \   000051   85..83       MOV     DPH,?V0 + 5
   \   000054   E5..         MOV     A,?V0 + 3
   \   000056   F0           MOVX    @DPTR,A
   2098              osal_msg_send( taskID, (byte *)msgPtr );
   \   000057                ; Setup parameters for call to function osal_msg_send
   \   000057   AA..         MOV     R2,?V0 + 4
   \   000059   AB..         MOV     R3,?V0 + 5
   \   00005B   EE           MOV     A,R6
   \   00005C   F9           MOV     R1,A
   \   00005D   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   000060   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   000062   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2099            }
   2100          }
   \                     ??ZDApp_SendMsg_1:
   \   000065   80..         SJMP    ?Subroutine28
   2101          
   2102          #if defined ( ZDO_NWKADDR_REQUEST )
   2103          /*********************************************************************
   2104           * @fn      ZDApp_NwkAddrRspCB()
   2105           *
   2106           * @brief
   2107           *
   2108           *   Called by ZDO when a NWK_addr_rsp message is received.
   2109           *
   2110           * @param  SrcAddr  - Source address
   2111           * @param  Status - response status
   2112           * @param  IEEEAddr - 64 bit IEEE address of device
   2113           * @param  aoi - 16 bit network address of interest.
   2114           * @param  NumAssocDev - number of associated devices to reporting device
   2115           * @param  AssocDevList - array short addresses of associated devices
   2116           *
   2117           * @return  none
   2118           */
   2119          void ZDApp_NwkAddrRspCB( zAddrType_t *SrcAddr, byte Status, byte *IEEEAddr,
   2120                                   uint16 nwkAddr, byte NumAssocDev,
   2121                                   byte StartIndex, uint16 *AssocDevList )
   2122          {
   2123            uint8 bufLen;
   2124            ZDO_NwkAddrResp_t *pNwkAddrRsp;
   2125          
   2126          #if defined ( MT_ZDO_FUNC )
   2127            /* First check if MT has subscribed for this callback. If so , pass it as
   2128            a event to MonitorTest and return control to calling function after that */
   2129            if ( _zdoCallbackSub & CB_ID_ZDO_NWK_ADDR_RSP )
   2130            {
   2131              zdo_MTCB_NwkIEEEAddrRspCB( SPI_CB_ZDO_NWK_ADDR_RSP, SrcAddr, Status,
   2132                            IEEEAddr, nwkAddr, NumAssocDev, StartIndex, AssocDevList );
   2133              return;
   2134            }
   2135          #endif  //MT_ZDO_FUNC
   2136          
   2137            if ( ZDApp_NwkAddrRsp_TaskID )
   2138            {
   2139              // Send the NWK Address response structure to the registered task
   2140              bufLen = sizeof( ZDO_NwkAddrResp_t ) + sizeof( uint16 ) * NumAssocDev;
   2141          
   2142              pNwkAddrRsp = (ZDO_NwkAddrResp_t *)osal_msg_allocate( bufLen );
   2143          
   2144              if ( pNwkAddrRsp )
   2145              {
   2146                pNwkAddrRsp->hdr.event = ZDO_NWK_ADDR_RESP;
   2147          
   2148                // Build the structure
   2149                pNwkAddrRsp->nwkAddr = nwkAddr;
   2150                osal_cpyExtAddr( pNwkAddrRsp->extAddr, IEEEAddr );
   2151                pNwkAddrRsp->numAssocDevs = NumAssocDev;
   2152                pNwkAddrRsp->startIndex = StartIndex;
   2153                osal_memcpy( pNwkAddrRsp->devList, AssocDevList, (sizeof( uint16 ) * NumAssocDev) );
   2154          
   2155                osal_msg_send( ZDApp_NwkAddrRsp_TaskID, (uint8 *)pNwkAddrRsp );
   2156              }
   2157            }
   2158          }
   2159          #endif // ZDO_NWKADDR_REQUEST
   2160          
   2161          #if defined ( ZDO_IEEEADDR_REQUEST )
   2162          /*********************************************************************
   2163           * @fn      ZDApp_IEEEAddrRspCB()
   2164           *
   2165           * @brief
   2166           *
   2167           *   Called by ZDO when a NWK_addr_rsp message is received.
   2168           *
   2169           * @param  SrcAddr  - Source address
   2170           * @param  Status - response status
   2171           * @param  IEEEAddr - 64 bit IEEE address of device
   2172           * @param  aoi - 16 bit network address of interest.
   2173           * @param  NumAssocDev - number of associated devices to reporting device
   2174           * @param  AssocDevList - array short addresses of associated devices
   2175           *
   2176           * @return  none
   2177           */
   2178          void ZDApp_IEEEAddrRspCB( zAddrType_t *SrcAddr, byte Status, byte *IEEEAddr,
   2179                                    uint16 aoi, byte NumAssocDev,
   2180                                    byte StartIndex, uint16 *AssocDevList )
   2181          {
   2182            uint8 bufLen;
   2183            ZDO_IEEEAddrResp_t *pIEEEAddrRsp;
   2184          
   2185          #if defined ( MT_ZDO_FUNC )
   2186            /* First check if MT has subscribed for this callback. If so , pass it as
   2187            a event to MonitorTest and return control to calling function after that */
   2188            if ( _zdoCallbackSub & CB_ID_ZDO_IEEE_ADDR_RSP )
   2189            {
   2190              zdo_MTCB_NwkIEEEAddrRspCB( SPI_CB_ZDO_IEEE_ADDR_RSP, SrcAddr, Status,
   2191                            IEEEAddr, 0, NumAssocDev, StartIndex, AssocDevList );
   2192              return;
   2193            }
   2194          #endif  //MT_ZDO_FUNC
   2195          
   2196            if ( ZDApp_IEEEAddrRsp_TaskID )
   2197            {
   2198              // Send the IEEE Address response structure to the registered task
   2199              bufLen = sizeof( ZDO_IEEEAddrResp_t ) + sizeof( uint16 ) * NumAssocDev;
   2200          
   2201              pIEEEAddrRsp = (ZDO_IEEEAddrResp_t *)osal_msg_allocate( bufLen );
   2202              if ( pIEEEAddrRsp )
   2203              {
   2204                pIEEEAddrRsp->hdr.event = ZDO_IEEE_ADDR_RESP;
   2205          
   2206                // Build the structure
   2207                pIEEEAddrRsp->nwkAddr = aoi;
   2208                osal_cpyExtAddr( pIEEEAddrRsp->extAddr, IEEEAddr );
   2209                pIEEEAddrRsp->numAssocDevs = NumAssocDev;
   2210                pIEEEAddrRsp->startIndex = StartIndex;
   2211                osal_memcpy( pIEEEAddrRsp->devList, AssocDevList, (sizeof( uint16 ) * NumAssocDev) );
   2212          
   2213                osal_msg_send( ZDApp_IEEEAddrRsp_TaskID, (uint8 *)pIEEEAddrRsp );
   2214              }
   2215            }
   2216          }
   2217          #endif // ZDO_IEEEADDR_REQUEST
   2218          
   2219          #if defined ( ZDO_NODEDESC_REQUEST )
   2220          /*********************************************************************
   2221           * @fn      ZDApp_NodeDescRspCB()
   2222           *
   2223           * @brief
   2224           *
   2225           *   Called by ZDO when a Node_Desc_rsp message is received.
   2226           *
   2227           * @param  SrcAddr  - Source address
   2228           * @param  Status - response status
   2229           * @param  aoi - 16 bit network address of interest.
   2230           * @param  pNodeDesc - pointer to the devices Node Descriptor
   2231           *                     NULL if Status != ZDP_SUCCESS
   2232           *
   2233           * @return  none
   2234           */
   2235          void ZDApp_NodeDescRspCB( zAddrType_t *SrcAddr, byte Status, uint16 aoi,
   2236                                    NodeDescriptorFormat_t *pNodeDesc )
   2237          {
   2238          #if defined ( MT_ZDO_FUNC )
   2239            /* First check if MT has subscribed for this callback. If so , pass it as
   2240            a event to MonitorTest and return control to calling function after that */
   2241            if ( _zdoCallbackSub & CB_ID_ZDO_NODE_DESC_RSP )
   2242            {
   2243              zdo_MTCB_NodeDescRspCB( SrcAddr, Status, aoi, pNodeDesc );
   2244              return;
   2245            }
   2246          #endif  //MT_ZDO_FUNC
   2247          }
   2248          #endif
   2249          
   2250          #if defined ( ZDO_POWERDESC_REQUEST )
   2251          /*********************************************************************
   2252           * @fn      ZDApp_PowerDescRspCB()
   2253           *
   2254           * @brief
   2255           *
   2256           *   Called by ZDO when a Power_Desc_rsp message is received.
   2257           *
   2258           * @param  SrcAddr  - Source address
   2259           * @param  Status - response status
   2260           * @param  aoi - 16 bit network address of interest.
   2261           * @param  pPwrDesc - pointer to the devices Power Descriptor
   2262           *                     NULL if Status != ZDP_SUCCESS
   2263           *
   2264           * @return  none
   2265           */
   2266          void ZDApp_PowerDescRspCB( zAddrType_t *SrcAddr, byte Status,
   2267                                      uint16 aoi, NodePowerDescriptorFormat_t *pPwrDesc )
   2268          {
   2269          #if defined ( MT_ZDO_FUNC )
   2270            /* First check if MT has subscribed for this callback. If so , pass it as
   2271            a event to MonitorTest and return control to calling function after that */
   2272            if ( _zdoCallbackSub & CB_ID_ZDO_POWER_DESC_RSP )
   2273            {
   2274              zdo_MTCB_PowerDescRspCB( SrcAddr, Status, aoi, pPwrDesc );
   2275              return;
   2276            }
   2277          #endif  //MT_ZDO_FUNC
   2278          }
   2279          #endif // ZDO_POWERDESC_REQUEST
   2280          
   2281          #if defined ( ZDO_SIMPLEDESC_REQUEST )
   2282          /*********************************************************************
   2283           * @fn      ZDApp_SimpleDescRspCB()
   2284           *
   2285           * @brief
   2286           *
   2287           *   Called by ZDO when a Simple_Desc_rsp message is received.
   2288           *
   2289           * @param  SrcAddr  - Source address
   2290           * @param  Status - response status
   2291           * @param  aoi - 16 bit network address of interest.
   2292           * @param  endPoint - Endpoint for description
   2293           * @param  pSimpleDesc - pointer to the devices Simple Descriptor
   2294           *                     NULL if Status != ZDP_SUCCESS
   2295           *
   2296           * @return  none
   2297           */
   2298          void ZDApp_SimpleDescRspCB( zAddrType_t *SrcAddr, byte Status,
   2299                                      uint16 aoi, byte endPoint,
   2300                                      SimpleDescriptionFormat_t *pSimpleDesc )
   2301          {
   2302          #if defined ( MT_ZDO_FUNC )
   2303            /* First check if MT has subscribed for this callback. If so , pass it as
   2304            a event to MonitorTest and return control to calling function after that */
   2305            if ( _zdoCallbackSub & CB_ID_ZDO_SIMPLE_DESC_RSP )
   2306            {
   2307              zdo_MTCB_SimpleDescRspCB( SrcAddr, Status, aoi, endPoint, pSimpleDesc );
   2308              return;
   2309            }
   2310          #endif  //MT_ZDO_FUNC
   2311          }
   2312          #endif // ZDO_SIMPLEDESC_REQUEST
   2313          
   2314          #if defined ( ZDO_ACTIVEEP_REQUEST )
   2315          /*********************************************************************
   2316           * @fn      ZDApp_ActiveEPRspCB()
   2317           *
   2318           * @brief
   2319           *
   2320           *   Called by ZDO when a Active_EP_rsp message is received.
   2321           *
   2322           * @param  src    - Device's short address that this response describes
   2323           * @param  Status - response status
   2324           * @param  epCnt  - number of epList items
   2325           * @param  epList - array of active endpoint.
   2326           *
   2327           * @return  none
   2328           */
   2329          void ZDApp_ActiveEPRspCB( zAddrType_t *src, byte Status,
   2330                                                               byte epCnt, byte *epList )
   2331          {
   2332          #if defined ( MT_ZDO_FUNC )
   2333            /* First check if MT has subscribed for this callback. If so , pass it as
   2334            a event to MonitorTest and return control to calling function after that */
   2335            if ( _zdoCallbackSub & CB_ID_ZDO_ACTIVE_EPINT_RSP )
   2336            {
   2337              zdo_MTCB_MatchActiveEPRspCB( SPI_CB_ZDO_ACTIVE_EPINT_RSP, src,
   2338                                            src->addr.shortAddr, Status, epCnt, epList );
   2339              return;
   2340            }
   2341          #endif  //MT_ZDO_FUNC
   2342          }
   2343          #endif // ZDO_ACTIVEEP_REQUEST
   2344          
   2345          #if defined ( ZDO_MATCH_REQUEST )
   2346          /*********************************************************************
   2347           * @fn      ZDApp_MatchDescRspCB()
   2348           *
   2349           * @brief
   2350           *
   2351           *   Called by ZDO when a Match_Desc_rsp message is received.
   2352           *
   2353           * NOTE:  Currently, this function accepts any responding device as THE
   2354           *        match and updates the endpoint (requested) destination's
   2355           *        address.  So, the last response received is the application's
   2356           *        match.
   2357           *
   2358           *        This function could be changed to do further device discovery
   2359           *        and/or accept multiple responses.
   2360           *
   2361           * @param  src     - Device's short address that this response describes
   2362           * @param  Status  - response status
   2363           * @param  epCnt   - number of epList items
   2364           * @param  epList  - array of active endpoint
   2365           *
   2366           * @return  none
   2367           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2368          void ZDApp_MatchDescRspCB( zAddrType_t *src, byte Status,
   \                     ZDApp_MatchDescRspCB:
   2369                                                               byte epCnt, byte *epList )
   2370          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 6,R2
   \   000007   8B..         MOV     ?V0 + 7,R3
   \   000009   8C..         MOV     ?V0 + 3,R4
   \   00000B   7410         MOV     A,#0x10
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 4,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 5,A
   2371          #if defined ( MT_ZDO_FUNC )
   2372            /* First check if MT has subscribed for this callback. If so , pass it as
   2373            a event to MonitorTest and return control to calling function after that */
   2374            if ( _zdoCallbackSub & CB_ID_ZDO_MATCH_DESC_RSP )
   2375            {
   2376              zdo_MTCB_MatchActiveEPRspCB( SPI_CB_ZDO_MATCH_DESC_RSP, src,
   2377                                            src->addr.shortAddr, Status, epCnt, epList );
   2378              return;
   2379            }
   2380          #endif  //MT_ZDO_FUNC
   2381          
   2382            if ( (Status != ZDP_SUCCESS) || (epCnt == 0) )
   \   000017   E9           MOV     A,R1
   \   000018   6003         JZ      $+5
   \   00001A   02....       LJMP    ??ZDApp_MatchDescRspCB_0 & 0xFFFF
   \   00001D   EC           MOV     A,R4
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDApp_MatchDescRspCB_0 & 0xFFFF
   2383            {
   2384          #if defined( LCD_SUPPORTED )
   2385              HalLcdWriteScreen( "Auto Find Rsp", "Unsuccessful" );
   2386          #endif
   2387              return;
   2388            }
   2389          
   2390            if ( ZDApp_MatchDescRsp_TaskID )
   \   000023   90....       MOV     DPTR,#??ZDApp_MatchDescRsp_TaskID
   \   000026   E0           MOVX    A,@DPTR
   \   000027   606C         JZ      ??ZDApp_MatchDescRspCB_1
   2391            {
   2392              // Send the IEEE Address response structure to the registered task.
   2393              uint8 bufLen = sizeof( ZDO_MatchDescResp_t ) + epCnt;
   2394              ZDO_MatchDescResp_t *pMatchDescRsp = (ZDO_MatchDescResp_t *)osal_msg_allocate( bufLen );
   \   000029                ; Setup parameters for call to function osal_msg_allocate
   \   000029   7405         MOV     A,#0x5
   \   00002B   25..         ADD     A,?V0 + 3
   \   00002D   FA           MOV     R2,A
   \   00002E   7B00         MOV     R3,#0x0
   \   000030   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000033   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000035   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000038   8A..         MOV     ?V0 + 0,R2
   \   00003A   8B..         MOV     ?V0 + 1,R3
   \   00003C   AE..         MOV     R6,?V0 + 0
   \   00003E   AF..         MOV     R7,?V0 + 1
   2395          
   2396              if ( pMatchDescRsp )
   \   000040   EE           MOV     A,R6
   \   000041   7001         JNZ     ??ZDApp_MatchDescRspCB_2
   \   000043   EF           MOV     A,R7
   \                     ??ZDApp_MatchDescRspCB_2:
   \   000044   604F         JZ      ??ZDApp_MatchDescRspCB_1
   2397              {
   2398                pMatchDescRsp->hdr.event = ZDO_MATCH_DESC_RESP;
   \   000046   74D4         MOV     A,#-0x2c
   \   000048   8E82         MOV     DPL,R6
   \   00004A   8F83         MOV     DPH,R7
   \   00004C   F0           MOVX    @DPTR,A
   2399          
   2400                // Build the structure.
   2401                pMatchDescRsp->nwkAddr = src->addr.shortAddr;
   \   00004D   85..82       MOV     DPL,?V0 + 6
   \   000050   85..83       MOV     DPH,?V0 + 7
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F8           MOV     R0,A
   \   000055   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000058   E8           MOV     A,R0
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   E9           MOV     A,R1
   \   00005C   12....       LCALL   ?Subroutine4 & 0xFFFF
   2402                pMatchDescRsp->epCnt = epCnt;
   \                     ??CrossCallReturnLabel_6:
   \   00005F   E5..         MOV     A,?V0 + 3
   \   000061   F0           MOVX    @DPTR,A
   2403                osal_memcpy( pMatchDescRsp->epList, epList, epCnt );
   \   000062                ; Setup parameters for call to function osal_memcpy
   \   000062   85....       MOV     ?V0 + 0,?V0 + 4
   \   000065   85....       MOV     ?V0 + 1,?V0 + 5
   \   000068   75..00       MOV     ?V0 + 2,#0x0
   \   00006B   78..         MOV     R0,#?V0 + 0
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000070   AC..         MOV     R4,?V0 + 3
   \   000072   7D00         MOV     R5,#0x0
   \   000074   EE           MOV     A,R6
   \   000075   2405         ADD     A,#0x5
   \   000077   FA           MOV     R2,A
   \   000078   EF           MOV     A,R7
   \   000079   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00007C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00007F   7403         MOV     A,#0x3
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   2404          
   2405                osal_msg_send( ZDApp_MatchDescRsp_TaskID, (uint8 *)pMatchDescRsp );
   \   000084                ; Setup parameters for call to function osal_msg_send
   \   000084   EE           MOV     A,R6
   \   000085   FA           MOV     R2,A
   \   000086   EF           MOV     A,R7
   \   000087   FB           MOV     R3,A
   \   000088   90....       MOV     DPTR,#??ZDApp_MatchDescRsp_TaskID
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F9           MOV     R1,A
   \   00008D   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   000090   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   000092   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2406              }
   2407            }
   2408          
   2409            if ( ZDApp_AutoFindMode_epDesc )
   \                     ??ZDApp_MatchDescRspCB_1:
   \   000095   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   000098   E0           MOVX    A,@DPTR
   \   000099   7002         JNZ     ??ZDApp_MatchDescRspCB_3
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \                     ??ZDApp_MatchDescRspCB_3:
   \   00009D   6043         JZ      ??ZDApp_MatchDescRspCB_0
   2410            {
   2411              ZDApp_SendNewDstAddr( *epList, src, 0, false,
   2412                                    *(ZDApp_AutoFindMode_epDesc->task_id),
   2413                                      ZDApp_AutoFindMode_epDesc->endPoint );
   \   00009F                ; Setup parameters for call to function ZDApp_SendNewDstAddr
   \   00009F   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   0000A2   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000A5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A8   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0000AB   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B1   75..00       MOV     ?V0 + 0,#0x0
   \   0000B4   78..         MOV     R0,#?V0 + 0
   \   0000B6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B9   7C00         MOV     R4,#0x0
   \   0000BB   7D00         MOV     R5,#0x0
   \   0000BD   AA..         MOV     R2,?V0 + 6
   \   0000BF   AB..         MOV     R3,?V0 + 7
   \   0000C1   85..82       MOV     DPL,?V0 + 4
   \   0000C4   85..83       MOV     DPH,?V0 + 5
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F9           MOV     R1,A
   \   0000C9   90....       MOV     DPTR,#(ZDApp_SendNewDstAddr & 0xffff)
   \   0000CC   74..         MOV     A,#((ZDApp_SendNewDstAddr >> 16) & 0xff)
   \   0000CE   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000D1   7403         MOV     A,#0x3
   \   0000D3   12....       LCALL   ?DEALLOC_XSTACK8
   2414          
   2415              HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   0000D6                ; Setup parameters for call to function HalLedSet
   \   0000D6   7A01         MOV     R2,#0x1
   \   0000D8   7908         MOV     R1,#0x8
   \   0000DA   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   0000DD   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   0000DF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_MatchDescRspCB_0:
   \   0000E2   02....       LJMP    ?Subroutine28 & 0xFFFF
   2416          
   2417          #if defined( LCD_SUPPORTED )
   2418              MatchRsps++;
   2419              HalLcdWriteString( "Auto Find Rsp", HAL_LCD_LINE_1 );
   2420              HalLcdWriteStringValue( "dstAddr Rcvd", MatchRsps, 10, HAL_LCD_LINE_2 );
   2421          #endif
   2422            }
   2423          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   22           RET
   2424          #endif // ZDO_MATCH_REQUEST
   2425          
   2426          #if defined ( ZDO_ENDDEVICEBIND_REQUEST )
   2427          /*********************************************************************
   2428           * @fn      ZDApp_EndDeviceBindRsp()
   2429           *
   2430           * @brief
   2431           *
   2432           *   Called by ZDO when a End_Device_Bind_rsp message is received.
   2433           *
   2434           * @param  SrcAddr  - Source address
   2435           * @param  Status - response status
   2436           *
   2437           * @return  none
   2438           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2439          void ZDApp_EndDeviceBindRsp( zAddrType_t *SrcAddr, byte Status )
   \                     ZDApp_EndDeviceBindRsp:
   2440          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2441          #if defined ( MT_ZDO_FUNC )
   2442            /* First check if MT has subscribed for this callback. If so , pass it as
   2443            a event to MonitorTest and return control to calling function after that */
   2444            if ( _zdoCallbackSub & CB_ID_ZDO_END_DEVICE_BIND_RSP )
   2445            {
   2446              zdo_MTCB_BindRspCB( SPI_CB_ZDO_END_DEVICE_BIND_RSP, SrcAddr, Status );
   2447              return;
   2448            }
   2449          #endif  //MT_ZDO_FUNC
   2450          
   2451            if ( Status == ZDP_SUCCESS )
   \   000004   E9           MOV     A,R1
   \   000005   7004         JNZ     ??ZDApp_EndDeviceBindRsp_0
   2452              HalLedSet ( HAL_LED_4, HAL_LED_MODE_ON );
   \   000007                ; Setup parameters for call to function HalLedSet
   \   000007   7A01         MOV     R2,#0x1
   \   000009   8002         SJMP    ??ZDApp_EndDeviceBindRsp_1
   2453          #if defined(BLINK_LEDS)
   2454            else
   2455              // Flash LED to show failure
   2456              HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
   \                     ??ZDApp_EndDeviceBindRsp_0:
   \   00000B                ; Setup parameters for call to function HalLedSet
   \   00000B   7A04         MOV     R2,#0x4
   \                     ??ZDApp_EndDeviceBindRsp_1:
   \   00000D   7908         MOV     R1,#0x8
   \   00000F   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000012   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000014   02....       LJMP    ??Subroutine29_0 & 0xFFFF
   2457          #endif
   2458          
   2459          #if defined( LCD_SUPPORTED )
   2460            HalLcdWriteString( "End Device Bind", HAL_LCD_LINE_1 );
   2461            if ( Status == ZDP_SUCCESS )
   2462              HalLcdWriteString( "Rsp SUCCESS", HAL_LCD_LINE_2 );
   2463            else if ( Status == ZDP_TIMEOUT )
   2464              HalLcdWriteString( "Rsp Timeout", HAL_LCD_LINE_2 );
   2465            else if ( Status == ZDP_NO_MATCH )
   2466              HalLcdWriteString( "Rsp No Match", HAL_LCD_LINE_2 );
   2467            else
   2468              HalLcdWriteString( "Rsp Not Supported", HAL_LCD_LINE_2 );
   2469          #endif  // LCD_SUPPORTED
   2470          }
   2471          #endif // ZDO_ENDDEVICEBIND_REQUEST
   2472          
   2473          #if defined ( ZDO_BIND_UNBIND_REQUEST )
   2474          /*********************************************************************
   2475           * @fn      ZDApp_BindRsp()
   2476           *
   2477           * @brief
   2478           *
   2479           *   Called by ZDO when a Bind_rsp message is received.
   2480           *
   2481           * @param  SrcAddr  - Source address
   2482           * @param  Status - response status
   2483           *
   2484           * @return  none
   2485           */
   2486          void ZDApp_BindRsp( zAddrType_t *SrcAddr, byte Status )
   2487          {
   2488            ZDO_BindRsp_t bindRsp;
   2489          
   2490          #if defined ( MT_ZDO_FUNC )
   2491            /* First check if MT has subscribed for this callback. If so , pass it as
   2492            a event to MonitorTest and return control to calling function after that */
   2493            if ( _zdoCallbackSub & CB_ID_ZDO_BIND_RSP )
   2494            {
   2495              zdo_MTCB_BindRspCB( SPI_CB_ZDO_BIND_RSP, SrcAddr, Status );
   2496              return;
   2497            }
   2498          #endif  //MT_ZDO_FUNC
   2499          
   2500            if ( ZDApp_BindUnbindRsp_TaskID != TASK_NO_TASK )
   2501            {
   2502              // Send the response structure to the registered task
   2503              bindRsp.nwkAddr = SrcAddr->addr.shortAddr;
   2504              bindRsp.status  = Status;
   2505          
   2506              ZDApp_SendMsg( ZDApp_BindUnbindRsp_TaskID,
   2507                             ZDO_BIND_RESP,
   2508                             sizeof(ZDO_BindRsp_t),
   2509                             (byte*)(&bindRsp) );
   2510            }
   2511          }
   2512          #endif // ZDO_BIND_UNBIND_REQUEST
   2513          
   2514          #if defined ( ZDO_BIND_UNBIND_REQUEST )
   2515          /*********************************************************************
   2516           * @fn      ZDApp_UnbindRsp()
   2517           *
   2518           * @brief
   2519           *
   2520           *   Called by ZDO when a Unbind_rsp message is received.
   2521           *
   2522           * @param  SrcAddr  - Source address
   2523           * @param  Status - response status
   2524           *
   2525           * @return  none
   2526           */
   2527          void ZDApp_UnbindRsp( zAddrType_t *SrcAddr, byte Status )
   2528          {
   2529            ZDO_UnbindRsp_t unbindRsp;
   2530          
   2531          #if defined ( MT_ZDO_FUNC )
   2532            /* First check if MT has subscribed for this callback. If so , pass it as
   2533            a event to MonitorTest and return control to calling function after that */
   2534            if ( _zdoCallbackSub & CB_ID_ZDO_UNBIND_RSP )
   2535            {
   2536              zdo_MTCB_BindRspCB( SPI_CB_ZDO_UNBIND_RSP, SrcAddr, Status );
   2537              return;
   2538            }
   2539          #endif  //MT_ZDO_FUNC
   2540          
   2541            if ( ZDApp_BindUnbindRsp_TaskID != TASK_NO_TASK )
   2542            {
   2543              // Send the response structure to the registered task
   2544              unbindRsp.nwkAddr = SrcAddr->addr.shortAddr;
   2545              unbindRsp.status  = Status;
   2546          
   2547              ZDApp_SendMsg( ZDApp_BindUnbindRsp_TaskID,
   2548                             ZDO_UNBIND_RESP,
   2549                             sizeof(ZDO_UnbindRsp_t),
   2550                             (byte*)(&unbindRsp) );
   2551            }
   2552          }
   2553          #endif // ZDO_BIND_UNBIND_REQUEST
   2554          
   2555          /*********************************************************************
   2556           * Call Back Functions from NWK  - API
   2557           */
   2558          
   2559          /*********************************************************************
   2560           * @fn          ZDO_NetworkDiscoveryConfirmCB
   2561           *
   2562           * @brief       This function returns a choice of PAN to join.
   2563           *
   2564           * @param       ResultCount - Number of routers discovered
   2565           * @param               NetworkList - Pointer to list of network descriptors
   2566           *
   2567           * @return      ZStatus_t
   2568           */
   2569          #define STACK_PROFILE_MAX 2

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2570          ZStatus_t ZDO_NetworkDiscoveryConfirmCB( byte ResultCount,
   \                     ZDO_NetworkDiscoveryConfirmCB:
   2571                                                   networkDesc_t *NetworkList )
   2572          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FC           MOV     R4,A
   2573            networkDesc_t *pNwkDesc;
   2574            ZDO_NetworkDiscoveryCfm_t msg;
   2575            byte  i, j;
   2576            uint8 stackProfile;
   2577            uint8 stackProfilePro;
   2578            uint8 selected;
   2579          
   2580          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   2581            if ( zdappMgmtNwkDiscReqInProgress )
   2582            {
   2583              zdappMgmtNwkDiscReqInProgress = false;
   2584              ZDO_FinishProcessingMgmtNwkDiscReq( ResultCount, NetworkList );
   2585              return ( ZSuccess );
   2586            }
   2587          #endif
   2588          
   2589            // process discovery results
   2590            stackProfilePro = FALSE;
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
   2591            selected = FALSE;
   2592          
   2593            for ( stackProfile = 0; stackProfile < STACK_PROFILE_MAX; stackProfile++ )
   \   00000F   7D00         MOV     R5,#0x0
   2594            {
   2595              for ( j = 0; j < (sizeof(sPVerList)/sizeof(sPVerList[0])); ++j )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_0:
   \   000011   75..00       MOV     ?V0 + 0,#0x0
   2596              {
   2597                pNwkDesc = NetworkList;
   \                     ??ZDO_NetworkDiscoveryConfirmCB_1:
   \   000014   EA           MOV     A,R2
   \   000015   FE           MOV     R6,A
   \   000016   EB           MOV     A,R3
   \   000017   FF           MOV     R7,A
   2598                for ( i = 0; i < ResultCount; i++, pNwkDesc = pNwkDesc->nextDesc )
   \   000018   75..00       MOV     ?V0 + 4,#0x0
   \   00001B   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_2 & 0xFFFF
   2599                {
   2600                  if ( zgConfigPANID != 0xFFFF )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_3:
   \   00001E   90....       MOV     DPTR,#zgConfigPANID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   64FF         XRL     A,#0xff
   \   000024   7004         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_4
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   64FF         XRL     A,#0xff
   \                     ??ZDO_NetworkDiscoveryConfirmCB_4:
   \   00002A   602B         JZ      ??ZDO_NetworkDiscoveryConfirmCB_5
   2601                  {
   2602                    // PAN Id is preconfigured. check if it matches
   2603                    // only 14 bits of pan id is used
   2604                    if ( pNwkDesc->panId != ( zgConfigPANID & 0x3FFF ) )
   \   00002C   90....       MOV     DPTR,#zgConfigPANID
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F8           MOV     R0,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   543F         ANL     A,#0x3f
   \   000035   F9           MOV     R1,A
   \   000036   8F83         MOV     DPH,R7
   \   000038   8E82         MOV     DPL,R6
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   68           XRL     A,R0
   \   00003C   7003         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_6
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   69           XRL     A,R1
   \                     ??ZDO_NetworkDiscoveryConfirmCB_6:
   \   000041   704F         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_7
   2605                      continue;
   2606                    #if !defined ( DEF_PROTO_VERS )
   2607                    // If the macro was not defined ensure we join the version supported by
   2608                    // this PAN by forcing a match below. We need this statement because we
   2609                    // want to (possibly) override the NV value if the PAN was pre-defined.
   2610                    // See App Note 026.
   2611                    sPVerList[j] = pNwkDesc->version;
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   C0E0         PUSH    A
   \   000051   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000054   D0E0         POP     A
   \   000056   F0           MOVX    @DPTR,A
   2612                    #endif
   2613                  }
   2614          
   2615                  // check that network is allowing joining
   2616                  //------------------------------------------------------------
   2617                  #if defined( RTR_NWK )
   2618                  //------------------------------------------------------------
   2619                  if ( stackProfilePro == FALSE )
   2620                  {
   2621                    if ( !pNwkDesc->routerCapacity )
   2622                    {
   2623                      continue;
   2624                    }
   2625                  }
   2626                  else
   2627                  {
   2628                    if ( !pNwkDesc->deviceCapacity )
   2629                    {
   2630                      continue;
   2631                    }
   2632                  }
   2633                  //------------------------------------------------------------
   2634                  #else
   2635                  //------------------------------------------------------------
   2636                  if ( !pNwkDesc->deviceCapacity )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_5:
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   602E         JZ      ??ZDO_NetworkDiscoveryConfirmCB_7
   2637                  {
   2638                    continue;
   2639                  }
   2640                  //------------------------------------------------------------
   2641                  #endif
   2642                  //------------------------------------------------------------
   2643          
   2644                  // check version of zigbee protocol
   2645                  if ( pNwkDesc->version != sPVerList[j] )
   \   000064   8E82         MOV     DPL,R6
   \   000066   8F83         MOV     DPH,R7
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000074   68           XRL     A,R0
   \   000075   701B         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_7
   2646                    continue;
   2647          
   2648                  // check version of stack profile
   2649                  if ( pNwkDesc->stackProfile != zgStackProfile )
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   F8           MOV     R0,A
   \   000085   90....       MOV     DPTR,#zgStackProfile
   \   000088   E0           MOVX    A,@DPTR
   \   000089   68           XRL     A,R0
   \   00008A   6049         JZ      ??ZDO_NetworkDiscoveryConfirmCB_8
   2650                  {
   2651                    stackProfilePro = TRUE;
   \   00008C   75..01       MOV     ?V0 + 1,#0x1
   2652          
   2653                    if ( stackProfile == 0 )
   \   00008F   ED           MOV     A,R5
   \   000090   7043         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_8
   2654                    {
   2655                      continue;
   2656                    }
   2657                  }
   2658          
   2659                  // check if beacon order is the right value..
   2660              //  if ( pNwkDesc->beaconOrder < ZDO_CONFIG_MAX_BO )
   2661              //    continue;
   2662          
   2663                  // choose this pan for joining
   2664                  break;
   2665                }
   \                     ??ZDO_NetworkDiscoveryConfirmCB_7:
   \   000092   05..         INC     ?V0 + 4
   \   000094   EE           MOV     A,R6
   \   000095   2414         ADD     A,#0x14
   \   000097   F582         MOV     DPL,A
   \   000099   EF           MOV     A,R7
   \   00009A   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   FE           MOV     R6,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   FF           MOV     R7,A
   \                     ??ZDO_NetworkDiscoveryConfirmCB_2:
   \   0000A2   E5..         MOV     A,?V0 + 4
   \   0000A4   C3           CLR     C
   \   0000A5   9C           SUBB    A,R4
   \   0000A6   5003         JNC     $+5
   \   0000A8   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_3 & 0xFFFF
   2666                if (i < ResultCount)
   2667                {
   2668                  selected = TRUE;
   2669                  break;
   2670                }
   2671              }
   \   0000AB   05..         INC     ?V0 + 0
   \   0000AD   E5..         MOV     A,?V0 + 0
   \   0000AF   C3           CLR     C
   \   0000B0   9402         SUBB    A,#0x2
   \   0000B2   5003         JNC     $+5
   \   0000B4   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_1 & 0xFFFF
   2672          
   2673              // break if selected or stack profile pro wasn't found
   2674              if ( (selected == TRUE) || (stackProfilePro == FALSE) )
   \   0000B7   E5..         MOV     A,?V0 + 1
   \   0000B9   600A         JZ      ??ZDO_NetworkDiscoveryConfirmCB_9
   2675              {
   2676                break;
   2677              }
   2678            }
   \   0000BB   0D           INC     R5
   \   0000BC   ED           MOV     A,R5
   \   0000BD   C3           CLR     C
   \   0000BE   9402         SUBB    A,#0x2
   \   0000C0   5003         JNC     $+5
   \   0000C2   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_0 & 0xFFFF
   2679          
   2680            if ( i == ResultCount )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_9:
   \   0000C5   EC           MOV     A,R4
   \   0000C6   65..         XRL     A,?V0 + 4
   \   0000C8   700B         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_8
   2681            {
   2682              msg.hdr.status = ZDO_FAIL;   // couldn't find appropriate PAN to join !
   \   0000CA   7401         MOV     A,#0x1
   \   0000CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CF   7401         MOV     A,#0x1
   \   0000D1   F0           MOVX    @DPTR,A
   \   0000D2   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_10 & 0xFFFF
   2683            }
   2684            else
   2685            {
   2686              // (possibly) reset NV network version we're running under.
   2687              if (NLME_GetProtocolVersion() != sPVerList[j])
   \                     ??ZDO_NetworkDiscoveryConfirmCB_8:
   \   0000D5                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   0000D5   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   0000D8   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   0000DA   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000DD   E9           MOV     A,R1
   \   0000DE   FA           MOV     R2,A
   \   0000DF   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   0000E2   6A           XRL     A,R2
   \   0000E3   6021         JZ      ??ZDO_NetworkDiscoveryConfirmCB_11
   2688              {
   2689                NLME_SetRequest(nwkProtocolVersion, 0, &sPVerList[j]);
   \   0000E5                ; Setup parameters for call to function NLME_SetRequest
   \   0000E5   E5..         MOV     A,?V0 + 0
   \   0000E7   24..         ADD     A,#(??sPVerList & 0xff)
   \   0000E9   FC           MOV     R4,A
   \   0000EA   E4           CLR     A
   \   0000EB   34..         ADDC    A,#((??sPVerList >> 8) & 0xff)
   \   0000ED   FD           MOV     R5,A
   \   0000EE   7A00         MOV     R2,#0x0
   \   0000F0   7B00         MOV     R3,#0x0
   \   0000F2   7998         MOV     R1,#-0x68
   \   0000F4   90....       MOV     DPTR,#(NLME_SetRequest & 0xffff)
   \   0000F7   74..         MOV     A,#((NLME_SetRequest >> 16) & 0xff)
   \   0000F9   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2690                // make sure we update NV
   2691                osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 1000 );
   \   0000FC                ; Setup parameters for call to function osal_start_timerEx
   \   0000FC   7CE8         MOV     R4,#-0x18
   \   0000FE   7D03         MOV     R5,#0x3
   \   000100   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000103   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2692              }
   2693          
   2694              msg.hdr.status = ZDO_SUCCESS;
   \                     ??ZDO_NetworkDiscoveryConfirmCB_11:
   \   000106   7401         MOV     A,#0x1
   \   000108   12....       LCALL   ?XSTACK_DISP0_8
   \   00010B   E4           CLR     A
   \   00010C   F0           MOVX    @DPTR,A
   2695              msg.panIdLSB = LO_UINT16( pNwkDesc->panId );
   \   00010D   8E82         MOV     DPL,R6
   \   00010F   8F83         MOV     DPH,R7
   \   000111   E0           MOVX    A,@DPTR
   \   000112   C0E0         PUSH    A
   \   000114   7402         MOV     A,#0x2
   \   000116   12....       LCALL   ?XSTACK_DISP0_8
   \   000119   D0E0         POP     A
   \   00011B   12....       LCALL   ?Subroutine18 & 0xFFFF
   2696              msg.panIdMSB = HI_UINT16( pNwkDesc->panId );
   \                     ??CrossCallReturnLabel_42:
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   C0E0         PUSH    A
   \   000121   7403         MOV     A,#0x3
   \   000123   12....       LCALL   ?XSTACK_DISP0_8
   \   000126   D0E0         POP     A
   \   000128   12....       LCALL   ?Subroutine18 & 0xFFFF
   2697              msg.logicalChannel = pNwkDesc->logicalChannel;
   \                     ??CrossCallReturnLabel_43:
   \   00012B   A3           INC     DPTR
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   C0E0         PUSH    A
   \   00012F   7404         MOV     A,#0x4
   \   000131   12....       LCALL   ?XSTACK_DISP0_8
   \   000134   D0E0         POP     A
   \   000136   12....       LCALL   ?Subroutine4 & 0xFFFF
   2698              msg.version = pNwkDesc->version;
   \                     ??CrossCallReturnLabel_7:
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   C0E0         PUSH    A
   \   00013F   7405         MOV     A,#0x5
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   D0E0         POP     A
   \   000146   F0           MOVX    @DPTR,A
   2699              osal_cpyExtAddr( msg.extendedPANID, pNwkDesc->extendedPANID );
   \   000147                ; Setup parameters for call to function osal_cpyExtAddr
   \   000147   EE           MOV     A,R6
   \   000148   240C         ADD     A,#0xc
   \   00014A   FC           MOV     R4,A
   \   00014B   EF           MOV     A,R7
   \   00014C   3400         ADDC    A,#0x0
   \   00014E   FD           MOV     R5,A
   \   00014F   7406         MOV     A,#0x6
   \   000151   12....       LCALL   ?XSTACK_DISP0_8
   \   000154   AA82         MOV     R2,DPL
   \   000156   AB83         MOV     R3,DPH
   \   000158   90....       MOV     DPTR,#(osal_cpyExtAddr & 0xffff)
   \   00015B   74..         MOV     A,#((osal_cpyExtAddr >> 16) & 0xff)
   \   00015D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2700            }
   2701          
   2702            ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_DISC_CNF, sizeof(ZDO_NetworkDiscoveryCfm_t), (byte *)&msg );
   \                     ??ZDO_NetworkDiscoveryConfirmCB_10:
   \   000160                ; Setup parameters for call to function ZDApp_SendMsg
   \   000160   85..82       MOV     DPL,?XSP + 0
   \   000163   85..83       MOV     DPH,?XSP + 1
   \   000166   AC82         MOV     R4,DPL
   \   000168   AD83         MOV     R5,DPH
   \   00016A   7B0E         MOV     R3,#0xe
   \   00016C   7A01         MOV     R2,#0x1
   \   00016E   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000171   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2703          
   2704            return (ZSuccess);
   \   000174   7900         MOV     R1,#0x0
   \   000176   740E         MOV     A,#0xe
   \   000178   12....       LCALL   ?DEALLOC_XSTACK8
   \   00017B   7F05         MOV     R7,#0x5
   \   00017D   02....       LJMP    ?BANKED_LEAVE_XDATA
   2705          }  // ZDO_NetworkDiscoveryConfirmCB

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85....       MOV     ?V0 + 2,?V0 + 0
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   24..         ADD     A,#(??sPVerList & 0xff)
   \   000007   F582         MOV     DPL,A
   \   000009   E4           CLR     A
   \   00000A   34..         ADDC    A,#((??sPVerList >> 8) & 0xff)
   \   00000C   F583         MOV     DPH,A
   \   00000E   22           RET
   2706          
   2707          /*********************************************************************
   2708           * @fn          ZDO_NetworkFormationConfirmCB
   2709           *
   2710           * @brief       This function reports the results of the request to
   2711           *              initialize a coordinator in a network.
   2712           *
   2713           * @param       Status - Result of NLME_NetworkFormationRequest()
   2714           *
   2715           * @return      none
   2716           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2717          void ZDO_NetworkFormationConfirmCB( ZStatus_t Status )
   \                     ZDO_NetworkFormationConfirmCB:
   2718          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2719          #if defined(ZDO_COORDINATOR)
   2720            nwkStatus = (byte)Status;
   2721          
   2722            if ( Status == ZSUCCESS )
   2723            {
   2724              // LED on shows Coordinator started
   2725              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   2726          
   2727              // LED off forgets HOLD_AUTO_START
   2728              HalLedSet (HAL_LED_4, HAL_LED_MODE_OFF);
   2729          
   2730          #if defined ( ZBIT )
   2731              SIM_SetColor(0xd0ffd0);
   2732          #endif
   2733          
   2734              if ( devState == DEV_HOLD )
   2735              {
   2736                // Began with HOLD_AUTO_START
   2737                devState = DEV_COORD_STARTING;
   2738              }
   2739            }
   2740          #if defined(BLINK_LEDS)
   2741            else
   2742              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   2743          #endif
   2744          
   2745            osal_set_event( ZDAppTaskID, ZDO_NETWORK_START );
   2746          #endif  //ZDO_COORDINATOR
   2747          }
   \   000000   02....       LJMP    ?BRET
   2748          
   2749          #if defined(RTR_NWK)
   2750          /*********************************************************************
   2751           * @fn          ZDO_StartRouterConfirmCB
   2752           *
   2753           * @brief       This function reports the results of the request to
   2754           *              start functioning as a router in a network.
   2755           *
   2756           * @param       Status - Result of NLME_StartRouterRequest()
   2757           *
   2758           * @return      none
   2759           */
   2760          void ZDO_StartRouterConfirmCB( ZStatus_t Status )
   2761          {
   2762            nwkStatus = (byte)Status;
   2763          
   2764            if ( Status == ZSUCCESS )
   2765            {
   2766              // LED on shows Router started
   2767              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   2768              // LED off forgets HOLD_AUTO_START
   2769              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   2770              if ( devState == DEV_HOLD )
   2771              {
   2772                // Began with HOLD_AUTO_START
   2773                devState = DEV_END_DEVICE;
   2774              }
   2775            }
   2776          #if defined(BLINK_LEDS)
   2777            else
   2778              HalLedSet( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   2779          #endif
   2780          
   2781            osal_set_event( ZDAppTaskID, ZDO_ROUTER_START );
   2782          }
   2783          #endif  //RTR_NWK
   2784          
   2785          /*********************************************************************
   2786           * @fn          ZDO_JoinConfirmCB
   2787           *
   2788           * @brief       This function allows the next hight layer to be notified
   2789           *              of the results of its request to join itself or another
   2790           *              device to a network.
   2791           *
   2792           * @param       Status - Result of NLME_JoinRequest()
   2793           *
   2794           * @return      none
   2795           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2796          void ZDO_JoinConfirmCB( uint16 PanId, ZStatus_t Status )
   \                     ZDO_JoinConfirmCB:
   2797          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2798            nwkStatus = (byte)Status;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#nwkStatus
   \   000008   F0           MOVX    @DPTR,A
   2799          
   2800            if ( Status == ZSUCCESS )
   \   000009   7023         JNZ     ??ZDO_JoinConfirmCB_0
   2801            {
   2802              // LED on shows device joined
   2803              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   \   00000B                ; Setup parameters for call to function HalLedSet
   \   00000B   7A01         MOV     R2,#0x1
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000012   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000014   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2804              // LED off forgets HOLD_AUTO_START
   2805              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   \   000017                ; Setup parameters for call to function HalLedSet
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7908         MOV     R1,#0x8
   \   00001B   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   00001D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2806              if ( (devState == DEV_HOLD) )
   \   000020   90....       MOV     DPTR,#devState
   \   000023   E0           MOVX    A,@DPTR
   \   000024   7003         JNZ     ??ZDO_JoinConfirmCB_1
   2807              {
   2808                // Began with HOLD_AUTO_START
   2809                devState = DEV_NWK_JOINING;
   \   000026   7403         MOV     A,#0x3
   \   000028   F0           MOVX    @DPTR,A
   2810              }
   2811          #if !  ( SECURE != 0  )
   2812              // Notify to save info into NV
   2813              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 100 );
   \                     ??ZDO_JoinConfirmCB_1:
   \   000029                ; Setup parameters for call to function osal_start_timerEx
   \   000029   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00002C   8009         SJMP    ??ZDO_JoinConfirmCB_2
   2814          #endif
   2815            }
   2816          #if defined(BLINK_LEDS)
   2817            else
   2818              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   \                     ??ZDO_JoinConfirmCB_0:
   \   00002E                ; Setup parameters for call to function HalLedSet
   \   00002E   7A04         MOV     R2,#0x4
   \   000030   7904         MOV     R1,#0x4
   \   000032   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000035   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \                     ??ZDO_JoinConfirmCB_2:
   \   000037   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2819          #endif
   2820          
   2821            // Notify ZDApp
   2822            ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_IND, sizeof(osal_event_hdr_t), (byte*)NULL );
   \   00003A                ; Setup parameters for call to function ZDApp_SendMsg
   \   00003A   7C00         MOV     R4,#0x0
   \   00003C   7D00         MOV     R5,#0x0
   \   00003E   7B02         MOV     R3,#0x2
   \   000040   7A02         MOV     R2,#0x2
   \   000042   02....       LJMP    ?Subroutine29 & 0xFFFF
   2823          }
   2824          
   2825          /*********************************************************************
   2826           * @fn          ZDO_JoinIndicationCB
   2827           *
   2828           * @brief       This function allows the next higher layer of a
   2829           *              coordinator to be notified of a remote join request.
   2830           *
   2831           * @param       ShortAddress - 16-bit address
   2832           * @param       ExtendedAddress - IEEE (64-bit) address
   2833           * @param       CapabilityInformation - Association Capability Information
   2834           *
   2835           * @return      ZStatus_t
   2836           */
   2837          #if defined(RTR_NWK)
   2838          ZStatus_t ZDO_JoinIndicationCB( uint16 ShortAddress, byte *ExtendedAddress,
   2839                                                   byte CapabilityInformation )
   2840          {
   2841          #if defined (AUTO_SOFT_START)
   2842              ZDX_PostCoordinatorIEEE(ShortAddress);
   2843          #endif
   2844          
   2845            // Notify to save info into NV
   2846            osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 1000 );
   2847          
   2848          #if   ( SECURE != 0  )
   2849            // send notification to TC of new device..
   2850            if ( _NIB.SecurityLevel )
   2851              osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 600 );
   2852          #endif  // SECURE
   2853          
   2854            return ( ZSuccess );
   2855          }
   2856          #endif  //RTR_NWK
   2857          
   2858          /*********************************************************************
   2859           * @fn          ZDO_LeaveCnf
   2860           *
   2861           * @brief       This function allows the next higher layer to be
   2862           *              notified of the results of its request for this or
   2863           *              a child device to leave the network.
   2864           *
   2865           * @param       cnf - NLME_LeaveCnf_t
   2866           *
   2867           * @return      none
   2868           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2869          void ZDO_LeaveCnf( NLME_LeaveCnf_t* cnf )
   \                     ZDO_LeaveCnf:
   2870          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2871            // Check for this device
   2872            if ( osal_ExtAddrEqual( cnf->extAddr,
   2873                                    NLME_GetExtAddr() ) == TRUE )
   \   000009                ; Setup parameters for call to function osal_ExtAddrEqual
   \   000009                ; Setup parameters for call to function NLME_GetExtAddr
   \   000009   90....       MOV     DPTR,#(NLME_GetExtAddr & 0xffff)
   \   00000C   74..         MOV     A,#((NLME_GetExtAddr >> 16) & 0xff)
   \   00000E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000011   EA           MOV     A,R2
   \   000012   FC           MOV     R4,A
   \   000013   EB           MOV     A,R3
   \   000014   FD           MOV     R5,A
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   FB           MOV     R3,A
   \   00001D   90....       MOV     DPTR,#(osal_ExtAddrEqual & 0xffff)
   \   000020   74..         MOV     A,#((osal_ExtAddrEqual >> 16) & 0xff)
   \   000022   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000025   E9           MOV     A,R1
   \   000026   6401         XRL     A,#0x1
   \   000028   7009         JNZ     ??ZDO_LeaveCnf_0
   2874            {
   2875              // Prepare to leave with reset
   2876              ZDApp_LeaveReset( cnf->rejoin );
   \   00002A                ; Setup parameters for call to function ZDApp_LeaveReset
   \   00002A   EE           MOV     A,R6
   \   00002B   240B         ADD     A,#0xb
   \   00002D   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000030   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2877            }
   2878            //------------------------------------------------------------------
   2879            #if defined( RTR_NWK )
   2880            //------------------------------------------------------------------
   2881            else
   2882            {
   2883              // Remove device address(optionally descendents) from data
   2884              ZDApp_LeaveUpdate( cnf->dstAddr,
   2885                                 cnf->extAddr,
   2886                                 cnf->removeChildren );
   2887            }
   2888            //------------------------------------------------------------------
   2889            #endif
   2890            //------------------------------------------------------------------
   2891          }
   \                     ??ZDO_LeaveCnf_0:
   \   000033   02....       LJMP    ??Subroutine25_0 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003   3400         ADDC    A,#0x0
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   90....       MOV     DPTR,#(ZDApp_LeaveReset & 0xffff)
   \   00000C   74..         MOV     A,#((ZDApp_LeaveReset >> 16) & 0xff)
   \   00000E   22           RET
   2892          
   2893          /*********************************************************************
   2894           * @fn          ZDO_LeaveInd
   2895           *
   2896           * @brief       This function allows the next higher layer of a
   2897           *              device to be notified of a remote leave request or
   2898           *              indication.
   2899           *
   2900           * @param       ind - NLME_LeaveInd_t
   2901           *
   2902           * @return      none
   2903           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2904          void ZDO_LeaveInd( NLME_LeaveInd_t* ind )
   \                     ZDO_LeaveInd:
   2905          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2906            uint8 leave;
   2907          
   2908          
   2909            // Parent is requesting the leave - NWK layer filters out illegal
   2910            // requests
   2911            if ( ind->request == TRUE )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   7008         JNZ     ??ZDO_LeaveInd_0
   2912            {
   2913              // Notify network of leave
   2914              //----------------------------------------------------------------
   2915              #if defined( RTR_NWK )
   2916              //----------------------------------------------------------------
   2917              NLME_LeaveRsp_t rsp;
   2918              rsp.rejoin         = ind->rejoin;
   2919              rsp.removeChildren = ind->removeChildren;
   2920              NLME_LeaveRsp( &rsp );
   2921              //----------------------------------------------------------------
   2922              #endif
   2923              //----------------------------------------------------------------
   2924          
   2925              // Prepare to leave with reset
   2926              ZDApp_LeaveReset( ind->rejoin );
   \                     ??ZDO_LeaveInd_1:
   \   00001C                ; Setup parameters for call to function ZDApp_LeaveReset
   \   00001C   EE           MOV     A,R6
   \   00001D   240C         ADD     A,#0xc
   \   00001F   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000022   8053         SJMP    ??ZDO_LeaveInd_2
   2927            }
   2928            else
   2929            {
   2930              leave = FALSE;
   2931          
   2932              // Check if this device needs to leave as a child or descendent
   2933              if ( ind->srcAddr == NLME_GetCoordShortAddr() )
   \                     ??ZDO_LeaveInd_0:
   \   000024   8E82         MOV     DPL,R6
   \   000026   8F83         MOV     DPH,R7
   \   000028   C082         PUSH    DPL
   \   00002A   C083         PUSH    DPH
   \   00002C                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   00002C   90....       MOV     DPTR,#(NLME_GetCoordShortAddr & 0xffff)
   \   00002F   74..         MOV     A,#((NLME_GetCoordShortAddr >> 16) & 0xff)
   \   000031   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000034   8A..         MOV     ?V0 + 0,R2
   \   000036   8B..         MOV     ?V0 + 1,R3
   \   000038   D083         POP     DPH
   \   00003A   D082         POP     DPL
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   65..         XRL     A,?V0 + 0
   \   00003F   7004         JNZ     ??ZDO_LeaveInd_3
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   65..         XRL     A,?V0 + 1
   \                     ??ZDO_LeaveInd_3:
   \   000045   7018         JNZ     ??ZDO_LeaveInd_4
   2934              {
   2935                if ( ( ind->removeChildren == TRUE               ) ||
   2936                     ( ZDO_Config_Node_Descriptor.LogicalType ==
   2937                       NODETYPE_DEVICE                           )    )
   \   000047   EE           MOV     A,R6
   \   000048   240B         ADD     A,#0xb
   \   00004A   F582         MOV     DPL,A
   \   00004C   EF           MOV     A,R7
   \   00004D   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000050   E0           MOVX    A,@DPTR
   \   000051   6401         XRL     A,#0x1
   \   000053   60C7         JZ      ??ZDO_LeaveInd_1
   \   000055   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   000058   E0           MOVX    A,@DPTR
   \   000059   5407         ANL     A,#0x7
   \   00005B   6402         XRL     A,#0x2
   \   00005D   60BD         JZ      ??ZDO_LeaveInd_1
   2938                {
   2939                  leave = TRUE;
   2940                }
   2941              }
   2942              else if ( ind->removeChildren == TRUE )
   2943              {
   2944                // Check NWK address allocation algorithm
   2945                //leave = RTG_ANCESTOR(nwkAddr,thisAddr);
   2946              }
   2947          
   2948              if ( leave == TRUE )
   2949              {
   2950                // Prepare to leave with reset
   2951                ZDApp_LeaveReset( ind->rejoin );
   2952              }
   2953              else
   2954              {
   2955                // Remove device address(optionally descendents) from data
   2956                ZDApp_LeaveUpdate( ind->srcAddr,
   2957                                   ind->extAddr,
   2958                                   ind->removeChildren );
   \                     ??ZDO_LeaveInd_4:
   \   00005F                ; Setup parameters for call to function NLME_RemoveChild
   \   00005F   EE           MOV     A,R6
   \   000060   240B         ADD     A,#0xb
   \   000062   F582         MOV     DPL,A
   \   000064   EF           MOV     A,R7
   \   000065   12....       LCALL   ??Subroutine16_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F9           MOV     R1,A
   \   00006A   EE           MOV     A,R6
   \   00006B   2402         ADD     A,#0x2
   \   00006D   FA           MOV     R2,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   FB           MOV     R3,A
   \   000072   90....       MOV     DPTR,#(NLME_RemoveChild & 0xffff)
   \   000075   74..         MOV     A,#((NLME_RemoveChild >> 16) & 0xff)
   \                     ??ZDO_LeaveInd_2:
   \   000077   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2959              }
   2960            }
   2961          }
   \   00007A   02....       LJMP    ??Subroutine24_1 & 0xFFFF
   2962          
   2963          /*********************************************************************
   2964           * @fn          ZDO_SyncIndicationCB
   2965           *
   2966           * @brief       This function allows the next higher layer of a
   2967           *              coordinator to be notified of a loss of synchronization
   2968           *                          with the parent/child device.
   2969           *
   2970           * @param       type: 0 - child; 1 - parent
   2971           *
   2972           *
   2973           * @return      none
   2974           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2975          void ZDO_SyncIndicationCB( byte type, uint16 shortAddr )
   \                     ZDO_SyncIndicationCB:
   2976          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2977          
   2978          #if !defined ( RTR_NWK )
   2979              if ( type == 1 )
   \   000004   7401         MOV     A,#0x1
   \   000006   69           XRL     A,R1
   \   000007   700E         JNZ     ??ZDO_SyncIndicationCB_0
   2980              {
   2981                ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_REQ, sizeof(osal_event_hdr_t), NULL );
   \   000009                ; Setup parameters for call to function ZDApp_SendMsg
   \   000009   7C00         MOV     R4,#0x0
   \   00000B   7D00         MOV     R5,#0x0
   \   00000D   7B02         MOV     R3,#0x2
   \   00000F   7A03         MOV     R2,#0x3
   \   000011   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000014   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2982              }
   2983          #endif
   2984            return;
   \                     ??ZDO_SyncIndicationCB_0:
   \   000017   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   2985          }
   2986          
   2987          /*********************************************************************
   2988           * @fn          ZDO_PollConfirmCB
   2989           *
   2990           * @brief       This function allows the next higher layer to be
   2991           *              notified of a Poll Confirm.
   2992           *
   2993           * @param       none
   2994           *
   2995           * @return      none
   2996           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2997          void ZDO_PollConfirmCB( byte status )
   \                     ZDO_PollConfirmCB:
   2998          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2999            return;
   \   000000   02....       LJMP    ?BRET
   3000          }
   3001          
   3002          /******************************************************************************
   3003           * @fn          ZDApp_NwkWriteNVRequest (stubs AddrMgrWriteNVRequest)
   3004           *
   3005           * @brief       Stub routine implemented by NHLE. NHLE should call
   3006           *              <AddrMgrWriteNV> when appropriate.
   3007           *
   3008           * @param       none
   3009           *
   3010           * @return      none
   3011           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3012          void ZDApp_NwkWriteNVRequest( void )
   \                     AddrMgrWriteNVRequest:
   3013          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3014            if ( !osal_get_timeoutEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV ) )
   \   000005                ; Setup parameters for call to function osal_get_timeoutEx
   \   000005   7A00         MOV     R2,#0x0
   \   000007   7B02         MOV     R3,#0x2
   \   000009   90....       MOV     DPTR,#ZDAppTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   90....       MOV     DPTR,#(osal_get_timeoutEx & 0xffff)
   \   000011   74..         MOV     A,#((osal_get_timeoutEx >> 16) & 0xff)
   \   000013   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000016   EA           MOV     A,R2
   \   000017   7001         JNZ     ??AddrMgrWriteNVRequest_0
   \   000019   EB           MOV     A,R3
   \                     ??AddrMgrWriteNVRequest_0:
   \   00001A   7006         JNZ     ??AddrMgrWriteNVRequest_1
   3015            {
   3016              // Trigger to save info into NV
   3017              osal_start_timerEx( ZDAppTaskID,
   3018                                  ZDO_NWK_UPDATE_NV,
   3019                                  ZDAPP_UPDATE_NWK_NV_TIME );
   \   00001C                ; Setup parameters for call to function osal_start_timerEx
   \   00001C   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00001F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3020            }
   3021          }
   \                     ??AddrMgrWriteNVRequest_1:
   \   000022   02....       LJMP    ??Subroutine24_1 & 0xFFFF
   3022          
   3023          /*********************************************************************
   3024           * Call Back Functions from Security  - API
   3025           */
   3026          
   3027          #if defined( ZDO_COORDINATOR )
   3028           /*********************************************************************
   3029           * @fn          ZDO_UpdateDeviceIndication
   3030           *
   3031           * @brief       This function notifies the "Trust Center" of a
   3032           *              network when a device joins or leaves the network.
   3033           *
   3034           * @param       extAddr - pointer to 64 bit address of new device
   3035           * @param       status  - 0 if a new device joined securely
   3036           *                      - 1 if a new device joined un-securely
   3037           *                      - 2 if a device left the network
   3038           *
   3039           * @return      true if newly joined device should be allowed to
   3040           *                                              remain on network
   3041           */
   3042          ZStatus_t ZDO_UpdateDeviceIndication( byte *extAddr, byte status )
   3043          {
   3044          
   3045          #if   ( SECURE != 0  )
   3046            // can implement a network access policy based on the
   3047            // IEEE address of newly joining devices...
   3048          #endif  // Trust Center
   3049          
   3050            return ZSuccess;
   3051          }
   3052          #endif // ZDO
   3053          
   3054          /*********************************************************************
   3055           * @fn          ZDApp_InMsgCB
   3056           *
   3057           * @brief       This function is called to pass up any message that is
   3058           *              not yet supported.  This allows for the developer to
   3059           *              support features themselves..
   3060           *
   3061           * @return      none
   3062           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3063          void ZDApp_InMsgCB( byte TransSeq, zAddrType_t *srcAddr, byte wasBroadcast,
   \                     ZDApp_InMsgCB:
   3064                            cId_t clusterID, byte asduLen, byte *asdu, byte SecurityUse )
   3065          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   740A         MOV     A,#0xa
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FE           MOV     R6,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FF           MOV     R7,A
   \   00000F   740E         MOV     A,#0xe
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FD           MOV     R5,A
   3066            if ( clusterID & ZDO_RESPONSE_BIT )
   \   000016   7480         MOV     A,#-0x80
   \   000018   5F           ANL     A,R7
   \   000019   F5..         MOV     ?V0 + 1,A
   \   00001B   E4           CLR     A
   \   00001C   7002         JNZ     ??ZDApp_InMsgCB_0
   \   00001E   E5..         MOV     A,?V0 + 1
   \                     ??ZDApp_InMsgCB_0:
   \   000020   7032         JNZ     ??ZDApp_InMsgCB_1
   3067            {
   3068              // Handle the response message
   3069            }
   3070            else
   3071            {
   3072              // Handle the request message by sending a generic "not supported".
   3073              // End Device Announce doesn't have a response.
   3074              if ( !wasBroadcast && clusterID != End_Device_annce )
   \   000022   EC           MOV     A,R4
   \   000023   702F         JNZ     ??ZDApp_InMsgCB_1
   \   000025   7413         MOV     A,#0x13
   \   000027   6E           XRL     A,R6
   \   000028   7001         JNZ     ??ZDApp_InMsgCB_2
   \   00002A   EF           MOV     A,R7
   \                     ??ZDApp_InMsgCB_2:
   \   00002B   6027         JZ      ??ZDApp_InMsgCB_1
   3075              {
   3076                ZDP_GenericRsp( TransSeq, srcAddr, ZDP_NOT_SUPPORTED, 0,
   3077                                (uint16)(clusterID | ZDO_RESPONSE_BIT), SecurityUse );
   \   00002D                ; Setup parameters for call to function ZDP_GenericRsp
   \   00002D   EE           MOV     A,R6
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   7480         MOV     A,#-0x80
   \   000032   4F           ORL     A,R7
   \   000033   F5..         MOV     ?V0 + 1,A
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003A   75..00       MOV     ?V0 + 0,#0x0
   \   00003D   75..00       MOV     ?V0 + 1,#0x0
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   7C84         MOV     R4,#-0x7c
   \   000047   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   00004A   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   00004C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00004F   7404         MOV     A,#0x4
   \   000051   12....       LCALL   ?DEALLOC_XSTACK8
   3078              }
   3079            }
   3080          }
   \                     ??ZDApp_InMsgCB_1:
   \   000054   02....       LJMP    ??Subroutine24_1 & 0xFFFF
   3081          
   3082          #if defined ( ZDO_MGMT_LQI_REQUEST )
   3083          /*********************************************************************
   3084           * @fn          ZDApp_MgmtLqiRspCB
   3085           *
   3086           * @brief       This function handles Management LQI response for the
   3087           *              Device Object application.
   3088           *
   3089           * @param       Status - ZSuccess or other for failure
   3090           * @param       NeighborLqiEntries - number of possible entries on
   3091           *                       the device
   3092           * @param       StartIndex - where this list start in possible entries
   3093           * @param       NeighborLqiCount - number of entries in this list
   3094           * @param       pList - pointer to the list of LQI items.
   3095           * @param       SecurityUse -
   3096           *
   3097           * @return      none
   3098           */
   3099          void ZDApp_MgmtLqiRspCB( uint16 SrcAddr, byte Status, byte NeighborLqiEntries,
   3100                                   byte StartIndex, byte NeighborLqiCount,
   3101                                   neighborLqiItem_t *pList )
   3102          {
   3103            byte x;
   3104          
   3105          #if defined ( MT_ZDO_FUNC )
   3106            /* First check if MT has subscribed for this callback. If so , pass it as
   3107            a event to MonitorTest and return control to calling function after that */
   3108            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_LQI_RSP )
   3109            {
   3110              zdo_MTCB_MgmtLqiRspCB( SrcAddr, Status, NeighborLqiEntries, StartIndex,
   3111                                                  NeighborLqiCount, pList );
   3112              return;
   3113            }
   3114          #endif  //MT_ZDO_FUNC
   3115          
   3116            if ( Status == ZSuccess )
   3117            {
   3118              for ( x = 0; x < NeighborLqiCount; x++, pList++ )
   3119              {
   3120                // Do something with the results
   3121              }
   3122            }
   3123            else
   3124            {
   3125              // Error
   3126            }
   3127          }
   3128          #endif // ZDO_MGMT_LQI_REQUEST
   3129          
   3130          #if defined ( ZDO_MGMT_NWKDISC_REQUEST )
   3131          /*********************************************************************
   3132           * @fn          ZDApp_MgmtNwkDiscRspCB
   3133           *
   3134           * @brief       This function handles Management Network Discovery
   3135           *              response for the Device Object application.
   3136           *
   3137           * @param       SrcAddr - source of the message
   3138           * @param       Status - ZSuccess or other for failure
   3139           * @param       NetworkCount - number of possible entries on
   3140           *                       the device
   3141           * @param       StartIndex - where this list start in possible entries
   3142           * @param       networkListCount - number of entries in this list
   3143           * @param       pList - pointer to the list of Network Discover items.
   3144           * @param       SecurityUse -
   3145           *
   3146           * @return      none
   3147           */
   3148          void ZDApp_MgmtNwkDiscRspCB( uint16 SrcAddr, byte Status, byte NetworkCount,
   3149                                       byte StartIndex, byte networkListCount,
   3150                                       mgmtNwkDiscItem_t *pList )
   3151          {
   3152            byte x;
   3153          
   3154          #if defined ( MT_ZDO_FUNC )
   3155            /* First check if MT has subscribed for this callback. If so , pass it as
   3156            a event to MonitorTest and return control to calling function after that */
   3157            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_NWKDISC_RSP )
   3158            {
   3159              zdo_MTCB_MgmtNwkDiscRspCB( SrcAddr, Status, NetworkCount, StartIndex,
   3160                                                  networkListCount, pList );
   3161              return;
   3162            }
   3163          #endif  //MT_ZDO_FUNC
   3164          
   3165            if ( Status == ZSuccess )
   3166            {
   3167              for ( x = 0; x < networkListCount; x++, pList++ )
   3168              {
   3169                // Do something with the results
   3170              }
   3171            }
   3172            else
   3173            {
   3174              // Error
   3175            }
   3176          }
   3177          #endif // ZDO_MGMT_NWKDISC_REQUEST
   3178          
   3179          #if defined ( ZDO_MGMT_RTG_REQUEST )
   3180          /*********************************************************************
   3181           * @fn          ZDApp_MgmtRtgRspCB
   3182           *
   3183           * @brief       This function handles Management Routing response for the
   3184           *              Device Object application.
   3185           *
   3186           * @param       SrcAddr - source of the message
   3187           * @param       Status - ZSuccess or other for failure
   3188           * @param       rtgCount - number of possible entries on
   3189           *                       the device
   3190           * @param       StartIndex - where this list start in possible entries
   3191           * @param       rtgCount - number of entries in this list
   3192           * @param       pList - pointer to the list of Network Discover items.
   3193           * @param       SecurityUse -
   3194           *
   3195           * @return      none
   3196           */
   3197          void ZDApp_MgmtRtgRspCB( uint16 SrcAddr, byte Status, byte rtgCount,
   3198                                   byte StartIndex, byte rtgListCount,
   3199                                   rtgItem_t *pList )
   3200          {
   3201            byte x;
   3202          
   3203          #if defined ( MT_ZDO_FUNC )
   3204            /* First check if MT has subscribed for this callback. If so , pass it as
   3205            a event to MonitorTest and return control to calling function after that */
   3206            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_RTG_RSP )
   3207            {
   3208              zdo_MTCB_MgmtRtgRspCB( SrcAddr, Status, rtgCount, StartIndex,
   3209                                                                  rtgListCount, pList );
   3210              return;
   3211            }
   3212          #endif  //MT_ZDO_FUNC
   3213          
   3214            if ( Status == ZSuccess )
   3215            {
   3216              for ( x = 0; x < rtgListCount; x++, pList++ )
   3217              {
   3218                // Do something with the results
   3219              }
   3220            }
   3221            else
   3222            {
   3223              // Error
   3224            }
   3225          }
   3226          #endif // ZDO_MGMT_RTG_REQUEST
   3227          
   3228          #if defined ( ZDO_MGMT_BIND_REQUEST )
   3229          /*********************************************************************
   3230           * @fn          ZDApp_MgmtBindRspCB
   3231           *
   3232           * @brief       This function handles Management Binding response for the
   3233           *              Device Object application.
   3234           *
   3235           * @param       SrcAddr - source of the message
   3236           * @param       Status - ZSuccess or other for failure
   3237           * @param       BindingCount - number of possible entries on
   3238           *                       the device
   3239           * @param       StartIndex - where this list start in possible entries
   3240           * @param       BindingListCount - number of entries in this list
   3241           * @param       pList - pointer to the list of Network Discover items.
   3242           * @param       SecurityUse -
   3243           *
   3244           * @return      none
   3245           */
   3246          void ZDApp_MgmtBindRspCB( uint16 SrcAddr, byte Status, byte BindingCount,
   3247                                   byte StartIndex, byte BindingListCount,
   3248                                   apsBindingItem_t *pList )
   3249          {
   3250            byte x;
   3251          
   3252          #if defined ( MT_ZDO_FUNC )
   3253            /* First check if MT has subscribed for this callback. If so , pass it as
   3254            a event to MonitorTest and return control to calling function after that */
   3255            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_BIND_RSP )
   3256            {
   3257              zdo_MTCB_MgmtBindRspCB( SrcAddr, Status, BindingCount, StartIndex,
   3258                                                            BindingListCount, pList );
   3259              return;
   3260            }
   3261          #endif  //MT_ZDO_FUNC
   3262          
   3263            if ( Status == ZSuccess )
   3264            {
   3265              for ( x = 0; x < BindingListCount; x++, pList++ )
   3266              {
   3267                // Do something with the results
   3268              }
   3269            }
   3270            else
   3271            {
   3272              // Error
   3273            }
   3274          }
   3275          #endif // ZDO_MGMT_BIND_REQUEST
   3276          
   3277          #if defined ( ZDO_MGMT_JOINDIRECT_REQUEST )
   3278          /*********************************************************************
   3279           * @fn          ZDApp_MgmtDirectJoinRspCB
   3280           *
   3281           * @brief       This function handles Management Direct Join response for the
   3282           *              Device Object application.
   3283           *
   3284           * @param       SrcAddr - source of the message
   3285           * @param       Status - ZSuccess or other for failure
   3286           * @param       SecurityUse -
   3287           *
   3288           * @return      none
   3289           */
   3290          void ZDApp_MgmtDirectJoinRspCB( uint16 SrcAddr, byte Status, byte SecurityUse )
   3291          {
   3292          #if defined ( MT_ZDO_FUNC )
   3293            /* First check if MT has subscribed for this callback. If so , pass it as
   3294            a event to MonitorTest and return control to calling function after that */
   3295            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_DIRECT_JOIN_RSP )
   3296            {
   3297              zdo_MTCB_MgmtDirectJoinRspCB( SrcAddr, Status, SecurityUse );
   3298              return;
   3299            }
   3300          #endif  //MT_ZDO_FUNC
   3301          
   3302            if ( Status == ZSuccess )
   3303            {
   3304              // Do something with the results
   3305            }
   3306            else
   3307            {
   3308              // Error
   3309            }
   3310          }
   3311          #endif // ZDO_MGMT_JOINDIRECT_REQUEST
   3312          
   3313          #if defined ( ZDO_MGMT_LEAVE_REQUEST )
   3314          /*********************************************************************
   3315           * @fn          ZDApp_MgmtLeaveRspCB
   3316           *
   3317           * @brief       This function handles Management Leave response for the
   3318           *              Device Object application.
   3319           *
   3320           * @param       SrcAddr - source of the message
   3321           * @param       Status - ZSuccess or other for failure
   3322           * @param       SecurityUse -
   3323           *
   3324           * @return      none
   3325           */
   3326          void ZDApp_MgmtLeaveRspCB( uint16 SrcAddr, byte Status, byte SecurityUse )
   3327          {
   3328          #if defined ( MT_ZDO_FUNC )
   3329            /* First check if MT has subscribed for this callback. If so , pass it as
   3330            a event to MonitorTest and return control to calling function after that */
   3331            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_LEAVE_RSP )
   3332            {
   3333              zdo_MTCB_MgmtLeaveRspCB( SrcAddr, Status, SecurityUse );
   3334              return;
   3335            }
   3336          #endif  //MT_ZDO_FUNC
   3337          
   3338            if ( Status == ZSuccess )
   3339            {
   3340              // Do something with the results
   3341            }
   3342            else
   3343            {
   3344              // Error
   3345            }
   3346          }
   3347          #endif // ZDO_MGMT_LEAVE_REQUEST
   3348          
   3349          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && !defined( REFLECTOR )
   3350          /*********************************************************************
   3351           * @fn          ZDApp_MgmtBindReqCB
   3352           *
   3353           * @brief       This function finishes the processing of the Management
   3354           *              Bind Request and generates the response.
   3355           *
   3356           * @param       none
   3357           *
   3358           * @return      none
   3359           */
   3360          void ZDApp_MgmtBindReqCB( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   3361          {
   3362            ZDO_MgmtBindReq_t *pBindReq;
   3363            osal_event_hdr_t *msgPtr;
   3364          
   3365            if ( ZDApp_MgmtBindReq_TaskID )
   3366            {
   3367              // Send the IEEE Address response structure to the registered task
   3368              msgPtr = (osal_event_hdr_t *)osal_msg_allocate( sizeof(osal_event_hdr_t) + sizeof( ZDO_MgmtBindReq_t ) );
   3369              if ( msgPtr )
   3370              {
   3371                msgPtr->event = ZDO_MGMT_BIND_REQ;
   3372                pBindReq = (ZDO_MgmtBindReq_t *)(msgPtr + 1);
   3373          
   3374                // Build the structure
   3375                pBindReq->hdr.srcAddr = SrcAddr->addr.shortAddr;
   3376                pBindReq->hdr.transSeq = TransSeq;
   3377                pBindReq->hdr.SecurityUse = SecurityUse;
   3378          
   3379                pBindReq->startIndex = StartIndex;
   3380                osal_msg_send( ZDApp_MgmtBindReq_TaskID, (uint8 *)msgPtr );
   3381              }
   3382            }
   3383          }
   3384          #endif // ZDO_MGMT_BIND_RESPONSE && !REFLECTOR
   3385          
   3386          #if defined ( ZDO_MGMT_PERMIT_JOIN_REQUEST )
   3387          
   3388          /*********************************************************************
   3389           * @fn          ZDApp_MgmtPermitJoinRspCB
   3390           *
   3391           * @brief       This function handles Management permit join response
   3392           *              for the Device Object application.
   3393           *
   3394           * @param       SrcAddr - source of the message
   3395           * @param       Status - ZSuccess or other for failure
   3396           * @param       SecurityUse -
   3397           *
   3398           * @return      none
   3399           */
   3400          void ZDApp_MgmtPermitJoinRspCB( uint16 SrcAddr, byte Status,
   3401                                          byte SecurityUse )
   3402          {
   3403          #if defined ( MT_ZDO_FUNC )
   3404            /* First check if MT has subscribed for this callback. If so , pass it as
   3405            a event to MonitorTest and return control to calling function after that */
   3406            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_PERMIT_JOIN_RSP )
   3407            {
   3408              zdo_MTCB_MgmtPermitJoinRspCB( SrcAddr, Status, SecurityUse );
   3409              return;
   3410            }
   3411          #endif  //MT_ZDO_FUNC
   3412          
   3413            if ( Status == ZSuccess )
   3414            {
   3415              // Do something with the results
   3416            }
   3417            else
   3418            {
   3419              // Error
   3420            }
   3421          }
   3422          #endif // ZDO_MGMT_LEAVE_REQUEST
   3423          
   3424          #if defined ( ZDO_USERDESC_REQUEST )
   3425          /*********************************************************************
   3426           * @fn          ZDApp_UserDescRspCB
   3427           *
   3428           * @brief       This function handles User Descriptor response for the
   3429           *              Device Object application.
   3430           *
   3431           * @param       SrcAddr - source of the message
   3432           * @param       Status - ZSuccess or other for failure
   3433           * @param       nwkAddrOfInterest - network address of remote device
   3434           * @param       userDescLen - length of user descriptor
   3435           * @param       userDesc - user descriptor byte string
   3436           * @param       SecurityUse -
   3437           *
   3438           * @return      none
   3439           */
   3440          void ZDApp_UserDescRspCB( uint16 SrcAddr, byte status, uint16 nwkAddrOfInterest,
   3441                                    byte userDescLen, byte *userDesc, byte SecurityUse )
   3442          {
   3443          #if defined ( MT_ZDO_FUNC )
   3444            /* First check if MT has subscribed for this callback. If so , pass it as
   3445            a event to MonitorTest and return control to calling function after that */
   3446            if ( _zdoCallbackSub & CB_ID_ZDO_USER_DESC_RSP )
   3447            {
   3448              zdo_MTCB_UserDescRspCB( SrcAddr, status, nwkAddrOfInterest,
   3449                                      userDescLen, userDesc, SecurityUse );
   3450              return;
   3451            }
   3452          #endif  //MT_ZDO_FUNC
   3453          
   3454            if ( status == ZSuccess )
   3455            {
   3456              // Do something with the results
   3457            }
   3458            else
   3459            {
   3460              // Error
   3461            }
   3462          }
   3463          #endif
   3464          
   3465          #if defined ( ZDO_USERDESCSET_REQUEST )
   3466          /*********************************************************************
   3467           * @fn          ZDApp_UserDescConfCB
   3468           *
   3469           * @brief       This function handles Management Direct Join response for the
   3470           *              Device Object application.
   3471           *
   3472           * @param       SrcAddr - source of the message
   3473           * @param       Status - ZSuccess or other for failure
   3474           * @param       SecurityUse -
   3475           *
   3476           * @return      none
   3477           */
   3478          void ZDApp_UserDescConfCB( uint16 SrcAddr, byte status, byte SecurityUse )
   3479          {
   3480          #if defined ( MT_ZDO_FUNC )
   3481            /* First check if MT has subscribed for this callback. If so , pass it as
   3482            a event to MonitorTest and return control to calling function after that */
   3483            if ( _zdoCallbackSub & CB_ID_ZDO_USER_DESC_CONF )
   3484            {
   3485              zdo_MTCB_UserDescConfCB( SrcAddr, status, SecurityUse );
   3486              return;
   3487            }
   3488          #endif  //MT_ZDO_FUNC
   3489          
   3490            if ( status == ZSuccess )
   3491            {
   3492              // Do something with the results
   3493            }
   3494            else
   3495            {
   3496              // Error
   3497            }
   3498          }
   3499          #endif
   3500          
   3501          #if defined ( ZDO_SERVERDISC_REQUEST )
   3502          /*********************************************************************
   3503           * @fn          ZDApp_ServerDiscRspCB
   3504           *
   3505           * @brief       Handle the Server_Discovery_rsp response.
   3506           *
   3507           * @param       srcAddr     - Source Address of the message.
   3508           * @param       status      - ZSuccess.
   3509           * @param       serverMask  - Bit mask of services matching the req serverMask.
   3510           * @param       securityUse -
   3511           *
   3512           * @return      none
   3513           */
   3514          void ZDApp_ServerDiscRspCB( uint16 srcAddr, byte status,
   3515                                      uint16 serverMask, byte securityUse )
   3516          {
   3517          #if defined ( MT_ZDO_FUNC )
   3518            if ( _zdoCallbackSub & CB_ID_ZDO_SERVERDISC_RSP )
   3519            {
   3520              zdo_MTCB_ServerDiscRspCB( srcAddr, status, serverMask, securityUse );
   3521              return;
   3522            }
   3523          #endif
   3524          
   3525            if ( status == ZSuccess )
   3526            {
   3527              // Do something with the results.
   3528            }
   3529            else
   3530            {
   3531              // Error
   3532            }
   3533          }
   3534          #endif
   3535          
   3536          /*********************************************************************
   3537           * @fn      ZDApp_EndDeviceAnnounceCB()
   3538           *
   3539           * @brief   Received an End Device Announce.
   3540           *
   3541           * @param   SrcAddr - Source of the message
   3542           * @param   nwkAddr - short address of the new device
   3543           * @param   extAddr - IEEE address of the new device
   3544           * @param   capabilities - device capabilities.  This field is only
   3545           *             populated in a v1.1 network so use the following before
   3546           *             using it:
   3547           *                  if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
   3548           *
   3549           * @return  none
   3550           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3551          void ZDApp_EndDeviceAnnounceCB( uint16 SrcAddr, uint16 nwkAddr, uint8 *extAddr,
   \                     ZDApp_EndDeviceAnnounceCB:
   3552                                         uint8 capabilities )
   3553          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   7418         MOV     A,#0x18
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   3554            ZDO_EndDeviceAnnounce_t Announce;
   3555          
   3556            // If it interests you - put your own code here.
   3557          
   3558            if ( ZDApp_EndDeviceAnnounce_TaskID )
   \   000016   90....       MOV     DPTR,#??ZDApp_EndDeviceAnnounce_TaskID
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   6043         JZ      ??ZDApp_EndDeviceAnnounceCB_0
   3559            {
   3560              // Build the structure
   3561              Announce.srcAddr = SrcAddr;
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   EA           MOV     A,R2
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   EB           MOV     A,R3
   \   000025   F0           MOVX    @DPTR,A
   3562              Announce.nwkAddr = nwkAddr;
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   EC           MOV     A,R4
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   ED           MOV     A,R5
   \   00002F   F0           MOVX    @DPTR,A
   3563              osal_cpyExtAddr( Announce.extAddr, extAddr );
   \   000030                ; Setup parameters for call to function osal_cpyExtAddr
   \   000030   E8           MOV     A,R0
   \   000031   FC           MOV     R4,A
   \   000032   E9           MOV     A,R1
   \   000033   FD           MOV     R5,A
   \   000034   7406         MOV     A,#0x6
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   AA82         MOV     R2,DPL
   \   00003B   AB83         MOV     R3,DPH
   \   00003D   90....       MOV     DPTR,#(osal_cpyExtAddr & 0xffff)
   \   000040   74..         MOV     A,#((osal_cpyExtAddr >> 16) & 0xff)
   \   000042   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3564              Announce.capabilities = capabilities;
   \   000045   740E         MOV     A,#0xe
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   EE           MOV     A,R6
   \   00004B   12....       LCALL   ?Subroutine1 & 0xFFFF
   3565          
   3566              ZDApp_SendMsg( ZDApp_EndDeviceAnnounce_TaskID, ZDO_END_DEVICE_ANNOUNCE,
   3567                            sizeof( ZDO_EndDeviceAnnounce_t ), (uint8 *)&Announce );
   \                     ??CrossCallReturnLabel_3:
   \   00004E   AC82         MOV     R4,DPL
   \   000050   AD83         MOV     R5,DPH
   \   000052   7B0F         MOV     R3,#0xf
   \   000054   7AD5         MOV     R2,#-0x2b
   \   000056   90....       MOV     DPTR,#??ZDApp_EndDeviceAnnounce_TaskID
   \   000059   12....       LCALL   ??Subroutine6_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00005C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3568            }
   3569          }
   \                     ??ZDApp_EndDeviceAnnounceCB_0:
   \   00005F   740F         MOV     A,#0xf
   \   000061   02....       LJMP    ?Subroutine25 & 0xFFFF
   3570          
   3571          /*********************************************************************
   3572           * @fn      ZDApp_ChangeMatchDescRespPermission()
   3573           *
   3574           * @brief   Changes the Match Descriptor Response permission.
   3575           *
   3576           * @param   endpoint - endpoint to allow responses
   3577           * @param   action - true to allow responses, false to not
   3578           *
   3579           * @return  none
   3580           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3581          void ZDApp_ChangeMatchDescRespPermission( uint8 endpoint, uint8 action )
   \                     ZDApp_ChangeMatchDescRespPermission:
   3582          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3583            // Store the action
   3584            afSetMatch( endpoint, action );
   \   000004                ; Setup parameters for call to function afSetMatch
   \   000004   90....       MOV     DPTR,#(afSetMatch & 0xffff)
   \   000007   74..         MOV     A,#((afSetMatch >> 16) & 0xff)
   \   000009   02....       LJMP    ??Subroutine29_0 & 0xFFFF
   3585          }
   3586          
   3587          /*********************************************************************
   3588           * @fn      ZDApp_NetworkInit()
   3589           *
   3590           * @brief   Used to start the network joining process
   3591           *
   3592           * @param   delay - mSec delay to wait before starting
   3593           *
   3594           * @return  none
   3595           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3596          void ZDApp_NetworkInit( uint16 delay )
   \                     ZDApp_NetworkInit:
   3597          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3598            if ( delay )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??ZDApp_NetworkInit_0
   \   000007   EB           MOV     A,R3
   \                     ??ZDApp_NetworkInit_0:
   \   000008   600D         JZ      ??ZDApp_NetworkInit_1
   3599            {
   3600              // Wait awhile before starting the device
   3601              osal_start_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT, delay );
   \   00000A                ; Setup parameters for call to function osal_start_timerEx
   \   00000A   EA           MOV     A,R2
   \   00000B   FC           MOV     R4,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FD           MOV     R5,A
   \   00000E   7A01         MOV     R2,#0x1
   \   000010   7B00         MOV     R3,#0x0
   \   000012   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000015   8005         SJMP    ??CrossCallReturnLabel_56
   3602            }
   3603            else
   3604            {
   3605              osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   \                     ??ZDApp_NetworkInit_1:
   \   000017                ; Setup parameters for call to function osal_set_event
   \   000017   7A01         MOV     R2,#0x1
   \   000019   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00001C   02....       LJMP    ??Subroutine29_0 & 0xFFFF
   3606            }
   3607          }
   3608          
   3609          #if defined ( ZDO_IEEEADDR_REQUEST )
   3610          /*********************************************************************
   3611           * @fn      ZDApp_RegisterForIEEEAddrRsp()
   3612           *
   3613           * @brief   Register to receive IEEE Addr Response messages
   3614           *
   3615           * @param   TaskID - ID of task to send message
   3616           *
   3617           * @return  none
   3618           */
   3619          void ZDApp_RegisterForIEEEAddrRsp( byte TaskID )
   3620          {
   3621            ZDApp_IEEEAddrRsp_TaskID = TaskID;    // Only 1 task at a time
   3622          }
   3623          #endif // defined ( ZDO_IEEEADDR_REQUEST )
   3624          
   3625          #if defined ( ZDO_NWKADDR_REQUEST )
   3626          /*********************************************************************
   3627           * @fn      ZDApp_RegisterForNwkAddrRsp()
   3628           *
   3629           * @brief   Register to receive NWK Addr Response messages
   3630           *
   3631           * @param   TaskID - ID of task to send message
   3632           *
   3633           * @return  none
   3634           */
   3635          void ZDApp_RegisterForNwkAddrRsp( byte TaskID )
   3636          {
   3637            ZDApp_NwkAddrRsp_TaskID = TaskID;    // Only 1 task at a time
   3638          }
   3639          #endif // defined ( ZDO_NWKADDR_REQUEST )
   3640          
   3641          /*********************************************************************
   3642           * @fn      ZDApp_RegisterForMatchDescRsp()
   3643           *
   3644           * @brief   Register to receive Match Descriptor Response messages
   3645           *
   3646           * @param   TaskID - ID of task to send message
   3647           *
   3648           * @return  none
   3649           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3650          void ZDApp_RegisterForMatchDescRsp( byte TaskID )
   \                     ZDApp_RegisterForMatchDescRsp:
   3651          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3652            ZDApp_MatchDescRsp_TaskID = TaskID;    // Only 1 task at a time
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#??ZDApp_MatchDescRsp_TaskID
   \   000008   F0           MOVX    @DPTR,A
   3653          }
   \   000009   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   3654          
   3655          /*********************************************************************
   3656           * @fn      ZDApp_RegisterForEndDeviceAnnounce()
   3657           *
   3658           * @brief   Register to receive End Device Announce messages
   3659           *
   3660           * @param   TaskID - ID of task to send message
   3661           *
   3662           * @return  none
   3663           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3664          void ZDApp_RegisterForEndDeviceAnnounce( byte TaskID )
   \                     ZDApp_RegisterForEndDeviceAnnounce:
   3665          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3666            ZDApp_EndDeviceAnnounce_TaskID = TaskID;    // Only 1 task at a time
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#??ZDApp_EndDeviceAnnounce_TaskID
   \   000008   F0           MOVX    @DPTR,A
   3667          }
   \   000009   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   3668          
   3669          #if defined ( ZDO_BIND_UNBIND_REQUEST )
   3670          /*********************************************************************
   3671           * @fn      ZDApp_RegisterForBindRsp()
   3672           *
   3673           * @brief   Register to receive Bind_rsp and Unbind_rsp messages
   3674           *
   3675           * @param   TaskID - ID of task to send message
   3676           *
   3677           * @return  none
   3678           */
   3679          void ZDApp_RegisterForBindRsp( byte TaskID )
   3680          {
   3681            ZDApp_BindUnbindRsp_TaskID = TaskID;    // Only 1 task at a time
   3682          }
   3683          #endif // ZDO_BIND_UNBIND_REQUEST
   3684          
   3685          #if defined ( ZDO_BIND_UNBIND_RESPONSE ) && !defined ( REFLECTOR )
   3686          /*********************************************************************
   3687           * @fn      ZDApp_RegisterForBindReq()
   3688           *
   3689           * @brief   Register to receive Bind and Unbind Request messages
   3690           *
   3691           * @param   TaskID - ID of task to send message
   3692           *
   3693           * @return  none
   3694           */
   3695          void ZDApp_RegisterForBindReq( byte TaskID )
   3696          {
   3697            ZDApp_BindReq_TaskID = TaskID;
   3698          }
   3699          #endif
   3700          
   3701          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && !defined ( REFLECTOR )
   3702          /*********************************************************************
   3703           * @fn      ZDApp_RegisterForMgmtBindReq()
   3704           *
   3705           * @brief   Register to receive Mgmt Bind Request messages
   3706           *
   3707           * @param   TaskID - ID of task to send message
   3708           *
   3709           * @return  none
   3710           */
   3711          void ZDApp_RegisterForMgmtBindReq( byte TaskID )
   3712          {
   3713            ZDApp_MgmtBindReq_TaskID = TaskID;
   3714          }
   3715          #endif
   3716          
   3717          /*********************************************************************
   3718           * @fn      ZDApp_StartUpFromApp()
   3719           *
   3720           * @brief   Start the device.  This function will only start a device
   3721           *          that is in the Holding state.
   3722           *
   3723           * @param   mode - ZDAPP_STARTUP_COORD - Start up as coordinator only
   3724           *                 ZDAPP_STARTUP_ROUTER - Start up as router only
   3725           *                 ZDAPP_STARTUP_AUTO - Startup in auto, look for coord,
   3726           *                                       if not found, become coord.
   3727           *
   3728           * @return  TRUE if started, FALSE if in the wrong mode
   3729           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3730          ZStatus_t ZDApp_StartUpFromApp( uint8 mode )
   \                     ZDApp_StartUpFromApp:
   3731          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3732            ZStatus_t ret = ZFailure;
   \   000004   7901         MOV     R1,#0x1
   3733          
   3734            if ( devState == DEV_HOLD )
   \   000006   90....       MOV     DPTR,#devState
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   700E         JNZ     ??ZDApp_StartUpFromApp_0
   3735            {
   3736              // Start the device's joining process
   3737              if ( ZDOInitDevice( 0 ) == ZDO_INITDEV_NEW_NETWORK_STATE )
   \   00000C                ; Setup parameters for call to function ZDOInitDevice
   \   00000C   7A00         MOV     R2,#0x0
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#(ZDOInitDevice & 0xffff)
   \   000013   74..         MOV     A,#((ZDOInitDevice >> 16) & 0xff)
   \   000015   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3738              {
   3739          #if defined( SOFT_START )
   3740                if ( mode == ZDAPP_STARTUP_COORD )
   3741                {
   3742                  devStartMode = MODE_HARD;     // Start as a coordinator
   3743                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   3744                }
   3745                else
   3746                {
   3747                  if ( mode == ZDAPP_STARTUP_ROUTER )
   3748                  {
   3749                    softStartAllowCoord = FALSE;  // Don't allow coord to start
   3750                    continueJoining = TRUE;
   3751                  }
   3752                  devStartMode = MODE_JOIN;     // Assume joining
   3753                }
   3754          #endif  // SOFT_START
   3755              }
   3756              ret = ZSuccess;
   \   000018   7900         MOV     R1,#0x0
   3757            }
   3758          
   3759            return ( ret );
   \                     ??ZDApp_StartUpFromApp_0:
   \   00001A   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   3760          }
   3761          
   3762          /*********************************************************************
   3763           * @fn      ZDApp_StopStartUp()
   3764           *
   3765           * @brief   Stops the joining process of a router.  This will only
   3766           *          work if the router is in the scanning process and
   3767           *          the SOFT_START feature is enabled.
   3768           *
   3769           * @param   none
   3770           *
   3771           * @return  TRUE if SOFT_START is enabled, FALSE if not possible
   3772           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3773          uint8 ZDApp_StopStartUp( void )
   \                     ZDApp_StopStartUp:
   3774          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3775            uint8 ret = FALSE;
   3776          
   3777          #if defined( SOFT_START )
   3778            continueJoining = FALSE;
   3779            ret = TRUE;
   3780          #endif  // SOFT_START
   3781          
   3782            return ( ret );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
   3783          }
   3784          
   3785          /*********************************************************************
   3786           * @fn      ZDApp_StartJoiningCycle()
   3787           *
   3788           * @brief   Starts the joining cycle of a device.  This will only
   3789           *          continue an already started (or stopped) joining cycle.
   3790           *
   3791           * @param   none
   3792           *
   3793           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   3794           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3795          uint8 ZDApp_StartJoiningCycle( void )
   \                     ZDApp_StartJoiningCycle:
   3796          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3797            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   6005         JZ      ??ZDApp_StartJoiningCycle_0
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6402         XRL     A,#0x2
   \   00000F   700F         JNZ     ??ZDApp_StartJoiningCycle_1
   3798            {
   3799              continueJoining = TRUE;
   \                     ??ZDApp_StartJoiningCycle_0:
   \   000011   7401         MOV     A,#0x1
   \   000013   90....       MOV     DPTR,#continueJoining
   \   000016   12....       LCALL   ?Subroutine2 & 0xFFFF
   3800              ZDApp_NetworkInit( 0 );
   \                     ??CrossCallReturnLabel_58:
   \   000019   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3801          
   3802              return ( TRUE );
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   8002         SJMP    ??ZDApp_StartJoiningCycle_2
   3803            }
   3804            else
   3805              return ( FALSE );
   \                     ??ZDApp_StartJoiningCycle_1:
   \   000020   7900         MOV     R1,#0x0
   \                     ??ZDApp_StartJoiningCycle_2:
   \   000022   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   3806          }
   3807          
   3808          /*********************************************************************
   3809           * @fn      ZDApp_StopJoiningCycle()
   3810           *
   3811           * @brief   Stops the joining or rejoining process of a device.
   3812           *
   3813           * @param   none
   3814           *
   3815           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   3816           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3817          uint8 ZDApp_StopJoiningCycle( void )
   \                     ZDApp_StopJoiningCycle:
   3818          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3819            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   6005         JZ      ??ZDApp_StopJoiningCycle_0
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6402         XRL     A,#0x2
   \   00000F   7009         JNZ     ??ZDApp_StopJoiningCycle_1
   3820            {
   3821              continueJoining = FALSE;
   \                     ??ZDApp_StopJoiningCycle_0:
   \   000011   E4           CLR     A
   \   000012   90....       MOV     DPTR,#continueJoining
   \   000015   F0           MOVX    @DPTR,A
   3822              return ( TRUE );
   \   000016   7901         MOV     R1,#0x1
   \   000018   8002         SJMP    ??ZDApp_StopJoiningCycle_2
   3823            }
   3824            else
   3825              return ( FALSE );
   \                     ??ZDApp_StopJoiningCycle_1:
   \   00001A   7900         MOV     R1,#0x0
   \                     ??ZDApp_StopJoiningCycle_2:
   \   00001C   02....       LJMP    ??Subroutine23_0 & 0xFFFF
   3826          }
   3827          
   3828          #if !defined ( ZDO_COORDINATOR ) || defined ( SOFT_START )
   3829          /*********************************************************************
   3830           * @fn      ZDApp_NodeProfileSync()
   3831           *
   3832           * @brief   Sync node with stack profile.
   3833           *
   3834           * @param   cfm - ZDO_NetworkDiscoveryCfm_t
   3835           *
   3836           * @return  none
   3837           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3838          void ZDApp_NodeProfileSync( ZDO_NetworkDiscoveryCfm_t* cfm )
   \                     ZDApp_NodeProfileSync:
   3839          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3840            networkDesc_t* desc;
   3841            uint16         panID;
   3842          
   3843            if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_DEVICETYPE_FFD  )
   \   000005   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   A2E1         MOV     C,0xE0 /* A   */.1
   \   00000B   505E         JNC     ??ZDApp_NodeProfileSync_0
   3844            {
   3845              panID = BUILD_UINT16( cfm->panIdLSB, cfm->panIdMSB );
   3846          
   3847              desc = nwk_getNetworkDesc( cfm->extendedPANID, panID, cfm->logicalChannel );
   \   00000D                ; Setup parameters for call to function nwk_getNetworkDesc
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   8A82         MOV     DPL,R2
   \   000019   8B83         MOV     DPH,R3
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FE           MOV     R6,A
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FD           MOV     R5,A
   \   000028   E4           CLR     A
   \   000029   2E           ADD     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   ED           MOV     A,R5
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FD           MOV     R5,A
   \   00002F   EA           MOV     A,R2
   \   000030   2406         ADD     A,#0x6
   \   000032   FA           MOV     R2,A
   \   000033   EB           MOV     A,R3
   \   000034   3400         ADDC    A,#0x0
   \   000036   FB           MOV     R3,A
   \   000037   90....       MOV     DPTR,#(nwk_getNetworkDesc & 0xffff)
   \   00003A   74..         MOV     A,#((nwk_getNetworkDesc >> 16) & 0xff)
   \   00003C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   3848          
   3849              if (desc != NULL)
   \   000043   E582         MOV     A,DPL
   \   000045   7002         JNZ     ??ZDApp_NodeProfileSync_1
   \   000047   E583         MOV     A,DPH
   \                     ??ZDApp_NodeProfileSync_1:
   \   000049   6020         JZ      ??ZDApp_NodeProfileSync_0
   3850              {
   3851                if ( desc->stackProfile != zgStackProfile )
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FA           MOV     R2,A
   \   000055   90....       MOV     DPTR,#zgStackProfile
   \   000058   E0           MOVX    A,@DPTR
   \   000059   6A           XRL     A,R2
   \   00005A   600F         JZ      ??ZDApp_NodeProfileSync_0
   3852                {
   3853                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_DEVICE;
   \   00005C   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   54F8         ANL     A,#0xf8
   \   000062   4402         ORL     A,#0x2
   \   000064   F0           MOVX    @DPTR,A
   3854                  ZDO_Config_Node_Descriptor.CapabilityFlags = CAPINFO_DEVICETYPE_RFD | CAPINFO_POWER_AC | CAPINFO_RCVR_ON_IDLE;
   \   000065   740C         MOV     A,#0xc
   \   000067   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   00006A   F0           MOVX    @DPTR,A
   3855                }
   3856              }
   3857            }
   3858          }
   \                     ??ZDApp_NodeProfileSync_0:
   \   00006B   02....       LJMP    ??Subroutine24_1 & 0xFFFF

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zdoDiscCounter>`:
   \   000000   01           DB 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for continueJoining>`:
   \   000000   01           DB 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for devState>`:
   \   000000   01           DB 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for sPVerList>`:
   \   000000   0201         DB 2, 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDApp_epDesc>`:
   \   000000   00           DB 0
   \   000001   ....0000     DW ZDAppTaskID, 0H
   \   000005   00           DB 0

   \                                 In segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
   3859          #endif
   3860          
   3861          /*********************************************************************
   3862          *********************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     AddrMgrWriteNVRequest              0      0     10
       -> osal_get_timeoutEx            0      0     20
       -> osal_start_timerEx            0      0     20
     ZDAppCheckForHoldKey               4      0      1
       -> HalKeyRead                    4      0      0
     ZDAppDetermineDeviceType           0      0      0
     ZDAppSetupProtoVersion             5      0      2
       -> NLME_GetProtocolVersion       4      0      2
       -> NLME_SetRequest               4      0      2
       -> osal_memset                   4      0      2
     ZDApp_AutoFindDestinationEx        1      0     32
       -> HalLedSet                     0      0     48
       -> afFindEndPointDesc            0      0     48
       -> osal_mem_alloc                0      0     48
       -> osal_memcpy                   0      0     54
       -> ZDP_MatchDescReq              0      0     64
     ZDApp_ChangeMatchDescRespPermission
                                        2      0      0
       -> afSetMatch                    4      0      0
     ZDApp_EndDeviceAnnounceCB          1      0     26
       -> osal_cpyExtAddr               0      0     48
       -> ZDApp_SendMsg                 0      0     48
     ZDApp_EndDeviceBindRsp             2      0      0
       -> HalLedSet                     4      0      0
       -> HalLedSet                     4      0      0
     ZDApp_InMsgCB                      0      0     19
       -> ZDP_GenericRsp                0      0     28
     ZDApp_Init                         2      0      1
       -> NLME_GetExtAddr               4      0      2
       -> ZDAppCheckForHoldKey          4      0      2
       -> ZDO_Init                      4      0      2
       -> afRegister                    4      0      2
       -> ZDAppSetupProtoVersion        4      0      2
       -> NLME_GetRequest               4      0      2
       -> NLME_SetBroadcastFilter       4      0      2
       -> ZDOInitDevice                 4      0      2
       -> HalLedBlink                   4      0      2
     ZDApp_InitUserDesc                 0      0     31
       -> osal_memset                   0      0     54
       -> osal_nv_item_init             0      0     58
       -> osal_nv_read                  0      0     62
     ZDApp_LeaveCtrlBypass              2      0      0
     ZDApp_LeaveCtrlInit                0      0     26
       -> osal_nv_item_init             0      0     24
       -> osal_nv_read                  0      0     28
     ZDApp_LeaveCtrlSet                 2      0     14
       -> osal_nv_write                 0      0     28
     ZDApp_LeaveCtrlStartup             1      0     26
       -> osal_nv_write                 0      0     28
     ZDApp_LeaveReset                   2      0     10
       -> ZDApp_LeaveCtrlSet            4      0      0
       -> ZDApp_ResetTimerStart         4      0      0
     ZDApp_LeaveUpdate                  2      0      0
       -> NLME_RemoveChild              4      0      0
     ZDApp_MatchDescRspCB               1      0     21
       -> osal_msg_allocate             0      0     32
       -> osal_memcpy                   0      0     38
       -> osal_msg_send                 0      0     32
       -> ZDApp_SendNewDstAddr          0      0     38
       -> HalLedSet                     0      0     32
     ZDApp_NetworkInit                  4      0     12
       -> osal_start_timerEx            4      0      0
       -> osal_set_event                4      0      0
     ZDApp_NetworkStartEvt              2      0      0
       -> osal_pwrmgr_device            4      0      0
       -> osal_set_event                4      0      0
       -> NLME_GetEnergyThreshold       4      0      0
       -> NLME_GetEnergyThreshold       4      0      0
       -> NLME_SetEnergyThreshold       4      0      0
       -> osal_set_event                4      0      0
       -> osal_set_event                4      0      0
     ZDApp_NodeProfileSync              0      0     20
       -> nwk_getNetworkDesc            0      0     20
     ZDApp_ProcessNetworkJoin           0      0     22
       -> osal_set_event                0      0     24
       -> NLME_GetShortAddr             0      0     24
       -> ZMacSetReq                    0      0     24
       -> osal_rand                     0      0     24
       -> ZDApp_NetworkInit             0      0     24
       -> osal_set_event                0      0     24
       -> NLME_SetPollRate              0      0     24
       -> NLME_SetQueuedPollRate        0      0     24
       -> NLME_SetResponseRate          0      0     24
       -> osal_rand                     0      0     24
       -> ZDApp_NetworkInit             0      0     24
     ZDApp_ProcessOSALMsg               0      0     21
       -> ZDP_IncomingData              0      0     20
       -> ZDApp_NodeProfileSync         0      0     20
       -> NLME_JoinRequest              0      0     22
       -> osal_rand                     0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> NLME_ReJoinRequest            0      0     20
       -> osal_rand                     0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> NLME_SetPollRate              0      0     20
       -> NLME_SetQueuedPollRate        0      0     20
       -> NLME_SetResponseRate          0      0     20
       -> osal_rand                     0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> ZDApp_ProcessNetworkJoin      0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> osal_set_event                0      0     20
     ZDApp_ReadNetworkRestoreState      0      0      9
       -> zgReadStartupOptions          0      0     18
     ZDApp_RegisterForEndDeviceAnnounce
                                        2      0      0
     ZDApp_RegisterForMatchDescRsp      2      0      0
     ZDApp_ResetTimerCancel             2      0      0
       -> osal_stop_timerEx             4      0      0
     ZDApp_ResetTimerStart              4      0      0
       -> osal_start_timerEx            4      0      0
     ZDApp_RestoreNetworkState          0      0      9
       -> NLME_InitNV                   0      0     18
       -> NLME_RestoreFromNV            0      0     18
       -> NLME_GetShortAddr             0      0     18
     ZDApp_SaveNetworkStateEvt          0      0      0
     ZDApp_SendEndDeviceBindReq         1      0     29
       -> HalLedSet                     0      0     40
       -> afFindSimpleDesc              0      0     40
       -> ZDP_EndDeviceBindReq          0      0     58
       -> osal_mem_free                 0      0     40
     ZDApp_SendEventMsg                 2      0      0
       -> ZDApp_SendMsg                 4      0      0
     ZDApp_SendMsg                      3      0     46
       -> osal_msg_allocate             0      0     32
       -> osal_memcpy                   0      0     38
       -> osal_msg_send                 0      0     32
     ZDApp_SendNewDstAddr               1      0     40
       -> osal_msg_allocate             0      0     36
       -> osal_memcpy                   0      0     42
       -> osal_msg_send                 0      0     36
     ZDApp_StartJoiningCycle            2      0      0
       -> ZDApp_NetworkInit             4      0      0
     ZDApp_StartUpFromApp               2      0      0
       -> ZDOInitDevice                 4      0      0
     ZDApp_StopJoiningCycle             2      0      0
     ZDApp_StopStartUp                  0      0      0
     ZDApp_event_loop                   0      0     10
       -> ZDO_StartDevice               0      0     20
       -> ZDApp_ProcessOSALMsg          0      0     20
       -> osal_msg_deallocate           0      0     20
       -> osal_msg_receive              0      0     20
       -> ZDO_UpdateNwkStatus           0      0     20
     ZDOInitDevice                      2      0     13
       -> ZDApp_LeaveCtrlInit           0      0     24
       -> ZDApp_LeaveCtrlStartup        0      0     24
       -> osal_rand                     0      0     24
       -> ZDApp_NetworkInit             0      0     24
     ZDO_JoinConfirmCB                  2      0      0
       -> HalLedSet                     4      0      0
       -> HalLedSet                     4      0      0
       -> osal_start_timerEx            4      0      0
       -> HalLedSet                     4      0      0
       -> ZDApp_SendMsg                 4      0      0
     ZDO_LeaveCnf                       0      0      9
       -> NLME_GetExtAddr               0      0     18
       -> osal_ExtAddrEqual             0      0     18
       -> ZDApp_LeaveReset              0      0     18
     ZDO_LeaveInd                       2      0     10
       -> ZDApp_LeaveReset              0      0     20
       -> NLME_GetCoordShortAddr        4      0     20
       -> NLME_RemoveChild              0      0     20
     ZDO_NetworkDiscoveryConfirmCB      2      0     27
       -> NLME_GetProtocolVersion       0      0     54
       -> NLME_SetRequest               0      0     54
       -> osal_start_timerEx            0      0     54
       -> osal_cpyExtAddr               0      0     54
       -> ZDApp_SendMsg                 0      0     54
     ZDO_NetworkFormationConfirmCB      0      0      0
     ZDO_PollConfirmCB                  0      0      0
     ZDO_SyncIndicationCB               2      0      0
       -> ZDApp_SendMsg                 4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     WDCTL                             1
     zdoDiscCounter                    1
     ZDAppNwkAddr                      9
     continueJoining                   1
     _tmpRejoinState                   1
     ZDAppTaskID                       1
     nwkStatus                         1
     ZDApp_AutoFindMode_epDesc         2
     ZDApp_LeaveCtrl                   1
     devState                          1
     devStartMode                      1
     ZDApp_MatchDescRsp_TaskID         1
     ZDApp_EndDeviceAnnounce_TaskID    1
     retryCnt                          1
     sPVerList                         2
     ZDApp_epDesc                      6
     ZDApp_Init                      149
     ?Subroutine23                    15
     ZDApp_event_loop                181
     ?Subroutine24                    10
     ZDOInitDevice                   117
     ZDApp_ReadNetworkRestoreState    25
     ?Subroutine25                     8
     ZDAppDetermineDeviceType          3
     ZDApp_NetworkStartEvt            98
     ?Subroutine26                    13
     ?Subroutine29                     9
     ZDApp_SaveNetworkStateEvt         3
     ZDApp_RestoreNetworkState        82
     ZDAppSetupProtoVersion           70
     ZDApp_InitUserDesc              136
     ZDAppCheckForHoldKey             25
     ZDApp_ProcessOSALMsg            320
     ?Subroutine13                    11
     ?Subroutine27                     8
     ?Subroutine0                      8
     ?Subroutine10                     9
     ?Subroutine12                    10
     ?Subroutine2                      6
     ZDApp_ProcessNetworkJoin        347
     ?Subroutine1                      8
     ZDApp_SendEndDeviceBindReq      215
     ?Subroutine8                      4
     ?Subroutine19                    10
     ?Subroutine7                      7
     ?Subroutine9                      8
     ?Subroutine20                     4
     ?Subroutine22                     9
     ZDApp_AutoFindDestinationEx     301
     ZDApp_ResetTimerStart            18
     ?Subroutine5                     19
     ZDApp_ResetTimerCancel           21
     ZDApp_LeaveCtrlInit              74
     ?Subroutine3                     14
     ZDApp_LeaveCtrlSet               59
     ZDApp_LeaveCtrlBypass            17
     ZDApp_LeaveCtrlStartup           84
     ZDApp_LeaveReset                 23
     ZDApp_LeaveUpdate                15
     ZDApp_SendNewDstAddr            181
     ?Subroutine28                     5
     ?Subroutine17                     9
     ?Subroutine16                     9
     ZDApp_SendEventMsg               11
     ?Subroutine6                     11
     ZDApp_SendMsg                   103
     ZDApp_MatchDescRspCB            229
     ?Subroutine4                      7
     ?Subroutine18                     7
     ZDApp_EndDeviceBindRsp           23
     ZDO_NetworkDiscoveryConfirmCB   384
     ?Subroutine15                     5
     ?Subroutine21                    15
     ZDO_NetworkFormationConfirmCB     3
     ZDO_JoinConfirmCB                69
     ZDO_LeaveCnf                     54
     ?Subroutine14                    15
     ZDO_LeaveInd                    125
     ZDO_SyncIndicationCB             26
     ZDO_PollConfirmCB                 3
     AddrMgrWriteNVRequest            37
     ZDApp_InMsgCB                    87
     ZDApp_EndDeviceAnnounceCB       100
     ZDApp_ChangeMatchDescRespPermission
                                      12
     ZDApp_NetworkInit                31
     ZDApp_RegisterForMatchDescRsp    12
     ZDApp_RegisterForEndDeviceAnnounce
                                      12
     ZDApp_StartUpFromApp             29
     ZDApp_StopStartUp                 5
     ZDApp_StartJoiningCycle          37
     ZDApp_StopJoiningCycle           31
     ZDApp_NodeProfileSync           110
     ?<Initializer for zdoDiscCounter>
                                       1
     ?<Initializer for continueJoining>
                                       1
     ?<Initializer for devState>       1
     ?<Initializer for sPVerList>      2
     ?<Initializer for ZDApp_epDesc>
                                       6
     _A_IEN0                           1

 
 4 370 bytes in segment BANKED_CODE
     2 bytes in segment SFR_AN
    11 bytes in segment XDATA_I
    11 bytes in segment XDATA_ID
    19 bytes in segment XDATA_Z
 
 4 381 bytes of CODE  memory
     0 bytes of DATA  memory (+ 2 bytes shared)
    30 bytes of XDATA memory

Errors: none
Warnings: none
