##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   17/Oct/2013  21:52:36 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  D:\Texas Instruments\ZStack-1.4.2-1.1.0\Component #
#                          s\stack\zdo\ZDObject.c                            #
#    Command line       =  -f E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wEnde #
#                          v.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR                #
#                          -DROOT=__near_func -DMAC_OPT_FFD=0 -DBLINK_LEDS   #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f    #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfig. #
#                          cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800     #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\Source\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mt\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\hal\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          hal\target\CC2430EB\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\osal\mcu #
#                          \ccsoc\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC #
#                          2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\osal\include\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨ #
#                          Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects #
#                          \zstack\Samples\SampleApp\CC2430DB\..\..\..\..\.. #
#                          \Components\stack\af\ -I                          #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\stack\nw #
#                          k\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\st #
#                          ack\sec\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\C #
#                          C2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\ #
#                          Samples\SampleApp\CC2430DB\..\..\..\..\..\Compone #
#                          nts\stack\sys\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶ #
#                          Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\stack\zdo\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\zmac\f8w #
#                          \ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\se #
#                          rvices\saddr\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Co #
#                          mponents\services\sdata\ -I                       #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          mac\high_level\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\..\..\..\..\ #
#                          Components\mac\low_level\srf03\ -I                #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\low_ #
#                          level\srf03\single_chip\ -D CC2430EB -D           #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D           #
#                          ZG_ENDDEVICE -lC E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\EndDeviceEB\List\ #
#                           -lA E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\EndDeviceEB\List\             #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\EndDeviceEB\Obj\ -e             #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          "D:\Texas Instruments\ZStack-1.4.2-1.1.0\Componen #
#                          ts\stack\zdo\ZDObject.c"                          #
#    List file          =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\List\ZDObject.lst      #
#    Object file        =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\Obj\ZDObject.r51       #
#                                                                            #
#                                                                            #
##############################################################################

D:\Texas Instruments\ZStack-1.4.2-1.1.0\Components\stack\zdo\ZDObject.c
      1          /*********************************************************************
      2              Filename:       ZDObject.c
      3              Revised:        $Date: 2007-05-14 17:34:18 -0700 (Mon, 14 May 2007) $
      4              Revision:       $Revision: 14296 $
      5          
      6              Description:
      7          
      8                This Zigbee Device Object.
      9          
     10              Notes:
     11          
     12              Copyright (c) 2006 by Texas Instruments, Inc.
     13              All Rights Reserved.  Permission to use, reproduce, copy, prepare
     14              derivative works, modify, distribute, perform, display or sell this
     15              software and/or its documentation for any purpose is prohibited
     16              without the express written consent of Texas Instruments, Inc.
     17          *********************************************************************/
     18          
     19          /*********************************************************************
     20           * INCLUDES
     21           */
     22          #include "ZComdef.h"
     23          #include "OSAL.h"
     24          #include "OSAL_Nv.h"
     25          #include "rtg.h"
     26          #include "NLMEDE.h"
     27          #include "nwk_globals.h"
     28          #include "APS.h"
     29          #include "APSMEDE.h"
     30          #include "AssocList.h"
     31          #include "BindingTable.h"
     32          #include "AddrMgr.h"
     33          #include "AF.h"
     34          #include "ZDObject.h"
     35          #include "ZDProfile.h"
     36          #include "ZDConfig.h"
     37          #include "ZDCache.h"
     38          #include "ZDSecMgr.h"
     39          #include "ZDApp.h"
     40          #include "nwk_util.h"   // NLME_IsAddressBroadcast()
     41          #include "ZGlobals.h"
     42          
     43          #if defined( LCD_SUPPORTED )
     44            #include "OnBoard.h"
     45          #endif
     46          
     47          /* HAL */
     48          #include "hal_lcd.h"
     49          
     50          /*********************************************************************
     51           * MACROS
     52           */
     53          
     54          /*********************************************************************
     55           * CONSTANTS
     56           */
     57          // NLME Stub Implementations
     58          #define ZDO_ProcessMgmtPermitJoinTimeout NLME_PermitJoiningTimeout
     59          
     60          // Status fields used by ZDO_ProcessMgmtRtgReq
     61          #define ZDO_MGMT_RTG_ENTRY_ACTIVE             0x00
     62          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY 0x01
     63          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED   0x02
     64          #define ZDO_MGMT_RTG_ENTRY_INACTIVE           0x03
     65          
     66          /*********************************************************************
     67           * TYPEDEFS
     68           */
     69          #if defined ( REFLECTOR )
     70          typedef struct
     71          {
     72            byte SrcTransSeq;
     73            zAddrType_t SrcAddr;
     74            uint16 LocalCoordinator;
     75            byte epIntf;
     76            uint16 ProfileID;
     77            byte numInClusters;
     78            uint16 *inClusters;
     79            byte numOutClusters;
     80            uint16 *outClusters;
     81            byte SecurityUse;
     82            byte status;
     83          } ZDO_EDBind_t;
     84          #endif // defined ( REFLECTOR )
     85          
     86          #if defined ( ZDO_COORDINATOR )
     87          enum
     88          {
     89            ZDMATCH_INIT,           // Initialized
     90            ZDMATCH_WAIT_REQ,       // Received first request, waiting for second
     91            ZDMATCH_SENDING_BINDS   // Received both requests, sending unbind/binds
     92          };
     93          
     94          enum
     95          {
     96            ZDMATCH_REASON_START,
     97            ZDMATCH_REASON_TIMEOUT,
     98            ZDMATCH_REASON_UNBIND_RSP,
     99            ZDMATCH_REASON_BIND_RSP
    100          };
    101          
    102          enum
    103          {
    104            ZDMATCH_SENDING_NOT,
    105            ZDMATCH_SENDING_UNBIND,
    106            ZDMATCH_SENDING_BIND
    107          };
    108          
    109          typedef struct
    110          {
    111            ZDEndDeviceBind_t ed1;
    112            ZDEndDeviceBind_t ed2;
    113            uint8  state;            // One of the above states
    114            uint8  sending;         // 0 - not sent, 1 - unbind, 2 bind - expecting response
    115            uint8  transSeq;
    116            uint8  ed1numMatched;
    117            uint16 *ed1Matched;
    118            uint8  ed2numMatched;
    119            uint16 *ed2Matched;
    120          } ZDMatchEndDeviceBind_t;
    121          #endif
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    138          static uint16 ZDOBuildBuf[26];  // temp area to build data without allocation
   \                     ??ZDOBuildBuf:
   \   000000                DS 52
    139          
    140          #if defined ( REFLECTOR )
    141          static ZDO_EDBind_t *ZDO_EDBind;     // Null when not used
    142          #endif
    143          
    144          #if defined ( MANAGED_SCAN )
    145            uint32 managedScanNextChannel = 0;
    146            uint32 managedScanChannelMask = 0;
    147            uint8  managedScanTimesPerChannel = 0;
    148          #endif
    149          
    150          #if defined ( ZDO_COORDINATOR )
    151            ZDMatchEndDeviceBind_t *matchED = (ZDMatchEndDeviceBind_t *)NULL;
    152          #endif
    153          
    154          /*********************************************************************
    155           * LOCAL FUNCTIONS
    156           */
    157          static void ZDODeviceSetup( void );
    158          static uint16 *ZDO_CreateAlignedUINT16List(uint8 num, uint8 *buf);
    159          #if defined ( MANAGED_SCAN )
    160            static void ZDOManagedScan_Next( void );
    161          #endif
    162          #if defined ( REFLECTOR )
    163            static void ZDO_RemoveEndDeviceBind( void );
    164            static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse );
    165          #endif
    166          #if defined ( REFLECTOR ) || defined( ZDO_COORDINATOR )
    167            static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    168                                          byte numList2, uint16 *list2, uint16 *pMatches );
    169          #endif
    170          #if defined ( ZDO_COORDINATOR )
    171            static void ZDO_RemoveMatchMemory( void );
    172            static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq );
    173            static uint8 ZDMatchSendState( uint8 reason, uint8 status, uint8 TransSeq );
    174            static void ZDO_EndDeviceBindMatchTimeoutCB( void );
    175          #endif
    176          
    177          /*********************************************************************
    178           * @fn          ZDO_Init
    179           *
    180           * @brief       ZDObject and ZDProfile initialization.
    181           *
    182           * @param       none
    183           *
    184           * @return      none
    185           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    186          void ZDO_Init( void )
   \                     ZDO_Init:
    187          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    188            // Initialize ZD items
    189            #if defined ( REFLECTOR )
    190            ZDO_EDBind = NULL;
    191            #endif
    192          
    193            // Setup the device - type of device to create.
    194            ZDODeviceSetup();
   \   000004                ; Setup parameters for call to function NLME_DeviceJoiningInit
   \   000004   90....       MOV     DPTR,#(NLME_DeviceJoiningInit & 0xffff)
   \   000007   74..         MOV     A,#((NLME_DeviceJoiningInit >> 16) & 0xff)
   \   000009   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    195          
    196            // Initialize ZigBee Device Security Manager
    197            ZDSecMgrInit();
   \   00000C                ; Setup parameters for call to function ZDSecMgrInit
   \   00000C   90....       MOV     DPTR,#(ZDSecMgrInit & 0xffff)
   \   00000F   74..         MOV     A,#((ZDSecMgrInit >> 16) & 0xff)
   \   000011   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    198          }
   \   000014                REQUIRE ?Subroutine21
   \   000014                ; // Fall through to label ?Subroutine21

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    199          
    200          #if defined ( MANAGED_SCAN )
    201          /*********************************************************************
    202           * @fn      ZDOManagedScan_Next()
    203           *
    204           * @brief   Setup a managed scan.
    205           *
    206           * @param   none
    207           *
    208           * @return  none
    209           */
    210          static void ZDOManagedScan_Next( void )
    211          {
    212            // Is it the first time
    213            if ( managedScanNextChannel == 0 && managedScanTimesPerChannel == 0 )
    214            {
    215              // Setup the defaults
    216              managedScanNextChannel  = 1;
    217          
    218              while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    219                managedScanNextChannel <<= 1;
    220          
    221              managedScanChannelMask = managedScanNextChannel;
    222              managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    223            }
    224            else
    225            {
    226              // Do we need to go to the next channel
    227              if ( managedScanTimesPerChannel == 0 )
    228              {
    229                // Find next active channel
    230                managedScanChannelMask  = managedScanNextChannel;
    231                managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    232              }
    233              else
    234              {
    235                managedScanTimesPerChannel--;
    236          
    237                if ( managedScanTimesPerChannel == 0 )
    238                {
    239                  managedScanNextChannel  <<= 1;
    240                  while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    241                    managedScanNextChannel <<= 1;
    242          
    243                  if ( managedScanNextChannel == 0 )
    244                    zdoDiscCounter  = NUM_DISC_ATTEMPTS + 1; // Stop
    245                }
    246              }
    247            }
    248          }
    249          #endif // MANAGED_SCAN
    250          
    251          /*********************************************************************
    252           * @fn      ZDODeviceSetup()
    253           *
    254           * @brief   Call set functions depending on the type of device compiled.
    255           *
    256           * @param   none
    257           *
    258           * @return  none
    259           */
    260          static void ZDODeviceSetup( void )
    261          {
    262          #if defined( ZDO_COORDINATOR )
    263            NLME_CoordinatorInit();
    264          #endif
    265          
    266          #if defined ( REFLECTOR )
    267            #if defined ( ZDO_COORDINATOR )
    268              APS_ReflectorInit( APS_REFLECTOR_PUBLIC );
    269            #else
    270              APS_ReflectorInit( APS_REFLECTOR_PRIVATE );
    271            #endif
    272          #endif
    273          
    274          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )
    275            NLME_DeviceJoiningInit();
    276          #endif
    277          }
    278          
    279          /*********************************************************************
    280           * @fn          ZDO_StartDevice
    281           *
    282           * @brief       This function starts a device in a network.
    283           *
    284           * @param       logicalType     - Device type to start
    285           *              startMode       - indicates mode of device startup
    286           *              beaconOrder     - indicates time betwen beacons
    287           *              superframeOrder - indicates length of active superframe
    288           *
    289           * @return      none
    290           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    291          void ZDO_StartDevice( byte logicalType, devStartModes_t startMode, byte beaconOrder, byte superframeOrder )
   \                     ZDO_StartDevice:
    292          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    293            ZStatus_t ret;
    294          
    295            ret = ZUnsupportedMode;
   \   00000A   7E12         MOV     R6,#0x12
    296          
    297          #if defined(ZDO_COORDINATOR)
    298            if ( logicalType == NODETYPE_COORDINATOR )
    299            {
    300              if ( startMode == MODE_HARD )
    301              {
    302                devState = DEV_COORD_STARTING;
    303                ret = NLME_NetworkFormationRequest( zgConfigPANID, zgDefaultChannelList,
    304                                                    zgDefaultStartingScanDuration, beaconOrder,
    305                                                    superframeOrder, false );
    306              }
    307              else if ( startMode == MODE_RESUME )
    308              {
    309                // Just start the coordinator
    310                devState = DEV_COORD_STARTING;
    311                ret = NLME_StartRouterRequest( beaconOrder, beaconOrder, false );
    312              }
    313              else
    314              {
    315          #if defined( LCD_SUPPORTED )
    316                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    317          #endif
    318              }
    319            }
    320          #endif  // !ZDO_COORDINATOR
    321          
    322          #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
    323            if ( logicalType == NODETYPE_ROUTER || logicalType == NODETYPE_DEVICE )
   \   00000C   7401         MOV     A,#0x1
   \   00000E   69           XRL     A,R1
   \   00000F   6008         JZ      ??ZDO_StartDevice_0
   \   000011   7402         MOV     A,#0x2
   \   000013   69           XRL     A,R1
   \   000014   6003         JZ      $+5
   \   000016   02....       LJMP    ??ZDO_StartDevice_1 & 0xFFFF
    324            {
    325              if ( (startMode == MODE_JOIN) || (startMode == MODE_REJOIN) )
   \                     ??ZDO_StartDevice_0:
   \   000019   EA           MOV     A,R2
   \   00001A   6005         JZ      ??ZDO_StartDevice_2
   \   00001C   7403         MOV     A,#0x3
   \   00001E   6A           XRL     A,R2
   \   00001F   7017         JNZ     ??ZDO_StartDevice_3
    326              {
    327                devState = DEV_NWK_DISC;
   \                     ??ZDO_StartDevice_2:
   \   000021   7402         MOV     A,#0x2
   \   000023   12....       LCALL   ?Subroutine1 & 0xFFFF
    328          
    329            #if defined( MANAGED_SCAN )
    330                ZDOManagedScan_Next();
    331                ret = NLME_NetworkDiscoveryRequest( managedScanChannelMask, BEACON_ORDER_15_MSEC );
    332            #else
    333                ret = NLME_NetworkDiscoveryRequest( zgDefaultChannelList, zgDefaultStartingScanDuration );
   \                     ??CrossCallReturnLabel_2:
   \   000026   12....       LCALL   ?L_MOV_X
   \   000029   AA..         MOV     R2,?V0 + 0
   \   00002B   AB..         MOV     R3,?V0 + 1
   \   00002D   AC..         MOV     R4,?V0 + 2
   \   00002F   AD..         MOV     R5,?V0 + 3
   \   000031   90....       MOV     DPTR,#(NLME_NetworkDiscoveryRequest & 0xffff)
   \   000034   74..         MOV     A,#((NLME_NetworkDiscoveryRequest >> 16) & 0xff)
   \   000036   8063         SJMP    ??ZDO_StartDevice_4
    334            #endif
    335              }
    336              else if ( startMode == MODE_RESUME )
   \                     ??ZDO_StartDevice_3:
   \   000038   7401         MOV     A,#0x1
   \   00003A   6A           XRL     A,R2
   \   00003B   7063         JNZ     ??ZDO_StartDevice_1
    337              {
    338                if ( logicalType == NODETYPE_ROUTER )
   \   00003D   7401         MOV     A,#0x1
   \   00003F   69           XRL     A,R1
   \   000040   7044         JNZ     ??ZDO_StartDevice_5
    339                {
    340                  ZMacScanCnf_t scanCnf;
    341                  devState = DEV_NWK_ORPHAN;
   \   000042   740A         MOV     A,#0xa
   \   000044   90....       MOV     DPTR,#devState
   \   000047   F0           MOVX    @DPTR,A
    342          
    343                  /* if router and nvram is available, fake successful orphan scan */
    344                  scanCnf.hdr.Status = ZSUCCESS;
   \   000048   7401         MOV     A,#0x1
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E4           CLR     A
   \   00004E   F0           MOVX    @DPTR,A
    345                  scanCnf.ScanType = ZMAC_ORPHAN_SCAN;
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   7403         MOV     A,#0x3
   \   000056   F0           MOVX    @DPTR,A
    346                  scanCnf.UnscannedChannels = 0;
   \   000057   90....       MOV     DPTR,#__Constant_0
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?L_MOV_X
   \   00005F   7404         MOV     A,#0x4
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?L_MOV_TO_X
    347                  scanCnf.ResultListSize = 0;
   \   000069   7408         MOV     A,#0x8
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   E4           CLR     A
   \   00006F   F0           MOVX    @DPTR,A
    348                  nwk_ScanJoiningOrphan(&scanCnf);
   \   000070                ; Setup parameters for call to function nwk_ScanJoiningOrphan
   \   000070   85..82       MOV     DPL,?XSP + 0
   \   000073   85..83       MOV     DPH,?XSP + 1
   \   000076   AA82         MOV     R2,DPL
   \   000078   AB83         MOV     R3,DPH
   \   00007A   90....       MOV     DPTR,#(nwk_ScanJoiningOrphan & 0xffff)
   \   00007D   74..         MOV     A,#((nwk_ScanJoiningOrphan >> 16) & 0xff)
   \   00007F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    349          
    350                  ret = ZSuccess;
   \   000082   7E00         MOV     R6,#0x0
   \   000084   801A         SJMP    ??ZDO_StartDevice_1
    351                }
    352                else
    353                {
    354                  devState = DEV_NWK_ORPHAN;
   \                     ??ZDO_StartDevice_5:
   \   000086   740A         MOV     A,#0xa
   \   000088   12....       LCALL   ?Subroutine1 & 0xFFFF
    355                  ret = NLME_OrphanJoinRequest( zgDefaultChannelList,
    356                                                zgDefaultStartingScanDuration );
   \                     ??CrossCallReturnLabel_3:
   \   00008B   12....       LCALL   ?L_MOV_X
   \   00008E   AA..         MOV     R2,?V0 + 0
   \   000090   AB..         MOV     R3,?V0 + 1
   \   000092   AC..         MOV     R4,?V0 + 2
   \   000094   AD..         MOV     R5,?V0 + 3
   \   000096   90....       MOV     DPTR,#(NLME_OrphanJoinRequest & 0xffff)
   \   000099   74..         MOV     A,#((NLME_OrphanJoinRequest >> 16) & 0xff)
   \                     ??ZDO_StartDevice_4:
   \   00009B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00009E   E9           MOV     A,R1
   \   00009F   FE           MOV     R6,A
    357                }
    358              }
    359              else
    360              {
    361          #if defined( LCD_SUPPORTED )
    362                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    363          #endif
    364              }
    365            }
    366          #endif  //!ZDO COORDINATOR || SOFT_START
    367          
    368            // configure the Security Manager for type of device
    369            ZDSecMgrConfig();
   \                     ??ZDO_StartDevice_1:
   \   0000A0                ; Setup parameters for call to function ZDSecMgrConfig
   \   0000A0   90....       MOV     DPTR,#(ZDSecMgrConfig & 0xffff)
   \   0000A3   74..         MOV     A,#((ZDSecMgrConfig >> 16) & 0xff)
   \   0000A5   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    370          
    371            if ( ret != ZSuccess )
   \   0000A8   EE           MOV     A,R6
   \   0000A9   6010         JZ      ??ZDO_StartDevice_6
    372              osal_start_timer( ZDO_NETWORK_INIT, NWK_RETRY_DELAY );
   \   0000AB                ; Setup parameters for call to function osal_start_timer
   \   0000AB   7CE8         MOV     R4,#-0x18
   \   0000AD   7D03         MOV     R5,#0x3
   \   0000AF   7A01         MOV     R2,#0x1
   \   0000B1   7B00         MOV     R3,#0x0
   \   0000B3   90....       MOV     DPTR,#(osal_start_timer & 0xffff)
   \   0000B6   74..         MOV     A,#((osal_start_timer >> 16) & 0xff)
   \   0000B8   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    373          }
   \                     ??ZDO_StartDevice_6:
   \   0000BB   740B         MOV     A,#0xb
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C0   02....       LJMP    ?Subroutine22 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   90....       MOV     DPTR,#devState
   \   000003   F0           MOVX    @DPTR,A
   \   000004                ; Setup parameters for call to function NLME_NetworkDiscoveryRequest
   \   000004                ; Setup parameters for call to function NLME_OrphanJoinRequest
   \   000004   90....       MOV     DPTR,#zgDefaultStartingScanDuration
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   90....       MOV     DPTR,#zgDefaultChannelList
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    374          
    375          /*********************************************************************
    376           * @fn      ZDO_UpdateNwkStatus()
    377           *
    378           * @brief
    379           *
    380           *   This function will send an update message to each registered
    381           *   application endpoint/interface about a network status change.
    382           *
    383           * @param   none
    384           *
    385           * @return  none
    386           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    387          void ZDO_UpdateNwkStatus( devStates_t state )
   \                     ZDO_UpdateNwkStatus:
    388          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
    389            // Endpoint/Interface descriptor list.
    390            epList_t *epDesc = epList;
   \   000007   90....       MOV     DPTR,#epList
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FE           MOV     R6,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FF           MOV     R7,A
    391            byte bufLen = sizeof(osal_event_hdr_t);
    392            osal_event_hdr_t *msgPtr;
    393          
    394            ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
   \   00000F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000F   90....       MOV     DPTR,#(NLME_GetShortAddr & 0xffff)
   \   000012   74..         MOV     A,#((NLME_GetShortAddr >> 16) & 0xff)
   \   000014   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000017   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00001A   EA           MOV     A,R2
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   EB           MOV     A,R3
   \   00001E   F0           MOVX    @DPTR,A
    395            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
   \   00001F                ; Setup parameters for call to function NLME_GetExtAddr
   \   00001F   90....       MOV     DPTR,#(NLME_GetExtAddr & 0xffff)
   \   000022   74..         MOV     A,#((NLME_GetExtAddr >> 16) & 0xff)
   \   000024   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000027   8041         SJMP    ??ZDO_UpdateNwkStatus_0
    396          
    397            while ( epDesc )
    398            {
    399              if ( epDesc->epDesc->endPoint != ZDO_EP )
   \                     ??ZDO_UpdateNwkStatus_1:
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000030   6027         JZ      ??ZDO_UpdateNwkStatus_2
    400              {
    401                msgPtr = (osal_event_hdr_t *)osal_msg_allocate( bufLen );
   \   000032                ; Setup parameters for call to function osal_msg_allocate
   \   000032   7A02         MOV     R2,#0x2
   \   000034   7B00         MOV     R3,#0x0
   \   000036   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000039   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   00003B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    402                if ( msgPtr )
   \   00003E   EA           MOV     A,R2
   \   00003F   7001         JNZ     ??ZDO_UpdateNwkStatus_3
   \   000041   EB           MOV     A,R3
   \                     ??ZDO_UpdateNwkStatus_3:
   \   000042   6015         JZ      ??ZDO_UpdateNwkStatus_2
    403                {
    404                  msgPtr->event = ZDO_STATE_CHANGE; // Command ID
   \   000044   74D1         MOV     A,#-0x2f
   \   000046   8A82         MOV     DPL,R2
   \   000048   8B83         MOV     DPH,R3
   \   00004A   F0           MOVX    @DPTR,A
    405                  msgPtr->status = (byte)state;
   \   00004B   A3           INC     DPTR
   \   00004C   E5..         MOV     A,?V0 + 0
   \   00004E   F0           MOVX    @DPTR,A
    406          
    407                  osal_msg_send( *(epDesc->epDesc->task_id), (byte *)msgPtr );
   \   00004F                ; Setup parameters for call to function osal_msg_send
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000056   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    408                }
    409              }
    410              epDesc = epDesc->nextDesc;
   \                     ??ZDO_UpdateNwkStatus_2:
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FE           MOV     R6,A
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \   000069   FF           MOV     R7,A
    411            }
   \                     ??ZDO_UpdateNwkStatus_0:
   \   00006A   EE           MOV     A,R6
   \   00006B   7001         JNZ     ??ZDO_UpdateNwkStatus_4
   \   00006D   EF           MOV     A,R7
   \                     ??ZDO_UpdateNwkStatus_4:
   \   00006E   70B9         JNZ     ??ZDO_UpdateNwkStatus_1
    412          }
   \   000070   02....       LJMP    ?Subroutine22 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \                     ??Subroutine18_0:
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000003   A3           INC     DPTR
   \   000004   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000007   F9           MOV     R1,A
   \   000008   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   00000B   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   00000D   22           RET
    413          
    414          #if defined ( REFLECTOR )
    415          /*********************************************************************
    416           * @fn          ZDO_RemoveEndDeviceBind
    417           *
    418           * @brief       Remove the end device bind
    419           *
    420           * @param  none
    421           *
    422           * @return      none
    423           */
    424          static void ZDO_RemoveEndDeviceBind( void )
    425          {
    426            if ( ZDO_EDBind )
    427            {
    428              // Free the RAM
    429              if ( ZDO_EDBind->inClusters )
    430                osal_mem_free( ZDO_EDBind->inClusters );
    431              if ( ZDO_EDBind->outClusters )
    432                osal_mem_free( ZDO_EDBind->outClusters );
    433              osal_mem_free( ZDO_EDBind );
    434              ZDO_EDBind = NULL;
    435            }
    436          }
    437          #endif // REFLECTOR
    438          
    439          #if defined ( REFLECTOR )
    440          /*********************************************************************
    441           * @fn          ZDO_RemoveEndDeviceBind
    442           *
    443           * @brief       Remove the end device bind
    444           *
    445           * @param  none
    446           *
    447           * @return      none
    448           */
    449          static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse )
    450          {
    451            ZDP_EndDeviceBindRsp( TransSeq, dstAddr, Status, secUse );
    452          
    453          #if defined( LCD_SUPPORTED )
    454            HalLcdWriteString( "End Device Bind", HAL_LCD_LINE_1 );
    455            if ( Status == ZDP_SUCCESS )
    456              HalLcdWriteString( "Success Sent", HAL_LCD_LINE_2 );
    457            else
    458              HalLcdWriteString( "Timeout", HAL_LCD_LINE_2 );
    459          #endif
    460          
    461          }
    462          #endif // REFLECTOR
    463          
    464          #if defined ( REFLECTOR ) || defined ( ZDO_COORDINATOR )
    465          /*********************************************************************
    466           * @fn          ZDO_CompareClusterLists
    467           *
    468           * @brief       Compare one list to another list
    469           *
    470           * @param       numList1 - number of items in list 1
    471           * @param       list1 - first list of cluster IDs
    472           * @param       numList2 - number of items in list 2
    473           * @param       list2 - second list of cluster IDs
    474           * @param       pMatches - buffer to put matches
    475           *
    476           * @return      number of matches
    477           */
    478          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    479                                    byte numList2, uint16 *list2, uint16 *pMatches )
    480          {
    481            byte x, y;
    482            uint16 z;
    483            byte numMatches = 0;
    484          
    485            // Check the first in against the seconds out
    486            for ( x = 0; x < numList1; x++ )
    487            {
    488              for ( y = 0; y < numList2; y++ )
    489              {
    490                z = list2[y];
    491                if ( list1[x] == z )
    492                  pMatches[numMatches++] = z;
    493              }
    494            }
    495          
    496            return ( numMatches );
    497          }
    498          #endif // REFLECTOR || ZDO_COORDINATOR
    499          
    500          #if defined ( REFLECTOR )
    501          /*********************************************************************
    502           * @fn          ZDO_DoEndDeviceBind
    503           *
    504           * @brief       Process the End Device Bind Req from ZDApp
    505           *
    506           * @param  bindReq  - Bind Request Information
    507           * @param  SecurityUse - Security enable/disable
    508           *
    509           * @return      none
    510           */
    511          void ZDO_DoEndDeviceBind( ZDEndDeviceBind_t *bindReq )
    512          {
    513            uint8 numMatches;
    514            uint8 Status;
    515            BindingEntry_t *pBind;
    516            AddrMgrEntry_t addrEntry;
    517            zAddrType_t SrcAddr;
    518          
    519            SrcAddr.addrMode = Addr16Bit;
    520            SrcAddr.addr.shortAddr = bindReq->srcAddr;
    521          
    522            // Ask for IEEE address
    523            if ( (bindReq->srcAddr != ZDAppNwkAddr.addr.shortAddr) )
    524            {
    525              addrEntry.user = ADDRMGR_USER_BINDING;
    526              addrEntry.nwkAddr = bindReq->srcAddr;
    527              Status = AddrMgrEntryLookupNwk( &addrEntry );
    528              if ( Status == TRUE)
    529              {
    530                // Add a reference to entry
    531                AddrMgrEntryAddRef( &addrEntry );
    532              }
    533              else
    534              {
    535                // If we have the extended address
    536                if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
    537                {
    538                  osal_cpyExtAddr( addrEntry.extAddr, bindReq->ieeeAddr );
    539                }
    540          
    541                // Not in address manager?
    542                AddrMgrEntryUpdate( &addrEntry );   // Add it
    543              }
    544          
    545              if ( AddrMgrExtAddrValid( addrEntry.extAddr ) == FALSE )
    546              {
    547                ZDP_IEEEAddrReq( bindReq->srcAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, false );
    548              }
    549            }
    550          
    551            if ( ZDO_EDBind )   // End Device Bind in progress
    552            {
    553              Status = ZDP_NO_MATCH;
    554          
    555              if ( bindReq->profileID == ZDO_EDBind->ProfileID )
    556              {
    557                // Check the first in against the seconds out
    558                numMatches = ZDO_CompareClusterLists(
    559                            ZDO_EDBind->numOutClusters, ZDO_EDBind->outClusters,
    560                            bindReq->numInClusters, bindReq->inClusters, ZDOBuildBuf );
    561          
    562                if ( numMatches )
    563                {
    564                  // if existing bind exists, remove it
    565                  pBind = bindFindExisting( &(ZDO_EDBind->SrcAddr), ZDO_EDBind->epIntf,
    566                                &SrcAddr, bindReq->endpoint );
    567                  if ( pBind )
    568                  {
    569                    bindRemoveEntry( pBind );
    570                    Status = ZDP_SUCCESS;
    571                  }
    572                  // else add new binding table entry
    573                  else if ( bindAddEntry( &(ZDO_EDBind->SrcAddr), ZDO_EDBind->epIntf,
    574                                &SrcAddr, bindReq->endpoint, numMatches, ZDOBuildBuf ) )
    575                    Status = ZDP_SUCCESS;
    576                  else
    577                    Status = ZDP_TABLE_FULL;
    578                }
    579          
    580                // Check the second in against the first out
    581                numMatches = ZDO_CompareClusterLists( bindReq->numOutClusters, bindReq->outClusters,
    582                                ZDO_EDBind->numInClusters, ZDO_EDBind->inClusters,
    583                                ZDOBuildBuf );
    584          
    585                if ( numMatches )
    586                {
    587                  // if existing bind exists, remove it
    588                  pBind = bindFindExisting( &SrcAddr, bindReq->endpoint, &(ZDO_EDBind->SrcAddr),
    589                                ZDO_EDBind->epIntf );
    590                  if ( pBind )
    591                  {
    592                    bindRemoveEntry( pBind );
    593                    Status = ZDP_SUCCESS;
    594                  }
    595                  // else add new binding table entry
    596                  else if ( bindAddEntry( &SrcAddr, bindReq->endpoint, &(ZDO_EDBind->SrcAddr),
    597                                ZDO_EDBind->epIntf, numMatches, ZDOBuildBuf ) )
    598                    Status = ZDP_SUCCESS;
    599                  else
    600                    Status = ZDP_TABLE_FULL;
    601                }
    602              }
    603          
    604              if ( Status == ZDP_SUCCESS )
    605              {
    606                // We've found a match, so we don't have to wait for the timeout
    607                APS_SetEndDeviceBindTimeout( 10, ZDO_EndDeviceTimeoutCB );  // psuedo stop end device timeout
    608          
    609                  // Notify to save info into NV
    610                osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
    611              }
    612          
    613              ZDO_EDBind->status = Status;
    614          
    615              // Send the response message to the device sending this message
    616              ZDO_SendEDBindRsp( bindReq->TransSeq, &SrcAddr, Status, bindReq->SecurityUse );
    617            }
    618            else  // Start a new End Device Bind
    619            {
    620              // Copy the info
    621              ZDO_EDBind = osal_mem_alloc( sizeof( ZDO_EDBind_t ) );
    622              if ( ZDO_EDBind )
    623              {
    624                osal_memcpy( &(ZDO_EDBind->SrcAddr), &SrcAddr, sizeof( zAddrType_t ) );
    625                ZDO_EDBind->LocalCoordinator = bindReq->localCoordinator;
    626                ZDO_EDBind->epIntf = bindReq->endpoint;
    627                ZDO_EDBind->ProfileID = bindReq->profileID;
    628                ZDO_EDBind->SrcTransSeq = bindReq->TransSeq;
    629          
    630                ZDO_EDBind->numInClusters = bindReq->numInClusters;
    631                if ( bindReq->numInClusters )
    632                {
    633                  ZDO_EDBind->inClusters = osal_mem_alloc( (short)(bindReq->numInClusters * sizeof(uint16)) );
    634                  if ( ZDO_EDBind->inClusters )
    635                  {
    636                    osal_memcpy( ZDO_EDBind->inClusters, bindReq->inClusters, (bindReq->numInClusters * sizeof( uint16 )) );
    637                  }
    638                  else
    639                  {
    640                    // Force no clusters
    641                    ZDO_EDBind->numInClusters = 0;
    642                  }
    643                }
    644                else
    645                  ZDO_EDBind->inClusters = NULL;
    646          
    647                ZDO_EDBind->numOutClusters = bindReq->numOutClusters;
    648                if ( bindReq->numOutClusters )
    649                {
    650                  ZDO_EDBind->outClusters = osal_mem_alloc( (short)(bindReq->numOutClusters*sizeof(uint16)) );
    651                  if ( ZDO_EDBind->outClusters )
    652                  {
    653                    osal_memcpy( ZDO_EDBind->outClusters, bindReq->outClusters, (bindReq->numOutClusters * sizeof( uint16 )) );
    654                  }
    655                  else
    656                  {
    657                    ZDO_EDBind->numOutClusters = 0;
    658                  }
    659                }
    660                else
    661                  ZDO_EDBind->outClusters = NULL;
    662          
    663                ZDO_EDBind->SecurityUse = bindReq->SecurityUse;
    664                ZDO_EDBind->status = ZDP_TIMEOUT;
    665          
    666                // Setup the timer
    667                APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceTimeoutCB );
    668              }
    669            }
    670          }
    671          #endif // REFLECTOR
    672          
    673          /*********************************************************************
    674           * Utility functions
    675           */
    676          
    677          /*********************************************************************
    678           * @fn          ZDO_CreateAlignedUINT16List
    679           *
    680           * @brief       Creates a list of cluster IDs that is guaranteed to be aligned.
    681           *              according to the needs of the target. If thre device is running
    682           *              Protocol version 1.0 the incoming buffer will have only a single
    683           *              byte for the cluster ID.
    684           *
    685           *              Depends on the malloc taking care of alignment.
    686           *
    687           *              When cluster ID went to 16 bits alignment for cluster IDs became
    688           *              an issue.
    689           *
    690           * @param       num  - number of entries in list
    691           * @param       buf  - pointer to list
    692           *
    693           * @return      pointer to aligned list. Null if can't allocate memory.
    694           *              Caller's responsibility to free memory.
    695           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    696          static uint16 *ZDO_CreateAlignedUINT16List(uint8 num, uint8 *buf)
   \                     ??ZDO_CreateAlignedUINT16List:
    697          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    698            uint16 *ptr;
    699          
    700            if ((ptr=osal_mem_alloc((short)(num*sizeof(uint16)))))  {
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E9           MOV     A,R1
   \   00000C   C3           CLR     C
   \   00000D   33           RLC     A
   \   00000E   FA           MOV     R2,A
   \   00000F   E4           CLR     A
   \   000010   33           RLC     A
   \   000011   FB           MOV     R3,A
   \   000012   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   000015   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   000017   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001A   8A..         MOV     ?V0 + 0,R2
   \   00001C   8B..         MOV     ?V0 + 1,R3
   \   00001E   EA           MOV     A,R2
   \   00001F   7001         JNZ     ??ZDO_CreateAlignedUINT16List_1
   \   000021   EB           MOV     A,R3
   \                     ??ZDO_CreateAlignedUINT16List_1:
   \   000022   605D         JZ      ??ZDO_CreateAlignedUINT16List_2
    701              uint8 i, ubyte, inc;
    702          
    703              inc = (ZB_PROT_V1_1 == NLME_GetProtocolVersion()) ? 2 : 1;
   \   000024                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   000024   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   000027   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   000029   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00002C   E9           MOV     A,R1
   \   00002D   6402         XRL     A,#0x2
   \   00002F   7004         JNZ     ??ZDO_CreateAlignedUINT16List_3
   \   000031   7B02         MOV     R3,#0x2
   \   000033   8002         SJMP    ??ZDO_CreateAlignedUINT16List_4
   \                     ??ZDO_CreateAlignedUINT16List_3:
   \   000035   7B01         MOV     R3,#0x1
    704          
    705              for (i=0; i<num; ++i)  {
   \                     ??ZDO_CreateAlignedUINT16List_4:
   \   000037   7A00         MOV     R2,#0x0
   \   000039   8031         SJMP    ??ZDO_CreateAlignedUINT16List_5
    706                // set upper byte to 0 if we're talking Version 1.0. otherwise
    707                // the buffer contains 16 bit cluster IDs.
    708                ubyte  = (2 == inc) ? buf[1] : 0;
   \                     ??ZDO_CreateAlignedUINT16List_6:
   \   00003B   75..00       MOV     ?V0 + 3,#0x0
    709                ptr[i] = BUILD_UINT16(buf[0], ubyte);
   \                     ??ZDO_CreateAlignedUINT16List_7:
   \   00003E   8E82         MOV     DPL,R6
   \   000040   8F83         MOV     DPH,R7
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FC           MOV     R4,A
   \   000044   E4           CLR     A
   \   000045   2C           ADD     A,R4
   \   000046   E5..         MOV     A,?V0 + 3
   \   000048   3400         ADDC    A,#0x0
   \   00004A   FD           MOV     R5,A
   \   00004B   EA           MOV     A,R2
   \   00004C   C3           CLR     C
   \   00004D   33           RLC     A
   \   00004E   F8           MOV     R0,A
   \   00004F   E4           CLR     A
   \   000050   33           RLC     A
   \   000051   F9           MOV     R1,A
   \   000052   E5..         MOV     A,?V0 + 0
   \   000054   28           ADD     A,R0
   \   000055   F582         MOV     DPL,A
   \   000057   E5..         MOV     A,?V0 + 1
   \   000059   39           ADDC    A,R1
   \   00005A   F583         MOV     DPH,A
   \   00005C   EC           MOV     A,R4
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   ED           MOV     A,R5
   \   000060   F0           MOVX    @DPTR,A
    710                buf    += inc;
   \   000061   8B..         MOV     ?V0 + 4,R3
   \   000063   EE           MOV     A,R6
   \   000064   25..         ADD     A,?V0 + 4
   \   000066   FE           MOV     R6,A
   \   000067   EF           MOV     A,R7
   \   000068   3400         ADDC    A,#0x0
   \   00006A   FF           MOV     R7,A
   \   00006B   0A           INC     R2
   \                     ??ZDO_CreateAlignedUINT16List_5:
   \   00006C   EA           MOV     A,R2
   \   00006D   C3           CLR     C
   \   00006E   95..         SUBB    A,?V0 + 2
   \   000070   500F         JNC     ??ZDO_CreateAlignedUINT16List_2
   \   000072   7402         MOV     A,#0x2
   \   000074   6B           XRL     A,R3
   \   000075   70C4         JNZ     ??ZDO_CreateAlignedUINT16List_6
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F5..         MOV     ?V0 + 3,A
   \   00007F   80BD         SJMP    ??ZDO_CreateAlignedUINT16List_7
    711              }
    712            }
    713          
    714            return ptr;
   \                     ??ZDO_CreateAlignedUINT16List_2:
   \   000081   AA..         MOV     R2,?V0 + 0
   \   000083   AB..         MOV     R3,?V0 + 1
   \   000085                REQUIRE ?Subroutine24
   \   000085                ; // Fall through to label ?Subroutine24
    715          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    716          
    717          /*********************************************************************
    718           * @fn          ZDO_CompareByteLists
    719           *
    720           * @brief       Compares two lists for matches.
    721           *
    722           * @param       ACnt  - number of entries in list A
    723           * @param       AList  - List A
    724           * @param       BCnt  - number of entries in list B
    725           * @param       BList  - List B
    726           *
    727           * @return      true if a match is found
    728           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    729          byte ZDO_AnyClusterMatches( byte ACnt, uint16 *AList, byte BCnt, uint16 *BList )
   \                     ZDO_AnyClusterMatches:
    730          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8C..         MOV     ?V0 + 1,R4
   \   000009   740C         MOV     A,#0xc
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine13 & 0xFFFF
    731            byte x, y;
    732          
    733            for ( x = 0; x < ACnt; x++ )
   \                     ??CrossCallReturnLabel_32:
   \   000011   75..00       MOV     ?V0 + 3,#0x0
   \   000014   8002         SJMP    ??ZDO_AnyClusterMatches_0
   \                     ??ZDO_AnyClusterMatches_1:
   \   000016   05..         INC     ?V0 + 3
   \                     ??ZDO_AnyClusterMatches_0:
   \   000018   E5..         MOV     A,?V0 + 3
   \   00001A   C3           CLR     C
   \   00001B   95..         SUBB    A,?V0 + 0
   \   00001D   5040         JNC     ??ZDO_AnyClusterMatches_2
    734            {
    735              for ( y = 0; y < BCnt; y++ )
   \   00001F   75..00       MOV     ?V0 + 2,#0x0
   \   000022   8002         SJMP    ??ZDO_AnyClusterMatches_3
   \                     ??ZDO_AnyClusterMatches_4:
   \   000024   05..         INC     ?V0 + 2
   \                     ??ZDO_AnyClusterMatches_3:
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   C3           CLR     C
   \   000029   95..         SUBB    A,?V0 + 1
   \   00002B   50E9         JNC     ??ZDO_AnyClusterMatches_1
    736              {
    737                if ( AList[x] == BList[y] )
   \   00002D   E5..         MOV     A,?V0 + 3
   \   00002F   C3           CLR     C
   \   000030   33           RLC     A
   \   000031   FC           MOV     R4,A
   \   000032   E4           CLR     A
   \   000033   33           RLC     A
   \   000034   FD           MOV     R5,A
   \   000035   EA           MOV     A,R2
   \   000036   2C           ADD     A,R4
   \   000037   F582         MOV     DPL,A
   \   000039   EB           MOV     A,R3
   \   00003A   3D           ADDC    A,R5
   \   00003B   F583         MOV     DPH,A
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FE           MOV     R6,A
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   FF           MOV     R7,A
   \   000042   E5..         MOV     A,?V0 + 2
   \   000044   C3           CLR     C
   \   000045   33           RLC     A
   \   000046   FC           MOV     R4,A
   \   000047   E4           CLR     A
   \   000048   33           RLC     A
   \   000049   FD           MOV     R5,A
   \   00004A   E8           MOV     A,R0
   \   00004B   2C           ADD     A,R4
   \   00004C   F582         MOV     DPL,A
   \   00004E   E9           MOV     A,R1
   \   00004F   3D           ADDC    A,R5
   \   000050   F583         MOV     DPH,A
   \   000052   E0           MOVX    A,@DPTR
   \   000053   6E           XRL     A,R6
   \   000054   7003         JNZ     ??ZDO_AnyClusterMatches_5
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   6F           XRL     A,R7
   \                     ??ZDO_AnyClusterMatches_5:
   \   000059   70C9         JNZ     ??ZDO_AnyClusterMatches_4
    738                {
    739                  return true;
   \   00005B   7901         MOV     R1,#0x1
   \   00005D   8002         SJMP    ??ZDO_AnyClusterMatches_6
    740                }
    741              }
    742            }
    743          
    744            return false;
   \                     ??ZDO_AnyClusterMatches_2:
   \   00005F   7900         MOV     R1,#0x0
   \                     ??ZDO_AnyClusterMatches_6:
   \   000061   80..         SJMP    ?Subroutine22
    745          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    746          
    747          /*********************************************************************
    748           * Callback functions from ZDProfile
    749           */
    750          
    751          /*********************************************************************
    752           * @fn          ZDO_ProcessNodeDescReq
    753           *
    754           * @brief       This function processes and responds to the
    755           *              Node_Desc_req message.
    756           *
    757           * @param       src  - Source address
    758           * @param       msg - NWKAddrOfInterest
    759           * @param       sty - Security enable/disable
    760           *
    761           * @return      none
    762           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    763          void ZDO_ProcessNodeDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessNodeDescReq:
    764          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740C         MOV     A,#0xc
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine4 & 0xFFFF
    765            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
    766            NodeDescriptorFormat_t *desc = NULL;
    767            byte stat = ZDP_INVALID_REQTYPE;
    768          
    769            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??CrossCallReturnLabel_12:
   \   000011   7004         JNZ     ??ZDO_ProcessNodeDescReq_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   65..         XRL     A,?V0 + 1
   \                     ??ZDO_ProcessNodeDescReq_0:
   \   000017   7026         JNZ     ??ZDO_ProcessNodeDescReq_1
    770            {
    771              desc = &ZDO_Config_Node_Descriptor;
    772            }
    773          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    774            else if ( CACHE_SERVER )
    775            {
    776              desc = (NodeDescriptorFormat_t *)ZDCacheGetDesc( aoi, eNodeDesc, &stat );
    777            }
    778          #endif
    779          
    780            if ( desc != NULL )
    781            {
    782              ZDP_NodeDescMsg( seq, src, aoi, desc, sty );
   \   000019                ; Setup parameters for call to function ZDP_NodeDescMsg
   \   000019   ED           MOV     A,R5
   \   00001A   F5..         MOV     ?V0 + 2,A
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000021   75....       MOV     ?V0 + 2,#(ZDO_Config_Node_Descriptor & 0xff)
   \   000024   75....       MOV     ?V0 + 3,#((ZDO_Config_Node_Descriptor >> 8) & 0xff)
   \   000027   78..         MOV     R0,#?V0 + 2
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   AC..         MOV     R4,?V0 + 0
   \   00002E   AD..         MOV     R5,?V0 + 1
   \   000030   90....       MOV     DPTR,#(ZDP_NodeDescMsg & 0xffff)
   \   000033   74..         MOV     A,#((ZDP_NodeDescMsg >> 16) & 0xff)
   \   000035   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000038   7403         MOV     A,#0x3
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003D   801F         SJMP    ??ZDO_ProcessNodeDescReq_2
    783            }
    784            else
    785            {
    786              ZDP_GenericRsp( seq, src, stat, aoi, Node_Desc_rsp, sty );
   \                     ??ZDO_ProcessNodeDescReq_1:
   \   00003F                ; Setup parameters for call to function ZDP_GenericRsp
   \   00003F   75..02       MOV     ?V0 + 2,#0x2
   \   000042   75..80       MOV     ?V0 + 3,#-0x80
   \   000045   78..         MOV     R0,#?V0 + 2
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7C80         MOV     R4,#-0x80
   \   000051   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   000054   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   000056   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
    787            }
    788          }
   \                     ??ZDO_ProcessNodeDescReq_2:
   \   00005E                REQUIRE ?Subroutine22
   \   00005E                ; // Fall through to label ?Subroutine22

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FD           MOV     R5,A
   \   000002   8E82         MOV     DPL,R6
   \   000004   8F83         MOV     DPH,R7
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0 + 0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FF           MOV     R7,A
   \   00000C   E4           CLR     A
   \   00000D   25..         ADD     A,?V0 + 0
   \   00000F   EF           MOV     A,R7
   \   000010   3400         ADDC    A,#0x0
   \   000012   F5..         MOV     ?V0 + 1,A
   \   000014   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000017   E0           MOVX    A,@DPTR
   \   000018   65..         XRL     A,?V0 + 0
   \   00001A   22           RET
    789          
    790          /*********************************************************************
    791           * @fn          ZDO_ProcessPowerDescReq
    792           *
    793           * @brief       This function processes and responds to the
    794           *              Node_Power_req message.
    795           *
    796           * @param       src  - Source address
    797           * @param       msg - NWKAddrOfInterest
    798           * @param       sty - Security enable/disable
    799           *
    800           * @return      none
    801           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    802          void ZDO_ProcessPowerDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessPowerDescReq:
    803          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740C         MOV     A,#0xc
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine4 & 0xFFFF
    804            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
    805            NodePowerDescriptorFormat_t *desc = NULL;
    806            byte stat = ZDP_INVALID_REQTYPE;
    807          
    808            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??CrossCallReturnLabel_13:
   \   000011   7004         JNZ     ??ZDO_ProcessPowerDescReq_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   65..         XRL     A,?V0 + 1
   \                     ??ZDO_ProcessPowerDescReq_0:
   \   000017   7026         JNZ     ??ZDO_ProcessPowerDescReq_1
    809            {
    810              desc = &ZDO_Config_Power_Descriptor;
    811            }
    812          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    813            else if ( CACHE_SERVER )
    814            {
    815              desc = (NodePowerDescriptorFormat_t *)ZDCacheGetDesc(aoi,ePowerDesc,&stat);
    816            }
    817          #endif
    818          
    819            if ( desc != NULL )
    820            {
    821              ZDP_PowerDescMsg( seq, src, aoi, desc, sty );
   \   000019                ; Setup parameters for call to function ZDP_PowerDescMsg
   \   000019   ED           MOV     A,R5
   \   00001A   F5..         MOV     ?V0 + 2,A
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000021   75....       MOV     ?V0 + 2,#(ZDO_Config_Power_Descriptor & 0xff)
   \   000024   75....       MOV     ?V0 + 3,#((ZDO_Config_Power_Descriptor >> 8) & 0xff)
   \   000027   78..         MOV     R0,#?V0 + 2
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   AC..         MOV     R4,?V0 + 0
   \   00002E   AD..         MOV     R5,?V0 + 1
   \   000030   90....       MOV     DPTR,#(ZDP_PowerDescMsg & 0xffff)
   \   000033   74..         MOV     A,#((ZDP_PowerDescMsg >> 16) & 0xff)
   \   000035   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000038   7403         MOV     A,#0x3
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003D   801F         SJMP    ??ZDO_ProcessPowerDescReq_2
    822            }
    823            else
    824            {
    825              ZDP_GenericRsp( seq, src, stat, aoi, Power_Desc_rsp, sty );
   \                     ??ZDO_ProcessPowerDescReq_1:
   \   00003F                ; Setup parameters for call to function ZDP_GenericRsp
   \   00003F   75..03       MOV     ?V0 + 2,#0x3
   \   000042   75..80       MOV     ?V0 + 3,#-0x80
   \   000045   78..         MOV     R0,#?V0 + 2
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7C80         MOV     R4,#-0x80
   \   000051   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   000054   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   000056   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
    826            }
    827          }
   \                     ??ZDO_ProcessPowerDescReq_2:
   \   00005E   80..         SJMP    ?Subroutine22
    828          
    829          /*********************************************************************
    830           * @fn          ZDO_ProcessSimpleDescReq
    831           *
    832           * @brief       This function processes and responds to the
    833           *              Simple_Desc_req message.
    834           *
    835           * @param       src - Source address
    836           * @param       msg - message data
    837           * @param       sty - Security enable/disable
    838           *
    839           * @return      none
    840           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    841          void ZDO_ProcessSimpleDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessSimpleDescReq:
    842          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   7410         MOV     A,#0x10
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F5..         MOV     ?V0 + 1,A
    843            SimpleDescriptionFormat_t *sDesc = NULL;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   E4           CLR     A
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   12....       LCALL   ?Subroutine0 & 0xFFFF
    844            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   \                     ??CrossCallReturnLabel_0:
   \   000024   F8           MOV     R0,A
   \   000025   E9           MOV     A,R1
   \   000026   3400         ADDC    A,#0x0
   \   000028   F9           MOV     R1,A
    845            byte endPoint = msg[2];
   \   000029   8C82         MOV     DPL,R4
   \   00002B   8D83         MOV     DPH,R5
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
    846            byte free = false;
   \   000031   75..00       MOV     ?V0 + 5,#0x0
    847            byte stat = ZDP_SUCCESS;
   \   000034   75..00       MOV     ?V0 + 4,#0x0
    848          
    849            if ( (endPoint == ZDO_EP) || (endPoint > MAX_ENDPOINTS) )
   \   000037   6005         JZ      ??ZDO_ProcessSimpleDescReq_0
   \   000039   C3           CLR     C
   \   00003A   94F1         SUBB    A,#-0xf
   \   00003C   4005         JC      ??ZDO_ProcessSimpleDescReq_1
    850            {
    851              stat = ZDP_INVALID_EP;
   \                     ??ZDO_ProcessSimpleDescReq_0:
   \   00003E   75..82       MOV     ?V0 + 4,#-0x7e
   \   000041   8038         SJMP    ??ZDO_ProcessSimpleDescReq_2
    852            }
    853            else if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??ZDO_ProcessSimpleDescReq_1:
   \   000043   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000046   E0           MOVX    A,@DPTR
   \   000047   68           XRL     A,R0
   \   000048   7003         JNZ     ??ZDO_ProcessSimpleDescReq_3
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   69           XRL     A,R1
   \                     ??ZDO_ProcessSimpleDescReq_3:
   \   00004D   7029         JNZ     ??ZDO_ProcessSimpleDescReq_4
    854            {
    855              free = afFindSimpleDesc( &sDesc, endPoint );
   \   00004F                ; Setup parameters for call to function afFindSimpleDesc
   \   00004F   EA           MOV     A,R2
   \   000050   F9           MOV     R1,A
   \   000051   85..82       MOV     DPL,?XSP + 0
   \   000054   85..83       MOV     DPH,?XSP + 1
   \   000057   AA82         MOV     R2,DPL
   \   000059   AB83         MOV     R3,DPH
   \   00005B   90....       MOV     DPTR,#(afFindSimpleDesc & 0xffff)
   \   00005E   74..         MOV     A,#((afFindSimpleDesc >> 16) & 0xff)
   \   000060   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000063   E9           MOV     A,R1
   \   000064   F5..         MOV     ?V0 + 5,A
    856              if ( sDesc == NULL )
   \   000066   85..82       MOV     DPL,?XSP + 0
   \   000069   85..83       MOV     DPH,?XSP + 1
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   7002         JNZ     ??ZDO_ProcessSimpleDescReq_5
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessSimpleDescReq_5:
   \   000071   7008         JNZ     ??ZDO_ProcessSimpleDescReq_2
    857              {
    858                stat = ZDP_NOT_ACTIVE;
   \   000073   75..83       MOV     ?V0 + 4,#-0x7d
   \   000076   8003         SJMP    ??ZDO_ProcessSimpleDescReq_2
    859              }
    860            }
    861          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    862            else if ( CACHE_SERVER )
    863            {
    864              stat = endPoint;
    865              sDesc = (SimpleDescriptionFormat_t *)ZDCacheGetDesc(aoi, eSimpDesc, &stat);
    866            }
    867          #endif
    868            else
    869            {
    870          #if defined ( RTR_NWK )
    871              stat = ZDP_DEVICE_NOT_FOUND;
    872          #else
    873              stat = ZDP_INVALID_REQTYPE;
   \                     ??ZDO_ProcessSimpleDescReq_4:
   \   000078   75..80       MOV     ?V0 + 4,#-0x80
    874          #endif
    875            }
    876          
    877            ZDP_SimpleDescMsg( seq, src, stat, sDesc, Simple_Desc_rsp, sty );
   \                     ??ZDO_ProcessSimpleDescReq_2:
   \   00007B                ; Setup parameters for call to function ZDP_SimpleDescMsg
   \   00007B   75..04       MOV     ?V0 + 2,#0x4
   \   00007E   75..80       MOV     ?V0 + 3,#-0x80
   \   000081   78..         MOV     R0,#?V0 + 2
   \   000083   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000086   7402         MOV     A,#0x2
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00008E   AD..         MOV     R5,?V0 + 1
   \   000090   AC..         MOV     R4,?V0 + 4
   \   000092   EE           MOV     A,R6
   \   000093   FA           MOV     R2,A
   \   000094   EF           MOV     A,R7
   \   000095   FB           MOV     R3,A
   \   000096   A9..         MOV     R1,?V0 + 0
   \   000098   90....       MOV     DPTR,#(ZDP_SimpleDescMsg & 0xffff)
   \   00009B   74..         MOV     A,#((ZDP_SimpleDescMsg >> 16) & 0xff)
   \   00009D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000A0   7404         MOV     A,#0x4
   \   0000A2   12....       LCALL   ?DEALLOC_XSTACK8
    878          
    879            if ( free )
   \   0000A5   E5..         MOV     A,?V0 + 5
   \   0000A7   600C         JZ      ??ZDO_ProcessSimpleDescReq_6
    880            {
    881              osal_mem_free( sDesc );
   \   0000A9                ; Setup parameters for call to function osal_mem_free
   \   0000A9   85..82       MOV     DPL,?XSP + 0
   \   0000AC   85..83       MOV     DPH,?XSP + 1
   \   0000AF   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0000B2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    882            }
    883          }
   \                     ??ZDO_ProcessSimpleDescReq_6:
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BA   02....       LJMP    ?Subroutine24 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000003   90....       MOV     DPTR,#(osal_mem_free & 0xffff)
   \   000006   74..         MOV     A,#((osal_mem_free >> 16) & 0xff)
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FA           MOV     R2,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F9           MOV     R1,A
   \   00000A   E4           CLR     A
   \   00000B   2A           ADD     A,R2
   \   00000C   22           RET
    884          
    885          /*********************************************************************
    886           * @fn          ZDO_ProcessActiveEPReq
    887           *
    888           * @brief       This function processes and responds to the
    889           *              Active_EP_req message.
    890           *
    891           * @param       src  - Source address
    892           * @param       sty - Security enable/disable
    893           *
    894           * @return      none
    895           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    896          void ZDO_ProcessActiveEPReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessActiveEPReq:
    897          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 6,R2
   \   000009   8B..         MOV     ?V0 + 7,R3
   \   00000B   7410         MOV     A,#0x10
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 1,A
    898            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   \   000013   8C82         MOV     DPL,R4
   \   000015   8D83         MOV     DPH,R5
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E4           CLR     A
   \   00001D   2A           ADD     A,R2
   \   00001E   FE           MOV     R6,A
   \   00001F   E9           MOV     A,R1
   \   000020   3400         ADDC    A,#0x0
   \   000022   FF           MOV     R7,A
    899            byte cnt = CACHE_EP_MAX;
    900            byte stat = ZDP_SUCCESS;
    901          
    902            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \   000023   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000026   E0           MOVX    A,@DPTR
   \   000027   6E           XRL     A,R6
   \   000028   7003         JNZ     ??ZDO_ProcessActiveEPReq_0
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   6F           XRL     A,R7
   \                     ??ZDO_ProcessActiveEPReq_0:
   \   00002D   7063         JNZ     ??ZDO_ProcessActiveEPReq_1
    903            {
    904              cnt = afNumEndPoints() - 1;  // -1 for ZDO endpoint descriptor
   \   00002F                ; Setup parameters for call to function afNumEndPoints
   \   00002F   90....       MOV     DPTR,#(afNumEndPoints & 0xffff)
   \   000032   74..         MOV     A,#((afNumEndPoints >> 16) & 0xff)
   \   000034   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000037   E9           MOV     A,R1
   \   000038   14           DEC     A
   \   000039   F5..         MOV     ?V0 + 2,A
    905              afEndPoints( (uint8 *)ZDOBuildBuf, true );
   \   00003B                ; Setup parameters for call to function afEndPoints
   \   00003B   7901         MOV     R1,#0x1
   \   00003D   7A..         MOV     R2,#(??ZDOBuildBuf & 0xff)
   \   00003F   7B..         MOV     R3,#((??ZDOBuildBuf >> 8) & 0xff)
   \   000041   90....       MOV     DPTR,#(afEndPoints & 0xffff)
   \   000044   74..         MOV     A,#((afEndPoints >> 16) & 0xff)
   \   000046   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    906            }
    907          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    908            else if ( CACHE_SERVER )
    909            {
    910              cnt = *((byte *)ZDCacheGetDesc(aoi, eActEPDesc, (uint8 *)ZDOBuildBuf));
    911              // If cnt = 0, err code in 1st byte of buf, otherwise EP list is in the buf.
    912              if ( cnt == 0 )
    913              {
    914                stat = ZDOBuildBuf[0];
    915              }
    916            }
    917          #endif
    918            else
    919            {
    920              stat = ZDP_INVALID_REQTYPE;
    921            }
    922          
    923            if ( cnt != CACHE_EP_MAX )
   \   000049   7404         MOV     A,#0x4
   \   00004B   65..         XRL     A,?V0 + 2
   \   00004D   6043         JZ      ??ZDO_ProcessActiveEPReq_1
    924            {
    925              ZDP_ActiveEPRsp( seq, src, stat, aoi, cnt, (uint8 *)ZDOBuildBuf, sty );
   \   00004F                ; Setup parameters for call to function ZDP_EPRsp
   \   00004F   78..         MOV     R0,#?V0 + 1
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000054   75....       MOV     ?V0 + 4,#(??ZDOBuildBuf & 0xff)
   \   000057   75....       MOV     ?V0 + 5,#((??ZDOBuildBuf >> 8) & 0xff)
   \   00005A   78..         MOV     R0,#?V0 + 4
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005F   E5..         MOV     A,?V0 + 2
   \   000061   F5..         MOV     ?V0 + 1,A
   \   000063   78..         MOV     R0,#?V0 + 1
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000068   8E..         MOV     ?V0 + 2,R6
   \   00006A   8F..         MOV     ?V0 + 3,R7
   \   00006C   78..         MOV     R0,#?V0 + 2
   \   00006E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000071   75..00       MOV     ?V0 + 1,#0x0
   \   000074   78..         MOV     R0,#?V0 + 1
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000079   AC..         MOV     R4,?V0 + 6
   \   00007B   AD..         MOV     R5,?V0 + 7
   \   00007D   A9..         MOV     R1,?V0 + 0
   \   00007F   7A05         MOV     R2,#0x5
   \   000081   7B80         MOV     R3,#-0x80
   \   000083   90....       MOV     DPTR,#(ZDP_EPRsp & 0xffff)
   \   000086   74..         MOV     A,#((ZDP_EPRsp >> 16) & 0xff)
   \   000088   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00008B   7407         MOV     A,#0x7
   \   00008D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000090   802B         SJMP    ??ZDO_ProcessActiveEPReq_2
    926            }
    927            else
    928            {
    929              ZDP_GenericRsp( seq, src, ZDP_NOT_SUPPORTED, aoi, Active_EP_rsp, sty );
   \                     ??ZDO_ProcessActiveEPReq_1:
   \   000092                ; Setup parameters for call to function ZDP_GenericRsp
   \   000092   75..05       MOV     ?V0 + 2,#0x5
   \   000095   75..80       MOV     ?V0 + 3,#-0x80
   \   000098   78..         MOV     R0,#?V0 + 2
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009D   8E..         MOV     ?V0 + 2,R6
   \   00009F   8F..         MOV     ?V0 + 3,R7
   \   0000A1   78..         MOV     R0,#?V0 + 2
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A6   AD..         MOV     R5,?V0 + 1
   \   0000A8   7C84         MOV     R4,#-0x7c
   \   0000AA   AA..         MOV     R2,?V0 + 6
   \   0000AC   AB..         MOV     R3,?V0 + 7
   \   0000AE   A9..         MOV     R1,?V0 + 0
   \   0000B0   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   0000B3   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   0000B5   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000B8   7404         MOV     A,#0x4
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
    930            }
    931          }
   \                     ??ZDO_ProcessActiveEPReq_2:
   \   0000BD                REQUIRE ?Subroutine25
   \   0000BD                ; // Fall through to label ?Subroutine25

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    932          
    933          /*********************************************************************
    934           * @fn          ZDO_ProcessMatchDescReq
    935           *
    936           * @brief       This function processes and responds to the
    937           *              Match_Desc_req message.
    938           *
    939           * @param       src  - Source address
    940           * @param       msg - input message containing search material
    941           * @param       sty - Security enable/disable
    942           *
    943           * @return      none
    944           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    945          void ZDO_ProcessMatchDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessMatchDescReq:
    946          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740B         MOV     A,#0xb
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E9           MOV     A,R1
   \   000010   F0           MOVX    @DPTR,A
   \   000011   740C         MOV     A,#0xc
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   EA           MOV     A,R2
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   EB           MOV     A,R3
   \   00001A   F0           MOVX    @DPTR,A
    947            byte epCnt = 0;
   \   00001B   7405         MOV     A,#0x5
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E4           CLR     A
   \   000021   12....       LCALL   ?Subroutine0 & 0xFFFF
    948            byte numInClusters;
    949            uint16 *inClusters;
    950            byte numOutClusters;
    951            uint16 *outClusters;
    952            epList_t *epDesc;
    953            SimpleDescriptionFormat_t *sDesc = NULL;
    954            uint8 allocated;
    955          
    956            // Parse the incoming message
    957            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   \                     ??CrossCallReturnLabel_1:
   \   000024   FE           MOV     R6,A
   \   000025   E9           MOV     A,R1
   \   000026   3400         ADDC    A,#0x0
   \   000028   FF           MOV     R7,A
    958            uint16 profileID = BUILD_UINT16( msg[2], msg[3] );
   \   000029   8C82         MOV     DPL,R4
   \   00002B   8D83         MOV     DPH,R5
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   E4           CLR     A
   \   00003B   2A           ADD     A,R2
   \   00003C   F5..         MOV     ?V0 + 0,A
   \   00003E   E9           MOV     A,R1
   \   00003F   3400         ADDC    A,#0x0
   \   000041   F5..         MOV     ?V0 + 1,A
    959            msg += 4;
   \   000043   EC           MOV     A,R4
   \   000044   2404         ADD     A,#0x4
   \   000046   F5..         MOV     ?V0 + 2,A
   \   000048   ED           MOV     A,R5
   \   000049   3400         ADDC    A,#0x0
    960            numInClusters = *msg++;
   \   00004B   85..82       MOV     DPL,?V0 + 2
   \   00004E   F583         MOV     DPH,A
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F5..         MOV     ?V0 + 7,A
   \   000053   A3           INC     DPTR
   \   000054   8582..       MOV     ?V0 + 2,DPL
   \   000057   8583..       MOV     ?V0 + 3,DPH
    961            inClusters = NULL;
   \   00005A   7406         MOV     A,#0x6
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   E4           CLR     A
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   F0           MOVX    @DPTR,A
    962            if (numInClusters)  {
   \   000063   E5..         MOV     A,?V0 + 7
   \   000065   6023         JZ      ??ZDO_ProcessMatchDescReq_0
    963              if (!(inClusters=ZDO_CreateAlignedUINT16List(numInClusters, msg)))  {
   \   000067                ; Setup parameters for call to function ZDO_CreateAlignedUINT16List
   \   000067   AA..         MOV     R2,?V0 + 2
   \   000069   AB..         MOV     R3,?V0 + 3
   \   00006B   F9           MOV     R1,A
   \   00006C   90....       MOV     DPTR,#(??ZDO_CreateAlignedUINT16List & 0xffff)
   \   00006F   74..         MOV     A,#((??ZDO_CreateAlignedUINT16List >> 16) & 0xff)
   \   000071   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000074   8A..         MOV     ?V0 + 4,R2
   \   000076   8B..         MOV     ?V0 + 5,R3
   \   000078   A8..         MOV     R0,?V0 + 4
   \   00007A   A9..         MOV     R1,?V0 + 5
   \   00007C   7406         MOV     A,#0x6
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000084   E8           MOV     A,R0
   \   000085   7001         JNZ     ??ZDO_ProcessMatchDescReq_1
   \   000087   E9           MOV     A,R1
   \                     ??ZDO_ProcessMatchDescReq_1:
   \   000088   606D         JZ      ??ZDO_ProcessMatchDescReq_2
    964                // can't allocate memory. drop message
    965                return;
    966              }
    967            }
    968            msg += numInClusters*sizeof(uint16);
   \                     ??ZDO_ProcessMatchDescReq_0:
   \   00008A   E5..         MOV     A,?V0 + 7
   \   00008C   C3           CLR     C
   \   00008D   33           RLC     A
   \   00008E   F8           MOV     R0,A
   \   00008F   E4           CLR     A
   \   000090   33           RLC     A
   \   000091   F9           MOV     R1,A
   \   000092   E5..         MOV     A,?V0 + 2
   \   000094   28           ADD     A,R0
   \   000095   F5..         MOV     ?V0 + 2,A
   \   000097   E5..         MOV     A,?V0 + 3
   \   000099   39           ADDC    A,R1
   \   00009A   F5..         MOV     ?V0 + 3,A
    969          
    970            numOutClusters = *msg++;
   \   00009C   85..82       MOV     DPL,?V0 + 2
   \   00009F   F583         MOV     DPH,A
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   85..82       MOV     DPL,?XSP + 0
   \   0000A5   85..83       MOV     DPH,?XSP + 1
   \   0000A8   F0           MOVX    @DPTR,A
    971            outClusters = NULL;
   \   0000A9   7408         MOV     A,#0x8
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   E4           CLR     A
   \   0000AF   F0           MOVX    @DPTR,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   12....       LCALL   ?Subroutine2 & 0xFFFF
    972            if (numOutClusters)  {
   \                     ??CrossCallReturnLabel_4:
   \   0000B4   6049         JZ      ??ZDO_ProcessMatchDescReq_3
    973              if (!(outClusters=ZDO_CreateAlignedUINT16List(numOutClusters, msg)))  {
   \   0000B6                ; Setup parameters for call to function ZDO_CreateAlignedUINT16List
   \   0000B6   85..82       MOV     DPL,?V0 + 2
   \   0000B9   85..83       MOV     DPH,?V0 + 3
   \   0000BC   A3           INC     DPTR
   \   0000BD   AA82         MOV     R2,DPL
   \   0000BF   AB83         MOV     R3,DPH
   \   0000C1   F9           MOV     R1,A
   \   0000C2   90....       MOV     DPTR,#(??ZDO_CreateAlignedUINT16List & 0xffff)
   \   0000C5   74..         MOV     A,#((??ZDO_CreateAlignedUINT16List >> 16) & 0xff)
   \   0000C7   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000CA   8A..         MOV     ?V0 + 2,R2
   \   0000CC   8B..         MOV     ?V0 + 3,R3
   \   0000CE   A8..         MOV     R0,?V0 + 2
   \   0000D0   A9..         MOV     R1,?V0 + 3
   \   0000D2   7408         MOV     A,#0x8
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000DA   E8           MOV     A,R0
   \   0000DB   7001         JNZ     ??ZDO_ProcessMatchDescReq_4
   \   0000DD   E9           MOV     A,R1
   \                     ??ZDO_ProcessMatchDescReq_4:
   \   0000DE   701F         JNZ     ??ZDO_ProcessMatchDescReq_3
    974                // can't allocate memory. drop message
    975                if (inClusters) {
   \   0000E0   7406         MOV     A,#0x6
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   7002         JNZ     ??ZDO_ProcessMatchDescReq_5
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_5:
   \   0000EA   600B         JZ      ??ZDO_ProcessMatchDescReq_2
    976                  osal_mem_free(inClusters);
   \   0000EC                ; Setup parameters for call to function osal_mem_free
   \   0000EC   7406         MOV     A,#0x6
   \                     ??ZDO_ProcessMatchDescReq_6:
   \   0000EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F1   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000F4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDO_ProcessMatchDescReq_2:
   \   0000F7   740E         MOV     A,#0xe
   \   0000F9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FC   02....       LJMP    ?Subroutine25 & 0xFFFF
    977                }
    978                return;
    979              }
    980            }
    981            msg += numOutClusters*sizeof(uint16);
    982          
    983            if ( NWK_BROADCAST_SHORTADDR_DEVALL == aoi )
   \                     ??ZDO_ProcessMatchDescReq_3:
   \   0000FF   74FF         MOV     A,#-0x1
   \   000101   6E           XRL     A,R6
   \   000102   7003         JNZ     ??ZDO_ProcessMatchDescReq_7
   \   000104   74FF         MOV     A,#-0x1
   \   000106   6F           XRL     A,R7
   \                     ??ZDO_ProcessMatchDescReq_7:
   \   000107   6052         JZ      ??ZDO_ProcessMatchDescReq_8
    984            {
    985          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    986              if ( CACHE_SERVER )
    987              {
    988                ZDCacheProcessMatchDescReq( seq, src, numInClusters, inClusters,
    989                                      numOutClusters, outClusters, profileID, aoi, sty );
    990              }
    991          #endif
    992            }
    993            else if ( ADDR_BCAST_NOT_ME == NLME_IsAddressBroadcast(aoi) )
   \   000109                ; Setup parameters for call to function NLME_IsAddressBroadcast
   \   000109   EE           MOV     A,R6
   \   00010A   FA           MOV     R2,A
   \   00010B   EF           MOV     A,R7
   \   00010C   FB           MOV     R3,A
   \   00010D   90....       MOV     DPTR,#(NLME_IsAddressBroadcast & 0xffff)
   \   000110   74..         MOV     A,#((NLME_IsAddressBroadcast >> 16) & 0xff)
   \   000112   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000115   E9           MOV     A,R1
   \   000116   6401         XRL     A,#0x1
   \   000118   7029         JNZ     ??ZDO_ProcessMatchDescReq_9
    994            {
    995              ZDP_MatchDescRsp( seq, src, ZDP_INVALID_REQTYPE,
    996                                             ZDAppNwkAddr.addr.shortAddr, 0, NULL, sty );
   \                     ??ZDO_ProcessMatchDescReq_10:
   \   00011A                ; Setup parameters for call to function ZDP_EPRsp
   \   00011A   741E         MOV     A,#0x1e
   \   00011C   12....       LCALL   ?XSTACK_DISP0_8
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F5..         MOV     ?V0 + 0,A
   \   000122   78..         MOV     R0,#?V0 + 0
   \   000124   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000127   75..00       MOV     ?V0 + 0,#0x0
   \   00012A   75..00       MOV     ?V0 + 1,#0x0
   \   00012D   78..         MOV     R0,#?V0 + 0
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000132   78..         MOV     R0,#?V0 + 0
   \   000134   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000137   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00013A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00013D   75..80       MOV     ?V0 + 0,#-0x80
   \   000140   02....       LJMP    ??ZDO_ProcessMatchDescReq_11 & 0xFFFF
    997              if (inClusters)  {
    998                osal_mem_free(inClusters);
    999              }
   1000              if (outClusters)  {
   1001                osal_mem_free(outClusters);
   1002              }
   1003              return;
   1004            }
   1005            else if ( (ADDR_NOT_BCAST == NLME_IsAddressBroadcast(aoi)) && (aoi != ZDAppNwkAddr.addr.shortAddr) )
   \                     ??ZDO_ProcessMatchDescReq_9:
   \   000143                ; Setup parameters for call to function NLME_IsAddressBroadcast
   \   000143   EE           MOV     A,R6
   \   000144   FA           MOV     R2,A
   \   000145   EF           MOV     A,R7
   \   000146   FB           MOV     R3,A
   \   000147   74..         MOV     A,#((NLME_IsAddressBroadcast >> 16) & 0xff)
   \   000149   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00014C   E9           MOV     A,R1
   \   00014D   700C         JNZ     ??ZDO_ProcessMatchDescReq_8
   \   00014F   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000152   E0           MOVX    A,@DPTR
   \   000153   6E           XRL     A,R6
   \   000154   7003         JNZ     ??ZDO_ProcessMatchDescReq_12
   \   000156   A3           INC     DPTR
   \   000157   E0           MOVX    A,@DPTR
   \   000158   6F           XRL     A,R7
   \                     ??ZDO_ProcessMatchDescReq_12:
   \   000159   70BF         JNZ     ??ZDO_ProcessMatchDescReq_10
   1006            {
   1007          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
   1008              if ( CACHE_SERVER )
   1009              {
   1010                ZDCacheProcessMatchDescReq( seq, src, numInClusters, inClusters,
   1011                                      numOutClusters, outClusters, profileID, aoi, sty );
   1012              }
   1013          #else
   1014              ZDP_MatchDescRsp( seq, src, ZDP_INVALID_REQTYPE,
   1015                                             ZDAppNwkAddr.addr.shortAddr, 0, NULL, sty );
   1016          #endif
   1017              if (inClusters)  {
   1018                osal_mem_free(inClusters);
   1019              }
   1020              if (outClusters)  {
   1021                osal_mem_free(outClusters);
   1022              }
   1023              return;
   1024            }
   1025          
   1026            // First count the number of endpoints that match.
   1027            epDesc = epList;
   \                     ??ZDO_ProcessMatchDescReq_8:
   \   00015B   90....       MOV     DPTR,#epList
   \   00015E   8062         SJMP    ??ZDO_ProcessMatchDescReq_13
   1028            while ( epDesc )
   1029            {
   1030              // Don't search endpoint 0 and check if response is allowed
   1031              if ( epDesc->epDesc->endPoint != ZDO_EP && (epDesc->flags&eEP_AllowMatch) )
   1032              {
   1033                if ( epDesc->pfnDescCB )
   1034                {
   1035                  sDesc = (SimpleDescriptionFormat_t *)epDesc->pfnDescCB( AF_DESCRIPTOR_SIMPLE, epDesc->epDesc->endPoint );
   1036                  allocated = TRUE;
   1037                }
   1038                else
   1039                {
   1040                  sDesc = epDesc->epDesc->simpleDesc;
   1041                  allocated = FALSE;
   1042                }
   1043          
   1044                if ( sDesc && sDesc->AppProfId == profileID )
   1045                {
   1046                  uint8 *uint8Buf = (uint8 *)ZDOBuildBuf;
   1047          
   1048                  // If there are no search input/ouput clusters - respond
   1049                  if ( ((numInClusters == 0) && (numOutClusters == 0))
   1050                      // Are there matching input clusters?
   1051                       || (ZDO_AnyClusterMatches( numInClusters, inClusters,
   1052                            sDesc->AppNumInClusters, sDesc->pAppInClusterList ))
   1053                      // Are there matching output clusters?
   1054                       || (ZDO_AnyClusterMatches( numOutClusters, outClusters,
   1055                            sDesc->AppNumOutClusters, sDesc->pAppOutClusterList ))     )
   1056                  {         
   1057                    // Notify the endpoint of the match.
   1058                    uint8 bufLen = sizeof( ZDO_MatchDescRspSent_t ) + (numOutClusters + numInClusters) * sizeof(uint16);
   1059                    ZDO_MatchDescRspSent_t *pRspSent = (ZDO_MatchDescRspSent_t *) osal_msg_allocate( bufLen );
   1060          
   1061                    if (pRspSent)
   1062                    {
   1063                      pRspSent->hdr.event = ZDO_MATCH_DESC_RSP_SENT;
   1064                      pRspSent->nwkAddr = src->addr.shortAddr;
   1065                      pRspSent->numInClusters = numInClusters;
   1066                      pRspSent->numOutClusters = numOutClusters;
   1067          
   1068                      if (numInClusters)
   1069                      {
   1070                        pRspSent->pInClusters = (uint16*) (pRspSent + 1);
   1071                        osal_memcpy(pRspSent->pInClusters, inClusters, numInClusters * sizeof(uint16));
   1072                      }
   1073                      else 
   1074                      {
   1075                        pRspSent->pInClusters = NULL;
   1076                      }
   1077                       
   1078                      if (numOutClusters)
   1079                      {
   1080                        pRspSent->pOutClusters = (uint16*)(pRspSent + 1) + numInClusters;
   1081                        osal_memcpy(pRspSent->pOutClusters, outClusters, numOutClusters * sizeof(uint16));
   1082                      }
   1083                      else 
   1084                      {
   1085                        pRspSent->pOutClusters = NULL;
   \                     ??ZDO_ProcessMatchDescReq_14:
   \   000160   8E82         MOV     DPL,R6
   \   000162   8F83         MOV     DPH,R7
   \   000164   A3           INC     DPTR
   \   000165   A3           INC     DPTR
   \   000166   A3           INC     DPTR
   \   000167   A3           INC     DPTR
   \   000168   A3           INC     DPTR
   \   000169   A3           INC     DPTR
   \   00016A   A3           INC     DPTR
   \   00016B   A3           INC     DPTR
   \   00016C   E4           CLR     A
   \   00016D   F0           MOVX    @DPTR,A
   \   00016E   A3           INC     DPTR
   \   00016F   F0           MOVX    @DPTR,A
   1086                      }
   1087                    
   1088                      osal_msg_send( *epDesc->epDesc->task_id, (uint8 *)pRspSent );
   \                     ??ZDO_ProcessMatchDescReq_15:
   \   000170                ; Setup parameters for call to function osal_msg_send
   \   000170   EE           MOV     A,R6
   \   000171   FA           MOV     R2,A
   \   000172   EF           MOV     A,R7
   \   000173   FB           MOV     R3,A
   \   000174   7401         MOV     A,#0x1
   \   000176   12....       LCALL   ?XSTACK_DISP0_8
   \   000179   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00017C   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00017F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1089                    }
   1090          
   1091                    uint8Buf[epCnt++] = sDesc->EndPoint;
   \                     ??ZDO_ProcessMatchDescReq_16:
   \   000182   7403         MOV     A,#0x3
   \   000184   12....       LCALL   ?XSTACK_DISP0_8
   \   000187   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00018A   C0E0         PUSH    A
   \   00018C   7405         MOV     A,#0x5
   \   00018E   12....       LCALL   ?XSTACK_DISP0_8
   \   000191   E0           MOVX    A,@DPTR
   \   000192   24..         ADD     A,#(??ZDOBuildBuf & 0xff)
   \   000194   F582         MOV     DPL,A
   \   000196   E4           CLR     A
   \   000197   34..         ADDC    A,#((??ZDOBuildBuf >> 8) & 0xff)
   \   000199   F583         MOV     DPH,A
   \   00019B   D0E0         POP     A
   \   00019D   F0           MOVX    @DPTR,A
   \   00019E   7405         MOV     A,#0x5
   \   0001A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   04           INC     A
   \   0001A5   F0           MOVX    @DPTR,A
   1092                  }
   1093                }
   1094          
   1095                if ( allocated )
   \                     ??ZDO_ProcessMatchDescReq_17:
   \   0001A6   740A         MOV     A,#0xa
   \   0001A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AB   E0           MOVX    A,@DPTR
   \   0001AC   600B         JZ      ??ZDO_ProcessMatchDescReq_18
   1096                  osal_mem_free( sDesc );
   \   0001AE                ; Setup parameters for call to function osal_mem_free
   \   0001AE   7403         MOV     A,#0x3
   \   0001B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B3   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   0001B6   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1097              }
   1098              epDesc = epDesc->nextDesc;
   \                     ??ZDO_ProcessMatchDescReq_18:
   \   0001B9   7401         MOV     A,#0x1
   \   0001BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BE   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0001C1   A3           INC     DPTR
   \                     ??ZDO_ProcessMatchDescReq_13:
   \   0001C2   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0001C5   7401         MOV     A,#0x1
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0001CD   7401         MOV     A,#0x1
   \   0001CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D2   E0           MOVX    A,@DPTR
   \   0001D3   7002         JNZ     ??ZDO_ProcessMatchDescReq_19
   \   0001D5   A3           INC     DPTR
   \   0001D6   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_19:
   \   0001D7   7003         JNZ     $+5
   \   0001D9   02....       LJMP    ??ZDO_ProcessMatchDescReq_20 & 0xFFFF
   \   0001DC   7401         MOV     A,#0x1
   \   0001DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E1   E0           MOVX    A,@DPTR
   \   0001E2   F8           MOV     R0,A
   \   0001E3   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0001E6   60D1         JZ      ??ZDO_ProcessMatchDescReq_18
   \   0001E8   7401         MOV     A,#0x1
   \   0001EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001ED   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001F3   50C4         JNC     ??ZDO_ProcessMatchDescReq_18
   \   0001F5   7401         MOV     A,#0x1
   \   0001F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FA   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0001FD   E0           MOVX    A,@DPTR
   \   0001FE   FC           MOV     R4,A
   \   0001FF   A3           INC     DPTR
   \   000200   E0           MOVX    A,@DPTR
   \   000201   FD           MOV     R5,A
   \   000202   A3           INC     DPTR
   \   000203   E0           MOVX    A,@DPTR
   \   000204   FE           MOV     R6,A
   \   000205   7900         MOV     R1,#0x0
   \   000207   EC           MOV     A,R4
   \   000208   4D           ORL     A,R5
   \   000209   4E           ORL     A,R6
   \   00020A   602C         JZ      ??ZDO_ProcessMatchDescReq_21
   \   00020C                ; Setup parameters for indirect call
   \   00020C   7401         MOV     A,#0x1
   \   00020E   12....       LCALL   ?XSTACK_DISP0_8
   \   000211   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000214   FA           MOV     R2,A
   \   000215   09           INC     R1
   \   000216   E9           MOV     A,R1
   \   000217   12....       LCALL   ?XSTACK_DISP0_8
   \   00021A   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   00021D   E0           MOVX    A,@DPTR
   \   00021E   8C82         MOV     DPL,R4
   \   000220   8D83         MOV     DPH,R5
   \   000222   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000225   7403         MOV     A,#0x3
   \   000227   12....       LCALL   ?XSTACK_DISP0_8
   \   00022A   EA           MOV     A,R2
   \   00022B   F0           MOVX    @DPTR,A
   \   00022C   A3           INC     DPTR
   \   00022D   EB           MOV     A,R3
   \   00022E   F0           MOVX    @DPTR,A
   \   00022F   740A         MOV     A,#0xa
   \   000231   12....       LCALL   ?XSTACK_DISP0_8
   \   000234   7401         MOV     A,#0x1
   \   000236   801E         SJMP    ??ZDO_ProcessMatchDescReq_22
   \                     ??ZDO_ProcessMatchDescReq_21:
   \   000238   7401         MOV     A,#0x1
   \   00023A   12....       LCALL   ?XSTACK_DISP0_8
   \   00023D   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000240   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000243   A3           INC     DPTR
   \   000244   A3           INC     DPTR
   \   000245   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000248   7403         MOV     A,#0x3
   \   00024A   12....       LCALL   ?XSTACK_DISP0_8
   \   00024D   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000250   740A         MOV     A,#0xa
   \   000252   12....       LCALL   ?XSTACK_DISP0_8
   \   000255   E4           CLR     A
   \                     ??ZDO_ProcessMatchDescReq_22:
   \   000256   F0           MOVX    @DPTR,A
   \   000257   7403         MOV     A,#0x3
   \   000259   12....       LCALL   ?XSTACK_DISP0_8
   \   00025C   E0           MOVX    A,@DPTR
   \   00025D   7002         JNZ     ??ZDO_ProcessMatchDescReq_23
   \   00025F   A3           INC     DPTR
   \   000260   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_23:
   \   000261   7003         JNZ     $+5
   \   000263   02....       LJMP    ??ZDO_ProcessMatchDescReq_17 & 0xFFFF
   \   000266   7403         MOV     A,#0x3
   \   000268   12....       LCALL   ?XSTACK_DISP0_8
   \   00026B   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00026E   E0           MOVX    A,@DPTR
   \   00026F   65..         XRL     A,?V0 + 0
   \   000271   7004         JNZ     ??ZDO_ProcessMatchDescReq_24
   \   000273   A3           INC     DPTR
   \   000274   E0           MOVX    A,@DPTR
   \   000275   65..         XRL     A,?V0 + 1
   \                     ??ZDO_ProcessMatchDescReq_24:
   \   000277   6003         JZ      $+5
   \   000279   02....       LJMP    ??ZDO_ProcessMatchDescReq_17 & 0xFFFF
   \   00027C   E5..         MOV     A,?V0 + 7
   \   00027E   7009         JNZ     ??ZDO_ProcessMatchDescReq_25
   \   000280   85..82       MOV     DPL,?XSP + 0
   \   000283   85..83       MOV     DPH,?XSP + 1
   \   000286   E0           MOVX    A,@DPTR
   \   000287   6069         JZ      ??ZDO_ProcessMatchDescReq_26
   \                     ??ZDO_ProcessMatchDescReq_25:
   \   000289                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   000289   7403         MOV     A,#0x3
   \   00028B   12....       LCALL   ?XSTACK_DISP0_8
   \   00028E   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000291   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000294   7405         MOV     A,#0x5
   \   000296   12....       LCALL   ?XSTACK_DISP0_8
   \   000299   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00029C   A3           INC     DPTR
   \   00029D   A3           INC     DPTR
   \   00029E   E0           MOVX    A,@DPTR
   \   00029F   FC           MOV     R4,A
   \   0002A0   7408         MOV     A,#0x8
   \   0002A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A5   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0002A8   A9..         MOV     R1,?V0 + 7
   \   0002AA   90....       MOV     DPTR,#(ZDO_AnyClusterMatches & 0xffff)
   \   0002AD   74..         MOV     A,#((ZDO_AnyClusterMatches >> 16) & 0xff)
   \   0002AF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0002B2   7402         MOV     A,#0x2
   \   0002B4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002B7   E9           MOV     A,R1
   \   0002B8   7038         JNZ     ??ZDO_ProcessMatchDescReq_26
   \   0002BA                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   0002BA   7403         MOV     A,#0x3
   \   0002BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BF   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0002C2   A3           INC     DPTR
   \   0002C3   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0002C6   7405         MOV     A,#0x5
   \   0002C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CB   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0002CE   E0           MOVX    A,@DPTR
   \   0002CF   FC           MOV     R4,A
   \   0002D0   740A         MOV     A,#0xa
   \   0002D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D5   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0002D8   7402         MOV     A,#0x2
   \   0002DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002DD   E0           MOVX    A,@DPTR
   \   0002DE   F9           MOV     R1,A
   \   0002DF   90....       MOV     DPTR,#(ZDO_AnyClusterMatches & 0xffff)
   \   0002E2   74..         MOV     A,#((ZDO_AnyClusterMatches >> 16) & 0xff)
   \   0002E4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0002E7   7402         MOV     A,#0x2
   \   0002E9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002EC   E9           MOV     A,R1
   \   0002ED   7003         JNZ     $+5
   \   0002EF   02....       LJMP    ??ZDO_ProcessMatchDescReq_17 & 0xFFFF
   \                     ??ZDO_ProcessMatchDescReq_26:
   \   0002F2                ; Setup parameters for call to function osal_msg_allocate
   \   0002F2   85..82       MOV     DPL,?XSP + 0
   \   0002F5   85..83       MOV     DPH,?XSP + 1
   \   0002F8   E0           MOVX    A,@DPTR
   \   0002F9   25..         ADD     A,?V0 + 7
   \   0002FB   C3           CLR     C
   \   0002FC   33           RLC     A
   \   0002FD   240A         ADD     A,#0xa
   \   0002FF   FA           MOV     R2,A
   \   000300   7B00         MOV     R3,#0x0
   \   000302   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000305   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000307   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00030A   8A..         MOV     ?V0 + 2,R2
   \   00030C   8B..         MOV     ?V0 + 3,R3
   \   00030E   AE..         MOV     R6,?V0 + 2
   \   000310   AF..         MOV     R7,?V0 + 3
   \   000312   EE           MOV     A,R6
   \   000313   7001         JNZ     ??ZDO_ProcessMatchDescReq_27
   \   000315   EF           MOV     A,R7
   \                     ??ZDO_ProcessMatchDescReq_27:
   \   000316   7003         JNZ     $+5
   \   000318   02....       LJMP    ??ZDO_ProcessMatchDescReq_16 & 0xFFFF
   \   00031B   74DB         MOV     A,#-0x25
   \   00031D   8E82         MOV     DPL,R6
   \   00031F   8F83         MOV     DPH,R7
   \   000321   F0           MOVX    @DPTR,A
   \   000322   740C         MOV     A,#0xc
   \   000324   12....       LCALL   ?XSTACK_DISP0_8
   \   000327   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00032A   F8           MOV     R0,A
   \   00032B   A3           INC     DPTR
   \   00032C   E0           MOVX    A,@DPTR
   \   00032D   F9           MOV     R1,A
   \   00032E   8E82         MOV     DPL,R6
   \   000330   8F83         MOV     DPH,R7
   \   000332   A3           INC     DPTR
   \   000333   A3           INC     DPTR
   \   000334   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000337   8E82         MOV     DPL,R6
   \   000339   8F83         MOV     DPH,R7
   \   00033B   A3           INC     DPTR
   \   00033C   A3           INC     DPTR
   \   00033D   A3           INC     DPTR
   \   00033E   A3           INC     DPTR
   \   00033F   E5..         MOV     A,?V0 + 7
   \   000341   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000344   8E82         MOV     DPL,R6
   \   000346   8F83         MOV     DPH,R7
   \   000348   A3           INC     DPTR
   \   000349   A3           INC     DPTR
   \   00034A   A3           INC     DPTR
   \   00034B   A3           INC     DPTR
   \   00034C   A3           INC     DPTR
   \   00034D   A3           INC     DPTR
   \   00034E   A3           INC     DPTR
   \   00034F   F0           MOVX    @DPTR,A
   \   000350   E5..         MOV     A,?V0 + 7
   \   000352   6040         JZ      ??ZDO_ProcessMatchDescReq_28
   \   000354   EE           MOV     A,R6
   \   000355   2405         ADD     A,#0x5
   \   000357   FA           MOV     R2,A
   \   000358   EF           MOV     A,R7
   \   000359   3400         ADDC    A,#0x0
   \   00035B   FB           MOV     R3,A
   \   00035C   EE           MOV     A,R6
   \   00035D   240A         ADD     A,#0xa
   \   00035F   F8           MOV     R0,A
   \   000360   EF           MOV     A,R7
   \   000361   3400         ADDC    A,#0x0
   \   000363   F9           MOV     R1,A
   \   000364   8A82         MOV     DPL,R2
   \   000366   8B83         MOV     DPH,R3
   \   000368   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00036B                ; Setup parameters for call to function osal_memcpy
   \   00036B   7406         MOV     A,#0x6
   \   00036D   12....       LCALL   ?XSTACK_DISP0_8
   \   000370   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000373   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000376   E5..         MOV     A,?V0 + 7
   \   000378   C3           CLR     C
   \   000379   33           RLC     A
   \   00037A   FC           MOV     R4,A
   \   00037B   E4           CLR     A
   \   00037C   33           RLC     A
   \   00037D   FD           MOV     R5,A
   \   00037E   8A82         MOV     DPL,R2
   \   000380   8B83         MOV     DPH,R3
   \   000382   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000385   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000388   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   00038A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00038D   7403         MOV     A,#0x3
   \   00038F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000392   800D         SJMP    ??ZDO_ProcessMatchDescReq_29
   \                     ??ZDO_ProcessMatchDescReq_28:
   \   000394   8E82         MOV     DPL,R6
   \   000396   8F83         MOV     DPH,R7
   \   000398   A3           INC     DPTR
   \   000399   A3           INC     DPTR
   \   00039A   A3           INC     DPTR
   \   00039B   A3           INC     DPTR
   \   00039C   A3           INC     DPTR
   \   00039D   E4           CLR     A
   \   00039E   F0           MOVX    @DPTR,A
   \   00039F   A3           INC     DPTR
   \   0003A0   F0           MOVX    @DPTR,A
   \                     ??ZDO_ProcessMatchDescReq_29:
   \   0003A1   85..82       MOV     DPL,?XSP + 0
   \   0003A4   85..83       MOV     DPH,?XSP + 1
   \   0003A7   E0           MOVX    A,@DPTR
   \   0003A8   7003         JNZ     $+5
   \   0003AA   02....       LJMP    ??ZDO_ProcessMatchDescReq_14 & 0xFFFF
   \   0003AD   E5..         MOV     A,?V0 + 7
   \   0003AF   C3           CLR     C
   \   0003B0   33           RLC     A
   \   0003B1   F8           MOV     R0,A
   \   0003B2   E4           CLR     A
   \   0003B3   33           RLC     A
   \   0003B4   F9           MOV     R1,A
   \   0003B5   EE           MOV     A,R6
   \   0003B6   28           ADD     A,R0
   \   0003B7   F8           MOV     R0,A
   \   0003B8   EF           MOV     A,R7
   \   0003B9   39           ADDC    A,R1
   \   0003BA   F9           MOV     R1,A
   \   0003BB   740A         MOV     A,#0xa
   \   0003BD   28           ADD     A,R0
   \   0003BE   FA           MOV     R2,A
   \   0003BF   E4           CLR     A
   \   0003C0   39           ADDC    A,R1
   \   0003C1   FB           MOV     R3,A
   \   0003C2   8E82         MOV     DPL,R6
   \   0003C4   8F83         MOV     DPH,R7
   \   0003C6   A3           INC     DPTR
   \   0003C7   A3           INC     DPTR
   \   0003C8   A3           INC     DPTR
   \   0003C9   A3           INC     DPTR
   \   0003CA   A3           INC     DPTR
   \   0003CB   A3           INC     DPTR
   \   0003CC   A3           INC     DPTR
   \   0003CD   A3           INC     DPTR
   \   0003CE   EA           MOV     A,R2
   \   0003CF   F0           MOVX    @DPTR,A
   \   0003D0   A3           INC     DPTR
   \   0003D1   EB           MOV     A,R3
   \   0003D2   F0           MOVX    @DPTR,A
   \   0003D3                ; Setup parameters for call to function osal_memcpy
   \   0003D3   7408         MOV     A,#0x8
   \   0003D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D8   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   0003DB   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0003DE   7403         MOV     A,#0x3
   \   0003E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E3   E0           MOVX    A,@DPTR
   \   0003E4   C3           CLR     C
   \   0003E5   33           RLC     A
   \   0003E6   FC           MOV     R4,A
   \   0003E7   E4           CLR     A
   \   0003E8   33           RLC     A
   \   0003E9   FD           MOV     R5,A
   \   0003EA   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   0003ED   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   0003EF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0003F2   7403         MOV     A,#0x3
   \   0003F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0003F7   02....       LJMP    ??ZDO_ProcessMatchDescReq_15 & 0xFFFF
   1099            }
   1100          
   1101            // Send the message only if at least one match found.
   1102            if ( epCnt )
   \                     ??ZDO_ProcessMatchDescReq_20:
   \   0003FA   7405         MOV     A,#0x5
   \   0003FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FF   E0           MOVX    A,@DPTR
   \   000400   6055         JZ      ??ZDO_ProcessMatchDescReq_30
   1103            {
   1104              if ( ZSuccess == ZDP_MatchDescRsp( seq, src, ZDP_SUCCESS,
   1105                                 ZDAppNwkAddr.addr.shortAddr, epCnt, (uint8 *)ZDOBuildBuf, sty ) )
   \   000402                ; Setup parameters for call to function ZDP_EPRsp
   \   000402   741E         MOV     A,#0x1e
   \   000404   12....       LCALL   ?XSTACK_DISP0_8
   \   000407   E0           MOVX    A,@DPTR
   \   000408   F5..         MOV     ?V0 + 0,A
   \   00040A   78..         MOV     R0,#?V0 + 0
   \   00040C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00040F   75....       MOV     ?V0 + 0,#(??ZDOBuildBuf & 0xff)
   \   000412   75....       MOV     ?V0 + 1,#((??ZDOBuildBuf >> 8) & 0xff)
   \   000415   78..         MOV     R0,#?V0 + 0
   \   000417   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00041A   7408         MOV     A,#0x8
   \   00041C   12....       LCALL   ?XSTACK_DISP0_8
   \   00041F   E0           MOVX    A,@DPTR
   \   000420   F5..         MOV     ?V0 + 0,A
   \   000422   78..         MOV     R0,#?V0 + 0
   \   000424   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000427   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00042A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00042D   75..00       MOV     ?V0 + 0,#0x0
   \                     ??ZDO_ProcessMatchDescReq_11:
   \   000430   78..         MOV     R0,#?V0 + 0
   \   000432   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000435   7413         MOV     A,#0x13
   \   000437   12....       LCALL   ?XSTACK_DISP0_8
   \   00043A   E0           MOVX    A,@DPTR
   \   00043B   FC           MOV     R4,A
   \   00043C   A3           INC     DPTR
   \   00043D   E0           MOVX    A,@DPTR
   \   00043E   FD           MOV     R5,A
   \   00043F   7412         MOV     A,#0x12
   \   000441   12....       LCALL   ?XSTACK_DISP0_8
   \   000444   E0           MOVX    A,@DPTR
   \   000445   F9           MOV     R1,A
   \   000446   7A06         MOV     R2,#0x6
   \   000448   7B80         MOV     R3,#-0x80
   \   00044A   90....       MOV     DPTR,#(ZDP_EPRsp & 0xffff)
   \   00044D   74..         MOV     A,#((ZDP_EPRsp >> 16) & 0xff)
   \   00044F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000452   7407         MOV     A,#0x7
   \   000454   12....       LCALL   ?DEALLOC_XSTACK8
   1106              {
   1107          #if defined( LCD_SUPPORTED )
   1108                HalLcdWriteScreen( "Match Desc Req", "Rsp Sent" );
   1109          #endif
   1110              }
   1111            }
   1112            else
   1113            {
   1114          #if defined( LCD_SUPPORTED )
   1115              HalLcdWriteScreen( "Match Desc Req", "Non Matched" );
   1116          #endif
   1117            }
   1118            if (inClusters)  {
   \                     ??ZDO_ProcessMatchDescReq_30:
   \   000457   7406         MOV     A,#0x6
   \   000459   12....       LCALL   ?XSTACK_DISP0_8
   \   00045C   E0           MOVX    A,@DPTR
   \   00045D   7002         JNZ     ??ZDO_ProcessMatchDescReq_31
   \   00045F   A3           INC     DPTR
   \   000460   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_31:
   \   000461   600B         JZ      ??ZDO_ProcessMatchDescReq_32
   \   000463                ; Setup parameters for call to function osal_mem_free
   \   000463   7406         MOV     A,#0x6
   \   000465   12....       LCALL   ?XSTACK_DISP0_8
   \   000468   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00046B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDO_ProcessMatchDescReq_32:
   \   00046E   7408         MOV     A,#0x8
   \   000470   12....       LCALL   ?XSTACK_DISP0_8
   \   000473   E0           MOVX    A,@DPTR
   \   000474   7002         JNZ     ??ZDO_ProcessMatchDescReq_33
   \   000476   A3           INC     DPTR
   \   000477   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_33:
   \   000478   7003         JNZ     $+5
   \   00047A   02....       LJMP    ??ZDO_ProcessMatchDescReq_2 & 0xFFFF
   \   00047D                ; Setup parameters for call to function osal_mem_free
   \   00047D   7408         MOV     A,#0x8
   \   00047F   02....       LJMP    ??ZDO_ProcessMatchDescReq_6 & 0xFFFF
   1119              osal_mem_free(inClusters);
   1120            }
   1121            if (outClusters)  {
   1122              osal_mem_free(outClusters);
   1123            }
   1124          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   75..00       MOV     ?V0 + 6,#0x0
   \   00000A   78..         MOV     R0,#?V0 + 4
   \   00000C   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F583         MOV     DPH,A
   \   000004   8882         MOV     DPL,R0
   \   000006                REQUIRE ?Subroutine23
   \   000006                ; // Fall through to label ?Subroutine23

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000003   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \                     ??Subroutine8_0:
   \   000002   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000003   A3           INC     DPTR
   \   000004   80..         SJMP    ?Subroutine23

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
   1125          
   1126          #if defined ( ZDO_COORDINATOR )
   1127          /*********************************************************************
   1128           * @fn          ZDO_ProcessEndDeviceBindReq
   1129           *
   1130           * @brief       This function processes and responds to the
   1131           *              End_Device_Bind_req message.
   1132           *
   1133           * @param       SrcAddr  - Source address
   1134           * @param       msg - input message containing search material
   1135           * @param       SecurityUse - Security enable/disable
   1136           *
   1137           * @return      none
   1138           */
   1139          void ZDO_ProcessEndDeviceBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg,
   1140                                            byte SecurityUse )
   1141          {
   1142            ZDEndDeviceBind_t bindReq;
   1143            uint8  protoVer;
   1144          
   1145            protoVer = NLME_GetProtocolVersion();
   1146          
   1147            // Parse the message
   1148            bindReq.TransSeq = TransSeq;
   1149            bindReq.srcAddr = SrcAddr->addr.shortAddr;
   1150            bindReq.SecurityUse = SecurityUse;
   1151          
   1152            bindReq.localCoordinator = BUILD_UINT16( msg[0], msg[1] );
   1153            msg += 2;
   1154          
   1155            if ( protoVer != ZB_PROT_V1_0 )
   1156            {
   1157              osal_cpyExtAddr( &(bindReq.ieeeAddr), msg );
   1158              msg += Z_EXTADDR_LEN;
   1159            }
   1160          
   1161            bindReq.endpoint = *msg++;
   1162            bindReq.profileID = BUILD_UINT16( msg[0], msg[1] );
   1163            msg += 2;
   1164          
   1165            bindReq.numInClusters = *msg++;
   1166            bindReq.inClusters = NULL;
   1167            if ( bindReq.numInClusters )
   1168            {
   1169              if ( !(bindReq.inClusters = ZDO_CreateAlignedUINT16List( bindReq.numInClusters, msg )) )
   1170              {
   1171                // can't allocate memory. drop message
   1172                return;
   1173              }
   1174            }
   1175            msg += (bindReq.numInClusters * ((protoVer != ZB_PROT_V1_0) ? sizeof ( uint16 ) : sizeof( uint8 )));
   1176          
   1177            bindReq.numOutClusters = *msg++;
   1178            bindReq.outClusters = NULL;
   1179            if ( bindReq.numOutClusters )
   1180            {
   1181              if ( !(bindReq.outClusters=ZDO_CreateAlignedUINT16List( bindReq.numOutClusters, msg )) )
   1182              {
   1183                // can't allocate memory. drop message
   1184                if ( bindReq.inClusters )
   1185                {
   1186                  osal_mem_free( bindReq.inClusters );
   1187                }
   1188                return;
   1189              }
   1190            }
   1191          
   1192            ZDApp_EndDeviceBindReqCB( &bindReq );
   1193          
   1194            if ( bindReq.inClusters )
   1195            {
   1196              osal_mem_free( bindReq.inClusters );
   1197            }
   1198            if ( bindReq.outClusters )
   1199            {
   1200              osal_mem_free( bindReq.outClusters );
   1201            }
   1202          }
   1203          #endif // ZDO_COORDINATOR
   1204          
   1205          #if defined ( REFLECTOR ) || defined ( ZDO_BIND_UNBIND_RESPONSE )
   1206          
   1207          /*********************************************************************
   1208           * @fn          ZDO_ProcessBindUnbindReq
   1209           *
   1210           * @brief       This function processes and responds to the
   1211           *              Bind_req or Unbind_req message.
   1212           *
   1213           * @param       SrcAddr  - Source address
   1214           * @param       msgClusterID - message cluster ID
   1215           * @param       msg - input message containing search material
   1216           * @param       SecurityUse - Security enable/disable
   1217           *
   1218           * @return      none
   1219           */
   1220          void ZDO_ProcessBindUnbindReq( byte TransSeq, zAddrType_t *SrcAddr, uint16 msgClusterID,
   1221                                        byte *msg, byte SecurityUse )
   1222          {
   1223            byte *SrcAddress;
   1224            byte SrcEpIntf;
   1225            uint16 ClusterID;
   1226            zAddrType_t DstAddress;
   1227            byte DstEpIntf;
   1228            uint8 protoVer;
   1229          
   1230            protoVer = NLME_GetProtocolVersion();
   1231          
   1232            SrcAddress = msg;
   1233            msg += Z_EXTADDR_LEN;
   1234            SrcEpIntf = *msg++;
   1235          
   1236            if ( protoVer != ZB_PROT_V1_0 )
   1237            {
   1238              ClusterID = BUILD_UINT16( msg[0], msg[1] );
   1239              msg += 2;
   1240            }
   1241            else
   1242            {
   1243              ClusterID = *msg++;
   1244            }
   1245          
   1246            if ( protoVer != ZB_PROT_V1_0 )
   1247            {
   1248              DstAddress.addrMode = *msg++;
   1249              if ( DstAddress.addrMode == Addr64Bit )
   1250              {
   1251                osal_cpyExtAddr( DstAddress.addr.extAddr, msg );
   1252                msg += Z_EXTADDR_LEN;
   1253                DstEpIntf = *msg;
   1254              }
   1255              else
   1256              {
   1257                DstAddress.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   1258                msg += sizeof ( uint16 );
   1259              }
   1260            }
   1261            else
   1262            {
   1263              DstAddress.addrMode = Addr64Bit;
   1264              osal_cpyExtAddr( DstAddress.addr.extAddr, msg );
   1265              msg += Z_EXTADDR_LEN;
   1266              DstEpIntf = *msg;
   1267            }
   1268          
   1269          
   1270            if ( msgClusterID == Bind_req )
   1271            {
   1272              ZDApp_BindReqCB( TransSeq, SrcAddr, SrcAddress, SrcEpIntf,
   1273                              ClusterID, &DstAddress, DstEpIntf, SecurityUse );
   1274            }
   1275            else
   1276            {
   1277              ZDApp_UnbindReqCB( TransSeq, SrcAddr, SrcAddress, SrcEpIntf,
   1278                              ClusterID, &DstAddress, DstEpIntf, SecurityUse );
   1279            }
   1280          }
   1281          #endif // REFLECTOR || ZDO_BIND_UNBIND_RESPONSE
   1282          
   1283          #if defined ( ZDO_NWKADDR_REQUEST ) || defined ( ZDO_IEEEADDR_REQUEST ) || defined ( REFLECTOR )
   1284          /*********************************************************************
   1285           * @fn      ZDO_ProcessAddrRsp
   1286           *
   1287           * @brief   Process an incoming NWK_addr_rsp or IEEE_addr_rsp message and then
   1288           *          invoke the corresponding CB function.
   1289           *
   1290           * @param   src - Source address of the request.
   1291           * @param   cId - Cluster ID of the request.
   1292           * @param   msg - Incoming request message.
   1293           *
   1294           * @return  none
   1295           */
   1296          void ZDO_ProcessAddrRsp( zAddrType_t *src, uint16 cId, byte *msg, byte msgLen )
   1297          {
   1298          #if defined ( REFLECTOR )
   1299            AddrMgrEntry_t addrEntry;
   1300          #endif
   1301            uint16 aoi;
   1302            uint16 *list = NULL;
   1303            byte idx = 0;
   1304            byte cnt = 0;
   1305          
   1306            byte stat = *msg++;
   1307            byte *ieee = msg;
   1308            msg += Z_EXTADDR_LEN;
   1309            aoi = BUILD_UINT16( msg[0], msg[1] );
   1310          
   1311          #if defined ( REFLECTOR )
   1312            // Add this to the address manager
   1313            addrEntry.user = ADDRMGR_USER_DEFAULT;
   1314            addrEntry.nwkAddr = aoi;
   1315            AddrMgrExtAddrSet( addrEntry.extAddr, ieee );
   1316            AddrMgrEntryUpdate( &addrEntry );
   1317          #endif
   1318          
   1319            // NumAssocDev field is only present on success.
   1320            if ( stat == ZDO_SUCCESS )
   1321            {
   1322              msg += 2;
   1323              cnt = ( msgLen > 1 + Z_EXTADDR_LEN + 2 ) ? *msg++ : 0;   // Single req: msgLen = status + IEEEAddr + NWKAddr
   1324          
   1325              // StartIndex field is only present if NumAssocDev field is non-zero.
   1326              if ( cnt != 0 )
   1327              {
   1328                idx = *msg++;
   1329          
   1330                if ( cnt > idx )
   1331                {
   1332                  list = osal_mem_alloc( (short)(cnt * sizeof( uint16 )) );
   1333          
   1334                  if ( list )
   1335                  {
   1336                    uint16 *pList = list;
   1337                    byte n = cnt - idx;
   1338          
   1339                    while ( n != 0 )
   1340                    {
   1341                      *pList++ = BUILD_UINT16( msg[0], msg[1] );
   1342                      msg += sizeof( uint16 );
   1343                      n--;
   1344                    }
   1345                  }
   1346                }
   1347              }
   1348            }
   1349          
   1350          #if defined ( ZDO_NWKADDR_REQUEST )
   1351            if ( cId == NWK_addr_rsp )
   1352            {
   1353              ZDApp_NwkAddrRspCB( src, stat, ieee, aoi, cnt, idx, list );
   1354            }
   1355          #endif
   1356          
   1357          #if defined ( ZDO_IEEEADDR_REQUEST )
   1358            if ( cId == IEEE_addr_rsp )
   1359            {
   1360              ZDApp_IEEEAddrRspCB( src, stat, ieee, aoi, cnt, idx, list );
   1361            }
   1362          #endif
   1363          
   1364            if ( list )
   1365            {
   1366              osal_mem_free( list );
   1367            }
   1368          }
   1369          #endif // ZDO_NWKADDR_REQUEST ZDO_IEEEADDR_REQUEST
   1370          
   1371          #if defined ( ZDO_NODEDESC_REQUEST )
   1372          /*********************************************************************
   1373           * @fn          ZDO_ProcessNodeDescRsp
   1374           *
   1375           * @brief       This function processes and responds to the
   1376           *              Node_Desc_rsp message.
   1377           *
   1378           * @param       SrcAddr  - Source address
   1379           * @param       msg - input message containing search material
   1380           *
   1381           * @return      none
   1382           */
   1383          void ZDO_ProcessNodeDescRsp( zAddrType_t *SrcAddr, byte *msg )
   1384          {
   1385            byte proVer = NLME_GetProtocolVersion();
   1386            NodeDescriptorFormat_t nodeDesc;
   1387            NodeDescriptorFormat_t *pNodeDesc = NULL;
   1388            byte Status = *msg++;
   1389            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   1390          
   1391            if ( Status == ZDP_SUCCESS )
   1392            {
   1393              msg += 2;
   1394              nodeDesc.LogicalType = *msg & 0x07;
   1395              if ( proVer == ZB_PROT_V1_0 )
   1396              {
   1397                nodeDesc.UserDescAvail = 0;
   1398                nodeDesc.ComplexDescAvail = 0;
   1399              }
   1400              else
   1401              {
   1402                nodeDesc.ComplexDescAvail = ( *msg & 0x08 ) >> 3;
   1403                nodeDesc.UserDescAvail = ( *msg & 0x10 ) >> 4;
   1404              }
   1405              msg++;  // Reserved bits.
   1406              nodeDesc.FrequencyBand = (*msg >> 3) & 0x1f;
   1407              nodeDesc.APSFlags = *msg++ & 0x07;
   1408              nodeDesc.CapabilityFlags = *msg++;
   1409              nodeDesc.ManufacturerCode[0] = *msg++;
   1410              nodeDesc.ManufacturerCode[1] = *msg++;
   1411              nodeDesc.MaxBufferSize = *msg++;
   1412              nodeDesc.MaxTransferSize[0] = *msg++;
   1413              nodeDesc.MaxTransferSize[1] = *msg++;
   1414              
   1415              if ( proVer == ZB_PROT_V1_0)
   1416              {
   1417                nodeDesc.ServerMask = 0;
   1418              }
   1419              else
   1420              {
   1421                nodeDesc.ServerMask = BUILD_UINT16( msg[0], msg[1] );
   1422              }
   1423              
   1424              pNodeDesc = &nodeDesc;
   1425            }
   1426          
   1427            ZDApp_NodeDescRspCB( SrcAddr, Status, aoi, pNodeDesc );
   1428          }
   1429          #endif // ZDO_NODEDESC_REQUEST
   1430          
   1431          #if defined ( ZDO_POWERDESC_REQUEST )
   1432          /*********************************************************************
   1433           * @fn          ZDO_ProcessPowerDescRsp
   1434           *
   1435           * @brief       This function processes and responds to the
   1436           *              Power_Desc_rsp message.
   1437           *
   1438           * @param       SrcAddr  - Source address
   1439           * @param       msg - input message containing search material
   1440           *
   1441           * @return      none
   1442           */
   1443          void ZDO_ProcessPowerDescRsp( zAddrType_t *SrcAddr, byte *msg )
   1444          {
   1445            NodePowerDescriptorFormat_t pwrDesc;
   1446            NodePowerDescriptorFormat_t *pPwrDesc = NULL;
   1447            byte Status = *msg++;
   1448            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   1449          
   1450            if ( Status == ZDP_SUCCESS )
   1451            {
   1452              msg += 2;
   1453              pwrDesc.AvailablePowerSources = *msg >> 4;
   1454              pwrDesc.PowerMode = *msg++ & 0x0F;
   1455              pwrDesc.CurrentPowerSourceLevel = *msg >> 4;
   1456              pwrDesc.CurrentPowerSource = *msg++ & 0x0F;
   1457              pPwrDesc = &pwrDesc;
   1458            }
   1459          
   1460            ZDApp_PowerDescRspCB( SrcAddr, Status, aoi, pPwrDesc );
   1461          }
   1462          #endif // ZDO_POWERDESC_REQUEST
   1463          
   1464          #if defined ( ZDO_SIMPLEDESC_REQUEST )
   1465          /*********************************************************************
   1466           * @fn          ZDO_ProcessSimpleDescRsp
   1467           *
   1468           * @brief       This function processes and responds to the
   1469           *              Simple_Desc_rsp message.
   1470           *
   1471           * @param       SrcAddr  - Source address
   1472           * @param       msg - input message containing search material
   1473           *
   1474           * @return      none
   1475           */
   1476          void ZDO_ProcessSimpleDescRsp( zAddrType_t *SrcAddr, byte *msg )
   1477          {
   1478            byte epIntf = 0;
   1479            SimpleDescriptionFormat_t simpleDesc;
   1480            SimpleDescriptionFormat_t *pSimpleDesc = NULL;
   1481            byte Status = *msg++;
   1482            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   1483          
   1484            if ( Status == ZDP_SUCCESS )
   1485            {
   1486              msg += 3;
   1487              epIntf = *msg;
   1488              pSimpleDesc = &simpleDesc;
   1489              ZDO_ParseSimpleDescBuf( msg, pSimpleDesc );
   1490            }
   1491          
   1492            ZDApp_SimpleDescRspCB( SrcAddr, Status, aoi, epIntf, pSimpleDesc );
   1493          }
   1494          #endif // ZDO_SIMPLEDESC_REQUEST
   1495          
   1496          #if defined ( ZDO_ACTIVEEP_REQUEST ) || defined ( ZDO_MATCH_REQUEST )
   1497          /*********************************************************************
   1498           * @fn          ZDO_ProcessEPListRsp
   1499           *
   1500           * @brief       This function processes and responds to the
   1501           *              Active_EP_rsp or Match_Desc_rsp message.
   1502           *
   1503           * @param       src  - Source address
   1504           * @param       ClusterID - Active_EP_rsp or Match_Desc_rsp
   1505           * @param       msg - input message containing search material
   1506           *
   1507           * @return      none
   1508           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1509          void ZDO_ProcessEPListRsp( zAddrType_t *src, uint16 ClusterID, byte *msg )
   \                     ZDO_ProcessEPListRsp:
   1510          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   740C         MOV     A,#0xc
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine13 & 0xFFFF
   1511            byte Status = *msg++;
   \                     ??CrossCallReturnLabel_35:
   \   00000D   8882         MOV     DPL,R0
   \   00000F   8983         MOV     DPH,R1
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F5..         MOV     ?V0 + 0,A
   \   000014   A3           INC     DPTR
   \   000015   A882         MOV     R0,DPL
   \   000017   A983         MOV     R1,DPH
   1512            byte cnt = msg[2];
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
   1513            byte *list = msg+3;
   1514          
   1515            src->addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   \   00001E   8882         MOV     DPL,R0
   \   000020   8983         MOV     DPH,R1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 2,A
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FF           MOV     R7,A
   \   000028   E4           CLR     A
   \   000029   25..         ADD     A,?V0 + 2
   \   00002B   FE           MOV     R6,A
   \   00002C   EF           MOV     A,R7
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   FF           MOV     R7,A
   \   000030   8A82         MOV     DPL,R2
   \   000032   8B83         MOV     DPH,R3
   \   000034   EE           MOV     A,R6
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   EF           MOV     A,R7
   \   000038   F0           MOVX    @DPTR,A
   1516          
   1517          #if defined ( ZDO_ACTIVEEP_REQUEST )
   1518            if ( ClusterID == Active_EP_rsp )
   1519              ZDApp_ActiveEPRspCB( src, Status, cnt, list );
   1520          #endif
   1521          
   1522          #if defined ( ZDO_MATCH_REQUEST )
   1523            if ( ClusterID == Match_Desc_rsp )
   \   000039   7406         MOV     A,#0x6
   \   00003B   6C           XRL     A,R4
   \   00003C   7003         JNZ     ??ZDO_ProcessEPListRsp_0
   \   00003E   7480         MOV     A,#-0x80
   \   000040   6D           XRL     A,R5
   \                     ??ZDO_ProcessEPListRsp_0:
   \   000041   7020         JNZ     ??ZDO_ProcessEPListRsp_1
   1524              ZDApp_MatchDescRspCB( src, Status, cnt, list );
   \   000043                ; Setup parameters for call to function ZDApp_MatchDescRspCB
   \   000043   E8           MOV     A,R0
   \   000044   2403         ADD     A,#0x3
   \   000046   F5..         MOV     ?V0 + 2,A
   \   000048   E9           MOV     A,R1
   \   000049   3400         ADDC    A,#0x0
   \   00004B   F5..         MOV     ?V0 + 3,A
   \   00004D   78..         MOV     R0,#?V0 + 2
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000052   AC..         MOV     R4,?V0 + 1
   \   000054   A9..         MOV     R1,?V0 + 0
   \   000056   90....       MOV     DPTR,#(ZDApp_MatchDescRspCB & 0xffff)
   \   000059   74..         MOV     A,#((ZDApp_MatchDescRspCB >> 16) & 0xff)
   \   00005B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00005E   7402         MOV     A,#0x2
   \   000060   12....       LCALL   ?DEALLOC_XSTACK8
   1525          #endif
   1526          }
   \                     ??ZDO_ProcessEPListRsp_1:
   \   000063   02....       LJMP    ?Subroutine22 & 0xFFFF
   1527          #endif  // ZDO_ACTIVEEP_REQUEST ZDO_MATCH_REQUEST
   1528          
   1529          #if defined ( ZDO_BIND_UNBIND_REQUEST ) || defined ( ZDO_ENDDEVICEBIND_REQUEST ) || defined ( ZDO_COORDINATOR )
   1530          /*********************************************************************
   1531           * @fn          ZDO_ProcessBindUnBindRsp
   1532           *
   1533           * @brief       This function processes and responds to the
   1534           *              End_Device_Bind_rsp message.
   1535           *
   1536           * @param       SrcAddr  - Source address
   1537           * @param       ClusterID - Active_EP_rsp or Match_Desc_rsp
   1538           * @param       msg - input message containing search material
   1539           *
   1540           * @return      none
   1541           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1542          void ZDO_ProcessBindUnbindRsp( zAddrType_t *SrcAddr, uint16 ClusterID, byte Status, uint8 TransSeq )
   \                     ZDO_ProcessBindUnbindRsp:
   1543          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1544          #if defined ( ZDO_COORDINATOR )
   1545            uint8 used = FALSE;
   1546          #endif
   1547          
   1548          #if defined ( ZDO_ENDDEVICEBIND_REQUEST )
   1549            if ( ClusterID == End_Device_Bind_rsp )
   \   000004   7420         MOV     A,#0x20
   \   000006   6C           XRL     A,R4
   \   000007   7003         JNZ     ??ZDO_ProcessBindUnbindRsp_0
   \   000009   7480         MOV     A,#-0x80
   \   00000B   6D           XRL     A,R5
   \                     ??ZDO_ProcessBindUnbindRsp_0:
   \   00000C   7008         JNZ     ??ZDO_ProcessBindUnbindRsp_1
   1550              ZDApp_EndDeviceBindRsp( SrcAddr, Status );
   \   00000E                ; Setup parameters for call to function ZDApp_EndDeviceBindRsp
   \   00000E   90....       MOV     DPTR,#(ZDApp_EndDeviceBindRsp & 0xffff)
   \   000011   74..         MOV     A,#((ZDApp_EndDeviceBindRsp >> 16) & 0xff)
   \   000013   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1551          #endif
   1552          
   1553          #if defined ( ZDO_COORDINATOR )
   1554            if ( matchED )
   1555            {
   1556              used = ZDMatchSendState(
   1557                     (uint8)((ClusterID == Bind_rsp) ? ZDMATCH_REASON_BIND_RSP : ZDMATCH_REASON_UNBIND_RSP),
   1558                     Status, TransSeq );
   1559            }
   1560          
   1561            if ( !used )
   1562          #endif
   1563            {
   1564            #if defined ( ZDO_BIND_UNBIND_REQUEST )
   1565              if ( ClusterID == Bind_rsp )
   1566                ZDApp_BindRsp( SrcAddr, Status );
   1567              else
   1568                ZDApp_UnbindRsp( SrcAddr, Status );
   1569            #endif
   1570            }
   1571          }
   \                     ??ZDO_ProcessBindUnbindRsp_1:
   \   000016   02....       LJMP    ?Subroutine21 & 0xFFFF
   1572          #endif // ZDO_BIND_UNBIND_REQUEST ZDO_ENDDEVICEBIND_REQUEST
   1573          
   1574          #if defined ( ZDO_SERVERDISC_REQUEST )
   1575          /*********************************************************************
   1576           * @fn          ZDO_ProcessServerDiscRsp
   1577           *
   1578           * @brief       Process the Server_Discovery_rsp message.
   1579           *
   1580           * @param       srcAddr - Source address.
   1581           * @param       msg - Byte array containing the Server_Discovery_rsp command frame.
   1582           * @param       SecurityUse -
   1583           *
   1584           * @return      none
   1585           */
   1586          void ZDO_ProcessServerDiscRsp(zAddrType_t *srcAddr, byte *msg, byte SecurityUse)
   1587          {
   1588            byte status = *msg++;
   1589            uint16 serverMask = BUILD_UINT16( msg[0], msg[1] );
   1590          
   1591            ZDApp_ServerDiscRspCB( srcAddr->addr.shortAddr, status, serverMask,
   1592                                   SecurityUse );
   1593          }
   1594          #endif
   1595          
   1596          #if defined ( ZDO_SERVERDISC_RESPONSE )
   1597          /*********************************************************************
   1598           * @fn          ZDO_ProcessServerDiscReq
   1599           *
   1600           * @brief       Process the Server_Discovery_req message.
   1601           *
   1602           * @param       transID - Transaction sequence number of request.
   1603           * @param       srcAddr  - Source address
   1604           * @param       msg - Byte array containing the Server_Discovery_req command frame.
   1605           * @param       SecurityUse -
   1606           *
   1607           * @return      none
   1608           */
   1609          void ZDO_ProcessServerDiscReq( byte transID, zAddrType_t *srcAddr, byte *msg,
   1610                                         byte SecurityUse )
   1611          {
   1612            uint16 serverMask = BUILD_UINT16( msg[0], msg[1] );
   1613            uint16 matchMask = serverMask & ZDO_Config_Node_Descriptor.ServerMask;
   1614          
   1615            if ( matchMask )
   1616            {
   1617              ZDP_ServerDiscRsp( transID, srcAddr, ZSUCCESS, ZDAppNwkAddr.addr.shortAddr,
   1618                                 matchMask, SecurityUse );
   1619            }
   1620          }
   1621          #endif
   1622          
   1623          /*********************************************************************
   1624           * Call Back Functions from APS  - API
   1625           */
   1626          
   1627          /*********************************************************************
   1628           * @fn          ZDO_EndDeviceTimeoutCB
   1629           *
   1630           * @brief       This function handles the binding timer for the End
   1631           *              Device Bind command.
   1632           *
   1633           * @param       none
   1634           *
   1635           * @return      none
   1636           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1637          void ZDO_EndDeviceTimeoutCB( void )
   \                     ZDO_EndDeviceTimeoutCB:
   1638          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1639          #if defined ( REFLECTOR )
   1640            byte stat;
   1641            if ( ZDO_EDBind )
   1642            {
   1643              stat = ZDO_EDBind->status;
   1644          
   1645              // Send the response message to the first sent
   1646              ZDO_SendEDBindRsp( ZDO_EDBind->SrcTransSeq, &(ZDO_EDBind->SrcAddr),
   1647                                  stat, ZDO_EDBind->SecurityUse );
   1648          
   1649              ZDO_RemoveEndDeviceBind();
   1650            }
   1651          #endif  // REFLECTOR
   1652          }
   \   000000   02....       LJMP    ?BRET

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0
   1653          
   1654          /*********************************************************************
   1655           * Optional Management Messages
   1656           */
   1657          
   1658          #if defined( ZDO_MGMT_LQI_RESPONSE ) && defined ( RTR_NWK )
   1659          /*********************************************************************
   1660           * @fn          ZDO_ProcessMgmtLqiReq
   1661           *
   1662           * @brief       This function handles parsing the incoming Management
   1663           *              LQI request and generate the response.
   1664           *
   1665           *   Note:      This function will limit the number of items returned
   1666           *              to ZDO_MAX_LQI_ITEMS items.
   1667           *
   1668           * @param       SrcAddr - source of the request
   1669           * @param       StartIndex - where to start the return list
   1670           * @param       SecurityUse -
   1671           *
   1672           * @return      none
   1673           */
   1674          void ZDO_ProcessMgmtLqiReq( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   1675          {
   1676            byte x;
   1677            byte index;
   1678            byte numItems;
   1679            byte maxItems;
   1680            ZDP_MgmtLqiItem_t* table;
   1681            ZDP_MgmtLqiItem_t* item;
   1682            neighborEntry_t    entry;
   1683            byte aItems;
   1684            associated_devices_t *aDevice;
   1685          
   1686            // Get the number of neighbor items
   1687            NLME_GetRequest( nwkNumNeighborTableEntries, 0, &maxItems );
   1688          
   1689            // Get the number of associated items
   1690            aItems = (uint8)AssocCount( PARENT, CHILD_FFD_RX_IDLE );
   1691            // Total number of items
   1692            maxItems += aItems;
   1693          
   1694            // Start with the supplied index
   1695            numItems = maxItems - StartIndex;
   1696          
   1697            // limit the size of the list
   1698            if ( numItems > ZDO_MAX_LQI_ITEMS )
   1699              numItems = ZDO_MAX_LQI_ITEMS;
   1700          
   1701            // Allocate the memory to build the table
   1702            table = (ZDP_MgmtLqiItem_t*)osal_mem_alloc( (short)
   1703                      ( numItems * sizeof( ZDP_MgmtLqiItem_t ) ) );
   1704          
   1705            if ( table != NULL )
   1706            {
   1707              x = 0;
   1708              item = table;
   1709              index = StartIndex;
   1710          
   1711              // Loop through associated items and build list
   1712              for ( ; x < numItems; x++ )
   1713              {
   1714                if ( index < aItems )
   1715                {
   1716                  // get next associated device
   1717                  aDevice = AssocFindDevice( index++ );
   1718          
   1719                  // set basic fields
   1720                  item->panID   = _NIB.nwkPanId;
   1721                  osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   1722                  item->nwkAddr = aDevice->shortAddr;
   1723                  item->permit  = ZDP_MGMT_BOOL_UNKNOWN;
   1724                  item->depth   = 0xFF;
   1725                  item->lqi     = aDevice->linkInfo.rxCost;
   1726          
   1727                  osal_memset( item->extAddr, 0x00, Z_EXTADDR_LEN );
   1728          
   1729                  // use association info to set other fields
   1730                  if ( aDevice->nodeRelation == PARENT )
   1731                  {
   1732                    if (  aDevice->shortAddr == 0 )
   1733                    {
   1734                      item->devType = ZDP_MGMT_DT_COORD;
   1735                    }
   1736                    else
   1737                    {
   1738                      item->devType = ZDP_MGMT_DT_ROUTER;
   1739                    }
   1740          
   1741                    item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1742                    item->relation = ZDP_MGMT_REL_PARENT;
   1743                  }
   1744                  else
   1745                  {
   1746                    if ( aDevice->nodeRelation < CHILD_FFD )
   1747                    {
   1748                      item->devType = ZDP_MGMT_DT_ENDDEV;
   1749          
   1750                      if ( aDevice->nodeRelation == CHILD_RFD )
   1751                      {
   1752                        item->rxOnIdle = FALSE;
   1753                      }
   1754                      else
   1755                      {
   1756                        item->rxOnIdle = TRUE;
   1757                      }
   1758                    }
   1759                    else
   1760                    {
   1761                      item->devType = ZDP_MGMT_DT_ROUTER;
   1762          
   1763                      if ( aDevice->nodeRelation == CHILD_FFD )
   1764                      {
   1765                        item->rxOnIdle = FALSE;
   1766                      }
   1767                      else
   1768                      {
   1769                        item->rxOnIdle = TRUE;
   1770                      }
   1771                    }
   1772          
   1773                    item->relation = ZDP_MGMT_REL_CHILD;
   1774                  }
   1775          
   1776                  item++;
   1777                }
   1778                else
   1779                {
   1780                  if ( StartIndex <= aItems )
   1781                    // Start with 1st neighbor
   1782                    index = 0;
   1783                  else
   1784                    // Start with >1st neighbor
   1785                    index = StartIndex - aItems;
   1786                  break;
   1787                }
   1788              }
   1789          
   1790              // Loop through neighbor items and finish list
   1791              for ( ; x < numItems; x++ )
   1792              {
   1793                // Add next neighbor table item
   1794                NLME_GetRequest( nwkNeighborTable, index++, &entry );
   1795          
   1796                // set ZDP_MgmtLqiItem_t fields
   1797                item->panID    = entry.panId;
   1798                osal_memset( item->extPanID, 0x00, Z_EXTADDR_LEN);
   1799                osal_memset( item->extAddr, 0x00, Z_EXTADDR_LEN );
   1800                item->nwkAddr  = entry.neighborAddress;
   1801                item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1802                item->relation = ZDP_MGMT_REL_UNKNOWN;
   1803                item->permit   = ZDP_MGMT_BOOL_UNKNOWN;
   1804                item->depth    = 0xFF;
   1805                item->lqi      = entry.linkInfo.rxCost;
   1806          
   1807                if ( item->nwkAddr == 0 )
   1808                {
   1809                  item->devType = ZDP_MGMT_DT_COORD;
   1810                }
   1811                else
   1812                {
   1813                  item->devType = ZDP_MGMT_DT_ROUTER;
   1814                }
   1815          
   1816                item++;
   1817              }
   1818          
   1819              // Send response
   1820              ZDP_MgmtLqiRsp( TransSeq, SrcAddr, ZSuccess, maxItems,
   1821                              StartIndex, numItems, table, false );
   1822          
   1823              osal_mem_free( table );
   1824            }
   1825          }
   1826          #endif // ZDO_MGMT_LQI_RESPONSE && RTR_NWK
   1827          
   1828          #if defined ( ZDO_MGMT_LQI_REQUEST )
   1829          /*********************************************************************
   1830           * @fn          ZDO_ProcessMgmtLqiRsp
   1831           *
   1832           * @brief       This function handles parsing the incoming Management
   1833           *              LQI response and then generates a callback to the ZD
   1834           *              application.
   1835           *
   1836           * @param       SrcAddr - source of the request
   1837           * @param       msg - buffer holding incoming message to parse
   1838           * @param       SecurityUse -
   1839           *
   1840           * @return      none
   1841           */
   1842          void ZDO_ProcessMgmtLqiRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   1843          {
   1844            byte x;
   1845            byte status;
   1846            byte startIndex = 0;
   1847            byte neighborLqiCount = 0;
   1848            byte neighborLqiEntries = 0;
   1849            neighborLqiItem_t *list = NULL;
   1850            byte proVer = NLME_GetProtocolVersion();
   1851          
   1852            status = *msg++;
   1853            if ( status == ZSuccess )
   1854            {
   1855              neighborLqiEntries = *msg++;
   1856              startIndex = *msg++;
   1857              neighborLqiCount = *msg++;
   1858          
   1859              // Allocate a buffer big enough to handle the list.
   1860              list = (neighborLqiItem_t *)osal_mem_alloc( neighborLqiCount *
   1861                                                  sizeof( neighborLqiItem_t ) );
   1862              if ( list )
   1863              {
   1864                neighborLqiItem_t *pList = list;
   1865          
   1866                for ( x = 0; x < neighborLqiCount; x++ )
   1867                {
   1868                  if ( proVer == ZB_PROT_V1_0 )
   1869                  {
   1870                    pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   1871                    msg += 2;
   1872                  }
   1873                  else
   1874                  {
   1875                    osal_cpyExtAddr(pList->extPANId, msg);   //Copy extended PAN ID
   1876                    msg += Z_EXTADDR_LEN;
   1877                  }
   1878          
   1879                  msg += Z_EXTADDR_LEN;  // Throwing away IEEE.
   1880                  pList->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   1881                  if ( proVer == ZB_PROT_V1_0 )
   1882                    msg += 2 + 1 + 1;          // Skip DeviceType, RxOnIdle, Relationship, PermitJoinging and Depth
   1883                  else
   1884                    msg += 2 + 1 + 1 + 1;      // Skip DeviceType, RxOnIdle, Rlationship, PermitJoining and Depth
   1885          
   1886                  pList->rxLqi = *msg++;
   1887                  pList->txQuality = 0;  // This is not specified OTA by ZigBee 1.1.
   1888                  pList++;
   1889                }
   1890              }
   1891            }
   1892          
   1893            // Call the callback to the application.
   1894            ZDApp_MgmtLqiRspCB( SrcAddr->addr.shortAddr, status, neighborLqiEntries,
   1895                                startIndex, neighborLqiCount, list );
   1896          
   1897            if ( list )
   1898            {
   1899              osal_mem_free( list );
   1900            }
   1901          }
   1902          #endif // ZDO_MGMT_LQI_REQUEST
   1903          
   1904          #if defined( ZDO_MGMT_NWKDISC_RESPONSE )
   1905          /*********************************************************************
   1906           * @fn          ZDO_ProcessMgmtNwkDiscReq
   1907           *
   1908           * @brief       This function handles parsing the incoming Management
   1909           *              Network Discover request and starts the request.
   1910           *
   1911           * @param       SrcAddr - source of the request
   1912           * @param       msg - pointer to incoming message
   1913           * @param       SecurityUse -
   1914           *
   1915           * @return      none
   1916           */
   1917          void ZDO_ProcessMgmtNwkDiscReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   1918          {
   1919            NLME_ScanFields_t scan;
   1920            uint8             index;
   1921          
   1922            scan.channels = BUILD_UINT32( msg[0], msg[1], msg[2], msg[3] );
   1923            msg += 4;
   1924            scan.duration = *msg++;
   1925            index         = *msg;
   1926          
   1927            // Save off the information to be used for the response
   1928            zdappMgmtNwkDiscReqInProgress          = true;
   1929            zdappMgmtNwkDiscRspAddr.addrMode       = Addr16Bit;
   1930            zdappMgmtNwkDiscRspAddr.addr.shortAddr = SrcAddr->addr.shortAddr;
   1931            zdappMgmtNwkDiscStartIndex             = index;
   1932            zdappMgmtNwkDiscRspTransSeq            = TransSeq;
   1933          
   1934            if ( NLME_NwkDiscReq2( &scan ) != ZSuccess )
   1935            {
   1936              NLME_NwkDiscTerm();
   1937          
   1938              // zdappMgmtNwkDiscReqInProgress will be reset in the confirm callback
   1939            }
   1940          }
   1941          #endif // ZDO_MGMT_NWKDISC_RESPONSE
   1942          
   1943          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   1944          /*********************************************************************
   1945           * @fn          ZDO_FinishProcessingMgmtNwkDiscReq
   1946           *
   1947           * @brief       This function finishes the processing of the Management
   1948           *              Network Discover Request and generates the response.
   1949           *
   1950           *   Note:      This function will limit the number of items returned
   1951           *              to ZDO_MAX_NWKDISC_ITEMS items.
   1952           *
   1953           * @param       ResultCountSrcAddr - source of the request
   1954           * @param       msg - pointer to incoming message
   1955           * @param       SecurityUse -
   1956           *
   1957           * @return      none
   1958           */
   1959          void ZDO_FinishProcessingMgmtNwkDiscReq( byte ResultCount,
   1960                                                   networkDesc_t *NetworkList )
   1961          {
   1962            byte count;
   1963          
   1964          #if defined ( RTR_NWK )
   1965            networkDesc_t *newDesc, *pList = NetworkList;
   1966          
   1967            // Look for my PanID.
   1968            while ( pList )
   1969            {
   1970              if ( pList->panId == _NIB.nwkPanId )
   1971              {
   1972                break;
   1973              }
   1974          
   1975              if ( !pList->nextDesc )
   1976              {
   1977                break;
   1978              }
   1979              pList = pList->nextDesc;
   1980            }
   1981          
   1982            // If my Pan not present (query to a star network ZC or an isolated ZR?),
   1983            // prepend it.
   1984            if ( !pList || (pList->panId != _NIB.nwkPanId) )
   1985            {
   1986              newDesc = (networkDesc_t *)osal_mem_alloc( sizeof( networkDesc_t ) );
   1987              if ( newDesc )
   1988              {
   1989                byte pJoin;
   1990          
   1991                newDesc->panId = _NIB.nwkPanId;
   1992                newDesc->logicalChannel = _NIB.nwkLogicalChannel;
   1993                newDesc->beaconOrder = _NIB.beaconOrder;
   1994                newDesc->superFrameOrder = _NIB.superFrameOrder;
   1995                newDesc->version = NLME_GetProtocolVersion();
   1996                newDesc->stackProfile = zgStackProfile;
   1997                //Extended PanID
   1998                osal_cpyExtAddr( newDesc->extendedPANID, _NIB.extendedPANID);
   1999          
   2000                ZMacGetReq( ZMacAssociationPermit, &pJoin );
   2001                newDesc->chosenRouter = ((pJoin) ? ZDAppNwkAddr.addr.shortAddr :
   2002                                                   INVALID_NODE_ADDR);
   2003          
   2004                newDesc->nextDesc = NetworkList;
   2005                NetworkList = newDesc;
   2006                ResultCount++;
   2007              }
   2008            }
   2009          #endif
   2010          
   2011            // Calc the count and apply a max count.
   2012            if ( zdappMgmtNwkDiscStartIndex > ResultCount )
   2013            {
   2014              count = 0;
   2015            }
   2016            else
   2017            {
   2018              count = ResultCount - zdappMgmtNwkDiscStartIndex;
   2019              if ( count > ZDO_MAX_NWKDISC_ITEMS )
   2020              {
   2021                count = ZDO_MAX_NWKDISC_ITEMS;
   2022              }
   2023          
   2024              // Move the list pointer up to the start index.
   2025              NetworkList += zdappMgmtNwkDiscStartIndex;
   2026            }
   2027          
   2028            ZDP_MgmtNwkDiscRsp( zdappMgmtNwkDiscRspTransSeq,
   2029                               &zdappMgmtNwkDiscRspAddr, ZSuccess, ResultCount,
   2030                                zdappMgmtNwkDiscStartIndex,
   2031                                count,
   2032                                NetworkList,
   2033                                false );
   2034          
   2035          #if defined ( RTR_NWK )
   2036            if ( newDesc )
   2037            {
   2038              osal_mem_free( newDesc );
   2039            }
   2040          #endif
   2041          
   2042            NLME_NwkDiscTerm();
   2043          }
   2044          #endif
   2045          
   2046          #if defined ( ZDO_MGMT_NWKDISC_REQUEST )
   2047          /*********************************************************************
   2048           * @fn          ZDO_ProcessMgmNwkDiscRsp
   2049           *
   2050           * @brief       This function handles parsing the incoming Management
   2051           *              Network Discover response and then generates a callback
   2052           *              to the ZD application.
   2053           *
   2054           * @param       SrcAddr - source of the request
   2055           * @param       msg - buffer holding incoming message to parse
   2056           * @param       SecurityUse -
   2057           *
   2058           * @return      none
   2059           */
   2060          void ZDO_ProcessMgmNwkDiscRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2061          {
   2062            byte x;
   2063            byte status;
   2064            byte networkCount = 0;
   2065            byte startIndex = 0;
   2066            byte networkListCount = 0;
   2067            mgmtNwkDiscItem_t *list = NULL;
   2068          
   2069            byte proVer = NLME_GetProtocolVersion();
   2070          
   2071            status = *msg++;
   2072            if ( status == ZSuccess )
   2073            {
   2074              networkCount = *msg++;
   2075              startIndex = *msg++;
   2076              networkListCount = *msg++;
   2077          
   2078              // Allocate a buffer big enough to handle the list.
   2079              list = (mgmtNwkDiscItem_t *)osal_mem_alloc( networkListCount *
   2080                                                  sizeof( mgmtNwkDiscItem_t ) );
   2081              if ( list )
   2082              {
   2083                mgmtNwkDiscItem_t *pList = list;
   2084                for ( x = 0; x < networkListCount; x++ )
   2085                {
   2086                  if ( proVer == ZB_PROT_V1_0 )  //Version 1.0
   2087                  {
   2088                    pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   2089                    msg += 2;
   2090                  }
   2091                  else
   2092                  {
   2093                    osal_cpyExtAddr(pList->extendedPANID, msg);   //Copy extended PAN ID
   2094                    pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   2095                    msg += Z_EXTADDR_LEN;
   2096          
   2097                  }
   2098                  pList->logicalChannel = *msg++;
   2099                  pList->stackProfile = (*msg) & 0x0F;
   2100                  pList->version = (*msg++ >> 4) & 0x0F;
   2101                  pList->beaconOrder = (*msg) & 0x0F;
   2102                  pList->superFrameOrder = (*msg++ >> 4) & 0x0F;
   2103                  pList->permitJoining = *msg++;
   2104                  pList++;
   2105                }
   2106              }
   2107            }
   2108          
   2109            // Call the callback to the application.
   2110            ZDApp_MgmtNwkDiscRspCB( SrcAddr->addr.shortAddr, status, networkCount,
   2111                                    startIndex, networkListCount, list );
   2112          
   2113            if ( list )
   2114            {
   2115              osal_mem_free( list );
   2116            }
   2117          }
   2118          #endif // ZDO_MGMT_NWKDISC_REQUEST
   2119          
   2120          #if defined ( ZDO_MGMT_RTG_RESPONSE ) && defined ( RTR_NWK )
   2121          /*********************************************************************
   2122           * @fn          ZDO_ProcessMgmtRtgReq
   2123           *
   2124           * @brief       This function finishes the processing of the Management
   2125           *              Routing Request and generates the response.
   2126           *
   2127           *   Note:      This function will limit the number of items returned
   2128           *              to ZDO_MAX_RTG_ITEMS items.
   2129           *
   2130           * @param       ResultCountSrcAddr - source of the request
   2131           * @param       msg - pointer to incoming message
   2132           * @param       SecurityUse -
   2133           *
   2134           * @return      none
   2135           */
   2136          void ZDO_ProcessMgmtRtgReq( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   2137          {
   2138            byte x;
   2139            byte maxNumItems;
   2140            byte numItems;
   2141            byte *pBuf;
   2142            rtgItem_t *pList;
   2143          
   2144            // Get the number of table items
   2145            NLME_GetRequest( nwkNumRoutingTableEntries, 0, &maxNumItems );
   2146          
   2147            numItems = maxNumItems - StartIndex;    // Start at the passed in index
   2148          
   2149            // limit the size of the list
   2150            if ( numItems > ZDO_MAX_RTG_ITEMS )
   2151              numItems = ZDO_MAX_RTG_ITEMS;
   2152          
   2153            // Allocate the memory to build the table
   2154            pBuf = osal_mem_alloc( (short)(sizeof( rtgItem_t ) * numItems) );
   2155          
   2156            if ( pBuf )
   2157            {
   2158              // Convert buffer to list
   2159              pList = (rtgItem_t *)pBuf;
   2160          
   2161              // Loop through items and build list
   2162              for ( x = 0; x < numItems; x++ )
   2163              {
   2164                NLME_GetRequest( nwkRoutingTable, (uint16)(x + StartIndex), (void*)pList );
   2165          
   2166                // Remap the status to the RoutingTableList Record Format defined in the ZigBee spec
   2167                switch( pList->status )
   2168                {
   2169                  case RT_ACTIVE:
   2170                    pList->status = ZDO_MGMT_RTG_ENTRY_ACTIVE;
   2171                    break;
   2172          
   2173                  case RT_DISC:
   2174                    pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY;
   2175                    break;
   2176          
   2177                  case RT_LINK_FAIL:
   2178                    pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED;
   2179          
   2180                  case RT_INIT:
   2181                  case RT_REPAIR:
   2182                  default:
   2183                    pList->status = ZDO_MGMT_RTG_ENTRY_INACTIVE;
   2184                    break;
   2185                }
   2186          
   2187                // Increment pointer to next record
   2188                pList++;
   2189              }
   2190          
   2191              // Send response
   2192              ZDP_MgmtRtgRsp( TransSeq, SrcAddr, ZSuccess, maxNumItems, StartIndex, numItems,
   2193                                    (rtgItem_t *)pBuf, false );
   2194          
   2195              osal_mem_free( pBuf );
   2196            }
   2197          }
   2198          #endif // defined(ZDO_MGMT_RTG_RESPONSE)  && defined(RTR_NWK)
   2199          
   2200          #if defined ( ZDO_MGMT_RTG_REQUEST )
   2201          /*********************************************************************
   2202           * @fn          ZDO_ProcessMgmtRtgRsp
   2203           *
   2204           * @brief       This function handles parsing the incoming Management
   2205           *              Routing response and then generates a callback
   2206           *              to the ZD application.
   2207           *
   2208           * @param       SrcAddr - source of the request
   2209           * @param       msg - buffer holding incoming message to parse
   2210           * @param       SecurityUse -
   2211           *
   2212           * @return      none
   2213           */
   2214          void ZDO_ProcessMgmtRtgRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2215          {
   2216            byte x;
   2217            byte status;
   2218            byte rtgCount = 0;
   2219            byte startIndex = 0;
   2220            byte rtgListCount = 0;
   2221            byte *pBuf = NULL;
   2222            rtgItem_t *pList = NULL;
   2223          
   2224            status = *msg++;
   2225            if ( status == ZSuccess )
   2226            {
   2227              rtgCount = *msg++;
   2228              startIndex = *msg++;
   2229              rtgListCount = *msg++;
   2230          
   2231              // Allocate a buffer big enough to handle the list
   2232              pBuf = osal_mem_alloc( rtgListCount * sizeof( rtgItem_t ) );
   2233              if ( pBuf )
   2234              {
   2235                pList = (rtgItem_t *)pBuf;
   2236                for ( x = 0; x < rtgListCount; x++ )
   2237                {
   2238                  pList->dstAddress = BUILD_UINT16( msg[0], msg[1] );
   2239                  msg += 2;
   2240                  pList->status = *msg++;
   2241                  pList->nextHopAddress = BUILD_UINT16( msg[0], msg[1] );
   2242                  msg += 2;
   2243                  pList++;
   2244                }
   2245              }
   2246            }
   2247          
   2248            // Call the callback to the application.
   2249            ZDApp_MgmtRtgRspCB( SrcAddr->addr.shortAddr, status, rtgCount,
   2250                                           startIndex, rtgListCount, (rtgItem_t *)pBuf );
   2251          
   2252            if ( pBuf )
   2253            {
   2254              osal_mem_free( pBuf );
   2255            }
   2256          }
   2257          #endif // ZDO_MGMT_RTG_REQUEST
   2258          
   2259          #if defined ( ZDO_MGMT_BIND_RESPONSE )
   2260          /*********************************************************************
   2261           * @fn          ZDO_ProcessMgmtBindReq
   2262           *
   2263           * @brief       This function finishes the processing of the Management
   2264           *              Bind Request and generates the response.
   2265           *
   2266           *   Note:      This function will limit the number of items returned
   2267           *              to ZDO_MAX_BIND_ITEMS items.
   2268           *
   2269           * @param       ResultCountSrcAddr - source of the request
   2270           * @param       msg - pointer to incoming message
   2271           * @param       SecurityUse -
   2272           *
   2273           * @return      none
   2274           */
   2275          void ZDO_ProcessMgmtBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   2276          {
   2277          #if defined ( REFLECTOR )
   2278            byte x;
   2279            uint16 maxNumItems;
   2280            uint16 numItems;
   2281            byte *pBuf = NULL;
   2282            apsBindingItem_t *pList;
   2283          
   2284            // Get the number of table items
   2285            APSME_GetRequest( apsNumBindingTableEntries, 0, (byte*)(&maxNumItems) );
   2286          
   2287            if ( maxNumItems > StartIndex )
   2288              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   2289            else
   2290              numItems = 0;
   2291          
   2292            // limit the size of the list
   2293            if ( numItems > ZDO_MAX_BIND_ITEMS )
   2294              numItems = ZDO_MAX_BIND_ITEMS;
   2295          
   2296            // Allocate the memory to build the table
   2297            if ( numItems )
   2298              pBuf = osal_mem_alloc( sizeof( apsBindingItem_t ) * numItems );
   2299          
   2300            if ( pBuf )
   2301            {
   2302              // Convert buffer to list
   2303              pList = (apsBindingItem_t *)pBuf;
   2304          
   2305              // Loop through items and build list
   2306              for ( x = 0; x < numItems; x++ )
   2307              {
   2308                APSME_GetRequest( apsBindingTable, (x + StartIndex), (void*)pList );
   2309                pList++;
   2310              }
   2311            }
   2312          
   2313            // Send response
   2314            ZDP_MgmtBindRsp( TransSeq, SrcAddr, ZSuccess, (byte)maxNumItems, StartIndex, (byte)numItems,
   2315                                  (apsBindingItem_t *)pBuf, false );
   2316          
   2317            if ( pBuf )
   2318            {
   2319              osal_mem_free( pBuf );
   2320            }
   2321          #else  // See if app support is needed
   2322          
   2323            ZDApp_MgmtBindReqCB( TransSeq, SrcAddr, StartIndex, SecurityUse );
   2324          
   2325          #endif
   2326          }
   2327          #endif // ZDO_MGMT_BIND_RESPONSE
   2328          
   2329          #if defined ( ZDO_MGMT_BIND_REQUEST )
   2330          /*********************************************************************
   2331           * @fn          ZDO_ProcessMgmtBindRsp
   2332           *
   2333           * @brief       This function handles parsing the incoming Management
   2334           *              Binding response and then generates a callback
   2335           *              to the ZD application.
   2336           *
   2337           * @param       SrcAddr - source of the request
   2338           * @param       msg - buffer holding incoming message to parse
   2339           * @param       SecurityUse -
   2340           *
   2341           * @return      none
   2342           */
   2343          void ZDO_ProcessMgmtBindRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2344          {
   2345            byte x;
   2346            byte status;
   2347            byte bindingCount = 0;
   2348            byte startIndex = 0;
   2349            byte bindingListCount = 0;
   2350            byte *pBuf = NULL;
   2351            apsBindingItem_t *pList = NULL;
   2352          
   2353            status = *msg++;
   2354            if ( status == ZSuccess )
   2355            {
   2356              bindingCount = *msg++;
   2357              startIndex = *msg++;
   2358              bindingListCount = *msg++;
   2359          
   2360              // Allocate a buffer big enough to handle the list
   2361              if ( bindingListCount )
   2362                pBuf = osal_mem_alloc( (short)(bindingListCount * sizeof( apsBindingItem_t )) );
   2363              if ( pBuf )
   2364              {
   2365                pList = (apsBindingItem_t *)pBuf;
   2366                for ( x = 0; x < bindingListCount; x++ )
   2367                {
   2368                  osal_cpyExtAddr( pList->srcAddr, msg );
   2369                  msg += Z_EXTADDR_LEN;
   2370                  pList->srcEP = *msg++;
   2371          
   2372                  // Get the Cluster ID
   2373                  if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
   2374                  {
   2375                    pList->clusterID = BUILD_UINT16( msg[0], msg[1] );
   2376                    msg += 2;
   2377                    pList->dstAddr.addrMode = *msg++;
   2378                    if ( pList->dstAddr.addrMode == Addr64Bit )
   2379                    {
   2380                      osal_cpyExtAddr( pList->dstAddr.addr.extAddr, msg );
   2381                      msg += Z_EXTADDR_LEN;
   2382                      pList->dstEP = *msg++;
   2383                    }
   2384                    else
   2385                    {
   2386                      pList->dstAddr.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   2387                      msg += 2;
   2388                    }
   2389                  }
   2390                  else
   2391                  {
   2392                    pList->clusterID = *msg++;
   2393          
   2394                    osal_cpyExtAddr( pList->dstAddr.addr.extAddr, msg );
   2395                    msg += Z_EXTADDR_LEN;
   2396                    pList->dstEP = *msg++;
   2397                  }
   2398          
   2399                  pList++;
   2400                }
   2401              }
   2402            }
   2403          
   2404            // Call the callback to the application
   2405            ZDApp_MgmtBindRspCB( SrcAddr->addr.shortAddr, status, bindingCount,
   2406                              startIndex, bindingListCount, (apsBindingItem_t *)pBuf );
   2407          
   2408            if ( pBuf )
   2409                osal_mem_free( pBuf );
   2410          }
   2411          #endif // ZDO_MGMT_BIND_REQUEST
   2412          
   2413          #if defined ( ZDO_MGMT_JOINDIRECT_RESPONSE ) && defined ( RTR_NWK )
   2414          /*********************************************************************
   2415           * @fn          ZDO_ProcessMgmtDirectJoinReq
   2416           *
   2417           * @brief       This function finishes the processing of the Management
   2418           *              Direct Join Request and generates the response.
   2419           *
   2420           * @param       SrcAddr - source of the request
   2421           * @param       msg - pointer to incoming message
   2422           * @param       SecurityUse -
   2423           *
   2424           * @return      none
   2425           */
   2426          void ZDO_ProcessMgmtDirectJoinReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2427          {
   2428            byte *deviceAddr;
   2429            byte capInfo;
   2430            byte stat;
   2431          
   2432            // Parse the message
   2433            deviceAddr = msg;
   2434            capInfo = msg[Z_EXTADDR_LEN];
   2435          
   2436            stat = (byte) NLME_DirectJoinRequest( deviceAddr, capInfo );
   2437          
   2438            ZDP_MgmtDirectJoinRsp( TransSeq, SrcAddr, stat, false );
   2439          }
   2440          #endif // ZDO_MGMT_JOINDIRECT_RESPONSE && RTR_NWK
   2441          
   2442          #if defined ( ZDO_MGMT_JOINDIRECT_REQUEST )
   2443          /*********************************************************************
   2444           * @fn          ZDO_ProcessMgmtDirectJoinRsp
   2445           *
   2446           * @brief       This function handles parsing the incoming Management
   2447           *              Direct Join response and then generates a callback
   2448           *              to the ZD application.
   2449           *
   2450           * @param       SrcAddr - source of the request
   2451           * @param       Status - ZSuccess or other for failure
   2452           * @param       SecurityUse -
   2453           *
   2454           * @return      none
   2455           */
   2456          void ZDO_ProcessMgmtDirectJoinRsp( zAddrType_t *SrcAddr, byte Status, byte SecurityUse )
   2457          {
   2458            // Call the callback to the application
   2459            ZDApp_MgmtDirectJoinRspCB( SrcAddr->addr.shortAddr, Status, SecurityUse );
   2460          }
   2461          #endif // ZDO_MGMT_JOINDIRECT_REQUEST
   2462          
   2463          #if defined ( ZDO_MGMT_LEAVE_RESPONSE )
   2464          /*********************************************************************
   2465           * @fn          ZDO_ProcessMgmtLeaveReq
   2466           *
   2467           * @brief       This function processes a Management Leave Request
   2468           *              and generates the response.
   2469           *
   2470           * @param       SrcAddr - source of the request
   2471           * @param       msg - pointer to incoming message
   2472           * @param       SecurityUse -
   2473           *
   2474           * @return      none
   2475           */
   2476          void ZDO_ProcessMgmtLeaveReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2477          {
   2478            NLME_LeaveReq_t req;
   2479            ZStatus_t       status;
   2480          
   2481          
   2482            if ( ( AddrMgrExtAddrValid( msg ) == FALSE                 ) ||
   2483                 ( osal_ExtAddrEqual( msg, NLME_GetExtAddr() ) == TRUE )    )
   2484            {
   2485              // Remove this device
   2486              req.extAddr = NULL;
   2487            }
   2488            else
   2489            {
   2490              // Remove child device
   2491              req.extAddr = msg;
   2492            }
   2493          
   2494            req.removeChildren = FALSE;
   2495            req.rejoin         = FALSE;
   2496            req.silent         = FALSE;
   2497          
   2498            status = NLME_LeaveReq( &req );
   2499          
   2500            ZDP_MgmtLeaveRsp( TransSeq, SrcAddr, status, FALSE );
   2501          }
   2502          #endif // ZDO_MGMT_LEAVE_RESPONSE
   2503          
   2504          #if defined ( ZDO_MGMT_LEAVE_REQUEST )
   2505          /*********************************************************************
   2506           * @fn          ZDO_ProcessMgmtLeaveRsp
   2507           *
   2508           * @brief       This function handles a Management Leave Response
   2509           *              and generates a callback to the ZD application.
   2510           *
   2511           * @param       SrcAddr - source of the request
   2512           * @param       Status - ZSuccess or other for failure
   2513           * @param       SecurityUse -
   2514           *
   2515           * @return      none
   2516           */
   2517          void ZDO_ProcessMgmtLeaveRsp( zAddrType_t *SrcAddr, byte Status, byte SecurityUse )
   2518          {
   2519            // Call the callback to the application
   2520            ZDApp_MgmtLeaveRspCB( SrcAddr->addr.shortAddr, Status, SecurityUse );
   2521          }
   2522          #endif // ZDO_MGMT_LEAVE_REQUEST
   2523          
   2524          #if defined( ZDO_MGMT_PERMIT_JOIN_RESPONSE ) && defined( RTR_NWK )
   2525          /*********************************************************************
   2526           * @fn          ZDO_ProcessMgmtPermitJoinReq
   2527           *
   2528           * @brief       This function processes a Management Permit Join Request
   2529           *              and generates the response.
   2530           *
   2531           * @param       SrcAddr - source of the request
   2532           * @param       msg - pointer to incoming message
   2533           * @param       SecurityUse -
   2534           *
   2535           * @return      none
   2536           */
   2537          void ZDO_ProcessMgmtPermitJoinReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg,
   2538                                             byte SecurityUse )
   2539          {
   2540            uint8 stat;
   2541            uint8 duration;
   2542            uint8 tcsig;
   2543          
   2544          
   2545            duration = msg[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION];
   2546            tcsig    = msg[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG];
   2547          
   2548            // Set the network layer permit join duration
   2549            stat = (byte) NLME_PermitJoiningRequest( duration );
   2550          
   2551            // Handle the Trust Center Significance
   2552            if ( tcsig == TRUE )
   2553            {
   2554              ZDSecMgrPermitJoining( duration );
   2555            }
   2556          
   2557            // Send a response if unicast
   2558            if (SrcAddr->addr.shortAddr != NWK_BROADCAST_SHORTADDR)
   2559            {
   2560              ZDP_MgmtPermitJoinRsp( TransSeq, SrcAddr, stat, false );
   2561            }
   2562          }
   2563          #endif // ZDO_MGMT_PERMIT_JOIN_RESPONSE && defined( RTR_NWK )
   2564          
   2565          /*
   2566           * This function stub allows the next higher layer to be notified of
   2567           * a permit joining timeout.
   2568           */
   2569          #if defined( RTR_NWK )
   2570          /*********************************************************************
   2571           * @fn          ZDO_ProcessMgmtPermitJoinTimeout
   2572           *
   2573           * @brief       This function stub allows the next higher layer to be
   2574           *              notified of a permit joining timeout. Currently, this
   2575           *              directly bypasses the APS layer.
   2576           *
   2577           * @param       none
   2578           *
   2579           * @return      none
   2580           */
   2581          void ZDO_ProcessMgmtPermitJoinTimeout( void )
   2582          {
   2583            #if defined( ZDO_MGMT_PERMIT_JOIN_RESPONSE )
   2584            {
   2585              // Currently, only the ZDSecMgr needs to be notified
   2586              ZDSecMgrPermitJoiningTimeout();
   2587            }
   2588            #endif
   2589          }
   2590          #endif // defined( RTR_NWK )
   2591          
   2592          #if defined ( ZDO_MGMT_PERMIT_JOIN_REQUEST )
   2593          /*********************************************************************
   2594           * @fn          ZDO_ProcessMgmtPermitJoinRsp
   2595           *
   2596           * @brief       This function handles a Management Permit Join Response
   2597           *              and generates a callback to the ZD application.
   2598           *
   2599           * @param       SrcAddr - source of the request
   2600           * @param       Status - ZSuccess or other for failure
   2601           * @param       SecurityUse -
   2602           *
   2603           * @return      none
   2604           */
   2605          void ZDO_ProcessMgmtPermitJoinRsp( zAddrType_t *SrcAddr, byte Status, byte SecurityUse )
   2606          {
   2607            // Call the callback to the application
   2608            ZDApp_MgmtPermitJoinRspCB( SrcAddr->addr.shortAddr, Status, SecurityUse );
   2609          }
   2610          #endif // ZDO_MGMT_PERMIT_JOIN_REQUEST
   2611          
   2612          #if defined ( ZDO_USERDESC_REQUEST )
   2613          /*********************************************************************
   2614           * @fn          ZDO_ProcessUserDescRsp
   2615           *
   2616           * @brief       This function handles parsing the incoming User
   2617           *              Descriptor Response and then generates a callback
   2618           *              to the ZD application.
   2619           *
   2620           * @param       SrcAddr - source of the request
   2621           * @param       msg - incoming response message
   2622           * @param       SecurityUse -
   2623           *
   2624           * @return      none
   2625           */
   2626          void ZDO_ProcessUserDescRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2627          {
   2628            ZDApp_UserDescRspCB( SrcAddr->addr.shortAddr,
   2629                                msg[0],                           // Status
   2630                                BUILD_UINT16( msg[1], msg[2] ),   // NWKAddrOfInterest
   2631                                msg[3],                           // Length
   2632                                &msg[4],                          // User Descriptor
   2633                                SecurityUse );
   2634          }
   2635          #endif // ZDO_USERDESC_REQUEST
   2636          
   2637          #if defined ( ZDO_USERDESC_RESPONSE )
   2638          /*********************************************************************
   2639           * @fn          ZDO_ProcessUserDescReq
   2640           *
   2641           * @brief       This function finishes the processing of the User
   2642           *              Descriptor Request and generates the response.
   2643           *
   2644           * @param       SrcAddr - source of the request
   2645           * @param       msg - pointer to incoming message
   2646           * @param       SecurityUse -
   2647           *
   2648           * @return      none
   2649           */
   2650          void ZDO_ProcessUserDescReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2651          {
   2652            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   2653            UserDescriptorFormat_t userDesc;
   2654          
   2655            if ( (aoi == ZDAppNwkAddr.addr.shortAddr) && (ZSUCCESS == osal_nv_read(
   2656                       ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc )) )
   2657            {
   2658              ZDP_UserDescRsp( TransSeq, SrcAddr, aoi, &userDesc, false );
   2659            }
   2660            else
   2661            {
   2662          #if defined( ZDO_CACHE )
   2663              (void)aoi;
   2664          #else
   2665              ZDP_GenericRsp(
   2666                 TransSeq, SrcAddr, ZDP_NOT_SUPPORTED, aoi, User_Desc_rsp, SecurityUse );
   2667          #endif
   2668            }
   2669          }
   2670          #endif // ZDO_USERDESC_RESPONSE
   2671          
   2672          #if defined ( ZDO_USERDESCSET_REQUEST )
   2673          /*********************************************************************
   2674           * @fn          ZDO_ProcessUserDescConf
   2675           *
   2676           * @brief       This function handles parsing the incoming User
   2677           *              Descriptor Confirm and then generates a callback
   2678           *              to the ZD application.
   2679           *
   2680           * @param       SrcAddr - source of the request
   2681           * @param       msg - incoming response message
   2682           * @param       SecurityUse -
   2683           *
   2684           * @return      none
   2685           */
   2686          void ZDO_ProcessUserDescConf( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2687          {
   2688            ZDApp_UserDescConfCB( SrcAddr->addr.shortAddr,
   2689                                  msg[0],                           // Status
   2690                                  SecurityUse );
   2691          }
   2692          #endif // ZDO_USERDESCSET_REQUEST
   2693          
   2694          
   2695          #if defined ( ZDO_USERDESCSET_RESPONSE )
   2696          /*********************************************************************
   2697           * @fn          ZDO_ProcessUserDescSet
   2698           *
   2699           * @brief       This function finishes the processing of the User
   2700           *              Descriptor Set and generates the response.
   2701           *
   2702           * @param       SrcAddr - source of the request
   2703           * @param       msg - pointer to incoming message
   2704           * @param       SecurityUse -
   2705           *
   2706           * @return      none
   2707           */
   2708          void ZDO_ProcessUserDescSet( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2709          {
   2710            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   2711            UserDescriptorFormat_t userDesc;
   2712            uint8 outMsg[3];
   2713            uint8 status;
   2714            uint16 nai;
   2715          
   2716            nai = BUILD_UINT16( msg[0], msg[1] );
   2717          
   2718            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   2719            {
   2720              if ( NLME_GetProtocolVersion() == ZB_PROT_V1_0 )
   2721                userDesc.len = AF_MAX_USER_DESCRIPTOR_LEN;
   2722              else
   2723              {
   2724                userDesc.len = (msg[2] < AF_MAX_USER_DESCRIPTOR_LEN) ? msg[2] : AF_MAX_USER_DESCRIPTOR_LEN;
   2725                msg ++;  // increment one for the length field
   2726              }
   2727              osal_memcpy( userDesc.desc, &msg[2], userDesc.len );
   2728              osal_nv_write( ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc );
   2729              if ( userDesc.len != 0 )
   2730              {
   2731                ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   2732              }
   2733              else
   2734              {
   2735                ZDO_Config_Node_Descriptor.UserDescAvail = FALSE;
   2736              }
   2737          
   2738              status = ZDP_SUCCESS;
   2739            }
   2740            else
   2741            {
   2742              status =  ZDP_NOT_SUPPORTED;
   2743            }
   2744          
   2745            outMsg[0] = status;
   2746            outMsg[1] = LO_UINT16( nai );
   2747            outMsg[2] = LO_UINT16( nai );
   2748          
   2749            ZDP_SendData( &TransSeq, SrcAddr, User_Desc_conf, 3, outMsg, SecurityUse );
   2750          }
   2751          #endif // ZDO_USERDESCSET_RESPONSE
   2752          
   2753          #if defined ( ZDO_ENDDEVICE_ANNCE ) && defined(RTR_NWK)
   2754          /*********************************************************************
   2755           * @fn          ZDO_ProcessEndDeviceAnnce
   2756           *
   2757           * @brief       This function processes an end device annouce message.
   2758           *
   2759           * @param       SrcAddr - source of the request
   2760           * @param       msg - pointer to incoming message
   2761           * @param       SecurityUse -
   2762           *
   2763           * @return      none
   2764           */
   2765          void ZDO_ProcessEndDeviceAnnce( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2766          {
   2767            uint16 nwkAddr;
   2768            associated_devices_t *dev;
   2769            AddrMgrEntry_t addrEntry;
   2770            uint8 *ieeeAddr;
   2771            uint8 capabilities;
   2772          
   2773            // Parse incoming message
   2774            nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2775            msg += 2;
   2776            ieeeAddr = msg;
   2777            msg += Z_EXTADDR_LEN;
   2778            if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
   2779            {
   2780              capabilities = *msg;
   2781            }
   2782            else
   2783            {
   2784              capabilities = 0;
   2785            }
   2786          
   2787            addrEntry.user = ADDRMGR_USER_DEFAULT;
   2788            addrEntry.nwkAddr = nwkAddr;
   2789            AddrMgrExtAddrSet( addrEntry.extAddr, ieeeAddr );
   2790            AddrMgrEntryUpdate( &addrEntry );
   2791          
   2792            // find device in device list
   2793            dev = AssocGetWithExt( ieeeAddr );
   2794            if ( dev != NULL )
   2795            {
   2796              // if found and address is different
   2797              if ( dev->shortAddr != nwkAddr )
   2798              {
   2799                // update device list if device is (was) not our child
   2800                if ( dev->nodeRelation == NEIGHBOR || dev->nodeRelation == OTHER )
   2801                {
   2802                  dev->shortAddr = nwkAddr;
   2803                }
   2804              }
   2805            }
   2806          
   2807            // Application notification
   2808            ZDApp_EndDeviceAnnounceCB( SrcAddr->addr.shortAddr, nwkAddr, ieeeAddr, capabilities );
   2809          }
   2810          #endif // ZDO_ENDDEVICE_ANNCE
   2811          
   2812          #if defined( ZDO_SIMPLEDESC_REQUEST ) || ( defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 ) )
   2813          /*********************************************************************
   2814           * @fn          ZDO_BuildSimpleDescBuf
   2815           *
   2816           * @brief       Build a byte sequence representation of a Simple Descriptor.
   2817           *
   2818           * @param       buf  - pointer to a byte array big enough for data.
   2819           * @param       desc - SimpleDescriptionFormat_t *
   2820           *
   2821           * @return      none
   2822           */
   2823          void ZDO_BuildSimpleDescBuf( byte *buf, SimpleDescriptionFormat_t *desc )
   2824          {
   2825            byte proVer = NLME_GetProtocolVersion();
   2826            byte cnt;
   2827            uint16 *ptr;
   2828          
   2829            *buf++ = desc->EndPoint;
   2830            *buf++ = HI_UINT16( desc->AppProfId );
   2831            *buf++ = LO_UINT16( desc->AppProfId );
   2832            *buf++ = HI_UINT16( desc->AppDeviceId );
   2833            *buf++ = LO_UINT16( desc->AppDeviceId );
   2834          
   2835            if ( proVer == ZB_PROT_V1_0 )
   2836            {
   2837              *buf++ = (byte)((desc->AppDevVer << 4) | (desc->Reserved));
   2838            }
   2839            else
   2840            {
   2841              *buf++ = (byte)(desc->AppDevVer << 4);
   2842            }
   2843          
   2844            *buf++ = desc->AppNumInClusters;
   2845            ptr = desc->pAppInClusterList;
   2846            for ( cnt = 0; cnt < desc->AppNumInClusters; ptr++, cnt++ )
   2847            {
   2848              *buf++ = HI_UINT16( *ptr );
   2849              *buf++ = LO_UINT16( *ptr );
   2850            }
   2851          
   2852            *buf++ = desc->AppNumOutClusters;
   2853            ptr = desc->pAppOutClusterList;
   2854            for ( cnt = 0; cnt < desc->AppNumOutClusters; ptr++, cnt++ )
   2855            {
   2856              *buf++ = HI_UINT16( *ptr );
   2857              *buf++ = LO_UINT16( *ptr );
   2858            }
   2859          }
   2860          
   2861          /*********************************************************************
   2862           * @fn          ZDO_ParseSimpleDescBuf
   2863           *
   2864           * @brief       Parse a byte sequence representation of a Simple Descriptor.
   2865           *
   2866           * @param       buf  - pointer to a byte array representing a Simple Desc.
   2867           * @param       desc - SimpleDescriptionFormat_t *
   2868           *
   2869           *              This routine allocates storage for the cluster IDs because
   2870           *              they are 16-bit and need to be aligned to be properly processed.
   2871           *              This routine returns non-zero if an allocation fails.
   2872           *
   2873           *              NOTE: This means that the caller or user of the input structure
   2874           *                    is responsible for freeing the memory
   2875           *
   2876           * @return      0: success
   2877           *              1: failure due to malloc failure.
   2878           */
   2879          uint8 ZDO_ParseSimpleDescBuf( byte *buf, SimpleDescriptionFormat_t *desc )
   2880          {
   2881            byte proVer = NLME_GetProtocolVersion();
   2882            uint8 num, i;
   2883          
   2884            desc->EndPoint = *buf++;
   2885            desc->AppProfId = BUILD_UINT16( buf[0], buf[1] );
   2886            buf += 2;
   2887            desc->AppDeviceId = BUILD_UINT16( buf[0], buf[1] );
   2888            buf += 2;
   2889            desc->AppDevVer = *buf >> 4;
   2890          
   2891            if ( proVer == ZB_PROT_V1_0 )
   2892            {
   2893              desc->Reserved = *buf++ &0x0F;
   2894            }
   2895            else
   2896            {
   2897              desc->Reserved = 0;
   2898              buf++;
   2899            }
   2900          
   2901            // move in input cluster list (if any). allocate aligned memory.
   2902            num = desc->AppNumInClusters = *buf++;
   2903            if (num)  {
   2904              if (!(desc->pAppInClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))  {
   2905                // malloc failed. we're done.
   2906                return 1;
   2907              }
   2908              for (i=0; i<num; ++i)  {
   2909                desc->pAppInClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   2910                buf += 2;
   2911              }
   2912            }
   2913          
   2914            // move in output cluster list (if any). allocate aligned memory.
   2915            num = desc->AppNumOutClusters = *buf++;
   2916            if (num)  {
   2917              if (!(desc->pAppOutClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))  {
   2918                // malloc failed. free input cluster list memory if there is any
   2919                if (desc->pAppInClusterList)  {
   2920                  osal_mem_free(desc->pAppInClusterList);
   2921                }
   2922                return 1;
   2923              }
   2924              for (i=0; i<num; ++i)  {
   2925                desc->pAppOutClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   2926                buf += 2;
   2927              }
   2928            }
   2929            return 0;
   2930          }
   2931          #endif
   2932          
   2933          #if defined ( ZDO_COORDINATOR )
   2934          /*********************************************************************
   2935           * @fn      ZDO_MatchEndDeviceBind()
   2936           *
   2937           * @brief
   2938           *
   2939           *   Called to match end device binding requests
   2940           *
   2941           * @param  bindReq  - binding request information
   2942           * @param  SecurityUse - Security enable/disable
   2943           *
   2944           * @return  none
   2945           */
   2946          void ZDO_MatchEndDeviceBind( ZDEndDeviceBind_t *bindReq )
   2947          {
   2948            zAddrType_t dstAddr;
   2949            uint8 sendRsp = FALSE;
   2950            uint8 status;
   2951          
   2952            // Is this the first request?
   2953            if ( matchED == NULL )
   2954            {
   2955              // Create match info structure
   2956              matchED = (ZDMatchEndDeviceBind_t *)osal_mem_alloc( sizeof ( ZDMatchEndDeviceBind_t ) );
   2957              if ( matchED )
   2958              {
   2959                // Clear the structure
   2960                osal_memset( (uint8 *)matchED, 0, sizeof ( ZDMatchEndDeviceBind_t ) );
   2961          
   2962                // Copy the first request's information
   2963                if ( !ZDO_CopyMatchInfo( &(matchED->ed1), bindReq ) )
   2964                {
   2965          
   2966                  status = ZDP_NO_ENTRY;
   2967                  sendRsp = TRUE;
   2968                }
   2969              }
   2970              else
   2971              {
   2972                status = ZDP_NO_ENTRY;
   2973                sendRsp = TRUE;
   2974              }
   2975          
   2976              if ( !sendRsp )
   2977              {
   2978                // Set into the correct state
   2979                matchED->state = ZDMATCH_WAIT_REQ;
   2980          
   2981                // Setup the timeout
   2982                APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   2983              }
   2984            }
   2985            else
   2986            {
   2987                matchED->state = ZDMATCH_SENDING_BINDS;
   2988          
   2989                // Copy the 2nd request's information
   2990                if ( !ZDO_CopyMatchInfo( &(matchED->ed2), bindReq ) )
   2991                {
   2992                  status = ZDP_NO_ENTRY;
   2993                  sendRsp = TRUE;
   2994                }
   2995          
   2996                // Make a source match for ed1
   2997                matchED->ed1numMatched = ZDO_CompareClusterLists(
   2998                            matchED->ed1.numOutClusters, matchED->ed1.outClusters,
   2999                            matchED->ed2.numInClusters, matchED->ed2.inClusters, ZDOBuildBuf );
   3000                if ( matchED->ed1numMatched )
   3001                {
   3002                  // Save the match list
   3003                  matchED->ed1Matched = osal_mem_alloc( (short)(matchED->ed1numMatched * sizeof ( uint16 )) );
   3004                  if ( matchED->ed1Matched )
   3005                  {
   3006                    osal_memcpy( matchED->ed1Matched, ZDOBuildBuf, (matchED->ed1numMatched * sizeof ( uint16 )) );
   3007                  }
   3008                  else
   3009                  {
   3010                    // Allocation error, stop
   3011                    status = ZDP_NO_ENTRY;
   3012                    sendRsp = TRUE;
   3013                  }
   3014                }
   3015          
   3016                // Make a source match for ed2
   3017                matchED->ed2numMatched = ZDO_CompareClusterLists(
   3018                            matchED->ed2.numOutClusters, matchED->ed2.outClusters,
   3019                            matchED->ed1.numInClusters, matchED->ed1.inClusters, ZDOBuildBuf );
   3020                if ( matchED->ed2numMatched )
   3021                {
   3022                  // Save the match list
   3023                  matchED->ed2Matched = osal_mem_alloc( (short)(matchED->ed2numMatched * sizeof ( uint16 )) );
   3024                  if ( matchED->ed2Matched )
   3025                  {
   3026                    osal_memcpy( matchED->ed2Matched, ZDOBuildBuf, (matchED->ed2numMatched * sizeof ( uint16 )) );
   3027                  }
   3028                  else
   3029                  {
   3030                    // Allocation error, stop
   3031                    status = ZDP_NO_ENTRY;
   3032                    sendRsp = TRUE;
   3033                  }
   3034                }
   3035          
   3036                if ( (sendRsp == FALSE) && (matchED->ed1numMatched || matchED->ed2numMatched) )
   3037                {
   3038                  // Do the first unbind/bind state
   3039                  ZDMatchSendState( ZDMATCH_REASON_START, ZDP_SUCCESS, 0 );
   3040                }
   3041                else
   3042                {
   3043                  status = ZDP_NO_MATCH;
   3044                  sendRsp = TRUE;
   3045                }
   3046            }
   3047          
   3048            if ( sendRsp )
   3049            {
   3050              // send response to this requester
   3051              dstAddr.addrMode = Addr16Bit;
   3052              dstAddr.addr.shortAddr = bindReq->srcAddr;
   3053              ZDP_EndDeviceBindRsp( bindReq->TransSeq, &dstAddr, status, bindReq->SecurityUse );
   3054          
   3055              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   3056              {
   3057                // send response to first requester
   3058                dstAddr.addrMode = Addr16Bit;
   3059                dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   3060                ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, status, matchED->ed1.SecurityUse );
   3061              }
   3062          
   3063              // Process ended - release memory used
   3064              ZDO_RemoveMatchMemory();
   3065            }
   3066          }
   3067          
   3068          static void ZDO_RemoveMatchMemory( void )
   3069          {
   3070            if ( matchED )
   3071            {
   3072              if ( matchED->ed2Matched )
   3073                osal_mem_free( matchED->ed2Matched );
   3074              if ( matchED->ed1Matched )
   3075                osal_mem_free( matchED->ed1Matched );
   3076          
   3077              if ( matchED->ed1.inClusters )
   3078                osal_mem_free( matchED->ed1.inClusters );
   3079          
   3080              if ( matchED->ed1.outClusters )
   3081                osal_mem_free( matchED->ed1.outClusters );
   3082          
   3083              if ( matchED->ed2.inClusters )
   3084                osal_mem_free( matchED->ed2.inClusters );
   3085          
   3086              if ( matchED->ed2.outClusters )
   3087                osal_mem_free( matchED->ed2.outClusters );
   3088          
   3089              osal_mem_free( matchED );
   3090          
   3091              matchED = (ZDMatchEndDeviceBind_t *)NULL;
   3092            }
   3093          }
   3094          
   3095          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq )
   3096          {
   3097            uint8 allOK = TRUE;
   3098          
   3099            // Copy bind information into the match info structure
   3100            osal_memcpy( (uint8 *)destReq, srcReq, sizeof ( ZDEndDeviceBind_t ) );
   3101          
   3102            // Copy input cluster IDs
   3103            if ( srcReq->numInClusters )
   3104            {
   3105              destReq->inClusters = osal_mem_alloc( (short)(srcReq->numInClusters * sizeof ( uint16 )) );
   3106              if ( destReq->inClusters )
   3107              {
   3108                // Copy the clusters
   3109                osal_memcpy( (uint8*)(destReq->inClusters), (uint8 *)(srcReq->inClusters),
   3110                                (srcReq->numInClusters * sizeof ( uint16 )) );
   3111              }
   3112              else
   3113                allOK = FALSE;
   3114            }
   3115          
   3116            // Copy output cluster IDs
   3117            if ( srcReq->numOutClusters )
   3118            {
   3119              destReq->outClusters = osal_mem_alloc( (short)(srcReq->numOutClusters * sizeof ( uint16 )) );
   3120              if ( destReq->outClusters )
   3121              {
   3122                // Copy the clusters
   3123                osal_memcpy( (uint8 *)(destReq->outClusters), (uint8 *)(srcReq->outClusters),
   3124                                (srcReq->numOutClusters * sizeof ( uint16 )) );
   3125              }
   3126              else
   3127                allOK = FALSE;
   3128            }
   3129          
   3130            if ( !allOK )
   3131            {
   3132              if ( destReq->inClusters )
   3133                osal_mem_free( destReq->inClusters );
   3134              if ( destReq->outClusters )
   3135                osal_mem_free( destReq->outClusters );
   3136            }
   3137          
   3138            return ( allOK );
   3139          }
   3140          
   3141          static uint8 ZDMatchSendState( uint8 reason, uint8 status, uint8 TransSeq )
   3142          {
   3143            uint8 *dstIEEEAddr;
   3144            uint8 dstEP;
   3145            zAddrType_t dstAddr;
   3146            zAddrType_t destinationAddr;
   3147            uint16 msgType;
   3148            uint16 clusterID;
   3149            ZDEndDeviceBind_t *ed = NULL;
   3150            uint8 rspStatus = ZDP_SUCCESS;
   3151          
   3152            if ( matchED == NULL )
   3153              return ( FALSE );
   3154          
   3155            // Check sequence number
   3156            if ( reason == ZDMATCH_REASON_BIND_RSP || reason == ZDMATCH_REASON_UNBIND_RSP )
   3157            {
   3158              if ( TransSeq != matchED->transSeq )
   3159                return( FALSE ); // ignore the message
   3160            }
   3161          
   3162            // turn off timer
   3163            APS_SetEndDeviceBindTimeout( 0, ZDO_EndDeviceBindMatchTimeoutCB );
   3164          
   3165            if ( reason == ZDMATCH_REASON_TIMEOUT )
   3166            {
   3167              rspStatus = ZDP_TIMEOUT;    // The process will stop
   3168            }
   3169          
   3170            if ( reason == ZDMATCH_REASON_START || reason == ZDMATCH_REASON_BIND_RSP )
   3171            {
   3172              matchED->sending = ZDMATCH_SENDING_UNBIND;
   3173          
   3174              if ( reason == ZDMATCH_REASON_BIND_RSP && status != ZDP_SUCCESS )
   3175              {
   3176                rspStatus = status;
   3177              }
   3178            }
   3179            else if ( reason == ZDMATCH_REASON_UNBIND_RSP )
   3180            {
   3181              if ( status == ZDP_SUCCESS )
   3182              {
   3183                matchED->sending = ZDMATCH_SENDING_UNBIND;
   3184              }
   3185              else
   3186              {
   3187                matchED->sending = ZDMATCH_SENDING_BIND;
   3188              }
   3189            }
   3190          
   3191            if ( reason != ZDMATCH_REASON_START && matchED->sending == ZDMATCH_SENDING_UNBIND )
   3192            {
   3193              // Move to the next cluster ID
   3194              if ( matchED->ed1numMatched )
   3195                matchED->ed1numMatched--;
   3196              else if ( matchED->ed2numMatched )
   3197                matchED->ed2numMatched--;
   3198            }
   3199          
   3200            // What message do we send now
   3201            if ( matchED->ed1numMatched )
   3202            {
   3203              ed = &(matchED->ed1);
   3204              clusterID = matchED->ed1Matched[matchED->ed1numMatched-1];
   3205              dstIEEEAddr = matchED->ed2.ieeeAddr;
   3206              dstEP = matchED->ed2.endpoint;
   3207            }
   3208            else if ( matchED->ed2numMatched )
   3209            {
   3210              ed = &(matchED->ed2);
   3211              clusterID = matchED->ed2Matched[matchED->ed2numMatched-1];
   3212              dstIEEEAddr = matchED->ed1.ieeeAddr;
   3213              dstEP = matchED->ed1.endpoint;
   3214            }
   3215          
   3216            dstAddr.addrMode = Addr16Bit;
   3217          
   3218            // Send the next message
   3219            if ( rspStatus == ZDP_SUCCESS && ed )
   3220            {
   3221              // Send unbind/bind message to source
   3222              if ( matchED->sending == ZDMATCH_SENDING_UNBIND )
   3223                msgType = Unbind_req;
   3224              else
   3225                msgType = Bind_req;
   3226          
   3227              dstAddr.addr.shortAddr = ed->srcAddr;
   3228          
   3229              // Save off the transaction sequence number
   3230              matchED->transSeq = ZDP_TransID;
   3231          
   3232              destinationAddr.addrMode = Addr64Bit;
   3233              osal_cpyExtAddr( destinationAddr.addr.extAddr, dstIEEEAddr );
   3234          
   3235              ZDP_BindUnbindReq( msgType, &dstAddr, ed->ieeeAddr, ed->endpoint, clusterID,
   3236                  &destinationAddr, dstEP, ed->SecurityUse );
   3237          
   3238              // Set timeout for response
   3239              APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   3240            }
   3241            else
   3242            {
   3243              // Send the response messages to requesting devices
   3244              // send response to first requester
   3245              dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   3246              ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, rspStatus, matchED->ed1.SecurityUse );
   3247          
   3248              // send response to second requester
   3249              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   3250              {
   3251                dstAddr.addr.shortAddr = matchED->ed2.srcAddr;
   3252                ZDP_EndDeviceBindRsp( matchED->ed2.TransSeq, &dstAddr, rspStatus, matchED->ed2.SecurityUse );
   3253              }
   3254          
   3255              // Process ended - release memory used
   3256              ZDO_RemoveMatchMemory();
   3257            }
   3258          
   3259            return ( TRUE );
   3260          }
   3261          
   3262          static void ZDO_EndDeviceBindMatchTimeoutCB( void )
   3263          {
   3264            ZDMatchSendState( ZDMATCH_REASON_TIMEOUT, ZDP_TIMEOUT, 0 );
   3265          }
   3266          
   3267          #endif // ZDO_COORDINATOR
   3268          
   3269          /*********************************************************************
   3270          *********************************************************************/
   3271          
   3272          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     ZDO_AnyClusterMatches              0      0     44
     ZDO_CreateAlignedUINT16List        0      0     44
       -> osal_mem_alloc                0      0     28
       -> NLME_GetProtocolVersion       0      0     28
     ZDO_EndDeviceTimeoutCB             0      0      0
     ZDO_Init                           2      0      0
       -> NLME_DeviceJoiningInit        4      0      0
       -> ZDSecMgrInit                  4      0      0
     ZDO_ProcessActiveEPReq             0      0     24
       -> afNumEndPoints                0      0     32
       -> afEndPoints                   0      0     32
       -> ZDP_EPRsp                     0      0     46
       -> ZDP_GenericRsp                0      0     40
     ZDO_ProcessBindUnbindRsp           2      0      1
       -> ZDApp_EndDeviceBindRsp        4      0      0
     ZDO_ProcessEPListRsp               0      0     16
       -> ZDApp_MatchDescRspCB          0      0     28
     ZDO_ProcessMatchDescReq            1      0     38
       -> ZDO_CreateAlignedUINT16List
                                        0      0     60
       -> ZDO_CreateAlignedUINT16List
                                        0      0     60
       -> osal_mem_free                 0      0     60
       -> NLME_IsAddressBroadcast       0      0     60
       -> ZDP_EPRsp                     0      0     74
       -> NLME_IsAddressBroadcast       0      0     60
       -> osal_msg_send                 0      0     60
       -> osal_mem_free                 0      0     60
       -> ZDO_AnyClusterMatches         0      0     64
       -> ZDO_AnyClusterMatches         0      0     64
       -> osal_msg_allocate             0      0     60
       -> osal_memcpy                   0      0     66
       -> osal_memcpy                   0      0     66
       -> ZDP_EPRsp                     0      0     74
       -> osal_mem_free                 0      0     60
       -> osal_mem_free                 0      0     60
     ZDO_ProcessNodeDescReq             0      0     17
       -> ZDP_NodeDescMsg               0      0     30
       -> ZDP_GenericRsp                0      0     32
     ZDO_ProcessPowerDescReq            0      0     17
       -> ZDP_PowerDescMsg              0      0     30
       -> ZDP_GenericRsp                0      0     32
     ZDO_ProcessSimpleDescReq           0      0     21
       -> afFindSimpleDesc              0      0     32
       -> ZDP_SimpleDescMsg             0      0     40
       -> osal_mem_free                 0      0     32
     ZDO_StartDevice                    1      0     23
       -> NLME_NetworkDiscoveryRequest
                                        0      0     46
       -> nwk_ScanJoiningOrphan         0      0     46
       -> NLME_OrphanJoinRequest        0      0     46
       -> ZDSecMgrConfig                0      0     46
       -> osal_start_timer              0      0     46
     ZDO_UpdateNwkStatus                1      0     12
       -> NLME_GetShortAddr             0      0     24
       -> NLME_GetExtAddr               0      0     24
       -> osal_msg_allocate             0      0     24
       -> osal_msg_send                 0      0     24


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     ZDOBuildBuf                      52
     ZDO_Init                         20
     ?Subroutine21                     7
     ZDO_StartDevice                 195
     ?Subroutine1                     15
     ?Subroutine22                     5
     ZDO_UpdateNwkStatus             115
     ?Subroutine18                     9
     ?Subroutine10                     4
     ?Subroutine15                    10
     ?Subroutine5                     14
     ZDO_CreateAlignedUINT16List     133
     ?Subroutine24                     5
     ZDO_AnyClusterMatches            99
     ?Subroutine13                     6
     ZDO_ProcessNodeDescReq           94
     ?Subroutine4                     27
     ZDO_ProcessPowerDescReq          96
     ZDO_ProcessSimpleDescReq        189
     ?Subroutine6                      9
     ?Subroutine19                     6
     ?Subroutine0                     13
     ZDO_ProcessActiveEPReq          189
     ?Subroutine25                     5
     ZDO_ProcessMatchDescReq        1154
     ?Subroutine14                     5
     ?Subroutine12                    13
     ?Subroutine11                     4
     ?Subroutine16                     6
     ?Subroutine20                     6
     ?Subroutine23                     5
     ?Subroutine9                      7
     ?Subroutine8                      8
     ?Subroutine17                     5
     ?Subroutine7                      6
     ?Subroutine3                      6
     ?Subroutine2                      9
     ZDO_ProcessEPListRsp            102
     ZDO_ProcessBindUnbindRsp         25
     ZDO_EndDeviceTimeoutCB            3
     __Constant_0                      4
     ?<Initializer for __Constant_0>
                                       4

 
 2 629 bytes in segment BANKED_CODE
     4 bytes in segment XDATA_I
     4 bytes in segment XDATA_ID
    52 bytes in segment XDATA_Z
 
 2 629 bytes of CODE  memory (+ 4 bytes shared)
    52 bytes of XDATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
