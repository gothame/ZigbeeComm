##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   17/Oct/2013  21:52:40 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Components\hal\target\CC2430 #
#                          EB\hal_uart.c                                     #
#    Command line       =  -f E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wEnde #
#                          v.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR                #
#                          -DROOT=__near_func -DMAC_OPT_FFD=0 -DBLINK_LEDS   #
#                          "-DCONST=const __code" -DGENERIC=__generic) -f    #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wConfig. #
#                          cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800     #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\Source\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mt\ -I   #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\hal\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          hal\target\CC2430EB\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\osal\mcu #
#                          \ccsoc\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC #
#                          2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\osal\include\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨ #
#                          Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects #
#                          \zstack\Samples\SampleApp\CC2430DB\..\..\..\..\.. #
#                          \Components\stack\af\ -I                          #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\stack\nw #
#                          k\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\st #
#                          ack\sec\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\C #
#                          C2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\ #
#                          Samples\SampleApp\CC2430DB\..\..\..\..\..\Compone #
#                          nts\stack\sys\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶ #
#                          Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\stack\zdo\ -I                           #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\zmac\f8w #
#                          \ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ #
#                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample #
#                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\se #
#                          rvices\saddr\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Co #
#                          mponents\services\sdata\ -I                       #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\incl #
#                          ude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC243 #
#                          0´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\..\..\Components\ #
#                          mac\high_level\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ #
#                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ #
#                          zstack\Samples\SampleApp\CC2430DB\..\..\..\..\..\ #
#                          Components\mac\low_level\srf03\ -I                #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\..\..\..\..\..\Components\mac\low_ #
#                          level\srf03\single_chip\ -D CC2430EB -D           #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D           #
#                          ZG_ENDDEVICE -lC E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ #
#                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zs #
#                          tack\Samples\SampleApp\CC2430DB\EndDeviceEB\List\ #
#                           -lA E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® #
#                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\EndDeviceEB\List\             #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿Ú #
#                          ÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\S #
#                          ampleApp\CC2430DB\EndDeviceEB\Obj\ -e             #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Components\hal\target\CC2430 #
#                          EB\hal_uart.c                                     #
#    List file          =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\List\hal_uart.lst      #
#    Object file        =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ· #
#                          ¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Samp #
#                          leApp\CC2430DB\EndDeviceEB\Obj\hal_uart.r51       #
#                                                                            #
#                                                                            #
##############################################################################

E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Components\hal\target\CC2430EB\hal_uart.c
      1          /******************************************************************************
      2              Filename:       _hal_uart.c
      3              Revised:        $Date: 2007-03-26 11:53:55 -0700 (Mon, 26 Mar 2007) $
      4              Revision:       $Revision: 13853 $
      5          
      6              Description: This file contains the interface to the H/W UART driver.
      7          
      8              Copyright (c) 2007 by Texas Instruments, Inc.
      9              All Rights Reserved.  Permission to use, reproduce, copy, prepare
     10              derivative works, modify, distribute, perform, display or sell this
     11              software and/or its documentation for any purpose is prohibited
     12              without the express written consent of Texas Instruments, Inc.
     13          ******************************************************************************/
     14          
     15          /*********************************************************************
     16           * INCLUDES
     17           */
     18          
     19          #include "hal_types.h"
     20          #include "hal_assert.h"
     21          #include "hal_board.h"

   \                                 In segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xc4
   \   unsigned char volatile __sfr U0UCR
   \                     U0UCR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd7
   \   unsigned char volatile __sfr DMAREQ
   \                     DMAREQ:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     22          #include "hal_defs.h"
     23          #if defined( HAL_UART_DMA ) && HAL_UART_DMA
     24            #include "hal_dma.h"
     25          #endif
     26          #include "hal_mcu.h"
     27          #include "hal_uart.h"
     28          #include "osal.h"
     29          
     30          /*********************************************************************
     31           * MACROS
     32           */
     33          
     34          #if !defined ( HAL_UART_DEBUG )
     35            #define HAL_UART_DEBUG  FALSE
     36          #endif
     37          
     38          #if !defined ( HAL_UART_CLOSE )
     39            #define HAL_UART_CLOSE  FALSE
     40          #endif
     41          
     42          #if !defined ( HAL_UART_BIG_TX_BUF )
     43            #define HAL_UART_BIG_TX_BUF  FALSE
     44          #endif
     45          
     46          /*
     47           *  The MAC_ASSERT macro is for use during debugging.
     48           *  The given expression must evaluate as "true" or else fatal error occurs.
     49           *  At that point, the call stack feature of the debugger can pinpoint where
     50           *  the problem occurred.
     51           *
     52           *  To disable this feature and save code size, the project should define
     53           *  HAL_UART_DEBUG to FALSE.
     54           */
     55          #if ( HAL_UART_DEBUG )
     56            #define HAL_UART_ASSERT( expr)        HAL_ASSERT( expr )
     57          #else
     58            #define HAL_UART_ASSERT( expr )
     59          #endif
     60          
     61          #define P2DIR_PRIPO               0xC0
     62          #if HAL_UART_0_ENABLE
     63            #define HAL_UART_PRIPO          0x00
     64          #else
     65            #define HAL_UART_PRIPO          0x40
     66          #endif
     67          
     68          #define HAL_UART_0_PERCFG_BIT     0x01  // ½«´®¿Ú0¶¨ÒåÔÚP0¿ÚÉÏ
     69          #define HAL_UART_0_P0_RX_TX       0x0c  // ÍâÎ§I/OÑ¡ÔñTXÎªP0_3,RXÎªP0_2.
     70          #define HAL_UART_0_P0_RTS         0x10  // Ñ¡ÔñRTSÒý½ÅP0_4.
     71          #define HAL_UART_0_P0_CTS         0x20  // Ñ¡ÔñCTSÒý½ÅP0_5.
     72          
     73          #define HAL_UART_1_PERCFG_BIT     0x02  // USART1 on P1, so set this bit.
     74          #define HAL_UART_1_P1_RTS         0x10  // Peripheral I/O Select for RTS.
     75          #define HAL_UART_1_P1_CTS         0x20  // Peripheral I/O Select for CTS.
     76          #define HAL_UART_1_P1_RX_TX       0xC0  // Peripheral I/O Select for Rx/Tx.
     77          
     78          #define TX_AVAIL( cfg ) \
     79            ((cfg->txTail == cfg->txHead) ? (cfg->txMax-1) : \
     80            ((cfg->txTail >  cfg->txHead) ? (cfg->txTail - cfg->txHead - 1) : \
     81                               (cfg->txMax - cfg->txHead + cfg->txTail)))
     82          
     83          #define RX0_FLOW_ON  ( P0 &= ~HAL_UART_0_P0_CTS )
     84          #define RX0_FLOW_OFF ( P0 |= HAL_UART_0_P0_CTS )
     85          #define RX1_FLOW_ON  ( P1 &= ~HAL_UART_1_P1_CTS)
     86          #define RX1_FLOW_OFF ( P1 |= HAL_UART_1_P1_CTS )
     87          
     88          #define RX_STOP_FLOW( cfg ) { \
     89            if ( !(cfg->flag & UART_CFG_U1F) ) \
     90            { \
     91              RX0_FLOW_OFF; \
     92            } \
     93            else \
     94            { \
     95              RX1_FLOW_OFF; \
     96            } \
     97            if ( cfg->flag & UART_CFG_DMA ) \
     98            { \
     99              cfg->rxTick = DMA_RX_DLY; \
    100            } \
    101            cfg->flag |= UART_CFG_RXF; \
    102          }
    103          
    104          #define RX_STRT_FLOW( cfg ) { \
    105            if ( !(cfg->flag & UART_CFG_U1F) ) \
    106            { \
    107              RX0_FLOW_ON; \
    108            } \
    109            else \
    110            { \
    111              RX1_FLOW_ON; \
    112            } \
    113            cfg->flag &= ~UART_CFG_RXF; \
    114          }
    115          
    116          #define UART_RX_AVAIL( cfg ) \
    117            ( (cfg->rxHead >= cfg->rxTail) ? (cfg->rxHead - cfg->rxTail) : \
    118                                             (cfg->rxMax - cfg->rxTail + cfg->rxHead +1 ) )
    119          
    120          /* Need to leave enough of the Rx buffer free to handle the incoming bytes
    121           * after asserting flow control, but before the transmitter has obeyed it.
    122           * At the max expected baud rate of 115.2k, 16 bytes will only take ~1.3 msecs,
    123           * but at the min expected baud rate of 38.4k, they could take ~4.2 msecs.
    124           * SAFE_RX_MIN and DMA_RX_DLY must both be consistent according to
    125           * the min & max expected baud rate.
    126           */
    127          #if !defined( SAFE_RX_MIN )
    128            #define SAFE_RX_MIN  48  // bytes - max expected per poll @ 115.2k
    129            // 16 bytes @ 38.4 kBaud -> 4.16 msecs -> 138 32-kHz ticks.
    130            #define DMA_RX_DLY  140
    131            //  2 bytes @ 38.4 kBaud -> 0.52 msecs ->  17 32-kHz ticks.
    132            #define DMA_TX_DLY   20
    133          #endif
    134          
    135          // The timeout tick is at 32-kHz, so multiply msecs by 33.
    136          #define RX_MSECS_TO_TICKS  33
    137          
    138          // The timeout only supports 1 byte.
    139          #if !defined( HAL_UART_RX_IDLE )
    140            #define HAL_UART_RX_IDLE  (6 * RX_MSECS_TO_TICKS)
    141          #endif
    142          
    143          // Only supporting 1 of the 2 USART modules to be driven by DMA at a time.
    144          #if HAL_UART_DMA == 1
    145            #define DMATRIG_RX  HAL_DMA_TRIG_URX0
    146            #define DMATRIG_TX  HAL_DMA_TRIG_UTX0
    147            #define DMA_UDBUF   HAL_DMA_U0DBUF
    148            #define DMA_PAD     U0BAUD
    149          #elif HAL_UART_DMA == 2
    150            #define DMATRIG_RX  HAL_DMA_TRIG_URX1
    151            #define DMATRIG_TX  HAL_DMA_TRIG_UTX1
    152            #define DMA_UDBUF   HAL_DMA_U1DBUF
    153            #define DMA_PAD     U1BAUD
    154          #endif
    155          
    156          #define DMA_RX( cfg ) { \
    157            volatile uint8 ft2430 = U0DBUF; \
    158            \
    159            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX ); \
    160            \
    161            HAL_DMA_SET_DEST( ch, cfg->rxBuf ); \
    162            \
    163            HAL_DMA_SET_LEN( ch, cfg->rxMax ); \
    164            \
    165            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_RX ); \
    166            \
    167            HAL_DMA_ARM_CH( HAL_DMA_CH_RX ); \
    168          }
    169          
    170          #define DMA_TX( cfg ) { \
    171            halDMADesc_t *ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX ); \
    172            \
    173            HAL_DMA_SET_SOURCE( ch, (cfg->txBuf + cfg->txTail) ); \
    174            \
    175            HAL_DMA_SET_LEN( ch, cfg->txCnt ); \
    176            \
    177            HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX ); \
    178            \
    179            HAL_DMA_ARM_CH( HAL_DMA_CH_TX ); \
    180            \
    181            HAL_DMA_START_CH( HAL_DMA_CH_TX ); \
    182          }
    183          
    184          /*********************************************************************
    185           * TYPEDEFS
    186           */
    187          
    188          typedef struct
    189          {
    190            uint8 *rxBuf;
    191            uint8 rxHead;
    192            uint8 rxTail;
    193            uint8 rxMax;
    194            uint8 rxCnt;
    195            uint8 rxTick;
    196            uint8 rxHigh;
    197          
    198            uint8 *txBuf;
    199          #if HAL_UART_BIG_TX_BUF
    200            uint16 txHead;
    201            uint16 txTail;
    202            uint16 txMax;
    203            uint16 txCnt;
    204          #else
    205            uint8 txHead;
    206            uint8 txTail;
    207            uint8 txMax;
    208            uint8 txCnt;
    209          #endif
    210            uint8 txTick;
    211          
    212            uint8 flag;
    213          
    214            halUARTCBack_t rxCB;
    215          } uartCfg_t;
    216          
    217          /*********************************************************************
    218           * CONSTANTS
    219           */
    220          
    221          // Used by DMA macros to shift 1 to create a mask for DMA registers.
    222          #define HAL_DMA_CH_TX    3
    223          #define HAL_DMA_CH_RX    4
    224          
    225          #define HAL_DMA_U0DBUF  0xDFC1
    226          #define HAL_DMA_U1DBUF  0xDFF9
    227          
    228          // UxCSR - USART Control and Status Register.
    229          #define CSR_MODE      0x80
    230          #define CSR_RE        0x40
    231          #define CSR_SLAVE     0x20
    232          #define CSR_FE        0x10
    233          #define CSR_ERR       0x08
    234          #define CSR_RX_BYTE   0x04
    235          #define CSR_TX_BYTE   0x02
    236          #define CSR_ACTIVE    0x01
    237          
    238          // UxUCR - USART UART Control Register.
    239          #define UCR_FLUSH     0x80
    240          #define UCR_FLOW      0x40
    241          #define UCR_D9        0x20
    242          #define UCR_BIT9      0x10
    243          #define UCR_PARITY    0x08
    244          #define UCR_SPB       0x04
    245          #define UCR_STOP      0x02
    246          #define UCR_START     0x01
    247          
    248          #define UTX0IE        0x04
    249          #define UTX1IE        0x08
    250          
    251          #define UART_CFG_U1F  0x80  // USART1 flag bit.
    252          #define UART_CFG_DMA  0x40  // Port is using DMA.
    253          #define UART_CFG_FLW  0x20  // Port is using flow control.
    254          #define UART_CFG_SP4  0x10
    255          #define UART_CFG_SP3  0x08
    256          #define UART_CFG_SP2  0x04
    257          #define UART_CFG_RXF  0x02  // Rx flow is disabled.
    258          #define UART_CFG_TXF  0x01  // Tx is in process.
    259          
    260          /*********************************************************************
    261           * GLOBAL VARIABLES
    262           */
    263          
    264          /*********************************************************************
    265           * GLOBAL FUNCTIONS
    266           */
    267          
    268          /*********************************************************************
    269           * LOCAL VARIABLES
    270           */
    271          
    272          #if HAL_UART_0_ENABLE

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    273          static uartCfg_t *cfg0;
   \                     ??cfg0:
   \   000000                DS 2
    274          #endif
    275          #if HAL_UART_1_ENABLE
    276          static uartCfg_t *cfg1;
    277          #endif
    278          
    279          /*********************************************************************
    280           * LOCAL FUNCTIONS
    281           */
    282          
    283          #if HAL_UART_DMA
    284          static void pollDMA( uartCfg_t *cfg );
    285          #endif
    286          #if HAL_UART_ISR
    287          static void pollISR( uartCfg_t *cfg );
    288          #endif
    289          
    290          #if HAL_UART_DMA
    291          /******************************************************************************
    292           * @fn      pollDMA
    293           *
    294           * @brief   Poll a USART module implemented by DMA.
    295           *
    296           * @param   cfg - USART configuration structure.
    297           *
    298           * @return  none
    299           *****************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    300          static void pollDMA( uartCfg_t *cfg )
   \                     ??pollDMA:
    301          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    302            const uint8 cnt = cfg->rxHead;
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   0A           INC     R2
   \   000012   0A           INC     R2
   \   000013   12....       LCALL   ?Subroutine6 & 0xFFFF
    303            uint8 *pad = cfg->rxBuf+(cfg->rxHead*2);
   \                     ??CrossCallReturnLabel_32:
   \   000016   C3           CLR     C
   \   000017   33           RLC     A
   \   000018   F8           MOV     R0,A
   \   000019   E4           CLR     A
   \   00001A   33           RLC     A
   \   00001B   F9           MOV     R1,A
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   E0           MOVX    A,@DPTR
   \   000021   28           ADD     A,R0
   \   000022   F8           MOV     R0,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   39           ADDC    A,R1
   \   000026   8035         SJMP    ??pollDMA_1
    304          
    305            // Pack the received bytes to the front of the queue.
    306            while ( (*pad == DMA_PAD) && (cfg->rxHead < cfg->rxMax) )
    307            {
    308              cfg->rxBuf[cfg->rxHead++] = *(pad+1);
   \                     ??pollDMA_2:
   \   000028   EE           MOV     A,R6
   \   000029   2402         ADD     A,#0x2
   \   00002B   FA           MOV     R2,A
   \   00002C   8882         MOV     DPL,R0
   \   00002E   8983         MOV     DPH,R1
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   C0E0         PUSH    A
   \   000034   8A82         MOV     DPL,R2
   \   000036   8B83         MOV     DPH,R3
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0 + 0,A
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   25..         ADD     A,?V0 + 0
   \   000042   FD           MOV     R5,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   3400         ADDC    A,#0x0
   \   000047   8D82         MOV     DPL,R5
   \   000049   F583         MOV     DPH,A
   \   00004B   D0E0         POP     A
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   8A82         MOV     DPL,R2
   \   000050   8B83         MOV     DPH,R3
   \   000052   E0           MOVX    A,@DPTR
   \   000053   04           INC     A
   \   000054   F0           MOVX    @DPTR,A
    309              pad += 2;
   \   000055   E8           MOV     A,R0
   \   000056   2402         ADD     A,#0x2
   \   000058   08           INC     R0
   \   000059   08           INC     R0
   \   00005A   E9           MOV     A,R1
   \   00005B   3400         ADDC    A,#0x0
   \                     ??pollDMA_1:
   \   00005D   F9           MOV     R1,A
    310            }
   \   00005E   8882         MOV     DPL,R0
   \   000060   8983         MOV     DPH,R1
   \   000062   E0           MOVX    A,@DPTR
   \   000063   65C2         XRL     A,0xc2
   \   000065   7019         JNZ     ??pollDMA_3
   \   000067   8E82         MOV     DPL,R6
   \   000069   8F83         MOV     DPH,R7
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   C0E0         PUSH    A
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FA           MOV     R2,A
   \   00007A   D0E0         POP     A
   \   00007C   C3           CLR     C
   \   00007D   9A           SUBB    A,R2
   \   00007E   40A8         JC      ??pollDMA_2
    311          
    312            if ( !(cfg->flag & UART_CFG_RXF) )
   \                     ??pollDMA_3:
   \   000080   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000083   A2E1         MOV     C,0xE0 /* A   */.1
   \   000085   8E82         MOV     DPL,R6
   \   000087   8F83         MOV     DPH,R7
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   4046         JC      ??pollDMA_4
    313            {
    314              /* It is necessary to stop Rx flow and wait for H/W-enqueued bytes still
    315               * incoming to stop before resetting the DMA Rx engine. If DMA Rx is
    316               * aborted during incoming data, a byte may be lost inside the engine
    317               * during the 2-step transfer process of read/write.
    318               */
    319              if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   FA           MOV     R2,A
   \   00008F   8E82         MOV     DPL,R6
   \   000091   8F83         MOV     DPH,R7
   \   000093   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000096   4023         JC      ??pollDMA_5
    320              {
    321                RX_STOP_FLOW( cfg );
   \   000098   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00009B   4004         JC      ??pollDMA_6
   \   00009D   D285         SETB    0x80.5
   \   00009F   8002         SJMP    ??pollDMA_7
   \                     ??pollDMA_6:
   \   0000A1   D295         SETB    0x90.5
   \                     ??pollDMA_7:
   \   0000A3   A2E6         MOV     C,0xE0 /* A   */.6
   \   0000A5   500D         JNC     ??pollDMA_8
   \   0000A7   748C         MOV     A,#-0x74
   \   0000A9   8E82         MOV     DPL,R6
   \   0000AB   8F83         MOV     DPH,R7
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   F0           MOVX    @DPTR,A
   \                     ??pollDMA_8:
   \   0000B4   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000B7   D2E1         SETB    0xE0 /* A   */.1
   \   0000B9   806D         SJMP    ??pollDMA_9
    322              }
    323              // If anything received, reset the Rx idle timer.
    324              else if ( cfg->rxHead != cnt )
   \                     ??pollDMA_5:
   \   0000BB   8E82         MOV     DPL,R6
   \   0000BD   8F83         MOV     DPH,R7
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   6C           XRL     A,R4
   \   0000C3   6064         JZ      ??pollDMA_10
    325              {
    326                cfg->rxTick = HAL_UART_RX_IDLE;
   \   0000C5   74C6         MOV     A,#-0x3a
   \   0000C7   8E82         MOV     DPL,R6
   \   0000C9   8F83         MOV     DPH,R7
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   8055         SJMP    ??pollDMA_9
    327              }
    328            }
    329            else if ( !cfg->rxTick && (cfg->rxHead == cfg->rxTail) )
   \                     ??pollDMA_4:
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   704F         JNZ     ??pollDMA_10
   \   0000DA   8E82         MOV     DPL,R6
   \   0000DC   8F83         MOV     DPH,R7
   \   0000DE   A3           INC     DPTR
   \   0000DF   A3           INC     DPTR
   \   0000E0   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   6A           XRL     A,R2
   \   0000E5   7042         JNZ     ??pollDMA_10
    330            {
    331              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
   \   0000E7   75D690       MOV     0xd6,#-0x70
    332              cfg->rxHead = cfg->rxTail = 0;
   \   0000EA   12....       LCALL   ?Subroutine15 & 0xFFFF
    333              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
   \                     ??CrossCallReturnLabel_52:
   \   0000ED   2404         ADD     A,#0x4
   \   0000EF   F5..         MOV     ?V0 + 0,A
   \   0000F1   EF           MOV     A,R7
   \   0000F2   3400         ADDC    A,#0x0
   \   0000F4   F5..         MOV     ?V0 + 1,A
   \   0000F6                ; Setup parameters for call to function osal_memset
   \   0000F6   85..82       MOV     DPL,?V0 + 0
   \   0000F9   F583         MOV     DPH,A
   \   0000FB   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   0000FE   8E82         MOV     DPL,R6
   \   000100   8F83         MOV     DPH,R7
   \   000102   E0           MOVX    A,@DPTR
   \   000103   FA           MOV     R2,A
   \   000104   A3           INC     DPTR
   \   000105   E0           MOVX    A,@DPTR
   \   000106   FB           MOV     R3,A
   \   000107   90....       MOV     DPTR,#(osal_memset & 0xffff)
   \   00010A   74..         MOV     A,#((osal_memset >> 16) & 0xff)
   \   00010C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    334              DMA_RX( cfg );
   \   00010F   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000112   85..82       MOV     DPL,?V0 + 0
   \   000115   85..83       MOV     DPH,?V0 + 1
   \   000118   12....       LCALL   ?Subroutine8 & 0xFFFF
    335              RX_STRT_FLOW( cfg );
   \                     ??CrossCallReturnLabel_40:
   \   00011B   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00011E   4004         JC      ??pollDMA_11
   \   000120   C285         CLR     0x80.5
   \   000122   8002         SJMP    ??pollDMA_12
   \                     ??pollDMA_11:
   \   000124   C295         CLR     0x90.5
   \                     ??pollDMA_12:
   \   000126   C2E1         CLR     0xE0 /* A   */.1
   \                     ??pollDMA_9:
   \   000128   F0           MOVX    @DPTR,A
    336            }
    337          
    338            if ( HAL_DMA_CHECK_IRQ( HAL_DMA_CH_TX ) )
   \                     ??pollDMA_10:
   \   000129   E5D1         MOV     A,0xd1
   \   00012B   A2E3         MOV     C,0xE0 /* A   */.3
   \   00012D   5048         JNC     ??pollDMA_13
    339            {
    340              HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_TX );
   \   00012F   53D1F7       ANL     0xd1,#0xf7
    341              cfg->flag &= ~UART_CFG_TXF;
   \   000132   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000135   C2E0         CLR     0xE0 /* A   */.0
   \   000137   F0           MOVX    @DPTR,A
    342              cfg->txTick = DMA_TX_DLY;
   \   000138   EE           MOV     A,R6
   \   000139   240E         ADD     A,#0xe
   \   00013B   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00013E   7414         MOV     A,#0x14
   \   000140   F0           MOVX    @DPTR,A
    343          
    344              if ( (cfg->txMax - cfg->txCnt) < cfg->txTail )
   \   000141   EE           MOV     A,R6
   \   000142   240C         ADD     A,#0xc
   \   000144   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000147   F8           MOV     R0,A
   \   000148   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00014B   E8           MOV     A,R0
   \   00014C   C3           CLR     C
   \   00014D   9A           SUBB    A,R2
   \   00014E   F8           MOV     R0,A
   \   00014F   E4           CLR     A
   \   000150   9400         SUBB    A,#0x0
   \   000152   F9           MOV     R1,A
   \   000153   EE           MOV     A,R6
   \   000154   240B         ADD     A,#0xb
   \   000156   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000159   C3           CLR     C
   \   00015A   E8           MOV     A,R0
   \   00015B   9A           SUBB    A,R2
   \   00015C   E9           MOV     A,R1
   \   00015D   9400         SUBB    A,#0x0
   \   00015F   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000161   65D0         XRL     A,PSW
   \   000163   33           RLC     A
   \   000164   5005         JNC     ??pollDMA_14
    345              {
    346                cfg->txTail = 0;  // DMA can only run to the end of the Tx buffer.
   \   000166   E4           CLR     A
   \                     ??pollDMA_15:
   \   000167   F0           MOVX    @DPTR,A
   \   000168   02....       LJMP    ??pollDMA_16 & 0xFFFF
    347              }
    348              else
    349              {
    350                cfg->txTail += cfg->txCnt;
   \                     ??pollDMA_14:
   \   00016B   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00016E   EE           MOV     A,R6
   \   00016F   240B         ADD     A,#0xb
   \   000171   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000174   2A           ADD     A,R2
   \   000175   80F0         SJMP    ??pollDMA_15
    351              }
    352            }
    353            else if ( !(cfg->flag & UART_CFG_TXF) && !cfg->txTick )
   \                     ??pollDMA_13:
   \   000177   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00017A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00017C   5003         JNC     $+5
   \   00017E   02....       LJMP    ??pollDMA_16 & 0xFFFF
   \   000181   EE           MOV     A,R6
   \   000182   240E         ADD     A,#0xe
   \   000184   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000187   6003         JZ      $+5
   \   000189   02....       LJMP    ??pollDMA_16 & 0xFFFF
    354            {
    355              if ( cfg->txTail != cfg->txHead )
   \   00018C   EE           MOV     A,R6
   \   00018D   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000190   6A           XRL     A,R2
   \   000191   7003         JNZ     $+5
   \   000193   02....       LJMP    ??pollDMA_16 & 0xFFFF
    356              {
    357                if ( cfg->txTail < cfg->txHead )
   \   000196   EE           MOV     A,R6
   \   000197   240B         ADD     A,#0xb
   \   000199   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00019C   C0E0         PUSH    A
   \   00019E   8E82         MOV     DPL,R6
   \   0001A0   8F83         MOV     DPH,R7
   \   0001A2   A3           INC     DPTR
   \   0001A3   A3           INC     DPTR
   \   0001A4   A3           INC     DPTR
   \   0001A5   A3           INC     DPTR
   \   0001A6   A3           INC     DPTR
   \   0001A7   A3           INC     DPTR
   \   0001A8   A3           INC     DPTR
   \   0001A9   A3           INC     DPTR
   \   0001AA   A3           INC     DPTR
   \   0001AB   A3           INC     DPTR
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   FA           MOV     R2,A
   \   0001AE   D0E0         POP     A
   \   0001B0   C3           CLR     C
   \   0001B1   9A           SUBB    A,R2
   \   0001B2   EE           MOV     A,R6
   \   0001B3   5007         JNC     ??pollDMA_17
    358                {
    359                  cfg->txCnt = cfg->txHead - cfg->txTail;
   \   0001B5   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   0001B8   C3           CLR     C
   \   0001B9   9A           SUBB    A,R2
   \   0001BA   800E         SJMP    ??pollDMA_18
    360                }
    361                else  // Can only run DMA engine up to max, then restart at zero.
    362                {
    363                  cfg->txCnt = cfg->txMax - cfg->txTail + 1;
   \                     ??pollDMA_17:
   \   0001BC   240B         ADD     A,#0xb
   \   0001BE   12....       LCALL   ??Subroutine2_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0001C1   EE           MOV     A,R6
   \   0001C2   240C         ADD     A,#0xc
   \   0001C4   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0001C7   C3           CLR     C
   \   0001C8   9A           SUBB    A,R2
   \   0001C9   04           INC     A
   \                     ??pollDMA_18:
   \   0001CA   C0E0         PUSH    A
   \   0001CC   EE           MOV     A,R6
   \   0001CD   240D         ADD     A,#0xd
   \   0001CF   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0001D2   D0E0         POP     A
   \   0001D4   F0           MOVX    @DPTR,A
    364                }
    365          
    366                cfg->flag |= UART_CFG_TXF;
   \   0001D5   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0001D8   D2E0         SETB    0xE0 /* A   */.0
   \   0001DA   F0           MOVX    @DPTR,A
    367                DMA_TX( cfg );
   \   0001DB   EE           MOV     A,R6
   \   0001DC   2408         ADD     A,#0x8
   \   0001DE   F8           MOV     R0,A
   \   0001DF   EF           MOV     A,R7
   \   0001E0   3400         ADDC    A,#0x0
   \   0001E2   F9           MOV     R1,A
   \   0001E3   EE           MOV     A,R6
   \   0001E4   240B         ADD     A,#0xb
   \   0001E6   FA           MOV     R2,A
   \   0001E7   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0001EA   8882         MOV     DPL,R0
   \   0001EC   8983         MOV     DPH,R1
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   2C           ADD     A,R4
   \   0001F0   A3           INC     DPTR
   \   0001F1   E0           MOVX    A,@DPTR
   \   0001F2   3400         ADDC    A,#0x0
   \   0001F4   90....       MOV     DPTR,#(dmaCh1234 + 16)
   \   0001F7   F0           MOVX    @DPTR,A
   \   0001F8   8A82         MOV     DPL,R2
   \   0001FA   8B83         MOV     DPH,R3
   \   0001FC   E0           MOVX    A,@DPTR
   \   0001FD   FA           MOV     R2,A
   \   0001FE   8882         MOV     DPL,R0
   \   000200   8983         MOV     DPH,R1
   \   000202   E0           MOVX    A,@DPTR
   \   000203   2A           ADD     A,R2
   \   000204   90....       MOV     DPTR,#(dmaCh1234 + 17)
   \   000207   F0           MOVX    @DPTR,A
   \   000208   EE           MOV     A,R6
   \   000209   240D         ADD     A,#0xd
   \   00020B   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00020E   90....       MOV     DPTR,#(dmaCh1234 + 21)
   \   000211   F0           MOVX    @DPTR,A
   \   000212   90....       MOV     DPTR,#(dmaCh1234 + 20)
   \   000215   E0           MOVX    A,@DPTR
   \   000216   54E0         ANL     A,#0xe0
   \   000218   F0           MOVX    @DPTR,A
   \   000219   53D1F7       ANL     0xd1,#0xf7
   \   00021C   75D608       MOV     0xd6,#0x8
   \   00021F   75D708       MOV     0xd7,#0x8
    368              }
    369            }
    370          }
   \                     ??pollDMA_16:
   \   000222   7401         MOV     A,#0x1
   \   000224   12....       LCALL   ?DEALLOC_XSTACK8
   \   000227                REQUIRE ?Subroutine19
   \   000227                ; // Fall through to label ?Subroutine19

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \                     ??Subroutine7_0:
   \   000003   3400         ADDC    A,#0x0
   \   000005   F583         MOV     DPH,A
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   EF           MOV     A,R7
   \   000001   3400         ADDC    A,#0x0
   \   000003   FB           MOV     R3,A
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FC           MOV     R4,A
   \   00000A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \                     ??Subroutine4_0:
   \   000006   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000009   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000B   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EE           MOV     A,R6
   \   000001   240D         ADD     A,#0xd
   \                     ??Subroutine2_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000009   FA           MOV     R2,A
   \   00000A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   240B         ADD     A,#0xb
   \   000002   F582         MOV     DPL,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   F583         MOV     DPH,A
   \   000009   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010                REQUIRE ?Subroutine20
   \   000010                ; // Fall through to label ?Subroutine20

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   8E82         MOV     DPL,R6
   \   000004   8F83         MOV     DPH,R7
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E4           CLR     A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   EE           MOV     A,R6
   \   00000E   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   33           RLC     A
   \   000003   FC           MOV     R4,A
   \   000004   E4           CLR     A
   \   000005   33           RLC     A
   \   000006   FD           MOV     R5,A
   \   000007   E5C2         MOV     A,0xc2
   \   000009   F4           CPL     A
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E5C1         MOV     A,0xc1
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   90....       MOV     DPTR,#(dmaCh1234 + 26)
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   8E82         MOV     DPL,R6
   \   000012   8F83         MOV     DPH,R7
   \   000014   E0           MOVX    A,@DPTR
   \   000015   90....       MOV     DPTR,#(dmaCh1234 + 27)
   \   000018   F0           MOVX    @DPTR,A
   \   000019   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   90....       MOV     DPTR,#(dmaCh1234 + 29)
   \   000004   F0           MOVX    @DPTR,A
   \   000005   90....       MOV     DPTR,#(dmaCh1234 + 28)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   54E0         ANL     A,#0xe0
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   53D1EF       ANL     0xd1,#0xef
   \   00000F   75D610       MOV     0xd6,#0x10
   \   000012   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F8           MOV     R0,A
   \   000006   74D0         MOV     A,#-0x30
   \   000008   28           ADD     A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   74FF         MOV     A,#-0x1
   \   00000C   3400         ADDC    A,#0x0
   \   00000E   F9           MOV     R1,A
   \   00000F   C3           CLR     C
   \   000010   EA           MOV     A,R2
   \   000011   98           SUBB    A,R0
   \   000012   E4           CLR     A
   \   000013   99           SUBB    A,R1
   \   000014   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000016   65D0         XRL     A,PSW
   \   000018   33           RLC     A
   \   000019   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \                     ??Subroutine5_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \                     ??Subroutine5_1:
   \   000006   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET
    371          #endif
    372          
    373          #if HAL_UART_ISR
    374          /******************************************************************************
    375           * @fn      pollISR
    376           *
    377           * @brief   Poll a USART module implemented by ISR.
    378           *
    379           * @param   cfg - USART configuration structure.
    380           *
    381           * @return  none
    382           *****************************************************************************/
    383          static void pollISR( uartCfg_t *cfg )
    384          {
    385            uint8 cnt = UART_RX_AVAIL( cfg );
    386          
    387            if ( !(cfg->flag & UART_CFG_RXF) )
    388            {
    389              // If anything received, reset the Rx idle timer.
    390              if ( cfg->rxCnt != cnt )
    391              {
    392                cfg->rxTick = HAL_UART_RX_IDLE;
    393                cfg->rxCnt = cnt;
    394              }
    395          
    396              /* It is necessary to stop Rx flow in advance of a full Rx buffer because
    397               * bytes can keep coming while sending H/W fifo flushes.
    398               */
    399              if ( cfg->rxCnt >= (cfg->rxMax - SAFE_RX_MIN) )
    400              {
    401                RX_STOP_FLOW( cfg );
    402              }
    403            }
    404          }
    405          #endif
    406          
    407          /******************************************************************************
    408           * @fn      HalUARTInit
    409           *
    410           * @brief   Initialize the UART
    411           *
    412           * @param   none
    413           *
    414           * @return  none
    415           *****************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    416          void HalUARTInit( void )
   \                     HalUARTInit:
    417          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    418          #if HAL_UART_DMA
    419            halDMADesc_t *ch;
    420          #endif
    421          
    422            // Set P2 priority - USART0 over USART1 if both are defined.
    423            P2DIR &= ~P2DIR_PRIPO;
   \   000004   53FF3F       ANL     0xff,#0x3f
   \   000007   E5FF         MOV     A,0xff
    424            P2DIR |= HAL_UART_PRIPO;
   \   000009   85FFFF       MOV     0xff,0xff
    425          
    426          //#if HAL_UART_0_ENABLE
    427            // Set UART0 I/O location to P0.
    428            PERCFG &= ~HAL_UART_0_PERCFG_BIT;
   \   00000C   53F1FE       ANL     0xf1,#0xfe
    429          
    430            /* Enable Tx and Rx on P0 */
    431            P0SEL |= HAL_UART_0_P0_RX_TX;
   \   00000F   43F30C       ORL     0xf3,#0xc
   \   000012   E5F3         MOV     A,0xf3
    432          
    433            /* Make sure ADC doesnt use this */
    434            ADCCFG &= ~HAL_UART_0_P0_RX_TX;
   \   000014   53F2F3       ANL     0xf2,#0xf3
   \   000017   E5F2         MOV     A,0xf2
    435          
    436            /* Mode is UART Mode */
    437            U0CSR = CSR_MODE;
   \   000019   758680       MOV     0x86,#-0x80
    438          
    439            /* Flush it */
    440            U0UCR = UCR_FLUSH;
   \   00001C   75C480       MOV     0xc4,#-0x80
    441          //#endif
    442          
    443          #if HAL_UART_1_ENABLE
    444            // Set UART1 I/O location to P1.
    445            PERCFG |= HAL_UART_1_PERCFG_BIT;
    446          
    447            /* Enable Tx and Rx on P1 */
    448            P1SEL  |= HAL_UART_1_P1_RX_TX;
    449          
    450            /* Make sure ADC doesnt use this */
    451            ADCCFG &= ~HAL_UART_1_P1_RX_TX;
    452          
    453            /* Mode is UART Mode */
    454            U1CSR = CSR_MODE;
    455          
    456            /* Flush it */
    457            U1UCR = UCR_FLUSH;
    458          #endif
    459          
    460          #if HAL_UART_DMA
    461            // Setup Tx by DMA.
    462            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX );
    463          
    464            // The start address of the destination.
    465            HAL_DMA_SET_DEST( ch, DMA_UDBUF );
   \   00001F   74DF         MOV     A,#-0x21
   \   000021   90....       MOV     DPTR,#(dmaCh1234 + 18)
   \   000024   F0           MOVX    @DPTR,A
   \   000025   74C1         MOV     A,#-0x3f
   \   000027   90....       MOV     DPTR,#(dmaCh1234 + 19)
   \   00002A   F0           MOVX    @DPTR,A
    466          
    467            // Using the length field to determine how many bytes to transfer.
    468            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
   \   00002B   90....       MOV     DPTR,#(dmaCh1234 + 20)
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   541F         ANL     A,#0x1f
   \   000031   F0           MOVX    @DPTR,A
    469          
    470            // One byte is transferred each time.
    471            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_BYTE );
    472          
    473            // The bytes are transferred 1-by-1 on Tx Complete trigger.
    474            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    475            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_TX );
   \   000032   740F         MOV     A,#0xf
   \   000034   90....       MOV     DPTR,#(dmaCh1234 + 22)
   \   000037   F0           MOVX    @DPTR,A
    476          
    477            // The source address is decremented by 1 byte after each transfer.
    478            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_1 );
    479          
    480            // The destination address is constant - the Tx Data Buffer.
    481            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_0 );
    482          
    483            // The DMA is to be polled and shall not issue an IRQ upon completion.
    484            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    485          
    486            // Xfer all 8 bits of a byte xfer.
    487            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    488          
    489            // DMA Tx has shared priority for memory access - every other one.
    490            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
   \   000038   7442         MOV     A,#0x42
   \   00003A   90....       MOV     DPTR,#(dmaCh1234 + 23)
   \   00003D   F0           MOVX    @DPTR,A
    491          
    492            // Setup Rx by DMA.
    493            ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX );
    494          
    495            // The start address of the source.
    496            HAL_DMA_SET_SOURCE( ch, DMA_UDBUF );
   \   00003E   74DF         MOV     A,#-0x21
   \   000040   90....       MOV     DPTR,#(dmaCh1234 + 24)
   \   000043   F0           MOVX    @DPTR,A
   \   000044   74C1         MOV     A,#-0x3f
   \   000046   90....       MOV     DPTR,#(dmaCh1234 + 25)
   \   000049   F0           MOVX    @DPTR,A
    497          
    498            // Using the length field to determine how many bytes to transfer.
    499            HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );
   \   00004A   90....       MOV     DPTR,#(dmaCh1234 + 28)
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   541F         ANL     A,#0x1f
   \   000050   F0           MOVX    @DPTR,A
    500          
    501            /* The trick is to cfg DMA to xfer 2 bytes for every 1 byte of Rx.
    502             * The byte after the Rx Data Buffer is the Baud Cfg Register,
    503             * which always has a known value. So init Rx buffer to inverse of that
    504             * known value. DMA word xfer will flip the bytes, so every valid Rx byte
    505             * in the Rx buffer will be preceded by a DMA_PAD char equal to the
    506             * Baud Cfg Register value.
    507             */
    508            HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_WORD );
    509          
    510            // The bytes are transferred 1-by-1 on Rx Complete trigger.
    511            HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );
    512            HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_RX );
   \   000051   748E         MOV     A,#-0x72
   \   000053   90....       MOV     DPTR,#(dmaCh1234 + 30)
   \   000056   F0           MOVX    @DPTR,A
    513          
    514            // The source address is constant - the Rx Data Buffer.
    515            HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_0 );
    516          
    517            // The destination address is incremented by 1 word after each transfer.
    518            HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_1 );
    519          
    520            // The DMA is to be polled and shall not issue an IRQ upon completion.
    521            HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );
    522          
    523            // Xfer all 8 bits of a byte xfer.
    524            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );
    525          
    526            // DMA has highest priority for memory access.
    527            HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );
   \   000057   7412         MOV     A,#0x12
   \   000059   90....       MOV     DPTR,#(dmaCh1234 + 31)
   \   00005C   F0           MOVX    @DPTR,A
    528          #endif
    529          }
   \   00005D                REQUIRE ?Subroutine21
   \   00005D                ; // Fall through to label ?Subroutine21

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    530          
    531          /******************************************************************************
    532           * @fn      HalUARTOpen
    533           *
    534           * @brief   Open a port according tp the configuration specified by parameter.
    535           *
    536           * @param   port   - UART port
    537           *          config - contains configuration information
    538           *
    539           * @return  Status of the function call
    540           *****************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    541          uint8 HalUARTOpen( uint8 port, halUARTCfg_t *config )
   \                     HalUARTOpen:
    542          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 2,R1
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
    543            uartCfg_t **cfgPP = NULL;
   \   000010   7E00         MOV     R6,#0x0
   \   000012   7F00         MOV     R7,#0x0
    544            uartCfg_t *cfg;
    545          
    546          //#if HAL_UART_0_ENABLE
    547            if ( port == HAL_UART_PORT_0 )
   \   000014   E9           MOV     A,R1
   \   000015   7004         JNZ     ??HalUARTOpen_0
    548            {
    549              cfgPP = &cfg0;
   \   000017   7E..         MOV     R6,#(??cfg0 & 0xff)
   \   000019   7F..         MOV     R7,#((??cfg0 >> 8) & 0xff)
    550            }
    551          //#endif
    552          
    553          #if HAL_UART_1_ENABLE
    554            if ( port == HAL_UART_PORT_1 )
    555            {
    556              cfgPP = &cfg1;
    557            }
    558          #endif
    559          
    560            HAL_UART_ASSERT( cfgPP );
    561          
    562          #if HAL_UART_CLOSE
    563            // Protect against user re-opening port before closing it.
    564            HalUARTClose( port );
    565          #else
    566            HAL_UART_ASSERT( *cfgPP == NULL );
    567          #endif
    568          
    569            HAL_UART_ASSERT( (config->baudRate == HAL_UART_BR_38400) ||
    570                             (config->baudRate == HAL_UART_BR_115200) );
    571          
    572            /* Whereas runtime heap alloc can be expected to fail - one-shot system
    573             * initialization must succeed, so no check for alloc fail.
    574             */
    575            *cfgPP = (uartCfg_t *)osal_mem_alloc( sizeof( uartCfg_t ) );
   \                     ??HalUARTOpen_0:
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   7A13         MOV     R2,#0x13
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   000022   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   000024   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   EA           MOV     A,R2
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   EB           MOV     A,R3
   \   00002F   F0           MOVX    @DPTR,A
    576            cfg = *cfgPP;
   \   000030   8E82         MOV     DPL,R6
   \   000032   8F83         MOV     DPH,R7
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FE           MOV     R6,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   FF           MOV     R7,A
    577            HAL_UART_ASSERT( cfg );
    578          
    579            cfg->rxMax = config->rx.maxBufSize;
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   240A         ADD     A,#0xa
   \   00003D   F5..         MOV     ?V0 + 4,A
   \   00003F   E5..         MOV     A,?V0 + 1
   \   000041   3400         ADDC    A,#0x0
   \   000043   F5..         MOV     ?V0 + 5,A
   \   000045   85..82       MOV     DPL,?V0 + 4
   \   000048   F583         MOV     DPH,A
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   8E82         MOV     DPL,R6
   \   00004D   8F83         MOV     DPH,R7
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   F0           MOVX    @DPTR,A
    580          
    581          #if !HAL_UART_BIG_TX_BUF
    582            HAL_UART_ASSERT( (config->tx.maxBufSize < 256) );
    583          #endif
    584            cfg->txMax = config->tx.maxBufSize;
   \   000054   EE           MOV     A,R6
   \   000055   240C         ADD     A,#0xc
   \   000057   F8           MOV     R0,A
   \   000058   EF           MOV     A,R7
   \   000059   3400         ADDC    A,#0x0
   \   00005B   F9           MOV     R1,A
   \   00005C   E5..         MOV     A,?V0 + 0
   \   00005E   2412         ADD     A,#0x12
   \   000060   F582         MOV     DPL,A
   \   000062   E5..         MOV     A,?V0 + 1
   \   000064   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000067   8882         MOV     DPL,R0
   \   000069   8983         MOV     DPH,R1
   \   00006B   F0           MOVX    @DPTR,A
    585            cfg->txBuf = osal_mem_alloc( cfg->txMax+1 );
   \   00006C                ; Setup parameters for call to function osal_mem_alloc
   \   00006C   F8           MOV     R0,A
   \   00006D   7401         MOV     A,#0x1
   \   00006F   28           ADD     A,R0
   \   000070   FA           MOV     R2,A
   \   000071   E4           CLR     A
   \   000072   3400         ADDC    A,#0x0
   \   000074   FB           MOV     R3,A
   \   000075   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   000078   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   00007A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00007D   8E82         MOV     DPL,R6
   \   00007F   8F83         MOV     DPH,R7
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   EA           MOV     A,R2
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   A3           INC     DPTR
   \   00008C   EB           MOV     A,R3
   \   00008D   F0           MOVX    @DPTR,A
    586          
    587            cfg->rxHead = cfg->rxTail = 0;
   \   00008E   12....       LCALL   ?Subroutine15 & 0xFFFF
    588            cfg->txHead = cfg->txTail = 0;
   \                     ??CrossCallReturnLabel_53:
   \   000091   240B         ADD     A,#0xb
   \   000093   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000096   E4           CLR     A
   \   000097   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   12....       LCALL   ?Subroutine14 & 0xFFFF
    589            cfg->rxHigh = config->rx.maxBufSize - config->flowControlThreshold;
   \                     ??CrossCallReturnLabel_50:
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F8           MOV     R0,A
   \   0000A8   85..82       MOV     DPL,?V0 + 4
   \   0000AB   85..83       MOV     DPH,?V0 + 5
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   C3           CLR     C
   \   0000B0   98           SUBB    A,R0
   \   0000B1   8E82         MOV     DPL,R6
   \   0000B3   8F83         MOV     DPH,R7
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   F0           MOVX    @DPTR,A
    590            cfg->rxCB = config->callBackFunc;
   \   0000BD   E5..         MOV     A,?V0 + 0
   \   0000BF   241B         ADD     A,#0x1b
   \   0000C1   F582         MOV     DPL,A
   \   0000C3   E5..         MOV     A,?V0 + 1
   \   0000C5   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000C8   F9           MOV     R1,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   FA           MOV     R2,A
   \   0000CC   A3           INC     DPTR
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   FB           MOV     R3,A
   \   0000CF   EE           MOV     A,R6
   \   0000D0   2410         ADD     A,#0x10
   \   0000D2   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0000D5   E9           MOV     A,R1
   \   0000D6   F0           MOVX    @DPTR,A
   \   0000D7   A3           INC     DPTR
   \   0000D8   EA           MOV     A,R2
   \   0000D9   F0           MOVX    @DPTR,A
   \   0000DA   A3           INC     DPTR
   \   0000DB   EB           MOV     A,R3
   \   0000DC   F0           MOVX    @DPTR,A
    591          
    592          #if HAL_UART_0_ENABLE
    593            if ( port == HAL_UART_PORT_0 )
   \   0000DD   E5..         MOV     A,?V0 + 2
   \   0000DF   6003         JZ      $+5
   \   0000E1   02....       LJMP    ??HalUARTOpen_1 & 0xFFFF
    594            {
    595              // Only supporting 38400 or 115200 for code size - other is possible.
    596              U0BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
   \   0000E4   85..82       MOV     DPL,?V0 + 0
   \   0000E7   85..83       MOV     DPH,?V0 + 1
   \   0000EA   A3           INC     DPTR
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   6406         XRL     A,#0x6
   \   0000EE   7004         JNZ     ??HalUARTOpen_2
   \   0000F0   7A3B         MOV     R2,#0x3b
   \   0000F2   8002         SJMP    ??HalUARTOpen_3
   \                     ??HalUARTOpen_2:
   \   0000F4   7AD8         MOV     R2,#-0x28
   \                     ??HalUARTOpen_3:
   \   0000F6   8AC2         MOV     0xc2,R2
    597              U0GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
   \   0000F8   85..82       MOV     DPL,?V0 + 0
   \   0000FB   85..83       MOV     DPH,?V0 + 1
   \   0000FE   A3           INC     DPTR
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   6406         XRL     A,#0x6
   \   000102   7004         JNZ     ??HalUARTOpen_4
   \   000104   7A0A         MOV     R2,#0xa
   \   000106   8002         SJMP    ??HalUARTOpen_5
   \                     ??HalUARTOpen_4:
   \   000108   7A0B         MOV     R2,#0xb
   \                     ??HalUARTOpen_5:
   \   00010A   8AC5         MOV     0xc5,R2
    598          
    599              U0CSR |= CSR_RE;
   \   00010C   438640       ORL     0x86,#0x40
    600          
    601          #if HAL_UART_DMA == 1
    602              cfg->flag = UART_CFG_DMA;
   \   00010F   EE           MOV     A,R6
   \   000110   240F         ADD     A,#0xf
   \   000112   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000115   7440         MOV     A,#0x40
   \   000117   F0           MOVX    @DPTR,A
    603              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    604              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    605              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
   \   000118   EE           MOV     A,R6
   \   000119   2404         ADD     A,#0x4
   \   00011B   F5..         MOV     ?V0 + 2,A
   \   00011D   EF           MOV     A,R7
   \   00011E   3400         ADDC    A,#0x0
   \   000120   F5..         MOV     ?V0 + 3,A
   \   000122                ; Setup parameters for call to function osal_mem_alloc
   \   000122   85..82       MOV     DPL,?V0 + 2
   \   000125   F583         MOV     DPH,A
   \   000127   E0           MOVX    A,@DPTR
   \   000128   C3           CLR     C
   \   000129   33           RLC     A
   \   00012A   FA           MOV     R2,A
   \   00012B   E4           CLR     A
   \   00012C   33           RLC     A
   \   00012D   FB           MOV     R3,A
   \   00012E   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   000131   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   000133   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000136   8E82         MOV     DPL,R6
   \   000138   8F83         MOV     DPH,R7
   \   00013A   EA           MOV     A,R2
   \   00013B   F0           MOVX    @DPTR,A
   \   00013C   A3           INC     DPTR
   \   00013D   EB           MOV     A,R3
   \   00013E   F0           MOVX    @DPTR,A
    606              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
   \   00013F                ; Setup parameters for call to function osal_memset
   \   00013F   85..82       MOV     DPL,?V0 + 2
   \   000142   85..83       MOV     DPH,?V0 + 3
   \   000145   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000148   90....       MOV     DPTR,#(osal_memset & 0xffff)
   \   00014B   74..         MOV     A,#((osal_memset >> 16) & 0xff)
   \   00014D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    607              DMA_RX( cfg );
   \   000150   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000153   85..82       MOV     DPL,?V0 + 2
   \   000156   85..83       MOV     DPH,?V0 + 3
   \   000159   12....       LCALL   ?Subroutine8 & 0xFFFF
    608          #else
    609              cfg->flag = 0;
    610              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    611              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    612              URX0IE = 1;
    613              IEN2 |= UTX0IE;
    614          #endif
    615          
    616              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    617              if ( config->flowControl )
   \                     ??CrossCallReturnLabel_41:
   \   00015C   85..82       MOV     DPL,?V0 + 0
   \   00015F   85..83       MOV     DPH,?V0 + 1
   \   000162   A3           INC     DPTR
   \   000163   A3           INC     DPTR
   \   000164   E0           MOVX    A,@DPTR
   \   000165   6013         JZ      ??HalUARTOpen_6
    618              {
    619                cfg->flag |= UART_CFG_FLW;
   \   000167   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00016A   D2E5         SETB    0xE0 /* A   */.5
   \   00016C   F0           MOVX    @DPTR,A
    620                U0UCR = UCR_FLOW | UCR_STOP;
   \   00016D   75C442       MOV     0xc4,#0x42
    621                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    622                P0SEL |= HAL_UART_0_P0_RTS;
   \   000170   43F310       ORL     0xf3,#0x10
    623                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    624                P0DIR |= HAL_UART_0_P0_CTS;
   \   000173   43FD20       ORL     0xfd,#0x20
    625                RX0_FLOW_ON;
   \   000176   C285         CLR     0x80.5
   \   000178   8003         SJMP    ??HalUARTOpen_1
    626              }
    627              else
    628              {
    629                U0UCR = UCR_STOP;
   \                     ??HalUARTOpen_6:
   \   00017A   75C402       MOV     0xc4,#0x2
    630              }
    631              }
    632          #endif
    633          
    634          #if HAL_UART_1_ENABLE
    635            if ( port == HAL_UART_PORT_1 )
    636            {
    637              // Only supporting 38400 or 115200 for code size - other is possible.
    638              U1BAUD = (config->baudRate == HAL_UART_BR_38400) ? 59 : 216;
    639              U1GCR = (config->baudRate == HAL_UART_BR_38400) ? 10 : 11;
    640          
    641              U1CSR |= CSR_RE;
    642          
    643          #if HAL_UART_DMA == 2
    644              cfg->flag = (UART_CFG_U1F | UART_CFG_DMA);
    645              HAL_UART_ASSERT( (config->rx.maxBufSize <= 128) );
    646              HAL_UART_ASSERT( (config->rx.maxBufSize > SAFE_RX_MIN) );
    647              cfg->rxBuf = osal_mem_alloc( cfg->rxMax*2 );
    648              osal_memset( cfg->rxBuf, ~DMA_PAD, cfg->rxMax*2 );
    649              DMA_RX( cfg );
    650          #else
    651              cfg->flag = UART_CFG_U1F;
    652              HAL_UART_ASSERT( (config->rx.maxBufSize < 256) );
    653              cfg->rxBuf = osal_mem_alloc( cfg->rxMax+1 );
    654              URX1IE = 1;
    655              IEN2 |= UTX1IE;
    656          #endif
    657          
    658              // 8 bits/char; no parity; 1 stop bit; stop bit hi.
    659              if ( config->flowControl )
    660              {
    661                cfg->flag |= UART_CFG_FLW;
    662                U1UCR = UCR_FLOW | UCR_STOP;
    663                // Must rely on H/W for RTS (i.e. Tx stops when receiver negates CTS.)
    664                P1SEL |= HAL_UART_1_P1_RTS;
    665                // Cannot use H/W for CTS as DMA does not clear the Rx bytes properly.
    666                P1DIR |= HAL_UART_1_P1_CTS;
    667                RX1_FLOW_ON;
    668              }
    669              else
    670              {
    671                U1UCR = UCR_STOP;
    672              }
    673            }
    674          #endif
    675          
    676            return HAL_UART_SUCCESS;
   \                     ??HalUARTOpen_1:
   \   00017D   7900         MOV     R1,#0x0
   \   00017F   7401         MOV     A,#0x1
   \   000181   12....       LCALL   ?DEALLOC_XSTACK8
   \   000184   7F06         MOV     R7,#0x6
   \   000186   02....       LJMP    ?BANKED_LEAVE_XDATA
    677          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 0
   \   000004   85..83       MOV     DPH,?V0 + 1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET
    678          
    679          /******************************************************************************
    680           * @fn      HalUARTClose
    681           *
    682           * @brief   Close the UART
    683           *
    684           * @param   port - UART port
    685           *
    686           * @return  none
    687           *****************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    688          void HalUARTClose( uint8 port )
   \                     HalUARTClose:
    689          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    690          #if HAL_UART_CLOSE
    691            uartCfg_t *cfg;
    692          
    693          #if HAL_UART_0_ENABLE
    694            if ( port == HAL_UART_PORT_0 )
    695            {
    696              U0CSR &= ~CSR_RE;
    697          #if HAL_UART_DMA == 1
    698              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    699              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    700          #else
    701              URX0IE = 0;
    702          #endif
    703              cfg = cfg0;
    704              cfg0 = NULL;
    705            }
    706          #endif
    707          #if HAL_UART_1_ENABLE
    708            if ( port == HAL_UART_PORT_1 )
    709            {
    710              U1CSR &= ~CSR_RE;
    711          #if HAL_UART_DMA == 2
    712              HAL_DMA_ABORT_CH( HAL_DMA_CH_RX );
    713              HAL_DMA_ABORT_CH( HAL_DMA_CH_TX );
    714          #else
    715              URX1IE = 0;
    716          #endif
    717              cfg = cfg1;
    718              cfg1 = NULL;
    719            }
    720          #endif
    721          
    722            if ( cfg )
    723            {
    724              if ( cfg->rxBuf )
    725              {
    726                osal_mem_free( cfg->rxBuf );
    727              }
    728              if ( cfg->txBuf )
    729              {
    730                osal_mem_free( cfg->txBuf );
    731              }
    732              osal_mem_free( cfg );
    733            }
    734          #endif
    735          }
   \   000000   02....       LJMP    ?BRET
    736          
    737          /******************************************************************************
    738           * @fn      HalUARTPoll
    739           *
    740           * @brief   Poll the UART.
    741           *
    742           * @param   none
    743           *
    744           * @return  none
    745           *****************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    746          void HalUARTPoll( void )
   \                     HalUARTPoll:
    747          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    748          #if ( HAL_UART_0_ENABLE | HAL_UART_1_ENABLE )
    749            static uint8 tickShdw;
    750            uartCfg_t *cfg;
    751            uint8 tick;
    752          
    753          #if HAL_UART_0_ENABLE
    754            if ( cfg0 )
   \   000005   90....       MOV     DPTR,#??cfg0
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7002         JNZ     ??HalUARTPoll_0
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \                     ??HalUARTPoll_0:
   \   00000D   600A         JZ      ??HalUARTPoll_1
    755            {
    756              cfg = cfg0;
   \   00000F   90....       MOV     DPTR,#??cfg0
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 1,A
    757            }
    758          #endif
    759          #if HAL_UART_1_ENABLE
    760            if ( cfg1 )
    761            {
    762              cfg = cfg1;
    763            }
    764          #endif
    765          
    766            // Use the LSB of the sleep timer (ST0 must be read first anyway).
    767            tick = ST0 - tickShdw;
   \                     ??HalUARTPoll_1:
   \   000019   90....       MOV     DPTR,#??tickShdw
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FA           MOV     R2,A
   \   00001E   E595         MOV     A,0x95
   \   000020   C3           CLR     C
   \   000021   9A           SUBB    A,R2
   \   000022   FA           MOV     R2,A
    768            tickShdw = ST0;
   \   000023   E595         MOV     A,0x95
   \   000025   F0           MOVX    @DPTR,A
    769          
    770            do
    771            {
    772              if ( cfg->txTick > tick )
   \   000026   E5..         MOV     A,?V0 + 0
   \   000028   240E         ADD     A,#0xe
   \   00002A   F582         MOV     DPL,A
   \   00002C   E5..         MOV     A,?V0 + 1
   \   00002E   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000031   FB           MOV     R3,A
   \   000032   EA           MOV     A,R2
   \   000033   C3           CLR     C
   \   000034   9B           SUBB    A,R3
   \   000035   5005         JNC     ??HalUARTPoll_2
    773              {
    774                cfg->txTick -= tick;
   \   000037   E0           MOVX    A,@DPTR
   \   000038   C3           CLR     C
   \   000039   9A           SUBB    A,R2
   \   00003A   8001         SJMP    ??HalUARTPoll_3
    775              }
    776              else
    777              {
    778                cfg->txTick = 0;
   \                     ??HalUARTPoll_2:
   \   00003C   E4           CLR     A
   \                     ??HalUARTPoll_3:
   \   00003D   12....       LCALL   ?Subroutine14 & 0xFFFF
    779              }
    780          
    781              if ( cfg->rxTick > tick )
   \                     ??CrossCallReturnLabel_51:
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   FB           MOV     R3,A
   \   000045   EA           MOV     A,R2
   \   000046   C3           CLR     C
   \   000047   9B           SUBB    A,R3
   \   000048   5011         JNC     ??HalUARTPoll_4
    782              {
    783                cfg->rxTick -= tick;
   \   00004A   85..82       MOV     DPL,?V0 + 0
   \   00004D   85..83       MOV     DPH,?V0 + 1
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   C3           CLR     C
   \   000058   9A           SUBB    A,R2
   \   000059   800D         SJMP    ??HalUARTPoll_5
    784              }
    785              else
    786              {
    787                cfg->rxTick = 0;
   \                     ??HalUARTPoll_4:
   \   00005B   E4           CLR     A
   \   00005C   85..82       MOV     DPL,?V0 + 0
   \   00005F   85..83       MOV     DPH,?V0 + 1
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \                     ??HalUARTPoll_5:
   \   000068   F0           MOVX    @DPTR,A
    788              }
    789          
    790          #if HAL_UART_ISR
    791          #if HAL_UART_DMA
    792              if ( cfg->flag & UART_CFG_DMA )
    793              {
    794                pollDMA( cfg );
    795              }
    796              else
    797          #endif
    798                {
    799                pollISR( cfg );
    800                }
    801          #elif HAL_UART_DMA
    802              pollDMA( cfg );
   \   000069                ; Setup parameters for call to function pollDMA
   \   000069   AA..         MOV     R2,?V0 + 0
   \   00006B   AB..         MOV     R3,?V0 + 1
   \   00006D   90....       MOV     DPTR,#(??pollDMA & 0xffff)
   \   000070   74..         MOV     A,#((??pollDMA >> 16) & 0xff)
   \   000072   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    803          #endif
    804          
    805              /* The following logic makes continuous callbacks on any eligible flag
    806               * until the condition corresponding to the flag is rectified.
    807               * So even if new data is not received, continuous callbacks are made.
    808               */
    809                if ( cfg->rxHead != cfg->rxTail )
   \   000075   85..82       MOV     DPL,?V0 + 0
   \   000078   85..83       MOV     DPH,?V0 + 1
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   FA           MOV     R2,A
   \   00007F   85..82       MOV     DPL,?V0 + 0
   \   000082   85..83       MOV     DPH,?V0 + 1
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   6A           XRL     A,R2
   \   00008A   7003         JNZ     $+5
   \   00008C   02....       LJMP    ??HalUARTPoll_6 & 0xFFFF
    810                {
    811                uint8 evt;
    812          
    813                if ( cfg->rxHead >= (cfg->rxMax - SAFE_RX_MIN) )
   \   00008F   85..82       MOV     DPL,?V0 + 0
   \   000092   85..83       MOV     DPH,?V0 + 1
   \   000095   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000098   4004         JC      ??HalUARTPoll_7
    814                {
    815                  evt = HAL_UART_RX_FULL;
   \   00009A   7F01         MOV     R7,#0x1
   \   00009C   8045         SJMP    ??HalUARTPoll_8
    816                }
    817                else if ( cfg->rxHigh && (cfg->rxHead >= cfg->rxHigh) )
   \                     ??HalUARTPoll_7:
   \   00009E   85..82       MOV     DPL,?V0 + 0
   \   0000A1   85..83       MOV     DPH,?V0 + 1
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   6024         JZ      ??HalUARTPoll_9
   \   0000AE   85..82       MOV     DPL,?V0 + 0
   \   0000B1   85..83       MOV     DPH,?V0 + 1
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   C0E0         PUSH    A
   \   0000B9   85..82       MOV     DPL,?V0 + 0
   \   0000BC   85..83       MOV     DPH,?V0 + 1
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   FA           MOV     R2,A
   \   0000C8   D0E0         POP     A
   \   0000CA   C3           CLR     C
   \   0000CB   9A           SUBB    A,R2
   \   0000CC   4004         JC      ??HalUARTPoll_9
    818                {
    819                  evt = HAL_UART_RX_ABOUT_FULL;
   \   0000CE   7F02         MOV     R7,#0x2
   \   0000D0   8011         SJMP    ??HalUARTPoll_8
    820              }
    821                else if ( cfg->rxTick == 0 )
   \                     ??HalUARTPoll_9:
   \   0000D2   85..82       MOV     DPL,?V0 + 0
   \   0000D5   85..83       MOV     DPH,?V0 + 1
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   703E         JNZ     ??HalUARTPoll_6
    822              {
    823                  evt = HAL_UART_RX_TIMEOUT;
   \   0000E1   7F04         MOV     R7,#0x4
   \                     ??HalUARTPoll_8:
   \   0000E3   E5..         MOV     A,?V0 + 0
   \   0000E5   2410         ADD     A,#0x10
   \   0000E7   F582         MOV     DPL,A
   \   0000E9   E5..         MOV     A,?V0 + 1
   \   0000EB   12....       LCALL   ??Subroutine3_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   FD           MOV     R5,A
   \   0000F1   A3           INC     DPTR
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   FE           MOV     R6,A
   \   0000F4   EC           MOV     A,R4
   \   0000F5   4D           ORL     A,R5
   \   0000F6   4E           ORL     A,R6
   \   0000F7   6026         JZ      ??HalUARTPoll_6
    824              }
    825              else
    826              {
    827                  evt = 0;
    828              }
    829          
    830              if ( evt && cfg->rxCB )
    831              {
    832                  cfg->rxCB( ((cfg->flag & UART_CFG_U1F)!=0), evt );
   \   0000F9                ; Setup parameters for indirect call
   \   0000F9   EF           MOV     A,R7
   \   0000FA   FA           MOV     R2,A
   \   0000FB   E5..         MOV     A,?V0 + 0
   \   0000FD   240F         ADD     A,#0xf
   \   0000FF   F582         MOV     DPL,A
   \   000101   E5..         MOV     A,?V0 + 1
   \   000103   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000106   E4           CLR     A
   \   000107   92E0         MOV     0xE0 /* A   */.0,C
   \   000109   F9           MOV     R1,A
   \   00010A   E5..         MOV     A,?V0 + 0
   \   00010C   2410         ADD     A,#0x10
   \   00010E   F582         MOV     DPL,A
   \   000110   E5..         MOV     A,?V0 + 1
   \   000112   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000115   A3           INC     DPTR
   \   000116   A3           INC     DPTR
   \   000117   E0           MOVX    A,@DPTR
   \   000118   8C82         MOV     DPL,R4
   \   00011A   8D83         MOV     DPH,R5
   \   00011C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    833              }
    834              }
    835          
    836          #if HAL_UART_0_ENABLE
    837              if ( cfg == cfg0 )
    838              {
    839          #if HAL_UART_1_ENABLE
    840                if ( cfg1 )
    841                {
    842                  cfg = cfg1;
    843                }
    844                else
    845          #endif
    846                  break;
    847              }
    848              else
    849          #endif
    850                break;
    851          
    852            } while ( TRUE );
    853          #else
    854            return;
    855          #endif
    856          }
   \                     ??HalUARTPoll_6:
   \   00011F   02....       LJMP    ?Subroutine19 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E8           MOV     A,R0
   \   000001   240C         ADD     A,#0xc
   \                     ??Subroutine3_0:
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \                     ??Subroutine3_1:
   \   000006   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000009   FC           MOV     R4,A
   \   00000A   22           RET

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
   \                     ??tickShdw:
   \   000000                DS 1
    857          
    858          /**************************************************************************************************
    859           * @fn      Hal_UART_RxBufLen()
    860           *
    861           * @brief   Calculate Rx Buffer length - the number of bytes in the buffer.
    862           *
    863           * @param   port - UART port
    864           *
    865           * @return  length of current Rx Buffer
    866           **************************************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    867          uint16 Hal_UART_RxBufLen( uint8 port )
   \                     Hal_UART_RxBufLen:
    868          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
    869            uartCfg_t *cfg = NULL;
   \   000005   7800         MOV     R0,#0x0
   \   000007   7900         MOV     R1,#0x0
    870          
    871          #if HAL_UART_0_ENABLE
    872            if ( port == HAL_UART_PORT_0 )
   \   000009   7008         JNZ     ??Hal_UART_RxBufLen_0
    873            {
    874              cfg = cfg0;
   \   00000B   90....       MOV     DPTR,#??cfg0
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
    875            }
    876          #endif
    877          #if HAL_UART_1_ENABLE
    878            if ( port == HAL_UART_PORT_1 )
    879            {
    880              cfg = cfg1;
    881            }
    882          #endif
    883          
    884            HAL_UART_ASSERT( cfg );
    885          
    886            return UART_RX_AVAIL( cfg );
   \                     ??Hal_UART_RxBufLen_0:
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   C0E0         PUSH    A
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FA           MOV     R2,A
   \   000025   D0E0         POP     A
   \   000027   C3           CLR     C
   \   000028   9A           SUBB    A,R2
   \   000029   8882         MOV     DPL,R0
   \   00002B   8983         MOV     DPH,R1
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   400D         JC      ??Hal_UART_RxBufLen_1
   \   000031   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000034   F8           MOV     R0,A
   \   000035   EA           MOV     A,R2
   \   000036   C3           CLR     C
   \   000037   98           SUBB    A,R0
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   9400         SUBB    A,#0x0
   \   00003C   8020         SJMP    ??Hal_UART_RxBufLen_2
   \                     ??Hal_UART_RxBufLen_1:
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000043   FC           MOV     R4,A
   \   000044   EA           MOV     A,R2
   \   000045   C3           CLR     C
   \   000046   9C           SUBB    A,R4
   \   000047   FA           MOV     R2,A
   \   000048   E4           CLR     A
   \   000049   9400         SUBB    A,#0x0
   \   00004B   FB           MOV     R3,A
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   2A           ADD     A,R2
   \   000054   F8           MOV     R0,A
   \   000055   E4           CLR     A
   \   000056   3B           ADDC    A,R3
   \   000057   F9           MOV     R1,A
   \   000058   7401         MOV     A,#0x1
   \   00005A   28           ADD     A,R0
   \   00005B   FA           MOV     R2,A
   \   00005C   E4           CLR     A
   \   00005D   39           ADDC    A,R1
   \                     ??Hal_UART_RxBufLen_2:
   \   00005E   FB           MOV     R3,A
   \   00005F   02....       LJMP    ?Subroutine21 & 0xFFFF
    887          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   8882         MOV     DPL,R0
   \   000004   8983         MOV     DPH,R1
   \   000006   02....       LJMP    ?Subroutine20 & 0xFFFF
    888          
    889          /*****************************************************************************
    890           * @fn      HalUARTRead
    891           *
    892           * @brief   Read a buffer from the UART
    893           *
    894           * @param   port - USART module designation
    895           *          buf  - valid data buffer at least 'len' bytes in size
    896           *          len  - max length number of bytes to copy to 'buf'
    897           *
    898           * @return  length of buffer that was read
    899           *****************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    900          uint16 HalUARTRead( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTRead:
    901          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    902            uartCfg_t *cfg = NULL;
   \   000006   7800         MOV     R0,#0x0
   \   000008   7900         MOV     R1,#0x0
    903            uint8 cnt = 0;
   \   00000A   88..         MOV     ?V0 + 2,R0
    904          
    905          #if HAL_UART_0_ENABLE
    906            if ( port == HAL_UART_PORT_0 )
   \   00000C   7016         JNZ     ??HalUARTRead_0
    907            {
    908              cfg = cfg0;
   \   00000E   90....       MOV     DPTR,#??cfg0
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   800C         SJMP    ??HalUARTRead_0
    909            }
    910          #endif
    911          #if HAL_UART_1_ENABLE
    912            if ( port == HAL_UART_PORT_1 )
    913            {
    914              cfg = cfg1;
    915            }
    916          #endif
    917          
    918            HAL_UART_ASSERT( cfg );
    919          
    920            while ( (cfg->rxTail != cfg->rxHead) && (cnt < len) )
    921            {
    922              *buf++ = cfg->rxBuf[cfg->rxTail];
    923              if ( cfg->rxTail == cfg->rxMax )
    924              {
    925                cfg->rxTail = 0;
    926              }
    927              else
    928              {
    929                cfg->rxTail++;
   \                     ??HalUARTRead_1:
   \   000018   8882         MOV     DPL,R0
   \   00001A   8983         MOV     DPH,R1
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   04           INC     A
   \                     ??HalUARTRead_2:
   \   000021   F0           MOVX    @DPTR,A
    930              }
    931              cnt++;
   \   000022   05..         INC     ?V0 + 2
   \                     ??HalUARTRead_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6E           XRL     A,R6
   \   000030   604E         JZ      ??HalUARTRead_3
   \   000032   85....       MOV     ?V0 + 0,?V0 + 2
   \   000035   C3           CLR     C
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   9C           SUBB    A,R4
   \   000039   E4           CLR     A
   \   00003A   9D           SUBB    A,R5
   \   00003B   5043         JNC     ??HalUARTRead_3
   \   00003D   E8           MOV     A,R0
   \   00003E   2403         ADD     A,#0x3
   \   000040   FE           MOV     R6,A
   \   000041   E9           MOV     A,R1
   \   000042   3400         ADDC    A,#0x0
   \   000044   FF           MOV     R7,A
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5..         MOV     ?V0 + 0,A
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   E0           MOVX    A,@DPTR
   \   000051   25..         ADD     A,?V0 + 0
   \   000053   F5..         MOV     ?V0 + 3,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   3400         ADDC    A,#0x0
   \   000059   85..82       MOV     DPL,?V0 + 3
   \   00005C   F583         MOV     DPH,A
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   8A82         MOV     DPL,R2
   \   000061   8B83         MOV     DPH,R3
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   AA82         MOV     R2,DPL
   \   000067   AB83         MOV     R3,DPH
   \   000069   8E82         MOV     DPL,R6
   \   00006B   8F83         MOV     DPH,R7
   \   00006D   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   6E           XRL     A,R6
   \   000074   70A2         JNZ     ??HalUARTRead_1
   \   000076   E4           CLR     A
   \   000077   8882         MOV     DPL,R0
   \   000079   8983         MOV     DPH,R1
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   80A1         SJMP    ??HalUARTRead_2
    932            }
    933          
    934          #if HAL_UART_DMA
    935            #if HAL_UART_ISR
    936            if ( cfg->flag & UART_CFG_DMA )
    937            #endif
    938            {
    939              /* If there is no flow control on a DMA-driven UART, the Rx Head & Tail
    940               * pointers must be reset to zero after every read in order to preserve the
    941               * full length of the Rx buffer. This implies that every Read must read all
    942               * of the Rx bytes available, or the pointers will not be reset and the
    943               * next incoming packet may not fit in the Rx buffer space remaining - thus
    944               * the end portion of the incoming packet that does not fit would be lost.
    945               */
    946              if ( !(cfg->flag & UART_CFG_FLW) )
   \                     ??HalUARTRead_3:
   \   000080   E8           MOV     A,R0
   \   000081   240F         ADD     A,#0xf
   \   000083   F582         MOV     DPL,A
   \   000085   E9           MOV     A,R1
   \   000086   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000089   A2E5         MOV     C,0xE0 /* A   */.5
   \   00008B   4003         JC      ??HalUARTRead_4
    947              {
    948                // This is a trick to trigger the DMA abort and restart logic in pollDMA.
    949                cfg->flag |= UART_CFG_RXF;
   \   00008D   D2E1         SETB    0xE0 /* A   */.1
   \   00008F   F0           MOVX    @DPTR,A
    950              }
    951            }
    952          #endif
    953          
    954          #if HAL_UART_ISR
    955            #if HAL_UART_DMA
    956            if ( !(cfg->flag & UART_CFG_DMA) )
    957            #endif
    958            {
    959              cfg->rxCnt = UART_RX_AVAIL( cfg );
    960          
    961              if ( cfg->flag & UART_CFG_RXF )
    962              {
    963                if ( cfg->rxCnt < (cfg->rxMax - SAFE_RX_MIN) )
    964                {
    965                  RX_STRT_FLOW( cfg );
    966                }
    967              }
    968            }
    969          #endif
    970          
    971            return cnt;
   \                     ??HalUARTRead_4:
   \   000090   AA..         MOV     R2,?V0 + 2
   \   000092   7B00         MOV     R3,#0x0
   \   000094                REQUIRE ?Subroutine22
   \   000094                ; // Fall through to label ?Subroutine22
    972          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   8882         MOV     DPL,R0
   \   000004   8983         MOV     DPH,R1
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   22           RET
    973          
    974          /******************************************************************************
    975           * @fn      HalUARTWrite
    976           *
    977           * @brief   Write a buffer to the UART.
    978           *
    979           * @param   port    - UART port
    980           *          pBuffer - pointer to the buffer that will be written, not freed
    981           *          length  - length of
    982           *
    983           * @return  length of the buffer that was sent
    984           *****************************************************************************/

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    985          uint16 HalUARTWrite( uint8 port, uint8 *buf, uint16 len )
   \                     HalUARTWrite:
    986          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   EC           MOV     A,R4
   \   00000C   FA           MOV     R2,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FB           MOV     R3,A
    987            uartCfg_t *cfg = NULL;
   \   00000F   7800         MOV     R0,#0x0
   \   000011   7900         MOV     R1,#0x0
    988            uint8 cnt;
    989          
    990          #if HAL_UART_0_ENABLE
    991            if ( port == HAL_UART_PORT_0 )
   \   000013   E5..         MOV     A,?V0 + 0
   \   000015   7008         JNZ     ??HalUARTWrite_0
    992            {
    993              cfg = cfg0;
   \   000017   90....       MOV     DPTR,#??cfg0
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
    994            }
    995          #endif
    996          #if HAL_UART_1_ENABLE
    997            if ( port == HAL_UART_PORT_1 )
    998            {
    999              cfg = cfg1;
   1000            }
   1001          #endif
   1002          
   1003            HAL_UART_ASSERT( cfg );
   1004          
   1005            if ( cfg->txHead == cfg->txTail )
   \                     ??HalUARTWrite_0:
   \   00001F   8882         MOV     DPL,R0
   \   000021   8983         MOV     DPH,R1
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   FC           MOV     R4,A
   \   00002F   E8           MOV     A,R0
   \   000030   240B         ADD     A,#0xb
   \   000032   F582         MOV     DPL,A
   \   000034   E9           MOV     A,R1
   \   000035   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   000038   6C           XRL     A,R4
   \   000039   701E         JNZ     ??HalUARTWrite_1
   1006            {
   1007          #if HAL_UART_DMA
   1008              // When pointers are equal, reset to zero to get max len w/out wrapping.
   1009              cfg->txHead = cfg->txTail = 0;
   \   00003B   E4           CLR     A
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00004F   74FF         MOV     A,#-0x1
   \   000051   2C           ADD     A,R4
   \   000052   1C           DEC     R4
   \   000053   74FF         MOV     A,#-0x1
   \   000055   3400         ADDC    A,#0x0
   \   000057   803B         SJMP    ??HalUARTWrite_2
   1010          #endif
   1011          #if HAL_UART_ISR
   1012          #if HAL_UART_DMA
   1013              if ( !(cfg->flag & UART_CFG_DMA) )
   1014          #endif
   1015              {
   1016                cfg->flag &= ~UART_CFG_TXF;
   1017              }
   1018          #endif
   1019            }
   1020          
   1021            // Accept "all-or-none" on write request.
   1022            if ( TX_AVAIL( cfg ) < len )
   \                     ??HalUARTWrite_1:
   \   000059   8882         MOV     DPL,R0
   \   00005B   8983         MOV     DPH,R1
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   C0E0         PUSH    A
   \   00006A   E8           MOV     A,R0
   \   00006B   240B         ADD     A,#0xb
   \   00006D   12....       LCALL   ??Subroutine3_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000070   D0E0         POP     A
   \   000072   C3           CLR     C
   \   000073   9C           SUBB    A,R4
   \   000074   500B         JNC     ??HalUARTWrite_3
   \   000076   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000079   74FF         MOV     A,#-0x1
   \   00007B   2C           ADD     A,R4
   \   00007C   1C           DEC     R4
   \   00007D   74FF         MOV     A,#-0x1
   \   00007F   8012         SJMP    ??HalUARTWrite_4
   \                     ??HalUARTWrite_3:
   \   000081   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000084   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000087   E8           MOV     A,R0
   \   000088   240B         ADD     A,#0xb
   \   00008A   F582         MOV     DPL,A
   \   00008C   E9           MOV     A,R1
   \   00008D   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000090   2C           ADD     A,R4
   \   000091   FC           MOV     R4,A
   \   000092   E4           CLR     A
   \                     ??HalUARTWrite_4:
   \   000093   3D           ADDC    A,R5
   \                     ??HalUARTWrite_2:
   \   000094   FD           MOV     R5,A
   \   000095   C3           CLR     C
   \   000096   EC           MOV     A,R4
   \   000097   9A           SUBB    A,R2
   \   000098   ED           MOV     A,R5
   \   000099   9B           SUBB    A,R3
   \   00009A   5006         JNC     ??HalUARTWrite_5
   1023            {
   1024              return 0;
   \   00009C   7A00         MOV     R2,#0x0
   \   00009E   7B00         MOV     R3,#0x0
   \   0000A0   8078         SJMP    ??HalUARTWrite_6
   1025            }
   1026          
   1027            for ( cnt = len; cnt; cnt-- )
   \                     ??HalUARTWrite_5:
   \   0000A2   EA           MOV     A,R2
   \   0000A3   F5..         MOV     ?V0 + 3,A
   \   0000A5   8013         SJMP    ??HalUARTWrite_7
   1028            {
   1029              cfg->txBuf[ cfg->txHead ] = *buf++;
   1030          
   1031              if ( cfg->txHead == cfg->txMax )
   1032              {
   1033                cfg->txHead = 0;
   1034              }
   1035              else
   1036              {
   1037                cfg->txHead++;
   \                     ??HalUARTWrite_8:
   \   0000A7   8882         MOV     DPL,R0
   \   0000A9   8983         MOV     DPH,R1
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   04           INC     A
   \                     ??HalUARTWrite_9:
   \   0000B7   F0           MOVX    @DPTR,A
   1038              }
   \   0000B8   15..         DEC     ?V0 + 3
   \                     ??HalUARTWrite_7:
   \   0000BA   E5..         MOV     A,?V0 + 3
   \   0000BC   605C         JZ      ??HalUARTWrite_6
   \   0000BE   E8           MOV     A,R0
   \   0000BF   240A         ADD     A,#0xa
   \   0000C1   FC           MOV     R4,A
   \   0000C2   E9           MOV     A,R1
   \   0000C3   3400         ADDC    A,#0x0
   \   0000C5   FD           MOV     R5,A
   \   0000C6   8E82         MOV     DPL,R6
   \   0000C8   8F83         MOV     DPH,R7
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   C0E0         PUSH    A
   \   0000CD   8C82         MOV     DPL,R4
   \   0000CF   8D83         MOV     DPH,R5
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   F5..         MOV     ?V0 + 0,A
   \   0000D4   8882         MOV     DPL,R0
   \   0000D6   8983         MOV     DPH,R1
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   25..         ADD     A,?V0 + 0
   \   0000E3   F5..         MOV     ?V0 + 2,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   3400         ADDC    A,#0x0
   \   0000E9   85..82       MOV     DPL,?V0 + 2
   \   0000EC   F583         MOV     DPH,A
   \   0000EE   D0E0         POP     A
   \   0000F0   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000F3   AE82         MOV     R6,DPL
   \   0000F5   AF83         MOV     R7,DPH
   \   0000F7   8C82         MOV     DPL,R4
   \   0000F9   8D83         MOV     DPH,R5
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   FC           MOV     R4,A
   \   0000FD   E8           MOV     A,R0
   \   0000FE   240C         ADD     A,#0xc
   \   000100   F582         MOV     DPL,A
   \   000102   E9           MOV     A,R1
   \   000103   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000106   6C           XRL     A,R4
   \   000107   709E         JNZ     ??HalUARTWrite_8
   \   000109   E4           CLR     A
   \   00010A   8882         MOV     DPL,R0
   \   00010C   8983         MOV     DPH,R1
   \   00010E   A3           INC     DPTR
   \   00010F   A3           INC     DPTR
   \   000110   A3           INC     DPTR
   \   000111   A3           INC     DPTR
   \   000112   A3           INC     DPTR
   \   000113   A3           INC     DPTR
   \   000114   A3           INC     DPTR
   \   000115   A3           INC     DPTR
   \   000116   A3           INC     DPTR
   \   000117   A3           INC     DPTR
   \   000118   809D         SJMP    ??HalUARTWrite_9
   1039            }
   1040          
   1041          #if HAL_UART_ISR
   1042          #if HAL_UART_DMA
   1043            if ( !(cfg->flag & UART_CFG_DMA) )
   1044          #endif
   1045            {
   1046              if ( !(cfg->flag & UART_CFG_TXF) && len )
   1047              {
   1048                cfg->flag |= UART_CFG_TXF;
   1049                if ( !(cfg->flag & UART_CFG_U1F) )
   1050                {
   1051                  U0DBUF = cfg->txBuf[cfg->txTail];
   1052                }
   1053                else
   1054                {
   1055                  U1DBUF = cfg->txBuf[cfg->txTail];
   1056                }
   1057              }
   1058            }
   1059          #endif
   1060          
   1061            return len;
   \                     ??HalUARTWrite_6:
   \   00011A   02....       LJMP    ?Subroutine22 & 0xFFFF
   1062          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   EC           MOV     A,R4
   \   000012   C3           CLR     C
   \   000013   95..         SUBB    A,?V0 + 0
   \   000015   FC           MOV     R4,A
   \   000016   E4           CLR     A
   \   000017   9400         SUBB    A,#0x0
   \   000019   FD           MOV     R5,A
   \   00001A   22           RET

   \                                 In segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1
   1063          
   1064          #if HAL_UART_ISR
   1065          /***************************************************************************************************
   1066           * @fn      halUart0RxIsr
   1067           *
   1068           * @brief   UART0 Receive Interrupt
   1069           *
   1070           * @param   None
   1071           *
   1072           * @return  None
   1073           ***************************************************************************************************/
   1074          #if HAL_UART_0_ENABLE
   1075          HAL_ISR_FUNCTION( halUart0RxIsr, URX0_VECTOR )
   1076          {
   1077            cfg0->rxBuf[cfg0->rxHead] = U0DBUF;
   1078          
   1079            if ( cfg0->rxHead == cfg0->rxMax )
   1080            {
   1081              cfg0->rxHead = 0;
   1082            }
   1083            else
   1084            {
   1085              cfg0->rxHead++;
   1086            }
   1087          }
   1088          #endif
   1089          
   1090          /***************************************************************************************************
   1091           * @fn      halUart1RxIsr
   1092           *
   1093           * @brief   UART1 Receive Interrupt
   1094           *
   1095           * @param   None
   1096           *
   1097           * @return  None
   1098           ***************************************************************************************************/
   1099          #if HAL_UART_1_ENABLE
   1100          HAL_ISR_FUNCTION( halUart1RxIsr, URX1_VECTOR )
   1101          {
   1102            cfg1->rxBuf[cfg1->rxHead] = U1DBUF;
   1103          
   1104            if ( cfg1->rxHead == cfg1->rxMax )
   1105            {
   1106              cfg1->rxHead = 0;
   1107            }
   1108            else
   1109            {
   1110              cfg1->rxHead++;
   1111            }
   1112          }
   1113          #endif
   1114          
   1115          /***************************************************************************************************
   1116           * @fn      halUart0TxIsr
   1117           *
   1118           * @brief   UART0 Transmit Interrupt
   1119           *
   1120           * @param   None
   1121           *
   1122           * @return  None
   1123           ***************************************************************************************************/
   1124          #if HAL_UART_0_ENABLE
   1125          HAL_ISR_FUNCTION( halUart0TxIsr, UTX0_VECTOR )
   1126          {
   1127            UTX0IF = 0;
   1128          
   1129            if ( cfg0->txTail == cfg0->txMax )
   1130            {
   1131              cfg0->txTail = 0;
   1132            }
   1133            else
   1134            {
   1135              cfg0->txTail++;
   1136            }
   1137          
   1138            if ( cfg0->txTail != cfg0->txHead )
   1139            {
   1140              U0DBUF = cfg0->txBuf[cfg0->txTail];
   1141            }
   1142          }
   1143          #endif
   1144          
   1145          /***************************************************************************************************
   1146           * @fn      halUart1TxIsr
   1147           *
   1148           * @brief   UART1 Transmit Interrupt
   1149           *
   1150           * @param   None
   1151           *
   1152           * @return  None
   1153           ***************************************************************************************************/
   1154          #if HAL_UART_1_ENABLE
   1155          HAL_ISR_FUNCTION( halUart1TxIsr, UTX1_VECTOR )
   1156          {
   1157            UTX1IF = 0;
   1158            U1CSR &= ~CSR_TX_BYTE;  // Rev-D does not require, older does.
   1159          
   1160            if ( cfg1->txTail == cfg1->txMax )
   1161            {
   1162              cfg1->txTail = 0;
   1163            }
   1164            else
   1165            {
   1166              cfg1->txTail++;
   1167            }
   1168          
   1169            if ( cfg1->txTail != cfg1->txHead )
   1170            {
   1171              U1DBUF = cfg1->txBuf[cfg1->txTail];
   1172            }
   1173          }
   1174          #endif
   1175          #endif
   1176          
   1177          /******************************************************************************
   1178          ******************************************************************************/

   Maximum stack usage in bytes:

     Function            ISTACK PSTACK XSTACK
     --------            ------ ------ ------
     HalUARTClose            0      0      0
     HalUARTInit             2      0      0
     HalUARTOpen             1      0     15
       -> osal_mem_alloc     0      0     30
       -> osal_mem_alloc     0      0     30
       -> osal_mem_alloc     0      0     30
       -> osal_memset        0      0     30
     HalUARTPoll             1      0     10
       -> pollDMA            0      0     20
     HalUARTRead             1      0     12
     HalUARTWrite            1      0     12
     Hal_UART_RxBufLen       3      0      0
     pollDMA                 1      0     21
       -> osal_memset        0      0     22


   Segment part sizes:

     Function/Label    Bytes
     --------------    -----
     U0CSR                1
     ST0                  1
     U0DBUF               1
     U0BAUD               1
     U0UCR                1
     U0GCR                1
     DMAIRQ               1
     DMAARM               1
     DMAREQ               1
     PERCFG               1
     ADCCFG               1
     P0SEL                1
     P0DIR                1
     P2DIR                1
     cfg0                 2
     pollDMA            551
     ?Subroutine19        5
     ?Subroutine7         8
     ?Subroutine6        11
     ?Subroutine4        12
     ?Subroutine2        11
     ?Subroutine0        16
     ?Subroutine20        5
     ?Subroutine16       10
     ?Subroutine15       15
     ?Subroutine11       12
     ?Subroutine9        26
     ?Subroutine17        7
     ?Subroutine8        19
     ?Subroutine1        26
     ?Subroutine5        10
     ?Subroutine18        6
     HalUARTInit         93
     ?Subroutine21        7
     HalUARTOpen        393
     ?Subroutine14       11
     HalUARTClose         3
     HalUARTPoll        290
     ?Subroutine3        11
     tickShdw             1
     Hal_UART_RxBufLen   98
     ?Subroutine12        9
     HalUARTRead        148
     ?Subroutine22        5
     ?Subroutine13        9
     HalUARTWrite       285
     ?Subroutine10       27
     _A_P0                1
     _A_P1                1

 
 2 139 bytes in segment BANKED_CODE
    16 bytes in segment SFR_AN
     3 bytes in segment XDATA_Z
 
 2 139 bytes of CODE  memory
     0 bytes of DATA  memory (+ 16 bytes shared)
     3 bytes of XDATA memory

Errors: none
Warnings: none
