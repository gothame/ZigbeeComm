//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR 8051 C/C++ Compiler V7.20H/W32                  17/Oct/2013  21:52:40 /
// Copyright 2004-2006 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Core               =  plain                                            /
//    Code model         =  banked                                           /
//    Data model         =  large                                            /
//    Calling convention =  xdata reentrant                                  /
//    Constant location  =  data                                             /
//    Dptr setup         =  1,16                                             /
//    Source file        =  D:\Texas Instruments\ZStack-1.4.2-1.1.0\Componen /
//                          ts\mac\low_level\srf03\single_chip\mac_csp_tx.c  /
//    Command line       =  -f E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ /
//                          ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples /
//                          \SampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wE /
//                          ndev.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR            /
//                          -DROOT=__near_func -DMAC_OPT_FFD=0 -DBLINK_LEDS  /
//                          "-DCONST=const __code" -DGENERIC=__generic) -f   /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wConf /
//                          ig.cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x00000800 /
//                           -DZDAPP_CONFIG_PAN_ID=0xFFFF                    /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_ /
//                          MASK=0x007F -DBEACON_REQUEST_DELAY=100           /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                   /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_ /
//                          POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7         /
//                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3 /
//                           -DNWK_MAX_DATA_RETRIES=2                        /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9       /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20         /
//                          -DNWK_MAX_BINDING_ENTRIES=10                     /
//                          -DMAX_BINDING_CLUSTER_IDS=5                      /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,    /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,  /
//                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE    /
//                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100          /
//                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440  /
//                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR     /
//                          Systems\Embedded Workbench 4.05 Evaluation       /
//                          version\8051\inc\" -I "D:\Program Files\IAR      /
//                          Systems\Embedded Workbench 4.05 Evaluation       /
//                          version\8051\inc\clib\" -I                       /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430 /
//                          Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Proje /
//                          cts\zstack\Samples\SampleApp\CC2430DB\..\Source\ /
//                           -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® /
//                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample /
//                          s\SampleApp\CC2430DB\..\..\..\ZMain\TI2430DB\    /
//                          -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ /
//                          ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples /
//                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mt /
//                          \ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´ /
//                          ®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sampl /
//                          es\SampleApp\CC2430DB\..\..\..\..\..\Components\ /
//                          hal\include\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ /
//                          ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\z /
//                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\ /
//                          Components\hal\target\CC2430EB\ -I               /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\..\..\..\..\..\Components\osal\ /
//                          mcu\ccsoc\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì /
//                          ¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zst /
//                          ack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Co /
//                          mponents\osal\include\ -I                        /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\..\..\..\..\..\Components\stack /
//                          \af\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC24 /
//                          30´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sa /
//                          mples\SampleApp\CC2430DB\..\..\..\..\..\Componen /
//                          ts\stack\nwk\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶ /
//                          Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\ /
//                          zstack\Samples\SampleApp\CC2430DB\..\..\..\..\.. /
//                          \Components\stack\sec\ -I                        /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\..\..\..\..\..\Components\stack /
//                          \sys\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2 /
//                          430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S /
//                          amples\SampleApp\CC2430DB\..\..\..\..\..\Compone /
//                          nts\stack\zdo\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ /
//                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects /
//                          \zstack\Samples\SampleApp\CC2430DB\..\..\..\..\. /
//                          .\Components\zmac\f8w\ -I                        /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\..\..\..\..\..\Components\zmac\ /
//                           -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´® /
//                          ¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sample /
//                          s\SampleApp\CC2430DB\..\..\..\..\..\Components\s /
//                          ervices\saddr\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ /
//                          ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects /
//                          \zstack\Samples\SampleApp\CC2430DB\..\..\..\..\. /
//                          .\Components\services\sdata\ -I                  /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\..\..\..\..\..\Components\mac\i /
//                          nclude\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\C /
//                          C2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack /
//                          \Samples\SampleApp\CC2430DB\..\..\..\..\..\Compo /
//                          nents\mac\high_level\ -I                         /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\..\..\..\..\..\Components\mac\l /
//                          ow_level\srf03\ -I E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨ /
//                          Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Project /
//                          s\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\ /
//                          ..\Components\mac\low_level\srf03\single_chip\   /
//                          -D CC2430EB -D NWK_AUTO_POLL -D ZTOOL_P1 -D      /
//                          MT_TASK -D ZG_ENDDEVICE -lC                      /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\EndDeviceEB\List\ -lA           /
//                          E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\EndDeviceEB\List\               /
//                          --diag_suppress Pe001,Pa010 --diag_remark pe550  /
//                          -o E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ /
//                          ÚÊÕ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples /
//                          \SampleApp\CC2430DB\EndDeviceEB\Obj\ -e          /
//                          --require_prototypes -z9 --no_code_motion        /
//                          --debug --core=plain --dptr=16,1                 /
//                          --data_model=large --code_model=banked           /
//                          --calling_convention=xdata_reentrant             /
//                          --place_constants=data --nr_virtual_regs 8       /
//                          "D:\Texas Instruments\ZStack-1.4.2-1.1.0\Compone /
//                          nts\mac\low_level\srf03\single_chip\mac_csp_tx.c /
//                          "                                                /
//    List file          =  E:\CPESÆ½Ì¨\Ó²¼þÆ½Ì¨\CC2430Í¨Ñ¶Æ½Ì¨\CC2430´®¿ÚÊÕ /
//                          ·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples\Sa /
//                          mpleApp\CC2430DB\EndDeviceEB\List\mac_csp_tx.s51 /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME mac_csp_tx

        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BCALL
        EXTERN ?BRET
        EXTERN ?S_DIV_MOD
        EXTERN ?V0

        FUNCTION ??cspPrepForTxProgram,021203H
        ARGFRAME ISTACK, 2, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBWEAK RFIM
        PUBWEAK RFST
        PUBWEAK T2CMP
        PUBWEAK T2OF0
        PUBWEAK T2THD
        PUBWEAK T2TLD
        PUBWEAK _A_IEN0
        PUBLIC macCspForceTxDoneIfPending
        FUNCTION macCspForceTxDoneIfPending,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxCancelAckTimeoutCallback
        FUNCTION macCspTxCancelAckTimeoutCallback,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxGoCsma
        FUNCTION macCspTxGoCsma,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxGoSlotted
        FUNCTION macCspTxGoSlotted,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxIntIsr
        FUNCTION macCspTxIntIsr,021203H
        ARGFRAME ISTACK, 2, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxPrepCsmaSlotted
        FUNCTION macCspTxPrepCsmaSlotted,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxPrepCsmaUnslotted
        FUNCTION macCspTxPrepCsmaUnslotted,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxPrepSlotted
        FUNCTION macCspTxPrepSlotted,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxRequestAckTimeoutCallback
        FUNCTION macCspTxRequestAckTimeoutCallback,021203H
        LOCFRAME XSTACK, 12, STACK
        PUBLIC macCspTxReset
        FUNCTION macCspTxReset,021203H
        LOCFRAME ISTACK, 2, STACK
        PUBLIC macCspTxStopIsr
        FUNCTION macCspTxStopIsr,021203H
        LOCFRAME ISTACK, 2, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP DATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource SP:8, PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        EXTERN macMcuAndRFIM
        FUNCTION macMcuAndRFIM,0202H
        ARGFRAME ISTACK, 2, STACK
        EXTERN halAssertHandler
        FUNCTION halAssertHandler,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME XSTACK, 12, STACK
        EXTERN macMcuWriteRFIF
        FUNCTION macMcuWriteRFIF,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME XSTACK, 12, STACK
        EXTERN macMcuOrRFIM
        FUNCTION macMcuOrRFIM,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME XSTACK, 12, STACK
        EXTERN macRxOn
        FUNCTION macRxOn,0202H
        ARGFRAME ISTACK, 2, STACK
        EXTERN macTxDoneCallback
        FUNCTION macTxDoneCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        EXTERN macRxHaltCleanup
        FUNCTION macRxHaltCleanup,0202H
        ARGFRAME ISTACK, 2, STACK
        EXTERN macTxTimestampCallback
        FUNCTION macTxTimestampCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        EXTERN macTxChannelBusyCallback
        FUNCTION macTxChannelBusyCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        EXTERN macTxAckNotReceivedCallback
        FUNCTION macTxAckNotReceivedCallback,0202H
        ARGFRAME ISTACK, 2, STACK
        EXTERN macPib
        EXTERN macRxOnFlag
        EXTERN macTxCsmaBackoffDelay

// D:\Texas Instruments\ZStack-1.4.2-1.1.0\Components\mac\low_level\srf03\single_chip\mac_csp_tx.c
//    1 /**************************************************************************************************
//    2     Filename:
//    3     Revised:        $Date: 2007-03-28 18:21:19 -0700 (Wed, 28 Mar 2007) $
//    4     Revision:       $Revision: 13888 $
//    5 
//    6     Description:
//    7 
//    8     Describe the purpose and contents of the file.
//    9 
//   10     Copyright (c) 2006 by Texas Instruments, Inc.
//   11     All Rights Reserved.  Permission to use, reproduce, copy, prepare
//   12     derivative works, modify, distribute, perform, display or sell this
//   13     software and/or its documentation for any purpose is prohibited
//   14     without the express written consent of Texas Instruments, Inc.
//   15 **************************************************************************************************/
//   16 
//   17 
//   18 
//   19 /* ------------------------------------------------------------------------------------------------
//   20  *                                           Includes
//   21  * ------------------------------------------------------------------------------------------------
//   22  */
//   23 
//   24 /* hal */
//   25 #include "hal_types.h"
//   26 #include "hal_mcu.h"

        ASEGN SFR_AN:DATA:NOROOT,091H
// unsigned char volatile __sfr RFIM
RFIM:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,094H
// unsigned char volatile __sfr T2CMP
T2CMP:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a1H
// unsigned char volatile __sfr T2OF0
T2OF0:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a6H
// unsigned char volatile __sfr T2TLD
T2TLD:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0a7H
// unsigned char volatile __sfr T2THD
T2THD:
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e1H
// unsigned char volatile __sfr RFST
RFST:
        DS 1
//   27 
//   28 /* high-level */
//   29 #include "mac_spec.h"
//   30 #include "mac_pib.h"
//   31 
//   32 /* exported low-level */
//   33 #include "mac_low_level.h"
//   34 
//   35 /* low-level specific */
//   36 #include "mac_csp_tx.h"
//   37 #include "mac_tx.h"
//   38 #include "mac_rx.h"
//   39 #include "mac_rx_onoff.h"
//   40 
//   41 /* target specific */
//   42 #include "mac_radio_defs.h"
//   43 
//   44 /* debug */
//   45 #include "mac_assert.h"
//   46 
//   47 
//   48 /* ------------------------------------------------------------------------------------------------
//   49  *                                   CSP Defines / Macros
//   50  * ------------------------------------------------------------------------------------------------
//   51  */
//   52 /* immediate strobe commands */
//   53 #define ISSTART     0xFE
//   54 #define ISSTOP      0xFF
//   55 
//   56 /* strobe processor instructions */
//   57 #define SKIP(s,c)   (0x00 | (((s) & 0x07) << 4) | ((c) & 0x0F))   /* skip 's' instructions if 'c' is true  */
//   58 #define WHILE(c)    SKIP(0,c)              /* pend while 'c' is true (derived instruction)        */
//   59 #define WAITW(w)    (0x80 | ((w) & 0x1F))  /* wait for 'w' number of MAC timer overflows          */
//   60 #define WEVENT      (0xB8)                 /* wait for MAC timer compare                          */
//   61 #define WAITX       (0xBB)                 /* wait for CPSX number of MAC timer overflows         */
//   62 #define LABEL       (0xBA)                 /* set next instruction as start of loop               */
//   63 #define RPT(c)      (0xA0 | ((c) & 0x0F))  /* if condition is true jump to last label             */
//   64 #define INT         (0xB9)                 /* assert IRQ_CSP_INT interrupt                        */
//   65 #define INCY        (0xBD)                 /* increment CSPY                                      */
//   66 #define INCMAXY(m)  (0xB0 | ((m) & 0x07))  /* increment CSPY but not above maximum value of 'm'   */
//   67 #define DECY        (0xBE)                 /* decrement CSPY                                      */
//   68 #define DECZ        (0xBF)                 /* decrement CSPZ                                      */
//   69 #define RANDXY      (0xBC)                 /* load the lower CSPY bits of CSPX with random value  */
//   70 
//   71 /* strobe processor command instructions */
//   72 #define SSTOP       (0xDF)    /* stop program execution                                      */
//   73 #define SNOP        (0xC0)    /* no operation                                                */
//   74 #define STXCALN     (0xC1)    /* enable and calibrate frequency synthesizer for TX           */
//   75 #define SRXON       (0xC2)    /* turn on receiver                                            */
//   76 #define STXON       (0xC3)    /* transmit after calibration                                  */
//   77 #define STXONCCA    (0xC4)    /* transmit after calibration if CCA indicates clear channel   */
//   78 #define SRFOFF      (0xC5)    /* turn off RX/TX                                              */
//   79 #define SFLUSHRX    (0xC6)    /* flush receive FIFO                                          */
//   80 #define SFLUSHTX    (0xC7)    /* flush transmit FIFO                                         */
//   81 #define SACK        (0xC8)    /* send ACK frame                                              */
//   82 #define SACKPEND    (0xC9)    /* send ACK frame with pending bit set                         */
//   83 
//   84 /* conditions for use with instructions SKIP and RPT */
//   85 #define C_CCA_IS_VALID        0x00
//   86 #define C_SFD_IS_ACTIVE       0x01
//   87 #define C_CPU_CTRL_IS_ON      0x02
//   88 #define C_END_INSTR_MEM       0x03
//   89 #define C_CSPX_IS_ZERO        0x04
//   90 #define C_CSPY_IS_ZERO        0x05
//   91 #define C_CSPZ_IS_ZERO        0x06
//   92 
//   93 /* negated conditions for use with instructions SKIP and RPT */
//   94 #define C_NEGATE(c)   ((c) | 0x08)
//   95 #define C_CCA_IS_INVALID      C_NEGATE(C_CCA_IS_VALID)
//   96 #define C_SFD_IS_INACTIVE     C_NEGATE(C_SFD_IS_ACTIVE)
//   97 #define C_CPU_CTRL_IS_OFF     C_NEGATE(C_CPU_CTRL_IS_ON)
//   98 #define C_NOT_END_INSTR_MEM   C_NEGATE(C_END_INSTR_MEM)
//   99 #define C_CSPX_IS_NON_ZERO    C_NEGATE(C_CSPX_IS_ZERO)
//  100 #define C_CSPY_IS_NON_ZERO    C_NEGATE(C_CSPY_IS_ZERO)
//  101 #define C_CSPZ_IS_NON_ZERO    C_NEGATE(C_CSPZ_IS_ZERO)
//  102 
//  103 ///////////////////////////////////////////////////////////////////////////////////////
//  104 //  REV_B_WORKAROUND : part of a workaround to help ameliorate chip bug #273.
//  105 //  This bug could actually be the source of extant every-once-in-a-while problems.
//  106 //  When Rev B is obsolete, delete these defines and all references to them.
//  107 //  Compile errors should flag all related fixes.
//  108 #define __SNOP_SKIP__     1
//  109 #define __SNOP__          SNOP
//  110 ///////////////////////////////////////////////////////////////////////////////////////
//  111 
//  112 
//  113 /* ------------------------------------------------------------------------------------------------
//  114  *                                         Defines
//  115  * ------------------------------------------------------------------------------------------------
//  116  */
//  117 
//  118 /* CSPY return values from CSP program */
//  119 #define CSPY_RXTX_COLLISION         0
//  120 #define CSPY_NO_RXTX_COLLISION      1
//  121 
//  122 /* CSPZ return values from CSP program */
//  123 #define CSPZ_CODE_TX_DONE           0
//  124 #define CSPZ_CODE_CHANNEL_BUSY      1
//  125 #define CSPZ_CODE_TX_ACK_TIME_OUT   2
//  126 
//  127 
//  128 /* ------------------------------------------------------------------------------------------------
//  129  *                                          Macros
//  130  * ------------------------------------------------------------------------------------------------
//  131  */
//  132 #define CSP_STOP_AND_CLEAR_PROGRAM()          st( RFST = ISSTOP;  )
//  133 #define CSP_START_PROGRAM()                   st( RFST = ISSTART; )
//  134 ////////////////////////////////////////////////////////////////////////////////////////////////////
//  135 //  REV_B_WORKAROUND : workaround for chip bug #574, delete this whole mess when Rev B is obsolete.
//  136 //  Compile errors will flag all instances of macro call.  Delete those too.
//  137 #ifndef _REMOVE_REV_B_WORKAROUNDS
//  138 #define __FIX_T2CMP_BUG__()   st( if (T2CMP == 0) { T2CMP = 1;} )
//  139 #else
//  140 #define __FIX_T2CMP_BUG__()
//  141 #endif
//  142 ////////////////////////////////////////////////////////////////////////////////////////////////////
//  143 
//  144 /*
//  145  *  These macros improve readability of using T2CMP in conjunction with WEVENT.
//  146  *
//  147  *  The timer2 compare, T2CMP, only compares one byte of the 16-bit timer register.
//  148  *  It is configurable and has been set to compare against the upper byte of the timer value.
//  149  *  The CSP instruction WEVENT waits for the timer value to be greater than or equal
//  150  *  the value of T2CMP.
//  151  *
//  152  *  Reading the timer value is done by reading the low byte first.  This latches the
//  153  *  high byte.  A trick with the ternary operator is used by a macro below to force a
//  154  *  read of the low byte when returning the value of the high byte.
//  155  *
//  156  *  CSP_WEVENT_SET_TRIGGER_NOW()      - sets the WEVENT trigger point at the current timer count
//  157  *  CSP_WEVENT_SET_TRIGGER_SYMBOLS(x) - sets the WEVENT trigger point in symbols
//  158  *  CSP_WEVENT_READ_COUNT_SYMBOLS()   - reads the current timer count in symbols
//  159  */
//  160 #define T2THD_TICKS_PER_SYMBOL                (MAC_RADIO_TIMER_TICKS_PER_SYMBOL() >> 8)
//  161 
//  162 #define CSP_WEVENT_SET_TRIGGER_NOW()          st( uint8 temp=T2TLD;  T2CMP = T2THD;  __FIX_T2CMP_BUG__(); )
//  163 #define CSP_WEVENT_SET_TRIGGER_SYMBOLS(x)     st( MAC_ASSERT(x <= MAC_A_UNIT_BACKOFF_PERIOD); \ 
//  164                                                   T2CMP = (x) * T2THD_TICKS_PER_SYMBOL; \ 
//  165                                                   __FIX_T2CMP_BUG__(); )
//  166 #define CSP_WEVENT_READ_COUNT_SYMBOLS()       (((T2TLD) ? T2THD : T2THD) / T2THD_TICKS_PER_SYMBOL)
//  167 
//  168 /*
//  169  *  Number of bits used for aligning a slotted transmit to the backoff count (plus
//  170  *  derived values).  There are restrictions on this value.  Compile time integrity
//  171  *  checks will catch an illegal setting of this value.  A full explanation accompanies
//  172  *  this compile time check (see bottom of this file).
//  173  */
//  174 #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS     4
//  175 #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN              (1 << SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS)
//  176 #define SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK       (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - 1)
//  177 
//  178 
//  179 
//  180 /* ------------------------------------------------------------------------------------------------
//  181  *                                     Local Programs
//  182  * ------------------------------------------------------------------------------------------------
//  183  */
//  184 static void cspPrepForTxProgram(void);
//  185 
//  186 
//  187 /**************************************************************************************************
//  188  * @fn          macCspTxReset
//  189  *
//  190  * @brief       Reset the CSP.  Immediately halts any running program.
//  191  *
//  192  * @param       none
//  193  *
//  194  * @return      none
//  195  **************************************************************************************************
//  196  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  197 void macCspTxReset(void)
macCspTxReset:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function macCspTxReset
//  198 {
        FUNCALL macCspTxReset, macMcuAndRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxReset, macMcuAndRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  199   MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuAndRFIM
        MOV	R1,#-0x3
        MOV	DPTR,#(macMcuAndRFIM & 0xffff)
        MOV	A,#((macMcuAndRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  200   MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuAndRFIM
        MOV	R1,#-0x2
        CFI EndBlock cfiBlock0
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1
//  201   CSP_STOP_AND_CLEAR_PROGRAM();
//  202 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-5
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        MOV	A,#((macMcuAndRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
        MOV	0xe1,#-0x1
        LJMP	??Subroutine0_1 & 0xFFFF
        CFI EndBlock cfiBlock1
//  203 
//  204 
//  205 /*=================================================================================================
//  206  * @fn          cspPrepForTxProgram
//  207  *
//  208  * @brief       Prepare and initialize for transmit CSP program.
//  209  *              Call *before* loading the CSP program!
//  210  *
//  211  * @param       none
//  212  *
//  213  * @return      none
//  214  *=================================================================================================
//  215  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  216 static void cspPrepForTxProgram(void)
??cspPrepForTxProgram:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function ??cspPrepForTxProgram
//  217 {
        FUNCALL ??cspPrepForTxProgram, halAssertHandler
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL ??cspPrepForTxProgram, macMcuWriteRFIF
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL ??cspPrepForTxProgram, macMcuWriteRFIF
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  218   MAC_ASSERT(!(RFIM & IM_CSP_STOP)); /* already an active CSP program */
        MOV	A,0x91
        MOV	C,0xE0 /* A   */.1
        JNC	??cspPrepForTxProgram_1
        ; Setup parameters for call to function halAssertHandler
        MOV	DPTR,#(halAssertHandler & 0xffff)
        MOV	A,#((halAssertHandler >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  219 
//  220   /* set up parameters for CSP transmit program */
//  221   CSPY = CSPY_NO_RXTX_COLLISION;
??cspPrepForTxProgram_1:
        MOV	A,#0x1
        MOV	DPTR,#-0x20ed
        MOVX	@DPTR,A
//  222   CSPZ = CSPZ_CODE_CHANNEL_BUSY;
        MOV	DPTR,#-0x20ec
        MOVX	@DPTR,A
//  223 
//  224   /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
//  225   CSP_STOP_AND_CLEAR_PROGRAM();
        MOV	0xe1,#-0x1
//  226   MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
        ; Setup parameters for call to function macMcuWriteRFIF
        MOV	R1,#-0x3
        MOV	DPTR,#(macMcuWriteRFIF & 0xffff)
        MOV	A,#((macMcuWriteRFIF >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  227   MAC_MCU_CSP_INT_CLEAR_INTERRUPT();
        ; Setup parameters for call to function macMcuWriteRFIF
        MOV	R1,#-0x2
        MOV	A,#((macMcuWriteRFIF >> 16) & 0xff)
        CFI EndBlock cfiBlock2
        REQUIRE ?Subroutine2
        ; // Fall through to label ?Subroutine2
//  228 }

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiBlock3 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-5
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        LCALL	?BCALL               ; Banked call to: DPTR()
        LJMP	??Subroutine0_1 & 0xFFFF
        CFI EndBlock cfiBlock3
//  229 
//  230 
//  231 /**************************************************************************************************
//  232  * @fn          macCspTxPrepCsmaUnslotted
//  233  *
//  234  * @brief       Prepare CSP for "Unslotted CSMA" transmit.  Load CSP program and set CSP parameters.
//  235  *
//  236  * @param       none
//  237  *
//  238  * @return      none
//  239  **************************************************************************************************
//  240  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  241 void macCspTxPrepCsmaUnslotted(void)
macCspTxPrepCsmaUnslotted:
        CFI Block cfiBlock4 Using cfiCommon0
        CFI Function macCspTxPrepCsmaUnslotted
//  242 {
        FUNCALL macCspTxPrepCsmaUnslotted, ??cspPrepForTxProgram
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  243   cspPrepForTxProgram();
        ; Setup parameters for call to function cspPrepForTxProgram
        MOV	DPTR,#(??cspPrepForTxProgram & 0xffff)
        MOV	A,#((??cspPrepForTxProgram >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  244 
//  245   /*----------------------------------------------------------------------
//  246    *  Load CSP program :  Unslotted CSMA transmit 
//  247    */
//  248 
//  249   /*
//  250    *  Wait for X number of backoffs, then wait for intra-backoff count
//  251    *  to reach value set for WEVENT.
//  252    */
//  253   RFST = WAITX;
        MOV	0xe1,#-0x45
//  254   RFST = WEVENT;
        MOV	0xe1,#-0x48
//  255 
//  256   /* wait for one backoff to guarantee receiver has been on at least that long */
//  257   RFST = WAITW(1);
        MOV	0xe1,#-0x7f
//  258   RFST = WEVENT;
        MOV	0xe1,#-0x48
//  259   
//  260   /* sample CCA, if it fails exit from here, CSPZ indicates result */
//  261   RFST = SKIP(1+__SNOP_SKIP__, C_CCA_IS_VALID);
        SJMP	?Subroutine0
        CFI EndBlock cfiBlock4
//  262   RFST = SSTOP;
//  263   RFST = __SNOP__;
//  264   
//  265   /* CSMA has passed so transmit */
//  266   RFST = STXON;
//  267 
//  268   /*
//  269    *  If the SFD pin is high at this point, there was an RX-TX collision.
//  270    *  In other words, TXON was strobed while receiving.  The CSP variable
//  271    *  CSPY is decremented to indicate this happened.  The rest of the transmit
//  272    *  continues normally.
//  273    */
//  274   RFST = SKIP(2+__SNOP_SKIP__, C_SFD_IS_INACTIVE);
//  275   RFST = WHILE(C_SFD_IS_ACTIVE);
//  276   RFST = DECY;
//  277   RFST = __SNOP__;
//  278 
//  279   /*
//  280    *  Watch the SFD pin to determine when the transmit has finished going out.
//  281    *  The INT instruction causes an interrupt to fire.  The ISR for this interrupt
//  282    *  handles the record the timestamp (which was just captured when SFD went high).
//  283    *  Decrement CSPZ at the last step to indicate transmit was successful.
//  284    */
//  285   RFST = WHILE(C_SFD_IS_INACTIVE);
//  286   RFST = INT;
//  287   RFST = WHILE(C_SFD_IS_ACTIVE);
//  288   RFST = DECZ;
//  289 }
//  290 
//  291 
//  292 /**************************************************************************************************
//  293  * @fn          macCspTxPrepCsmaSlotted
//  294  *
//  295  * @brief       Prepare CSP for "Slotted CSMA" transmit.  Load CSP program and set CSP parameters.
//  296  *
//  297  * @param       none
//  298  *
//  299  * @return      none
//  300  **************************************************************************************************
//  301  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  302 void macCspTxPrepCsmaSlotted(void)
macCspTxPrepCsmaSlotted:
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function macCspTxPrepCsmaSlotted
//  303 {
        FUNCALL macCspTxPrepCsmaSlotted, ??cspPrepForTxProgram
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  304   cspPrepForTxProgram();
        ; Setup parameters for call to function cspPrepForTxProgram
        MOV	DPTR,#(??cspPrepForTxProgram & 0xffff)
        MOV	A,#((??cspPrepForTxProgram >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  305 
//  306   /*----------------------------------------------------------------------
//  307    *  Load CSP program :  Slotted CSMA transmit 
//  308    */
//  309   
//  310   /* wait for X number of backoffs */
//  311   RFST = WAITX;
        MOV	0xe1,#-0x45
//  312 
//  313   /* wait for one backoff to guarantee receiver has been on at least that long */
//  314   RFST = WAITW(1);
        MOV	0xe1,#-0x7f
//  315 
//  316   /* sample CCA, if it fails exit from here, CSPZ indicates result */
//  317   RFST = SKIP(1+__SNOP_SKIP__, C_CCA_IS_VALID);
        MOV	0xe1,#0x20
//  318   RFST = SSTOP;
        MOV	0xe1,#-0x21
//  319   RFST = __SNOP__;
        MOV	0xe1,#-0x40
//  320   
//  321   /* per CSMA in specification, wait one backoff */
//  322   RFST = WAITW(1);
        MOV	0xe1,#-0x7f
//  323   
//  324   /* sample CCA again, if it fails exit from here, CSPZ indicates result */
//  325   RFST = SKIP(1+__SNOP_SKIP__, C_CCA_IS_VALID);
        SJMP	?Subroutine0
        CFI EndBlock cfiBlock5
//  326   RFST = SSTOP;
//  327   RFST = __SNOP__;
//  328   
//  329   /* CSMA has passed so transmit */
//  330   RFST = STXON;
//  331 
//  332   /*
//  333    *  If the SFD pin is high at this point, there was an RX-TX collision.
//  334    *  In other words, TXON was strobed while receiving.  The CSP variable
//  335    *  CSPY is decremented to indicate this happened.  The rest of the transmit
//  336    *  continues normally.
//  337    */
//  338   RFST = SKIP(2+__SNOP_SKIP__, C_SFD_IS_INACTIVE);
//  339   RFST = WHILE(C_SFD_IS_ACTIVE);
//  340   RFST = DECY;
//  341   RFST = __SNOP__;
//  342 
//  343   /*
//  344    *  Watch the SFD pin to determine when the transmit has finished going out.
//  345    *  The INT instruction causes an interrupt to fire.  The ISR for this interrupt
//  346    *  handles the record the timestamp (which was just captured when SFD went high).
//  347    *  Decrement CSPZ at the last step to indicate transmit was successful.
//  348    */
//  349   RFST = WHILE(C_SFD_IS_INACTIVE);
//  350   RFST = INT;
//  351   RFST = WHILE(C_SFD_IS_ACTIVE);
//  352   RFST = DECZ;
//  353 }
//  354 
//  355 
//  356 /**************************************************************************************************
//  357  * @fn          macCspTxGoCsma
//  358  *
//  359  * @brief       Run previously loaded CSP program for CSMA transmit.  Handles either
//  360  *              slotted or unslotted CSMA transmits.  When CSP program has finished,
//  361  *              an interrupt occurs and macCspTxStopIsr() is called.  This ISR will in
//  362  *              turn call macTxDoneCallback().
//  363  *
//  364  * @param       none
//  365  *
//  366  * @return      none
//  367  **************************************************************************************************
//  368  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  369 void macCspTxGoCsma(void)
macCspTxGoCsma:
        CFI Block cfiBlock6 Using cfiCommon0
        CFI Function macCspTxGoCsma
//  370 {
        FUNCALL macCspTxGoCsma, macMcuOrRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxGoCsma, macMcuOrRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxGoCsma, macRxOn
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  371   /*
//  372    *  Set CSPX with the countdown time of the CSMA delay.  Subtract one because there is
//  373    *  a built-in one backoff delay in the CSP program to make sure receiver has been 'on'
//  374    *  for at least one backoff.  Don't subtract though if CSPX is already zero!
//  375    */
//  376   CSPX = macTxCsmaBackoffDelay;
        MOV	DPTR,#macTxCsmaBackoffDelay
        MOVX	A,@DPTR
        MOV	DPTR,#-0x20ee
        MOVX	@DPTR,A
//  377   if (CSPX != 0)
        MOVX	A,@DPTR
        JZ	??macCspTxGoCsma_0
//  378   {
//  379     CSPX--;
        MOVX	A,@DPTR
        DEC	A
        MOVX	@DPTR,A
//  380   }
//  381 
//  382   /*
//  383    *  Set WEVENT to trigger at the current value of the timer.  This allows
//  384    *  unslotted CSMA to transmit just a little bit sooner.
//  385    */
//  386   CSP_WEVENT_SET_TRIGGER_NOW();
??macCspTxGoCsma_0:
        MOV	A,0xa6
        MOV	0x94,0xa7
        MOV	A,0x94
        JNZ	??macCspTxGoCsma_1
        MOV	0x94,#0x1
//  387 
//  388   /*
//  389    *  Enable interrupt that fires when CSP program stops.
//  390    *  Also enable interrupt that fires when INT instruction
//  391    *  is executed.
//  392    */
//  393   MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
??macCspTxGoCsma_1:
        ; Setup parameters for call to function macMcuOrRFIM
        MOV	R1,#0x2
        MOV	DPTR,#(macMcuOrRFIM & 0xffff)
        MOV	A,#((macMcuOrRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  394   MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuOrRFIM
        MOV	R1,#0x1
        MOV	A,#((macMcuOrRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  395   
//  396   /*
//  397    *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
//  398    *  least one backoff before performing clear channel assessment (CCA).
//  399    */
//  400   macRxOn();
        ; Setup parameters for call to function macRxOn
        MOV	DPTR,#(macRxOn & 0xffff)
        MOV	A,#((macRxOn >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  401 
//  402   /* start the CSP program */
//  403   CSP_START_PROGRAM();
        MOV	0xe1,#-0x2
//  404 }
        SJMP	??Subroutine0_1
        CFI EndBlock cfiBlock6

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock7 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-5
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        MOV	0xe1,#0x20
        MOV	0xe1,#-0x21
        MOV	0xe1,#-0x40
??Subroutine0_0:
        MOV	0xe1,#-0x3d
        MOV	0xe1,#0x39
        MOV	0xe1,#0x1
        MOV	0xe1,#-0x42
        MOV	0xe1,#-0x40
        MOV	0xe1,#0x9
        MOV	0xe1,#-0x47
        MOV	0xe1,#0x1
        MOV	0xe1,#-0x41
??Subroutine0_1:
        POP	DPH
        CFI CFA_SP SP+-4
        CFI DPH0 SameValue
        POP	DPL
        CFI CFA_SP SP+-3
        CFI DPL0 SameValue
        LJMP	?BRET
        CFI EndBlock cfiBlock7
//  405 
//  406 
//  407 /**************************************************************************************************
//  408  * @fn          macCspTxPrepSlotted
//  409  *
//  410  * @brief       Prepare CSP for "Slotted" (non-CSMA) transmit.
//  411  *              Load CSP program and set CSP parameters.
//  412  *
//  413  * @param       none
//  414  *
//  415  * @return      none
//  416  **************************************************************************************************
//  417  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  418 void macCspTxPrepSlotted(void)
macCspTxPrepSlotted:
        CFI Block cfiBlock8 Using cfiCommon0
        CFI Function macCspTxPrepSlotted
//  419 {
        FUNCALL macCspTxPrepSlotted, ??cspPrepForTxProgram
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  420   cspPrepForTxProgram();
        ; Setup parameters for call to function cspPrepForTxProgram
        MOV	DPTR,#(??cspPrepForTxProgram & 0xffff)
        MOV	A,#((??cspPrepForTxProgram >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  421 
//  422   /*----------------------------------------------------------------------
//  423    *  Load CSP program :  Slotted transmit (no CSMA)
//  424    */
//  425   
//  426   /* wait for X number of backoffs */
//  427   RFST = WAITX;
        MOV	0xe1,#-0x45
//  428 
//  429   /* just transmit, no CSMA required */
//  430   RFST = STXON;
        SJMP	??Subroutine0_0
        CFI EndBlock cfiBlock8
//  431 
//  432   /*
//  433    *  If the SFD pin is high at this point, there was an RX-TX collision.
//  434    *  In other words, TXON was strobed while receiving.  The CSP variable
//  435    *  CSPY is decremented to indicate this happened.  The rest of the transmit
//  436    *  continues normally.
//  437    */
//  438   RFST = SKIP(2+__SNOP_SKIP__, C_SFD_IS_INACTIVE);
//  439   RFST = WHILE(C_SFD_IS_ACTIVE);
//  440   RFST = DECY;
//  441   RFST = __SNOP__;
//  442   
//  443   /*
//  444    *  Watch the SFD pin to determine when the transmit has finished going out.
//  445    *  The INT instruction causes an interrupt to fire.  The ISR for this interrupt
//  446    *  handles the record the timestamp (which was just captured when SFD went high).
//  447    *  Decrement CSPZ at the last step to indicate transmit was successful.
//  448    */
//  449   RFST = WHILE(C_SFD_IS_INACTIVE);
//  450   RFST = INT;
//  451   RFST = WHILE(C_SFD_IS_ACTIVE);
//  452   RFST = DECZ;
//  453 }
//  454 
//  455 
//  456 /**************************************************************************************************
//  457  * @fn          macCspTxGoSlotted
//  458  *
//  459  * @brief       Run previously loaded CSP program for non-CSMA slotted transmit.   When CSP
//  460  *              program has finished, an interrupt occurs and macCspTxStopIsr() is called.
//  461  *              This ISR will in turn call macTxDoneCallback().
//  462  *
//  463  * @param       none
//  464  *
//  465  * @return      none
//  466  **************************************************************************************************
//  467  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  468 void macCspTxGoSlotted(void)
macCspTxGoSlotted:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function macCspTxGoSlotted
//  469 {
        FUNCALL macCspTxGoSlotted, macMcuOrRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxGoSlotted, macMcuOrRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  470   halIntState_t  s;
//  471   uint8 lowByteOfBackoffCount;
//  472   uint8 backoffCountdown;
//  473   
//  474   /*
//  475    *  Enable interrupt that fires when CSP program stops.
//  476    *  Also enable interrupt that fires when INT instruction
//  477    *  is executed.
//  478    */
//  479   MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuOrRFIM
        MOV	R1,#0x2
        MOV	DPTR,#(macMcuOrRFIM & 0xffff)
        MOV	A,#((macMcuOrRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  480   MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuOrRFIM
        MOV	R1,#0x1
        MOV	A,#((macMcuOrRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  481 
//  482   /* critical section needed for timer accesses */
//  483   HAL_ENTER_CRITICAL_SECTION(s);
        MOV	C,0xa8.7
        CLR	A
        MOV	0xE0 /* A   */.0,C
        MOV	R3,A
        CLR	0xa8.7
//  484 
//  485   /* store lowest byte of backoff count (same as lowest byte of overflow count) */
//  486   lowByteOfBackoffCount = T2OF0;
        MOV	A,0xa1
        MOV	R4,A
//  487 
//  488   /*
//  489    *  Compute the number of backoffs until time to strobe transmit.  The strobe should
//  490    *  occur one backoff before the SFD pin is expected to go high.  So, the forumla for the
//  491    *  countdown value is to determine when the lower bits would rollover and become zero,
//  492    *  and then subtract one.
//  493    */
//  494   backoffCountdown = SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - (lowByteOfBackoffCount & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) - 1;
        MOV	A,#0xf
        ANL	A,R4
        MOV	R2,A
        MOV	A,#0xf
        CLR	C
        SUBB	A,R2
        MOV	R2,A
//  495   
//  496   /*
//  497    *  Store backoff countdown value into CSPX.
//  498    *
//  499    *  Note: it is OK if this value is zero.  The WAITX instruction at the top of the
//  500    *  CSP program will immediately continue if CSPX is zero when executed.  However,
//  501    *  if the countdown is zero, it means the transmit function was not called early
//  502    *  enough for a properly timed slotted transmit.  The transmit will be late.
//  503    */
//  504   CSPX = backoffCountdown;
        MOV	DPTR,#-0x20ee
        MOVX	@DPTR,A
//  505 
//  506   /*
//  507    *  The receiver will be turned on during CSP execution, guaranteed.
//  508    *  Since it is not possible to update C variables within the CSP,
//  509    *  the new "on" state of the receiver must be set a little early
//  510    *  here before the CSP is started.
//  511    */
//  512   MAC_RX_WAS_FORCED_ON();
        MOV	A,#0x1
        MOV	DPTR,#macRxOnFlag
        MOVX	@DPTR,A
//  513 
//  514   /* start the CSP program */
//  515   CSP_START_PROGRAM();
        MOV	0xe1,#-0x2
//  516   
//  517   /*
//  518    *  If the previous stored low byte of the backoff count is no longer equal to
//  519    *  the current value, a rollover has occurred.  This means the backoff countdown
//  520    *  stored in CSPX may not be correct.
//  521    *
//  522    *  In this case, the value of CSPX is reloaded to reflect the correct backoff
//  523    *  countdown value (this is one less than what was just used as a rollover has
//  524    *  occurred).  Since it is certain a rollover *just* occurred, there is no danger
//  525    *  of another rollover occurring.  This means the value written to CSPX is guaranteed
//  526    *  to be accurate.
//  527    *
//  528    *  Also, the logic below ensures that the value written to CSPX is at least one.
//  529    *  This is needed for correct operation of the WAITX instruction.  As with an
//  530    *  initial backoff countdown value of zero, if this case does occur, it means the
//  531    *  transmit function was not called early enough for a properly timed slotted transmit.
//  532    *  The transmit will be late.
//  533    *
//  534    *  Finally, worth noting, writes to CSPX may not work if the CSP is executing the WAITX
//  535    *  instruction and a timer rollover occurs.  In this case, however, there is no possibility
//  536    *  of that happening.  If CSPX is updated here, a rollover has just occurred so a
//  537    *  collision is not possible (still within a critical section here too).
//  538    */
//  539   if ((lowByteOfBackoffCount != T2OF0) && (backoffCountdown > 1))
        MOV	A,0xa1
        XRL	A,R4
        JZ	??macCspTxGoSlotted_0
        MOV	A,R2
        CLR	C
        SUBB	A,#0x2
        JC	??macCspTxGoSlotted_0
//  540   {
//  541     CSPX = backoffCountdown - 1;
        MOV	A,#-0x1
        ADD	A,R2
        MOV	DPTR,#-0x20ee
        MOVX	@DPTR,A
//  542   }
//  543   
//  544   HAL_EXIT_CRITICAL_SECTION(s);
??macCspTxGoSlotted_0:
        MOV	A,R3
        MOV	C,0xE0 /* A   */.0
        MOV	0xa8.7,C
//  545 }
        SJMP	??Subroutine0_1
        CFI EndBlock cfiBlock9
//  546 
//  547 
//  548 /**************************************************************************************************
//  549  * @fn          macCspForceTxDoneIfPending
//  550  *
//  551  * @brief       The function clears out any pending TX done logic.  Used by receive logic
//  552  *              to make sure its ISR does not prevent transmit from completing in a reasonable
//  553  *              amount of time.
//  554  *
//  555  * @param       none
//  556  *
//  557  * @return      none
//  558  **************************************************************************************************
//  559  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  560 void macCspForceTxDoneIfPending(void)
macCspForceTxDoneIfPending:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function macCspForceTxDoneIfPending
//  561 {
        FUNCALL macCspForceTxDoneIfPending, macMcuAndRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspForceTxDoneIfPending, macCspTxIntIsr
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspForceTxDoneIfPending, macTxDoneCallback
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  562 ///////////////////////////////////////////////////////////////////////////////////////
//  563 //  REV_B_WORKAROUND : work workaround for chip bug #273.  The instruction DECZ might
//  564 //  be incorrectly executed twice, resulting an illegal value for CSPZ.
//  565 //  Delete when Rev B is obsolete.
//  566 ///////////////////////////////////////////////////////////////////////////////////////
//  567 #ifndef _REMOVE_REV_B_WORKAROUNDS
//  568   if (CSPZ >= 0xF8) { CSPZ = 0; }
        MOV	DPTR,#-0x20ec
        MOVX	A,@DPTR
        CLR	C
        SUBB	A,#-0x8
        JC	??macCspForceTxDoneIfPending_0
        CLR	A
        MOVX	@DPTR,A
//  569 #endif
//  570 ///////////////////////////////////////////////////////////////////////////////////////
//  571   
//  572   if ((CSPZ == CSPZ_CODE_TX_DONE) &&  MAC_MCU_CSP_STOP_INTERRUPT_IS_ENABLED())
??macCspForceTxDoneIfPending_0:
        MOVX	A,@DPTR
        JNZ	??macCspForceTxDoneIfPending_1
        MOV	A,0x91
        MOV	C,0xE0 /* A   */.1
        JNC	??macCspForceTxDoneIfPending_1
//  573   {
//  574     MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuAndRFIM
        MOV	R1,#-0x3
        MOV	DPTR,#(macMcuAndRFIM & 0xffff)
        MOV	A,#((macMcuAndRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  575     if (MAC_MCU_CSP_INT_INTERRUPT_IS_ENABLED())
        MOV	A,0x91
        MOV	C,0xE0 /* A   */.0
        JNC	??macCspForceTxDoneIfPending_2
//  576     {
//  577       macCspTxIntIsr();
        ; Setup parameters for call to function macCspTxIntIsr
        MOV	DPTR,#(macCspTxIntIsr & 0xffff)
        MOV	A,#((macCspTxIntIsr >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  578     }
//  579     macTxDoneCallback();
??macCspForceTxDoneIfPending_2:
        ; Setup parameters for call to function macTxDoneCallback
        MOV	DPTR,#(macTxDoneCallback & 0xffff)
        MOV	A,#((macTxDoneCallback >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  580   }
//  581 }
??macCspForceTxDoneIfPending_1:
        LJMP	??Subroutine0_1 & 0xFFFF
        CFI EndBlock cfiBlock10
//  582 
//  583 
//  584 /**************************************************************************************************
//  585  * @fn          macCspTxRequestAckTimeoutCallback
//  586  *
//  587  * @brief       Requests a callback after the ACK timeout period has expired.  At that point,
//  588  *              the function macTxAckTimeoutCallback() is called via an interrupt.
//  589  *
//  590  * @param       none
//  591  *
//  592  * @return      none
//  593  **************************************************************************************************
//  594  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  595 void macCspTxRequestAckTimeoutCallback(void)
macCspTxRequestAckTimeoutCallback:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function macCspTxRequestAckTimeoutCallback
//  596 {
        FUNCALL macCspTxRequestAckTimeoutCallback, halAssertHandler
        LOCFRAME XSTACK, 12, STACK
        ARGFRAME XSTACK, 12, STACK
        FUNCALL macCspTxRequestAckTimeoutCallback, halAssertHandler
        LOCFRAME XSTACK, 12, STACK
        ARGFRAME XSTACK, 12, STACK
        FUNCALL macCspTxRequestAckTimeoutCallback, halAssertHandler
        LOCFRAME XSTACK, 12, STACK
        ARGFRAME XSTACK, 12, STACK
        FUNCALL macCspTxRequestAckTimeoutCallback, macMcuWriteRFIF
        LOCFRAME XSTACK, 12, STACK
        ARGFRAME XSTACK, 12, STACK
        FUNCALL macCspTxRequestAckTimeoutCallback, macMcuOrRFIM
        LOCFRAME XSTACK, 12, STACK
        ARGFRAME XSTACK, 12, STACK
        MOV	A,#-0xc
        LCALL	?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
//  597   uint8 startSymbol;
//  598   uint8 symbols;
//  599   uint8 rollovers;
//  600 
//  601   MAC_ASSERT(!(RFIM & IM_CSP_STOP)); /* already an active CSP program */
        MOV	A,0x91
        MOV	C,0xE0 /* A   */.1
        JNC	??macCspTxRequestAckTimeoutCallback_0
        ; Setup parameters for call to function halAssertHandler
        MOV	DPTR,#(halAssertHandler & 0xffff)
        MOV	A,#((halAssertHandler >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  602 
//  603   /* record current symbol count */
//  604   startSymbol = CSP_WEVENT_READ_COUNT_SYMBOLS();
??macCspTxRequestAckTimeoutCallback_0:
        MOV	A,0xa6
        MOV	R2,0xa7
        MOV	DPL,R2
        MOV	R0,DPL
        MOV	R1,#0x0
        MOV	R2,#0x2
        MOV	R3,#0x0
        LCALL	?S_DIV_MOD
        MOV	A,R0
        MOV	?V0 + 0,A
//  605 
//  606   /* set symbol timeout from PIB */
//  607   symbols = macPib.ackWaitDuration;
        MOV	DPTR,#macPib
        MOVX	A,@DPTR
        MOV	R6,A
//  608 
//  609   /* make sure delay value is not too small for logic to handle */
//  610   MAC_ASSERT(symbols > MAC_A_UNIT_BACKOFF_PERIOD);  /* symbols timeout period must be great than a backoff */
        CLR	C
        SUBB	A,#0x15
        JNC	??macCspTxRequestAckTimeoutCallback_1
        ; Setup parameters for call to function halAssertHandler
        MOV	DPTR,#(halAssertHandler & 0xffff)
        MOV	A,#((halAssertHandler >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  611 
//  612   /* subtract out symbols left in current backoff period */
//  613   symbols = symbols - (MAC_A_UNIT_BACKOFF_PERIOD - startSymbol);
??macCspTxRequestAckTimeoutCallback_1:
        MOV	A,#-0x14
        ADD	A,?V0 + 0
        ADD	A,R6
        MOV	R6,A
//  614 
//  615   /* calculate rollovers needed for remaining symbols */
//  616   rollovers = symbols / MAC_A_UNIT_BACKOFF_PERIOD;
        MOV	B,#0x14
        DIV	AB
        MOV	R7,A
//  617 
//  618   /* calculate symbols that still need counted after last rollover */
//  619   symbols = symbols - (rollovers * MAC_A_UNIT_BACKOFF_PERIOD);
        MOV	B,#0x14
        MUL	AB
        XCH	A,R6
        SUBB	A,R6
        MOV	R6,A
//  620 
//  621   /* add one to rollovers to account for symbols remaining in the current backoff period */
//  622   rollovers++;
        INC	R7
//  623 
//  624   /* set up parameters for CSP program */
//  625   CSPZ = CSPZ_CODE_TX_ACK_TIME_OUT;
        MOV	A,#0x2
        MOV	DPTR,#-0x20ec
        MOVX	@DPTR,A
//  626   CSPX = rollovers;
        MOV	A,R7
        MOV	DPTR,#-0x20ee
        MOVX	@DPTR,A
//  627   CSP_WEVENT_SET_TRIGGER_SYMBOLS(symbols);
        MOV	A,R6
        CLR	C
        SUBB	A,#0x15
        JC	??macCspTxRequestAckTimeoutCallback_2
        ; Setup parameters for call to function halAssertHandler
        MOV	DPTR,#(halAssertHandler & 0xffff)
        MOV	A,#((halAssertHandler >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
??macCspTxRequestAckTimeoutCallback_2:
        MOV	A,R6
        CLR	C
        RLC	A
        MOV	0x94,A
        MOV	A,0x94
        JNZ	??macCspTxRequestAckTimeoutCallback_3
        MOV	0x94,#0x1
//  628 
//  629   /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
//  630   CSP_STOP_AND_CLEAR_PROGRAM();
??macCspTxRequestAckTimeoutCallback_3:
        MOV	0xe1,#-0x1
//  631   MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
        ; Setup parameters for call to function macMcuWriteRFIF
        MOV	R1,#-0x3
        MOV	DPTR,#(macMcuWriteRFIF & 0xffff)
        MOV	A,#((macMcuWriteRFIF >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  632   
//  633   /*--------------------------
//  634    * load CSP program
//  635    */
//  636   RFST = WAITX;
        MOV	0xe1,#-0x45
//  637   RFST = WEVENT;
        MOV	0xe1,#-0x48
//  638   /*--------------------------
//  639    */
//  640   
//  641   /* run CSP program */
//  642   MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuOrRFIM
        MOV	R1,#0x2
        MOV	DPTR,#(macMcuOrRFIM & 0xffff)
        MOV	A,#((macMcuOrRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  643   CSP_START_PROGRAM();
        MOV	0xe1,#-0x2
//  644 
//  645   /*
//  646    *  For bullet proof operation, must account for the boundary condition
//  647    *  where a rollover occurs after count was read but before CSP program
//  648    *  was started.
//  649    *
//  650    *  If current symbol count is less that the symbol count recorded at the
//  651    *  start of this function, a rollover has occurred.
//  652    */
//  653   if (CSP_WEVENT_READ_COUNT_SYMBOLS() < startSymbol)
        MOV	A,0xa6
        MOV	R2,0xa7
        MOV	DPL,R2
        MOV	R0,DPL
        MOV	R1,#0x0
        MOV	R2,#0x2
        MOV	R3,#0x0
        LCALL	?S_DIV_MOD
        CLR	C
        MOV	A,R0
        SUBB	A,?V0 + 0
        MOV	A,R1
        SUBB	A,#0x0
        MOV	C,0xD0 /* PSW */.2
        XRL	A,PSW
        RLC	A
        JNC	??macCspTxRequestAckTimeoutCallback_4
//  654   {
//  655     /* a rollover has occurred, make sure it was accounted for */
//  656     if (CSPX == rollovers)
        MOV	DPTR,#-0x20ee
        MOVX	A,@DPTR
        XRL	A,R7
        JNZ	??macCspTxRequestAckTimeoutCallback_4
//  657     {
//  658       /*
//  659        *  Rollover event missed, manually decrement CSPX to adjust.
//  660        *
//  661        *  Note : there is a very small chance that CSPX does not
//  662        *  get decremented.  This would occur if CSPX were written
//  663        *  at exactly the same time a timer overflow is occurring (which
//  664        *  causes the CSP instruction WAITX to decrement CSPX).  This
//  665        *  would be extremely rare, but if it does happen, the only
//  666        *  consequence is that the ACK timeout period is extended
//  667        *  by one backoff.
//  668        */
//  669       CSPX--;
        MOVX	A,@DPTR
        DEC	A
        MOVX	@DPTR,A
//  670     }
//  671   }
//  672 }
??macCspTxRequestAckTimeoutCallback_4:
        MOV	R7,#0x4
        LJMP	?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock11
//  673 
//  674 
//  675 /**************************************************************************************************
//  676  * @fn          macCspTxCancelAckTimeoutCallback
//  677  *
//  678  * @brief       Cancels previous request for ACK timeout callback.
//  679  *
//  680  * @param       none
//  681  *
//  682  * @return      none
//  683  **************************************************************************************************
//  684  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  685 void macCspTxCancelAckTimeoutCallback(void)
macCspTxCancelAckTimeoutCallback:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI Function macCspTxCancelAckTimeoutCallback
//  686 {
        FUNCALL macCspTxCancelAckTimeoutCallback, macMcuAndRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  687   MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuAndRFIM
        MOV	R1,#-0x3
        MOV	DPTR,#(macMcuAndRFIM & 0xffff)
        LJMP	?Subroutine1 & 0xFFFF
        CFI EndBlock cfiBlock12
//  688   CSP_STOP_AND_CLEAR_PROGRAM();
//  689 }
//  690 
//  691 
//  692 /**************************************************************************************************
//  693  * @fn          macCspTxIntIsr
//  694  *
//  695  * @brief       Interrupt service routine for handling INT type interrupts from CSP.
//  696  *              This interrupt happens when the CSP instruction INT is executed.  It occurs
//  697  *              once the SFD signal goes high indicating that transmit has successfully
//  698  *              started.  The timer value has been captured at this point and timestamp
//  699  *              can be stored.
//  700  *
//  701  * @param       none
//  702  *
//  703  * @return      none
//  704  **************************************************************************************************
//  705  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  706 void macCspTxIntIsr(void)
macCspTxIntIsr:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function macCspTxIntIsr
//  707 {
        FUNCALL macCspTxIntIsr, macMcuAndRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxIntIsr, macRxHaltCleanup
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxIntIsr, macTxTimestampCallback
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  708 ///////////////////////////////////////////////////////////////////////////////////////
//  709 //  REV_B_WORKAROUND : work workaround for chip bug #273.  The instruction DECY might
//  710 //  be incorrectly executed twice, resulting an illegal value for CSPZ.
//  711 //  Delete when Rev B is obsolete.
//  712 ///////////////////////////////////////////////////////////////////////////////////////
//  713 #ifndef _REMOVE_REV_B_WORKAROUNDS
//  714   if (CSPY >= 0xF8) { CSPY = 0; }
        MOV	DPTR,#-0x20ed
        MOVX	A,@DPTR
        CLR	C
        SUBB	A,#-0x8
        JC	??macCspTxIntIsr_0
        CLR	A
        MOVX	@DPTR,A
//  715 #endif
//  716 ///////////////////////////////////////////////////////////////////////////////////////
//  717 
//  718   MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
??macCspTxIntIsr_0:
        ; Setup parameters for call to function macMcuAndRFIM
        MOV	R1,#-0x2
        MOV	DPTR,#(macMcuAndRFIM & 0xffff)
        MOV	A,#((macMcuAndRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  719 
//  720   if (CSPY == CSPY_RXTX_COLLISION)
        MOV	DPTR,#-0x20ed
        MOVX	A,@DPTR
        JNZ	??macCspTxIntIsr_1
//  721   {
//  722     macRxHaltCleanup();
        ; Setup parameters for call to function macRxHaltCleanup
        MOV	DPTR,#(macRxHaltCleanup & 0xffff)
        MOV	A,#((macRxHaltCleanup >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  723   }
//  724 
//  725   /* execute callback function that records transmit timestamp */
//  726   macTxTimestampCallback();
??macCspTxIntIsr_1:
        ; Setup parameters for call to function macTxTimestampCallback
        MOV	DPTR,#(macTxTimestampCallback & 0xffff)
        MOV	A,#((macTxTimestampCallback >> 16) & 0xff)
        LJMP	?Subroutine2 & 0xFFFF
        CFI EndBlock cfiBlock13
//  727 }
//  728 
//  729 
//  730 /**************************************************************************************************
//  731  * @fn          macCspTxStopIsr
//  732  *
//  733  * @brief       Interrupt service routine for handling STOP type interrupts from CSP.
//  734  *              This interrupt occurs when the CSP program stops by 1) reaching the end of the
//  735  *              program, 2) executing SSTOP within the program, 3) executing immediate
//  736  *              instruction ISSTOP.
//  737  *
//  738  *              The value of CSPZ indicates if interrupt is being used for ACK timeout or
//  739  *              is the end of a transmit.
//  740  *
//  741  * @param       none
//  742  *
//  743  * @return      none
//  744  **************************************************************************************************
//  745  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  746 void macCspTxStopIsr(void)
macCspTxStopIsr:
        CFI Block cfiBlock14 Using cfiCommon0
        CFI Function macCspTxStopIsr
//  747 {
        FUNCALL macCspTxStopIsr, macMcuAndRFIM
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxStopIsr, macTxDoneCallback
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxStopIsr, macTxChannelBusyCallback
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxStopIsr, halAssertHandler
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        FUNCALL macCspTxStopIsr, macTxAckNotReceivedCallback
        LOCFRAME ISTACK, 2, STACK
        ARGFRAME ISTACK, 2, STACK
        PUSH	DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH	DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  748   MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
        ; Setup parameters for call to function macMcuAndRFIM
        MOV	R1,#-0x3
        MOV	DPTR,#(macMcuAndRFIM & 0xffff)
        MOV	A,#((macMcuAndRFIM >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  749 
//  750 ///////////////////////////////////////////////////////////////////////////////////////
//  751 //  REV_B_WORKAROUND : work workaround for chip bug #273.  The instruction DECZ might
//  752 //  be incorrectly executed twice, resulting an illegal value for CSPZ.
//  753 //  Delete when Rev B is obsolete.
//  754 ///////////////////////////////////////////////////////////////////////////////////////
//  755 #ifndef _REMOVE_REV_B_WORKAROUNDS
//  756   if (CSPZ >= 0xF8) { CSPZ = 0; }
        MOV	DPTR,#-0x20ec
        MOVX	A,@DPTR
        CLR	C
        SUBB	A,#-0x8
        JC	??macCspTxStopIsr_0
        CLR	A
        MOVX	@DPTR,A
//  757 #endif
//  758 ///////////////////////////////////////////////////////////////////////////////////////
//  759 
//  760   if (CSPZ == CSPZ_CODE_TX_DONE)
??macCspTxStopIsr_0:
        MOVX	A,@DPTR
        JNZ	??macCspTxStopIsr_1
//  761   {
//  762     macTxDoneCallback();
        ; Setup parameters for call to function macTxDoneCallback
        MOV	DPTR,#(macTxDoneCallback & 0xffff)
        MOV	A,#((macTxDoneCallback >> 16) & 0xff)
        SJMP	??macCspTxStopIsr_2
//  763   }
//  764   else if (CSPZ == CSPZ_CODE_CHANNEL_BUSY)
??macCspTxStopIsr_1:
        MOVX	A,@DPTR
        XRL	A,#0x1
        JNZ	??macCspTxStopIsr_3
//  765   {
//  766     macTxChannelBusyCallback();
        ; Setup parameters for call to function macTxChannelBusyCallback
        MOV	DPTR,#(macTxChannelBusyCallback & 0xffff)
        MOV	A,#((macTxChannelBusyCallback >> 16) & 0xff)
        SJMP	??macCspTxStopIsr_2
//  767   }
//  768   else
//  769   {
//  770     MAC_ASSERT(CSPZ == CSPZ_CODE_TX_ACK_TIME_OUT); /* unexpected CSPZ value */
??macCspTxStopIsr_3:
        MOVX	A,@DPTR
        XRL	A,#0x2
        JZ	??macCspTxStopIsr_4
        ; Setup parameters for call to function halAssertHandler
        MOV	DPTR,#(halAssertHandler & 0xffff)
        MOV	A,#((halAssertHandler >> 16) & 0xff)
        LCALL	?BCALL               ; Banked call to: DPTR()
//  771     macTxAckNotReceivedCallback();
??macCspTxStopIsr_4:
        ; Setup parameters for call to function macTxAckNotReceivedCallback
        MOV	DPTR,#(macTxAckNotReceivedCallback & 0xffff)
        MOV	A,#((macTxAckNotReceivedCallback >> 16) & 0xff)
??macCspTxStopIsr_2:
        LJMP	?Subroutine2 & 0xFFFF
        CFI EndBlock cfiBlock14
//  772   }
//  773 }

        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DS 1

        END
//  774 
//  775 
//  776 
//  777 /**************************************************************************************************
//  778  *                                  Compile Time Integrity Checks
//  779  **************************************************************************************************
//  780  */
//  781 #if ((CSPY_RXTX_COLLISION != 0) || (CSPY_NO_RXTX_COLLISION != 1))
//  782 #error "ERROR!  The CSPY return values are very specific and tied into the actual CSP program."
//  783 #endif
//  784 
//  785 #if ((CSPZ_CODE_TX_DONE != 0) || (CSPZ_CODE_CHANNEL_BUSY != 1))
//  786 #error "ERROR!  The CSPZ return values are very specific and tied into the actual CSP program."
//  787 #endif
//  788 
//  789 #if (MAC_TX_TYPE_SLOTTED_CSMA != 0)
//  790 #error "WARNING!  This define value changed.  It was selected for optimum performance."
//  791 #endif
//  792 
//  793 #if (T2THD_TICKS_PER_SYMBOL == 0)
//  794 #error "ERROR!  Timer compare will not work on high byte.  Clock speed is probably too slow."
//  795 #endif
//  796 
//  797 #define BACKOFFS_PER_BASE_SUPERFRAME  (MAC_A_BASE_SLOT_DURATION * MAC_A_NUM_SUPERFRAME_SLOTS)
//  798 #if (((BACKOFFS_PER_BASE_SUPERFRAME - 1) & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) != SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK)
//  799 #error "ERROR!  The specified bit mask for backoff alignment of slotted transmit does not rollover 'cleanly'."
//  800 /*
//  801  *  In other words, the backoff count for the number of superframe rolls over before the
//  802  *  specified number of bits rollover.  For example, if backoff count for a superframe
//  803  *  rolls over at 48, the binary number immediately before a rollover is 00101111.
//  804  *  In this case four bits would work as an alignment mask.  Five would not work though as
//  805  *  the lower five bits would go from 01111 to 00000 (instead of the value 10000 which
//  806  *  would be expected) because it a new superframe is starting.
//  807  */
//  808 #endif
//  809 #if (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS < 2)
//  810 #error "ERROR!  Not enough backoff countdown bits to be practical."
//  811 #endif
//  812 
//  813 
//  814 /**************************************************************************************************
//  815 */
// 
// 712 bytes in segment BANKED_CODE
//   7 bytes in segment SFR_AN
// 
// 712 bytes of CODE memory
//   0 bytes of DATA memory (+ 7 bytes shared)
//
//Errors: none
//Warnings: none
