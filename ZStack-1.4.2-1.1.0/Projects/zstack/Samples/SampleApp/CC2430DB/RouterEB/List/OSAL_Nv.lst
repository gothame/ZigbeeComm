##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   24/Jan/2013  14:47:46 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  D:\Texas Instruments\ZStack-1.4.2-1.1.0\Component #
#                          s\osal\mcu\ccsoc\OSAL_Nv.c                        #
#    Command line       =  -f E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç #
#                          ¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006 #
#                          -´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8 #
#                          wRouter.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR          #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TR #
#                          UE -DRTR_NWK -DBLINK_LEDS "-DCONST=const __code"  #
#                          -DGENERIC=__generic) -f                           #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                    #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\ -I                           #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\Source\ -I                 #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mt\ #
#                           -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂ #
#                          ç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee200 #
#                          6-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\Components #
#                          \hal\include\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª· #
#                          ¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2 #
#                          006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projec #
#                          ts\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\ #
#                          ..\Components\hal\target\CC2430EB\ -I             #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\osa #
#                          l\mcu\ccsoc\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢ #
#                          ×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee20 #
#                          06\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Project #
#                          s\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\. #
#                          .\Components\osal\include\ -I                     #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\sta #
#                          ck\af\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\Î #
#                          ÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\Zig #
#                          Bee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zsta #
#                          ck\Samples\SampleApp\CC2430DB\..\..\..\..\..\Comp #
#                          onents\stack\nwk\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC243 #
#                          0¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zig #
#                          Bee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2430DB\..\..\.. #
#                          \..\..\Components\stack\sec\ -I                   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\sta #
#                          ck\sys\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ #
#                          ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\Zi #
#                          gBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Com #
#                          ponents\stack\zdo\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC24 #
#                          30¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zi #
#                          gBee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\P #
#                          rojects\zstack\Samples\SampleApp\CC2430DB\..\..\. #
#                          .\..\..\Components\zmac\f8w\ -I                   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍ #
#                          øÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2 #
#                          006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\services\saddr\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC24 #
#                          30¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zi #
#                          gBee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\P #
#                          rojects\zstack\Samples\SampleApp\CC2430DB\..\..\. #
#                          .\..\..\Components\services\sdata\ -I             #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mac #
#                          \include\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁ #
#                          Ï\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ #
#                          ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\mac\high_level\ -I                      #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mac #
#                          \low_level\srf03\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC243 #
#                          0¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zig #
#                          Bee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2430DB\..\..\.. #
#                          \..\..\Components\mac\low_level\srf03\single_chip #
#                          \ -D CC2430EB -D ZTOOL_P1 -D MT_TASK -lC          #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\ -lA            #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\                #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç #
#                          ¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006 #
#                          -´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\RouterEB\Obj\ -e           #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          "D:\Texas Instruments\ZStack-1.4.2-1.1.0\Componen #
#                          ts\osal\mcu\ccsoc\OSAL_Nv.c"                      #
#    List file          =  E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\OSAL_Nv.lst     #
#    Object file        =  E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\Obj\OSAL_Nv.r51      #
#                                                                            #
#                                                                            #
##############################################################################

D:\Texas Instruments\ZStack-1.4.2-1.1.0\Components\osal\mcu\ccsoc\OSAL_Nv.c
      1          /*********************************************************************
      2              Filename:       OSAL_Nv.c
      3              Revised:        $Date: 2007-04-11 14:41:47 -0700 (Wed, 11 Apr 2007) $
      4              Revision:       $Revision: 13998 $
      5          
      6              Description: This module contains the OSAL non-volatile memory functions.
      7          
      8              Notes: A trick buried deep in initPage() requires that the MSB of the NV
      9                     Item Id be reserved for use by this module.
     10          
     11              Copyright (c) 2007 by Texas Instruments, Inc.
     12              All Rights Reserved.  Permission to use, reproduce, copy, prepare
     13              derivative works, modify, distribute, perform, display or sell this
     14              software and/or its documentation for any purpose is prohibited
     15              without the express written consent of Texas Instruments, Inc.
     16          *********************************************************************/
     17          
     18          /*********************************************************************
     19           * INCLUDES
     20           */
     21          
     22          #include "ZComDef.h"
     23          #include "hal_adc.h"

   \                                 In segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr FWT
   \                     FWT:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xac
   \   unsigned char volatile __sfr FADDRL
   \                     FADDRL:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr FADDRH
   \                     FADDRH:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xae
   \   unsigned char volatile __sfr FCTL
   \                     FCTL:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1
     24          #include "hal_dma.h"
     25          #include "osal.h"
     26          #include "OSAL_Nv.h"
     27          #include <ioCC2430.h>
     28          
     29          #if !defined ( OSAL_NV_CLEANUP )
     30            #define OSAL_NV_CLEANUP  FALSE
     31          #endif
     32          
     33          /*********************************************************************
     34           * CONSTANTS
     35           */
     36          
     37          #define OSAL_NV_DMA_CH         (&dmaCh0)
     38          
     39          #define OSAL_NV_ACTIVE          0x00
     40          #define OSAL_NV_ERASED          0xFF
     41          #define OSAL_NV_ERASED_ID       0xFFFF
     42          #define OSAL_NV_ZEROED_ID       0x0000
     43          
     44          #define OSAL_NV_PAGE_FREE      (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
     45          
     46          /* The last Flash page will reserve an IEEE addr block at the end of the page where the tools know
     47           * to program the IEEE.
     48           */
     49          #define OSAL_NV_IEEE_OFFSET    (OSAL_NV_PAGE_SIZE - Z_EXTADDR_LEN)
     50          #define OSAL_NV_IEEE_PAGE       63
     51          
     52          // In case pages 0-1 are ever used, define a null page value.
     53          #define OSAL_NV_PAGE_NULL       0
     54          
     55          // In case item Id 0 is ever used, define a null item value.
     56          #define OSAL_NV_ITEM_NULL       0
     57          
     58          #define OSAL_NV_WORD_SIZE       4
     59          
     60          #define OSAL_NV_PAGE_HDR_OFFSET 0
     61          
     62          /*********************************************************************
     63           * MACROS
     64           */
     65          
     66          #define OSAL_NV_PAGE_ERASE( pg ) \
     67            st( \
     68              FADDRH = (pg) << 1; \
     69              FCTL = 0x01; \
     70              asm("NOP");              \
     71              while(FCTL == 0x80);     \
     72            )
     73          
     74          #define OSAL_NV_PAGE_TO_ADDR( pg )    ((uint32)pg << 11)
     75          #define OSAL_NV_ADDR_TO_PAGE( addr )  ((uint8)(addr >> 11))
     76          
     77          #define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalAdcCheckVdd( HAL_ADC_VDD_LIMIT_4 ))
     78          
     79          /*********************************************************************
     80           * TYPEDEFS
     81           */
     82          
     83          typedef struct
     84          {
     85            uint16 id;
     86            uint16 len;   // Enforce Flash-WORD size on len.
     87            uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
     88            uint16 stat;  // Item status.
     89          } osalNvHdr_t;
     90          // Struct member offsets.
     91          #define OSAL_NV_HDR_ID    0
     92          #define OSAL_NV_HDR_LEN   2
     93          #define OSAL_NV_HDR_CHK   4
     94          #define OSAL_NV_HDR_STAT  6
     95          
     96          #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
     97          #define OSAL_NV_HDR_SIZE  8
     98          #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
     99          
    100          typedef struct
    101          {
    102            uint16 active;
    103            uint16 inUse;
    104            uint16 xfer;
    105            uint16 spare;
    106          } osalNvPgHdr_t;
    107          // Struct member offsets.
    108          #define OSAL_NV_PG_ACTIVE 0
    109          #define OSAL_NV_PG_INUSE  2
    110          #define OSAL_NV_PG_XFER   4
    111          #define OSAL_NV_PG_SPARE  6
    112          
    113          #define OSAL_NV_PAGE_HDR_SIZE  8
    114          #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
    115          
    116          typedef enum
    117          {
    118            eNvXfer,
    119            eNvZero
    120          } eNvHdrEnum;
    121          
    122          typedef enum
    123          {
    124            ePgActive,
    125            ePgInUse,
    126            ePgXfer,
    127            ePgSpare
    128          } ePgHdrEnum;
    129          
    130          /*********************************************************************
    131           * GLOBAL VARIABLES
    132           */
    133          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    134          uint8 __xdata FBuff[4];  // Flash buffer for DMA transfer.
   \                     FBuff:
   \   000000                DS 4
    135          
    136          /*********************************************************************
    137           * EXTERNAL VARIABLES
    138           */
    139          
    140          /*********************************************************************
    141           * EXTERNAL FUNCTIONS
    142           */
    143          
    144          extern __near_func uint8 GetCodeByte(uint32);
    145          extern __near_func void halFlashDmaTrigger(void);
    146          
    147          extern bool HalAdcCheckVdd(uint8 limit);
    148          
    149          /*********************************************************************
    150           * LOCAL VARIABLES
    151           */
    152          
    153          // Offset into the page of the first available erased space.

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    154          static uint16 pgOff[OSAL_NV_PAGES_USED];
   \                     ??pgOff:
   \   000000                DS 4
    155          
    156          // Count of the bytes lost for the zeroed-out items.

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    157          static uint16 pgLost[OSAL_NV_PAGES_USED];
   \                     ??pgLost:
   \   000000                DS 4
    158          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    159          static uint8 pgRes;  // Page reserved for item compacting transfer.
   \                     ??pgRes:
   \   000000                DS 1
    160          
    161          /* It saves ~100 code bytes to move a uint8* parameter/return value from findItem()
    162           * to this local global.
    163           */

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    164          static uint8 findPg;
   \                     ??findPg:
   \   000000                DS 1
    165          
    166          /* Immediately before the voltage critical operations of a page erase or
    167           * a word write, check bus voltage. If less than min, set global flag & abort.
    168           * Since this is to be done at the lowest level, many void functions would have to be changed to
    169           * return a value and code added to check that value before proceeding, resulting in a very
    170           * expensive code size hit for implementing this properly. Therefore, use this global as follows:
    171           * at the start of osal_nv_item_init/osal_nv_write, set to FALSE, and at the end, before returning,
    172           * check the value. Thus, the global is an accumulator of any error that occurred in any of the
    173           * attempts to modify Flash with a low bus voltage during the complicated sequence of events that
    174           * may occur on any item init or write. This is much more expedient and code saving than adding
    175           * return values and checking return values to early out. No matter which method is used, an NV
    176           * data record may end up mangled due to the low VCC conditions. The strategy is that the headers
    177           * and checksums will detect and allow recovery from such a condition.
    178           *
    179           * One unfortunate side-effect of using the global fail flag vice adding and checking return
    180           * values, is that setItem(), unaware that setting an item Id to zero has failed due to the low VCC
    181           * check, will still update the page Lost bytes counter. Having an artificially high lost byte
    182           * count makes it look like there are more bytes to recover from compacting a page than there may
    183           * actually be. An easy work-around it to invoke initNV() from osal_nv_item_init or osal_nv_write
    184           * anytime that the failF gets set - this will re-walk all of the pages and set the page offset
    185           * count and page lost bytes count to their actual values.
    186           */

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    187          static uint8 failF;
   \                     ??failF:
   \   000000                DS 1
    188          
    189          /*********************************************************************
    190           * LOCAL FUNCTIONS
    191           */
    192          
    193          static void   initDMA( void );
    194          static void   execDMA( void );
    195          
    196          static uint8  initNV( void );
    197          
    198          static void   setPageUse( uint8 pg, uint8 inUse );
    199          static uint16 initPage( uint8 pg, uint16 id );
    200          static void   erasePage( uint8 pg );
    201          static void   compactPage( uint8 pg );
    202          
    203          static uint16 findItem( uint16 id );
    204          static uint8  initItem( uint16 id, uint16 len, void *buf );
    205          static uint8  initItem2( uint16 id, uint16 len, uint8 *comPg );
    206          static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
    207          
    208          static uint16 calcChkB( uint16 len, uint8 *buf );
    209          static uint16 calcChkF( byte pg, uint16 offset, uint16 len );
    210          
    211          static void   readHdr( uint8 pg, uint16 offset, uint8 *buf );
    212          static void   readWord( uint8 pg, uint16 offset, uint8 *buf );
    213          
    214          static void   writeWord( uint8 pg, uint16 offset, uint8 *buf );
    215          static void   writeWordD( uint8 pg, uint16 offset, uint8 *buf );
    216          static void   writeWordH( uint8 pg, uint16 offset, uint8 *buf );
    217          static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
    218          static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
    219          
    220          static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf );
    221          
    222          /*********************************************************************
    223           * @fn      initDMA
    224           *
    225           * @brief   Initialize the DMA Channel for NV flash operations.
    226           *
    227           * @param   none
    228           *
    229           * @return  None
    230           */
    231          static void initDMA( void )
    232          {
    233            // Start address of the destination is the Flash Write Data register.
    234            OSAL_NV_DMA_CH->dstAddrH = 0xdf;
    235            OSAL_NV_DMA_CH->dstAddrL = 0xaf;
    236            OSAL_NV_DMA_CH->srcAddrH = (uint16)FBuff >> 8;
    237            OSAL_NV_DMA_CH->srcAddrL = (uint16)FBuff;
    238          
    239            // Using the length field to determine how many bytes to transfer.
    240            HAL_DMA_SET_VLEN( OSAL_NV_DMA_CH, HAL_DMA_VLEN_USE_LEN );
    241          
    242            // Transfer 4 bytes at a time.
    243            HAL_DMA_SET_LEN( OSAL_NV_DMA_CH, OSAL_NV_WORD_SIZE );
    244          
    245            // Transfer size is 1 byte.
    246            HAL_DMA_SET_WORD_SIZE( OSAL_NV_DMA_CH, HAL_DMA_WORDSIZE_BYTE );
    247          
    248            // After every 4-byte transfer, must await Flash write done indication.
    249            HAL_DMA_SET_TRIG_MODE( OSAL_NV_DMA_CH, HAL_DMA_TMODE_SINGLE );
    250            HAL_DMA_SET_TRIG_SRC( OSAL_NV_DMA_CH, HAL_DMA_TRIG_FLASH );
    251          
    252            // The source address is incremented by 1 byte after each transfer.
    253            HAL_DMA_SET_SRC_INC( OSAL_NV_DMA_CH, HAL_DMA_SRCINC_1 );
    254          
    255            // The destination address is constant - the Flash Write Data register.
    256            HAL_DMA_SET_DST_INC( OSAL_NV_DMA_CH, HAL_DMA_DSTINC_0 );
    257          
    258            // The DMA is to be polled and shall not issue an IRQ upon completion.
    259            HAL_DMA_SET_IRQ( OSAL_NV_DMA_CH, HAL_DMA_IRQMASK_DISABLE );
    260          
    261            // Xfer all 8 bits of a byte xfer.
    262            HAL_DMA_SET_M8( OSAL_NV_DMA_CH, HAL_DMA_M8_USE_8_BITS );
    263          
    264            // DMA memory access has highest priority.
    265            HAL_DMA_SET_PRIORITY( OSAL_NV_DMA_CH, HAL_DMA_PRI_HIGH );
    266          }
    267          
    268          /*********************************************************************
    269           * @fn      execDMA
    270           *
    271           * @brief   Arms and triggers a DMA write to Flash memory.
    272           *
    273           * @param   none
    274           *
    275           * @return  none
    276           */
    277          static void execDMA( void )
    278          {
    279            if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
    280            {
    281              failF = TRUE;
    282              return;
    283            }
    284          
    285            HAL_DMA_CLEAR_IRQ( 0 );
    286          
    287            HAL_DMA_ARM_CH( 0 );
    288          
    289            halFlashDmaTrigger();
    290          
    291            while ( !(HAL_DMA_CHECK_IRQ( 0 )) );
    292          
    293            while ( FCTL & FWBUSY );
    294          }
    295          
    296          /*********************************************************************
    297           * @fn      initNV
    298           *
    299           * @brief   Initialize the NV flash pages.
    300           *
    301           * @param   none
    302           *
    303           * @return  TRUE if NV pages seem ok; FALSE otherwise.
    304           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    305          static uint8 initNV( void )
   \                     ??initNV:
    306          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    307            osalNvPgHdr_t pgHdr, ieee;
    308            uint8 oldPg = OSAL_NV_PAGE_NULL;
   \   00000A   75..00       MOV     ?V0 + 1,#0x0
    309            uint8 newPg = OSAL_NV_PAGE_NULL;
   \   00000D   7F00         MOV     R7,#0x0
    310            uint8 xBad;
    311            uint8 pg;
    312          
    313            readHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
   \   00000F                ; Setup parameters for call to function readHdr
   \   00000F   7408         MOV     A,#0x8
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   7AF8         MOV     R2,#-0x8
   \   00001A   7B07         MOV     R3,#0x7
   \   00001C   793F         MOV     R1,#0x3f
   \   00001E   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   000021   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   000023   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    314            if ( (ieee.active == OSAL_NV_ERASED_ID) &&
    315                 (ieee.inUse == OSAL_NV_ERASED_ID) &&
    316                 (ieee.xfer == OSAL_NV_ERASED_ID) &&
    317                 (ieee.spare == OSAL_NV_ERASED_ID) )
   \   000026   7408         MOV     A,#0x8
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   64FF         XRL     A,#0xff
   \   00002E   7004         JNZ     ??initNV_1
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   64FF         XRL     A,#0xff
   \                     ??initNV_1:
   \   000034   7035         JNZ     ??initNV_2
   \   000036   740A         MOV     A,#0xa
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   64FF         XRL     A,#0xff
   \   00003E   7004         JNZ     ??initNV_3
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   64FF         XRL     A,#0xff
   \                     ??initNV_3:
   \   000044   7025         JNZ     ??initNV_2
   \   000046   740C         MOV     A,#0xc
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   64FF         XRL     A,#0xff
   \   00004E   7004         JNZ     ??initNV_4
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   64FF         XRL     A,#0xff
   \                     ??initNV_4:
   \   000054   7015         JNZ     ??initNV_2
   \   000056   740E         MOV     A,#0xe
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   64FF         XRL     A,#0xff
   \   00005E   7004         JNZ     ??initNV_5
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   64FF         XRL     A,#0xff
   \                     ??initNV_5:
   \   000064   7005         JNZ     ??initNV_2
    318            {
    319              xBad = TRUE;
   \   000066   75..01       MOV     ?V0 + 0,#0x1
   \   000069   8002         SJMP    ??initNV_6
    320            }
    321            else
    322            {
    323              xBad = FALSE;
   \                     ??initNV_2:
   \   00006B   8F..         MOV     ?V0 + 0,R7
    324            }
    325          
    326            pgRes = OSAL_NV_PAGE_NULL;
   \                     ??initNV_6:
   \   00006D   E4           CLR     A
   \   00006E   90....       MOV     DPTR,#??pgRes
   \   000071   F0           MOVX    @DPTR,A
    327          
    328            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   000072   7E3C         MOV     R6,#0x3c
    329            {
    330          #if OSAL_NV_CLEANUP
    331              OSAL_NV_PAGE_ERASE( pg );
    332              asm( "NOP" );
    333          #endif
    334          
    335              readHdr( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr) );
   \                     ??initNV_7:
   \   000074                ; Setup parameters for call to function readHdr
   \   000074   85..82       MOV     DPL,?XSP + 0
   \   000077   85..83       MOV     DPH,?XSP + 1
   \   00007A   AC82         MOV     R4,DPL
   \   00007C   AD83         MOV     R5,DPH
   \   00007E   7A00         MOV     R2,#0x0
   \   000080   7B00         MOV     R3,#0x0
   \   000082   EE           MOV     A,R6
   \   000083   F9           MOV     R1,A
   \   000084   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   000087   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   000089   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    336          
    337              if ( pgHdr.active == OSAL_NV_ERASED_ID )
   \   00008C   85..82       MOV     DPL,?XSP + 0
   \   00008F   85..83       MOV     DPH,?XSP + 1
   \   000092   E0           MOVX    A,@DPTR
   \   000093   64FF         XRL     A,#0xff
   \   000095   7004         JNZ     ??initNV_8
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   64FF         XRL     A,#0xff
   \                     ??initNV_8:
   \   00009B   7018         JNZ     ??initNV_9
    338              {
    339                if ( pgRes == OSAL_NV_PAGE_NULL )
   \   00009D   90....       MOV     DPTR,#??pgRes
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   7004         JNZ     ??initNV_10
    340                {
    341                  pgRes = pg;
   \   0000A3   EE           MOV     A,R6
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   8034         SJMP    ??initNV_11
    342                }
    343                else
    344                {
    345                  setPageUse( pg, TRUE );
   \                     ??initNV_10:
   \   0000A7                ; Setup parameters for call to function setPageUse
   \   0000A7   7A01         MOV     R2,#0x1
   \   0000A9   EE           MOV     A,R6
   \   0000AA   F9           MOV     R1,A
   \   0000AB   90....       MOV     DPTR,#(??setPageUse & 0xffff)
   \   0000AE   74..         MOV     A,#((??setPageUse >> 16) & 0xff)
   \   0000B0   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000B3   8026         SJMP    ??initNV_11
    346                }
    347              }
    348              else  // Page is active.
    349              {
    350                // If the page is not yet in use, it is the tgt of items from an xfer.
    351                if ( pgHdr.inUse == OSAL_NV_ERASED_ID )
   \                     ??initNV_9:
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   64FF         XRL     A,#0xff
   \   0000BD   7004         JNZ     ??initNV_12
   \   0000BF   A3           INC     DPTR
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   64FF         XRL     A,#0xff
   \                     ??initNV_12:
   \   0000C3   7004         JNZ     ??initNV_13
    352                {
    353                  newPg = pg;
   \   0000C5   EE           MOV     A,R6
   \   0000C6   FF           MOV     R7,A
   \   0000C7   8012         SJMP    ??initNV_11
    354                }
    355                // An Xfer from this page was in progress.
    356                else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
   \                     ??initNV_13:
   \   0000C9   7404         MOV     A,#0x4
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   64FF         XRL     A,#0xff
   \   0000D1   7004         JNZ     ??initNV_14
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   64FF         XRL     A,#0xff
   \                     ??initNV_14:
   \   0000D7   6002         JZ      ??initNV_11
    357                {
    358                  oldPg = pg;
   \   0000D9   8E..         MOV     ?V0 + 1,R6
    359                }
    360              }
    361          
    362              // Calculate page offset and lost bytes.
    363              initPage( pg, OSAL_NV_ITEM_NULL );
   \                     ??initNV_11:
   \   0000DB                ; Setup parameters for call to function initPage
   \   0000DB   7A00         MOV     R2,#0x0
   \   0000DD   7B00         MOV     R3,#0x0
   \   0000DF   EE           MOV     A,R6
   \   0000E0   F9           MOV     R1,A
   \   0000E1   90....       MOV     DPTR,#(??initPage & 0xffff)
   \   0000E4   74..         MOV     A,#((??initPage >> 16) & 0xff)
   \   0000E6   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    364          
    365              readHdr( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr) );
   \   0000E9                ; Setup parameters for call to function readHdr
   \   0000E9   85..82       MOV     DPL,?XSP + 0
   \   0000EC   85..83       MOV     DPH,?XSP + 1
   \   0000EF   AC82         MOV     R4,DPL
   \   0000F1   AD83         MOV     R5,DPH
   \   0000F3   7AF8         MOV     R2,#-0x8
   \   0000F5   7B07         MOV     R3,#0x7
   \   0000F7   EE           MOV     A,R6
   \   0000F8   F9           MOV     R1,A
   \   0000F9   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   0000FC   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   0000FE   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    366              if ( xBad )
   \   000101   E5..         MOV     A,?V0 + 0
   \   000103   85..82       MOV     DPL,?XSP + 0
   \   000106   85..83       MOV     DPH,?XSP + 1
   \   000109   6058         JZ      ??initNV_15
    367              {
    368                /* TBD - For the cost of more code space, the IEEE could be checksummed & then tested here
    369                 * before installing to the erased IEEE on page 63.
    370                 */
    371                if ( (pgHdr.active != OSAL_NV_ERASED_ID) ||
    372                     (pgHdr.inUse != OSAL_NV_ERASED_ID) ||
    373                     (pgHdr.xfer != OSAL_NV_ERASED_ID) ||
    374                     (pgHdr.spare != OSAL_NV_ERASED_ID) )
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   64FF         XRL     A,#0xff
   \   00010E   7004         JNZ     ??initNV_16
   \   000110   A3           INC     DPTR
   \   000111   E0           MOVX    A,@DPTR
   \   000112   64FF         XRL     A,#0xff
   \                     ??initNV_16:
   \   000114   7030         JNZ     ??initNV_17
   \   000116   7402         MOV     A,#0x2
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   64FF         XRL     A,#0xff
   \   00011E   7004         JNZ     ??initNV_18
   \   000120   A3           INC     DPTR
   \   000121   E0           MOVX    A,@DPTR
   \   000122   64FF         XRL     A,#0xff
   \                     ??initNV_18:
   \   000124   7020         JNZ     ??initNV_17
   \   000126   7404         MOV     A,#0x4
   \   000128   12....       LCALL   ?XSTACK_DISP0_8
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   64FF         XRL     A,#0xff
   \   00012E   7004         JNZ     ??initNV_19
   \   000130   A3           INC     DPTR
   \   000131   E0           MOVX    A,@DPTR
   \   000132   64FF         XRL     A,#0xff
   \                     ??initNV_19:
   \   000134   7010         JNZ     ??initNV_17
   \   000136   7406         MOV     A,#0x6
   \   000138   12....       LCALL   ?XSTACK_DISP0_8
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   64FF         XRL     A,#0xff
   \   00013E   7004         JNZ     ??initNV_20
   \   000140   A3           INC     DPTR
   \   000141   E0           MOVX    A,@DPTR
   \   000142   64FF         XRL     A,#0xff
   \                     ??initNV_20:
   \   000144   606F         JZ      ??initNV_21
    375                {
    376                  writeWordD( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&pgHdr) );
   \                     ??initNV_17:
   \   000146                ; Setup parameters for call to function writeWordD
   \   000146   85..82       MOV     DPL,?XSP + 0
   \   000149   85..83       MOV     DPH,?XSP + 1
   \   00014C   AC82         MOV     R4,DPL
   \   00014E   AD83         MOV     R5,DPH
   \   000150   7AF8         MOV     R2,#-0x8
   \   000152   7B07         MOV     R3,#0x7
   \   000154   793F         MOV     R1,#0x3f
   \   000156   90....       MOV     DPTR,#(??writeWordD & 0xffff)
   \   000159   74..         MOV     A,#((??writeWordD >> 16) & 0xff)
   \   00015B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    377                  xBad = FALSE;
   \   00015E   75..00       MOV     ?V0 + 0,#0x0
   \   000161   8052         SJMP    ??initNV_21
    378                }
    379              }
    380              else
    381              {
    382                if ( (pgHdr.active == OSAL_NV_ERASED_ID) &&
    383                     (pgHdr.inUse == OSAL_NV_ERASED_ID) &&
    384                     (pgHdr.xfer == OSAL_NV_ERASED_ID) &&
    385                     (pgHdr.spare == OSAL_NV_ERASED_ID) )
   \                     ??initNV_15:
   \   000163   E0           MOVX    A,@DPTR
   \   000164   64FF         XRL     A,#0xff
   \   000166   7004         JNZ     ??initNV_22
   \   000168   A3           INC     DPTR
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   64FF         XRL     A,#0xff
   \                     ??initNV_22:
   \   00016C   7047         JNZ     ??initNV_21
   \   00016E   7402         MOV     A,#0x2
   \   000170   12....       LCALL   ?XSTACK_DISP0_8
   \   000173   E0           MOVX    A,@DPTR
   \   000174   64FF         XRL     A,#0xff
   \   000176   7004         JNZ     ??initNV_23
   \   000178   A3           INC     DPTR
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   64FF         XRL     A,#0xff
   \                     ??initNV_23:
   \   00017C   7037         JNZ     ??initNV_21
   \   00017E   7404         MOV     A,#0x4
   \   000180   12....       LCALL   ?XSTACK_DISP0_8
   \   000183   E0           MOVX    A,@DPTR
   \   000184   64FF         XRL     A,#0xff
   \   000186   7004         JNZ     ??initNV_24
   \   000188   A3           INC     DPTR
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   64FF         XRL     A,#0xff
   \                     ??initNV_24:
   \   00018C   7027         JNZ     ??initNV_21
   \   00018E   7406         MOV     A,#0x6
   \   000190   12....       LCALL   ?XSTACK_DISP0_8
   \   000193   E0           MOVX    A,@DPTR
   \   000194   64FF         XRL     A,#0xff
   \   000196   7004         JNZ     ??initNV_25
   \   000198   A3           INC     DPTR
   \   000199   E0           MOVX    A,@DPTR
   \   00019A   64FF         XRL     A,#0xff
   \                     ??initNV_25:
   \   00019C   7017         JNZ     ??initNV_21
    386                {
    387                  writeWordD( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
   \   00019E                ; Setup parameters for call to function writeWordD
   \   00019E   7408         MOV     A,#0x8
   \   0001A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A3   AC82         MOV     R4,DPL
   \   0001A5   AD83         MOV     R5,DPH
   \   0001A7   7AF8         MOV     R2,#-0x8
   \   0001A9   7B07         MOV     R3,#0x7
   \   0001AB   EE           MOV     A,R6
   \   0001AC   F9           MOV     R1,A
   \   0001AD   90....       MOV     DPTR,#(??writeWordD & 0xffff)
   \   0001B0   74..         MOV     A,#((??writeWordD >> 16) & 0xff)
   \   0001B2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    388                }
    389              }
    390            }  // for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \                     ??initNV_21:
   \   0001B5   0E           INC     R6
   \   0001B6   EE           MOV     A,R6
   \   0001B7   C3           CLR     C
   \   0001B8   943E         SUBB    A,#0x3e
   \   0001BA   5003         JNC     $+5
   \   0001BC   02....       LJMP    ??initNV_7 & 0xFFFF
    391          
    392            /* First the old page is erased, and then the new page is put into use.
    393             * So if a transfer was in progress, the new page will always not yet be
    394             * marked as in use, since that is the last step to ending a transfer.
    395             */
    396            if ( newPg != OSAL_NV_PAGE_NULL )
   \   0001BF   EF           MOV     A,R7
   \   0001C0   6023         JZ      ??initNV_26
    397            {
    398              /* If there is already a fallow page reserved, keep it and put the newPg in use.
    399               * An unfinished compaction will finish to the new reserve page and the old page
    400               * will be erased and reserved.
    401               */
    402              if ( pgRes != OSAL_NV_PAGE_NULL )
   \   0001C2   90....       MOV     DPTR,#??pgRes
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   600E         JZ      ??initNV_27
    403              {
    404                setPageUse( newPg, TRUE );
   \   0001C8                ; Setup parameters for call to function setPageUse
   \   0001C8   7A01         MOV     R2,#0x1
   \   0001CA   EF           MOV     A,R7
   \   0001CB   F9           MOV     R1,A
   \   0001CC   90....       MOV     DPTR,#(??setPageUse & 0xffff)
   \   0001CF   74..         MOV     A,#((??setPageUse >> 16) & 0xff)
   \   0001D1   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0001D4   8002         SJMP    ??initNV_28
    405              }
    406              else
    407              {
    408                pgRes = newPg;
   \                     ??initNV_27:
   \   0001D6   EF           MOV     A,R7
   \   0001D7   F0           MOVX    @DPTR,A
    409              }
    410          
    411              /* If a page compaction was interrupted and the page being compacted is not
    412               * yet erased, then there may be items remaining to xfer before erasing.
    413               */
    414              if ( oldPg != OSAL_NV_PAGE_NULL )
   \                     ??initNV_28:
   \   0001D8   E5..         MOV     A,?V0 + 1
   \   0001DA   6009         JZ      ??initNV_26
    415              {
    416                compactPage( oldPg );
   \   0001DC                ; Setup parameters for call to function compactPage
   \   0001DC   F9           MOV     R1,A
   \   0001DD   90....       MOV     DPTR,#(??compactPage & 0xffff)
   \   0001E0   74..         MOV     A,#((??compactPage >> 16) & 0xff)
   \   0001E2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    417              }
    418            }
    419          
    420            return (pgRes != OSAL_NV_PAGE_NULL);
   \                     ??initNV_26:
   \   0001E5   90....       MOV     DPTR,#??pgRes
   \   0001E8   E0           MOVX    A,@DPTR
   \   0001E9   6004         JZ      ??initNV_29
   \   0001EB   7901         MOV     R1,#0x1
   \   0001ED   8002         SJMP    ??initNV_30
   \                     ??initNV_29:
   \   0001EF   7900         MOV     R1,#0x0
   \                     ??initNV_30:
   \   0001F1   7410         MOV     A,#0x10
   \   0001F3                REQUIRE ?Subroutine66
   \   0001F3                ; // Fall through to label ?Subroutine66
    421          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F02         MOV     R7,#0x2
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    422          
    423          /*********************************************************************
    424           * @fn      setPageUse
    425           *
    426           * @brief   Set page header active/inUse state according to 'inUse'.
    427           *
    428           * @param   pg - Valid NV page to verify and init.
    429           * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
    430           *
    431           * @return  none
    432           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    433          static void setPageUse( uint8 pg, uint8 inUse )
   \                     ??setPageUse:
    434          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    435            osalNvPgHdr_t pgHdr;
    436          
    437            pgHdr.active = OSAL_NV_ZEROED_ID;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
    438          
    439            if ( inUse )
   \   000013   EA           MOV     A,R2
   \   000014   6008         JZ      ??setPageUse_1
    440            {
    441              pgHdr.inUse = OSAL_NV_ZEROED_ID;
   \   000016   7402         MOV     A,#0x2
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   E4           CLR     A
   \   00001C   8007         SJMP    ??setPageUse_2
    442            }
    443            else
    444            {
    445              pgHdr.inUse = OSAL_NV_ERASED_ID;
   \                     ??setPageUse_1:
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   74FF         MOV     A,#-0x1
   \                     ??setPageUse_2:
   \   000025   12....       LCALL   ??Subroutine29_0 & 0xFFFF
    446            }
    447          
    448            writeWord( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*)(&pgHdr) );
   \                     ??CrossCallReturnLabel_81:
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \   00002C   90....       MOV     DPTR,#(??writeWord & 0xffff)
   \   00002F   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   000031   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    449          }
   \   000034   7408         MOV     A,#0x8
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   \   000039                REQUIRE ?Subroutine67
   \   000039                ; // Fall through to label ?Subroutine67

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E4           CLR     A
   \                     ??Subroutine29_0:
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \                     ??Subroutine29_1:
   \   000009   F0           MOVX    @DPTR,A
   \   00000A                ; Setup parameters for call to function writeWordH
   \   00000A                ; Setup parameters for call to function writeWord
   \   00000A                ; Setup parameters for call to function writeWord
   \   00000A                ; Setup parameters for call to function writeWord
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   22           RET
    450          
    451          /*********************************************************************
    452           * @fn      initPage
    453           *
    454           * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
    455           *
    456           * @param   pg - Valid NV page to verify and init.
    457           * @param   id - Valid NV item Id to use function as a "findItem".
    458           *               If set to NULL then just perform the page initialization.
    459           *
    460           * @return  If 'id' is non-NULL and good checksums are found, return the offset
    461           *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
    462           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    463          static uint16 initPage( uint8 pg, uint16 id )
   \                     ??initPage:
    464          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000013   89..         MOV     ?V0 + 6,R1
    465            uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
   \   000015   75..08       MOV     ?V0 + 2,#0x8
   \   000018   75..00       MOV     ?V0 + 3,#0x0
    466            uint16 sz, lost = 0;
   \   00001B   7E00         MOV     R6,#0x0
   \   00001D   7F00         MOV     R7,#0x0
   \   00001F   8037         SJMP    ??initPage_1
    467            osalNvHdr_t hdr;
    468          
    469            do
    470            {
    471              readHdr( pg, offset, (uint8 *)(&hdr) );
    472          
    473              if ( hdr.id == OSAL_NV_ERASED_ID )
    474              {
    475                break;
    476              }
    477              offset += OSAL_NV_HDR_SIZE;
    478              sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
    479          
    480              // A bad 'len' write has blown away the rest of the page.
    481              if ( (offset + sz) > OSAL_NV_PAGE_FREE )
    482              {
    483                lost += (OSAL_NV_PAGE_FREE - offset + OSAL_NV_HDR_SIZE);
    484                offset = OSAL_NV_PAGE_FREE;
    485                break;
    486              }
    487          
    488              if ( hdr.id != OSAL_NV_ZEROED_ID )
    489              {
    490                if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
    491                {
    492                  /* This trick allows function to do double duty for findItem() without
    493                   * compromising its essential functionality at powerup initialization.
    494                   */
    495                  if ( id != OSAL_NV_ITEM_NULL )
    496                  {
    497                    /* This trick allows asking to find the old/transferred item in case
    498                     * of a successful new item write that gets interrupted before the
    499                     * old item can be zeroed out.
    500                     */
    501                    if ( (id & 0x7fff) == hdr.id )
    502                    {
    503                      if ( (((id & 0x8000) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
    504                           (((id & 0x8000) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
    505                      {
    506                        return offset;
    507                      }
    508                    }
    509                  }
    510                  // When invoked from the osal_nv_init(), find and zero any duplicates.
    511                  else if ( hdr.stat == OSAL_NV_ERASED_ID )
    512                  {
    513                    /* The trick of setting the MSB of the item Id causes the logic
    514                     * immediately above to return a valid page only if the header 'stat'
    515                     * indicates that it was the older item being transferred.
    516                     */
    517                    uint16 off = findItem( (hdr.id | 0x8000) );
    518          
    519                    if ( off != OSAL_NV_ITEM_NULL )
    520                    {
    521                      setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
    522                    }
    523                  }
    524                }
    525                else
    526                {
    527                  setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
   \                     ??initPage_2:
   \   000021                ; Setup parameters for call to function setItem
   \   000021   7C01         MOV     R4,#0x1
   \   000023   AA..         MOV     R2,?V0 + 2
   \   000025   AB..         MOV     R3,?V0 + 3
   \   000027   A9..         MOV     R1,?V0 + 6
   \                     ??initPage_3:
   \   000029   90....       MOV     DPTR,#(??setItem & 0xffff)
   \   00002C   74..         MOV     A,#((??setItem >> 16) & 0xff)
   \   00002E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    528                }
    529              }
    530          
    531              if ( hdr.id == OSAL_NV_ZEROED_ID )
   \                     ??initPage_4:
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E0           MOVX    A,@DPTR
   \   000037   7002         JNZ     ??initPage_5
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \                     ??initPage_5:
   \   00003B   700F         JNZ     ??initPage_6
    532              {
    533                lost += (OSAL_NV_HDR_SIZE + sz);
   \   00003D   7408         MOV     A,#0x8
   \   00003F   25..         ADD     A,?V0 + 0
   \   000041   F8           MOV     R0,A
   \   000042   E4           CLR     A
   \   000043   35..         ADDC    A,?V0 + 1
   \   000045   F9           MOV     R1,A
   \   000046   EE           MOV     A,R6
   \   000047   28           ADD     A,R0
   \   000048   FE           MOV     R6,A
   \   000049   EF           MOV     A,R7
   \   00004A   39           ADDC    A,R1
   \   00004B   FF           MOV     R7,A
    534              }
    535              offset += sz;
   \                     ??initPage_6:
   \   00004C   E5..         MOV     A,?V0 + 2
   \   00004E   25..         ADD     A,?V0 + 0
   \   000050   F5..         MOV     ?V0 + 2,A
   \   000052   E5..         MOV     A,?V0 + 3
   \   000054   35..         ADDC    A,?V0 + 1
   \   000056   F5..         MOV     ?V0 + 3,A
    536          
    537            } while ( TRUE );
   \                     ??initPage_1:
   \   000058                ; Setup parameters for call to function readHdr
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   AC82         MOV     R4,DPL
   \   00005F   AD83         MOV     R5,DPH
   \   000061   AA..         MOV     R2,?V0 + 2
   \   000063   AB..         MOV     R3,?V0 + 3
   \   000065   A9..         MOV     R1,?V0 + 6
   \   000067   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   00006A   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   00006C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00006F   7402         MOV     A,#0x2
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   64FF         XRL     A,#0xff
   \   000077   7004         JNZ     ??initPage_7
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   64FF         XRL     A,#0xff
   \                     ??initPage_7:
   \   00007D   603C         JZ      ??initPage_8
   \   00007F   E5..         MOV     A,?V0 + 2
   \   000081   2408         ADD     A,#0x8
   \   000083   F5..         MOV     ?V0 + 2,A
   \   000085   E5..         MOV     A,?V0 + 3
   \   000087   3400         ADDC    A,#0x0
   \   000089   F5..         MOV     ?V0 + 3,A
   \   00008B   7404         MOV     A,#0x4
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000093   F5..         MOV     ?V0 + 0,A
   \   000095   74FF         MOV     A,#-0x1
   \   000097   59           ANL     A,R1
   \   000098   F5..         MOV     ?V0 + 1,A
   \   00009A   E5..         MOV     A,?V0 + 0
   \   00009C   25..         ADD     A,?V0 + 2
   \   00009E   F8           MOV     R0,A
   \   00009F   E9           MOV     A,R1
   \   0000A0   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   0000A3   4037         JC      ??initPage_9
   \   0000A5   E4           CLR     A
   \   0000A6   2E           ADD     A,R6
   \   0000A7   F8           MOV     R0,A
   \   0000A8   7408         MOV     A,#0x8
   \   0000AA   3F           ADDC    A,R7
   \   0000AB   F9           MOV     R1,A
   \   0000AC   E8           MOV     A,R0
   \   0000AD   C3           CLR     C
   \   0000AE   95..         SUBB    A,?V0 + 2
   \   0000B0   FE           MOV     R6,A
   \   0000B1   E9           MOV     A,R1
   \   0000B2   95..         SUBB    A,?V0 + 3
   \   0000B4   FF           MOV     R7,A
   \   0000B5   75..F8       MOV     ?V0 + 2,#-0x8
   \   0000B8   75..07       MOV     ?V0 + 3,#0x7
    538          
    539            pgOff[pg - OSAL_NV_PAGE_BEG] = offset;
   \                     ??initPage_8:
   \   0000BB   E5..         MOV     A,?V0 + 6
   \   0000BD   12....       LCALL   ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   0000C0   E5..         MOV     A,?V0 + 2
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   E5..         MOV     A,?V0 + 3
   \   0000C6   12....       LCALL   ?Subroutine32 & 0xFFFF
    540            pgLost[pg - OSAL_NV_PAGE_BEG] = lost;
   \                     ??CrossCallReturnLabel_89:
   \   0000C9   EE           MOV     A,R6
   \   0000CA   F0           MOVX    @DPTR,A
   \   0000CB   A3           INC     DPTR
   \   0000CC   EF           MOV     A,R7
   \   0000CD   F0           MOVX    @DPTR,A
    541          
    542            return OSAL_NV_ITEM_NULL;
   \   0000CE   7A00         MOV     R2,#0x0
   \   0000D0   7B00         MOV     R3,#0x0
   \                     ??initPage_10:
   \   0000D2   740A         MOV     A,#0xa
   \   0000D4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D7   7F07         MOV     R7,#0x7
   \   0000D9   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??initPage_9:
   \   0000DC   7402         MOV     A,#0x2
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   7002         JNZ     ??initPage_11
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \                     ??initPage_11:
   \   0000E6   7003         JNZ     $+5
   \   0000E8   02....       LJMP    ??initPage_4 & 0xFFFF
   \   0000EB                ; Setup parameters for call to function calcChkF
   \   0000EB   7404         MOV     A,#0x4
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0000F3   AA..         MOV     R2,?V0 + 2
   \   0000F5   AB..         MOV     R3,?V0 + 3
   \   0000F7   A9..         MOV     R1,?V0 + 6
   \   0000F9   90....       MOV     DPTR,#(??calcChkF & 0xffff)
   \   0000FC   74..         MOV     A,#((??calcChkF >> 16) & 0xff)
   \   0000FE   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000101   8A..         MOV     ?V0 + 4,R2
   \   000103   8B..         MOV     ?V0 + 5,R3
   \   000105   A8..         MOV     R0,?V0 + 4
   \   000107   A9..         MOV     R1,?V0 + 5
   \   000109   7406         MOV     A,#0x6
   \   00010B   12....       LCALL   ?XSTACK_DISP0_8
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   68           XRL     A,R0
   \   000110   7003         JNZ     ??initPage_12
   \   000112   A3           INC     DPTR
   \   000113   E0           MOVX    A,@DPTR
   \   000114   69           XRL     A,R1
   \                     ??initPage_12:
   \   000115   6003         JZ      $+5
   \   000117   02....       LJMP    ??initPage_2 & 0xFFFF
   \   00011A   85..82       MOV     DPL,?XSP + 0
   \   00011D   85..83       MOV     DPH,?XSP + 1
   \   000120   E0           MOVX    A,@DPTR
   \   000121   7002         JNZ     ??initPage_13
   \   000123   A3           INC     DPTR
   \   000124   E0           MOVX    A,@DPTR
   \                     ??initPage_13:
   \   000125   605E         JZ      ??initPage_14
   \   000127   85..82       MOV     DPL,?XSP + 0
   \   00012A   85..83       MOV     DPH,?XSP + 1
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   F8           MOV     R0,A
   \   00012F   A3           INC     DPTR
   \   000130   E0           MOVX    A,@DPTR
   \   000131   547F         ANL     A,#0x7f
   \   000133   F9           MOV     R1,A
   \   000134   7402         MOV     A,#0x2
   \   000136   12....       LCALL   ?XSTACK_DISP0_8
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   68           XRL     A,R0
   \   00013B   7003         JNZ     ??initPage_15
   \   00013D   A3           INC     DPTR
   \   00013E   E0           MOVX    A,@DPTR
   \   00013F   69           XRL     A,R1
   \                     ??initPage_15:
   \   000140   6003         JZ      $+5
   \   000142   02....       LJMP    ??initPage_4 & 0xFFFF
   \   000145   85..82       MOV     DPL,?XSP + 0
   \   000148   85..83       MOV     DPH,?XSP + 1
   \   00014B   A3           INC     DPTR
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   5480         ANL     A,#0x80
   \   00014F   F9           MOV     R1,A
   \   000150   E4           CLR     A
   \   000151   7001         JNZ     ??initPage_16
   \   000153   E9           MOV     A,R1
   \                     ??initPage_16:
   \   000154   7015         JNZ     ??initPage_17
   \   000156   7408         MOV     A,#0x8
   \   000158   12....       LCALL   ?XSTACK_DISP0_8
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   64FF         XRL     A,#0xff
   \   00015E   7004         JNZ     ??initPage_18
   \   000160   A3           INC     DPTR
   \   000161   E0           MOVX    A,@DPTR
   \   000162   64FF         XRL     A,#0xff
   \                     ??initPage_18:
   \   000164   6003         JZ      $+5
   \   000166   02....       LJMP    ??initPage_4 & 0xFFFF
   \   000169   8013         SJMP    ??initPage_19
   \                     ??initPage_17:
   \   00016B   7408         MOV     A,#0x8
   \   00016D   12....       LCALL   ?XSTACK_DISP0_8
   \   000170   E0           MOVX    A,@DPTR
   \   000171   64FF         XRL     A,#0xff
   \   000173   7004         JNZ     ??initPage_20
   \   000175   A3           INC     DPTR
   \   000176   E0           MOVX    A,@DPTR
   \   000177   64FF         XRL     A,#0xff
   \                     ??initPage_20:
   \   000179   7003         JNZ     $+5
   \   00017B   02....       LJMP    ??initPage_4 & 0xFFFF
   \                     ??initPage_19:
   \   00017E   AA..         MOV     R2,?V0 + 2
   \   000180   AB..         MOV     R3,?V0 + 3
   \   000182   02....       LJMP    ??initPage_10 & 0xFFFF
   \                     ??initPage_14:
   \   000185   7408         MOV     A,#0x8
   \   000187   12....       LCALL   ?XSTACK_DISP0_8
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   64FF         XRL     A,#0xff
   \   00018D   7004         JNZ     ??initPage_21
   \   00018F   A3           INC     DPTR
   \   000190   E0           MOVX    A,@DPTR
   \   000191   64FF         XRL     A,#0xff
   \                     ??initPage_21:
   \   000193   6003         JZ      $+5
   \   000195   02....       LJMP    ??initPage_4 & 0xFFFF
   \   000198                ; Setup parameters for call to function findItem
   \   000198   7402         MOV     A,#0x2
   \   00019A   12....       LCALL   ?XSTACK_DISP0_8
   \   00019D   E0           MOVX    A,@DPTR
   \   00019E   FA           MOV     R2,A
   \   00019F   A3           INC     DPTR
   \   0001A0   E0           MOVX    A,@DPTR
   \   0001A1   4480         ORL     A,#0x80
   \   0001A3   FB           MOV     R3,A
   \   0001A4   90....       MOV     DPTR,#(??findItem & 0xffff)
   \   0001A7   74..         MOV     A,#((??findItem >> 16) & 0xff)
   \   0001A9   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0001AC   EA           MOV     A,R2
   \   0001AD   7001         JNZ     ??initPage_22
   \   0001AF   EB           MOV     A,R3
   \                     ??initPage_22:
   \   0001B0   7003         JNZ     $+5
   \   0001B2   02....       LJMP    ??initPage_4 & 0xFFFF
   \   0001B5                ; Setup parameters for call to function setItem
   \   0001B5   7C01         MOV     R4,#0x1
   \   0001B7   90....       MOV     DPTR,#??findPg
   \   0001BA   E0           MOVX    A,@DPTR
   \   0001BB   F9           MOV     R1,A
   \   0001BC   02....       LJMP    ??initPage_3 & 0xFFFF
    543          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   EE           MOV     A,R6
   \                     ??Subroutine45_0:
   \   000001   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   E8           MOV     A,R0
   \   000001   24..         ADD     A,#((??pgLost + 136) & 0xff)
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006   34..         ADDC    A,#(((??pgLost - 120) >> 8) & 0xff)
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2403         ADD     A,#0x3
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   F9           MOV     R1,A
   \   000009   74FC         MOV     A,#-0x4
   \   00000B   58           ANL     A,R0
   \   00000C   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   C3           CLR     C
   \   000001   33           RLC     A
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   33           RLC     A
   \   000005   F9           MOV     R1,A
   \   000006   E8           MOV     A,R0
   \   000007   24..         ADD     A,#((??pgOff + 136) & 0xff)
   \   000009   F582         MOV     DPL,A
   \   00000B   E9           MOV     A,R1
   \   00000C   34..         ADDC    A,#(((??pgOff - 120) >> 8) & 0xff)
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   35..         ADDC    A,?V0 + 3
   \   000002   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   F9           MOV     R1,A
   \                     ??Subroutine61_0:
   \   000001   C3           CLR     C
   \   000002   E8           MOV     A,R0
   \   000003   94F9         SUBB    A,#-0x7
   \   000005   E9           MOV     A,R1
   \   000006   9407         SUBB    A,#0x7
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    544          
    545          /*********************************************************************
    546           * @fn      erasePage
    547           *
    548           * @brief   Erases a page in Flash.
    549           *
    550           * @param   pg - Valid NV page to erase.
    551           *
    552           * @return  none
    553           */
    554          static void erasePage( uint8 pg )
    555          {
    556            osalNvHdr_t ieee;
    557          
    558            if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
    559            {
    560              failF = TRUE;
    561              return;
    562            }
    563          
    564            OSAL_NV_PAGE_ERASE( pg );
    565          
    566            pgOff[pg - OSAL_NV_PAGE_BEG] = OSAL_NV_PAGE_HDR_SIZE;
    567            pgLost[pg - OSAL_NV_PAGE_BEG] = 0;
    568          
    569            readHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
    570            if ( (ieee.id != OSAL_NV_ERASED_ID) ||
    571                 (ieee.len != OSAL_NV_ERASED_ID) ||
    572                 (ieee.chk != OSAL_NV_ERASED_ID) ||
    573                 (ieee.stat != OSAL_NV_ERASED_ID) )
    574            {
    575              writeWordD( pg, OSAL_NV_IEEE_OFFSET, (uint8 *)(&ieee) );
    576            }
    577          }
    578          
    579          /*********************************************************************
    580           * @fn      compactPage
    581           *
    582           * @brief   Compacts the page specified.
    583           *
    584           * @param   srcPg - Valid NV page to erase.
    585           *
    586           * @return  none
    587           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    588          static void compactPage( uint8 srcPg )
   \                     ??compactPage:
    589          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    590            uint16 dstOff = pgOff[pgRes-OSAL_NV_PAGE_BEG];
   \   00000C   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00000F   12....       LCALL   ?Subroutine19 & 0xFFFF
    591            uint16 srcOff = OSAL_NV_ZEROED_ID;
   \                     ??CrossCallReturnLabel_55:
   \   000012   12....       LCALL   ?Subroutine29 & 0xFFFF
    592            osalNvHdr_t hdr;
    593          
    594            // Mark page as being in process of compaction.
    595            writeWordH( srcPg, OSAL_NV_PG_XFER, (uint8*)(&srcOff) );
   \                     ??CrossCallReturnLabel_79:
   \   000015   7A04         MOV     R2,#0x4
   \   000017   FB           MOV     R3,A
   \   000018   EE           MOV     A,R6
   \   000019   F9           MOV     R1,A
   \   00001A   90....       MOV     DPTR,#(??writeWordH & 0xffff)
   \   00001D   74..         MOV     A,#((??writeWordH >> 16) & 0xff)
   \   00001F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    596          
    597            srcOff = OSAL_NV_PAGE_HDR_SIZE;
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   7408         MOV     A,#0x8
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   E4           CLR     A
   \   00002D   02....       LJMP    ??compactPage_1 & 0xFFFF
    598          
    599            do
    600            {
    601              uint16 sz;
    602              readHdr( srcPg, srcOff, (uint8 *)(&hdr) );
    603          
    604              if ( hdr.id == OSAL_NV_ERASED_ID )
    605              {
    606                break;
    607              }
    608          
    609              srcOff += OSAL_NV_HDR_SIZE;
    610          
    611              if ( (srcOff + hdr.len) > OSAL_NV_PAGE_FREE )
    612              {
    613                break;
    614              }
    615          
    616              sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
   \                     ??compactPage_2:
   \   000030   7404         MOV     A,#0x4
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000038   F5..         MOV     ?V0 + 4,A
   \   00003A   74FF         MOV     A,#-0x1
   \   00003C   59           ANL     A,R1
   \   00003D   F5..         MOV     ?V0 + 5,A
    617          
    618              if ( hdr.id != OSAL_NV_ZEROED_ID )
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   7002         JNZ     ??compactPage_3
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \                     ??compactPage_3:
   \   000049   7003         JNZ     $+5
   \   00004B   02....       LJMP    ??compactPage_4 & 0xFFFF
    619              {
    620                if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
   \   00004E                ; Setup parameters for call to function calcChkF
   \   00004E   7404         MOV     A,#0x4
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000056   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000059   90....       MOV     DPTR,#(??calcChkF & 0xffff)
   \   00005C   74..         MOV     A,#((??calcChkF >> 16) & 0xff)
   \   00005E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000061   8A..         MOV     ?V0 + 2,R2
   \   000063   8B..         MOV     ?V0 + 3,R3
   \   000065   A8..         MOV     R0,?V0 + 2
   \   000067   A9..         MOV     R1,?V0 + 3
   \   000069   7406         MOV     A,#0x6
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   68           XRL     A,R0
   \   000070   7003         JNZ     ??compactPage_5
   \   000072   A3           INC     DPTR
   \   000073   E0           MOVX    A,@DPTR
   \   000074   69           XRL     A,R1
   \                     ??compactPage_5:
   \   000075   7065         JNZ     ??compactPage_6
    621                {
    622                  setItem( srcPg, srcOff, eNvXfer );
   \   000077                ; Setup parameters for call to function setItem
   \   000077   7C00         MOV     R4,#0x0
   \   000079   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   00007C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    623                  writeBuf( pgRes, dstOff, OSAL_NV_HDR_SIZE, (byte *)(&hdr) );
   \   00007F                ; Setup parameters for call to function writeBuf
   \   00007F   7402         MOV     A,#0x2
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   8582..       MOV     ?V0 + 2,DPL
   \   000087   8583..       MOV     ?V0 + 3,DPH
   \   00008A   78..         MOV     R0,#?V0 + 2
   \   00008C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008F   7C08         MOV     R4,#0x8
   \   000091   7D00         MOV     R5,#0x0
   \   000093   AA..         MOV     R2,?V0 + 0
   \   000095   AB..         MOV     R3,?V0 + 1
   \   000097   90....       MOV     DPTR,#??pgRes
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   F9           MOV     R1,A
   \   00009C   90....       MOV     DPTR,#(??writeBuf & 0xffff)
   \   00009F   74..         MOV     A,#((??writeBuf >> 16) & 0xff)
   \   0000A1   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000A4   7402         MOV     A,#0x2
   \   0000A6   12....       LCALL   ?DEALLOC_XSTACK8
    624                  dstOff += OSAL_NV_HDR_SIZE;
   \   0000A9   12....       LCALL   ?Subroutine43 & 0xFFFF
    625                  xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
   \                     ??CrossCallReturnLabel_114:
   \   0000AC                ; Setup parameters for call to function xferBuf
   \   0000AC   78..         MOV     R0,#?V0 + 4
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B1   78..         MOV     R0,#?V0 + 0
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   90....       MOV     DPTR,#??pgRes
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   FC           MOV     R4,A
   \   0000BB   7404         MOV     A,#0x4
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ??Subroutine15_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   0000C3   90....       MOV     DPTR,#(??xferBuf & 0xffff)
   \   0000C6   74..         MOV     A,#((??xferBuf >> 16) & 0xff)
   \   0000C8   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000CB   7404         MOV     A,#0x4
   \   0000CD   12....       LCALL   ?DEALLOC_XSTACK8
    626                  dstOff += sz;
   \   0000D0   E5..         MOV     A,?V0 + 0
   \   0000D2   25..         ADD     A,?V0 + 4
   \   0000D4   F5..         MOV     ?V0 + 0,A
   \   0000D6   E5..         MOV     A,?V0 + 1
   \   0000D8   35..         ADDC    A,?V0 + 5
   \   0000DA   F5..         MOV     ?V0 + 1,A
    627                }
    628          
    629                setItem( srcPg, srcOff, eNvZero );  // Mark old location as invalid.
   \                     ??compactPage_6:
   \   0000DC                ; Setup parameters for call to function setItem
   \   0000DC   7C01         MOV     R4,#0x1
   \   0000DE   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   0000E1   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    630              }
    631          
    632              srcOff += sz;
   \                     ??compactPage_4:
   \   0000E4   85..82       MOV     DPL,?XSP + 0
   \   0000E7   85..83       MOV     DPH,?XSP + 1
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   25..         ADD     A,?V0 + 4
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   35..         ADDC    A,?V0 + 5
   \                     ??compactPage_1:
   \   0000F2   F0           MOVX    @DPTR,A
    633          
    634            } while ( TRUE );
   \   0000F3                ; Setup parameters for call to function readHdr
   \   0000F3   7402         MOV     A,#0x2
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   AC82         MOV     R4,DPL
   \   0000FA   AD83         MOV     R5,DPH
   \   0000FC   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0000FF   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   000102   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   000104   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000107   7402         MOV     A,#0x2
   \   000109   12....       LCALL   ?XSTACK_DISP0_8
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   64FF         XRL     A,#0xff
   \   00010F   7004         JNZ     ??compactPage_7
   \   000111   A3           INC     DPTR
   \   000112   E0           MOVX    A,@DPTR
   \   000113   64FF         XRL     A,#0xff
   \                     ??compactPage_7:
   \   000115   602D         JZ      ??compactPage_8
   \   000117   85..82       MOV     DPL,?XSP + 0
   \   00011A   85..83       MOV     DPH,?XSP + 1
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   2408         ADD     A,#0x8
   \   000120   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000123   85..82       MOV     DPL,?XSP + 0
   \   000126   85..83       MOV     DPH,?XSP + 1
   \   000129   C082         PUSH    DPL
   \   00012B   C083         PUSH    DPH
   \   00012D   7404         MOV     A,#0x4
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000135   D083         POP     DPH
   \   000137   D082         POP     DPL
   \   000139   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   00013C   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   00013F   5003         JNC     $+5
   \   000141   02....       LJMP    ??compactPage_2 & 0xFFFF
    635          
    636            pgOff[pgRes-OSAL_NV_PAGE_BEG] = dstOff;
   \                     ??compactPage_8:
   \   000144   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000147   E5..         MOV     A,?V0 + 0
   \   000149   F0           MOVX    @DPTR,A
   \   00014A   A3           INC     DPTR
   \   00014B   E5..         MOV     A,?V0 + 1
   \   00014D   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000150   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000153   E9           MOV     A,R1
   \   000154   7009         JNZ     ??compactPage_9
   \   000156   7401         MOV     A,#0x1
   \   000158   90....       MOV     DPTR,#??failF
   \   00015B   F0           MOVX    @DPTR,A
   \   00015C   02....       LJMP    ??compactPage_10 & 0xFFFF
   \                     ??compactPage_9:
   \   00015F   EE           MOV     A,R6
   \   000160   C3           CLR     C
   \   000161   33           RLC     A
   \   000162   F5AD         MOV     0xad,A
   \   000164   75AE01       MOV     0xae,#0x1
   \   000167   00           NOP
   \                     ??compactPage_11:
   \   000168   7480         MOV     A,#-0x80
   \   00016A   65AE         XRL     A,0xae
   \   00016C   60FA         JZ      ??compactPage_11
   \   00016E   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000171   7408         MOV     A,#0x8
   \   000173   F0           MOVX    @DPTR,A
   \   000174   A3           INC     DPTR
   \   000175   E4           CLR     A
   \   000176   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000179   E4           CLR     A
   \   00017A   F0           MOVX    @DPTR,A
   \   00017B   A3           INC     DPTR
   \   00017C   F0           MOVX    @DPTR,A
   \   00017D                ; Setup parameters for call to function readHdr
   \   00017D   740A         MOV     A,#0xa
   \   00017F   12....       LCALL   ?XSTACK_DISP0_8
   \   000182   AC82         MOV     R4,DPL
   \   000184   AD83         MOV     R5,DPH
   \   000186   7AF8         MOV     R2,#-0x8
   \   000188   7B07         MOV     R3,#0x7
   \   00018A   793F         MOV     R1,#0x3f
   \   00018C   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   00018F   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   000191   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000194   740A         MOV     A,#0xa
   \   000196   12....       LCALL   ?XSTACK_DISP0_8
   \   000199   E0           MOVX    A,@DPTR
   \   00019A   64FF         XRL     A,#0xff
   \   00019C   7004         JNZ     ??compactPage_12
   \   00019E   A3           INC     DPTR
   \   00019F   E0           MOVX    A,@DPTR
   \   0001A0   64FF         XRL     A,#0xff
   \                     ??compactPage_12:
   \   0001A2   7030         JNZ     ??compactPage_13
   \   0001A4   740C         MOV     A,#0xc
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   64FF         XRL     A,#0xff
   \   0001AC   7004         JNZ     ??compactPage_14
   \   0001AE   A3           INC     DPTR
   \   0001AF   E0           MOVX    A,@DPTR
   \   0001B0   64FF         XRL     A,#0xff
   \                     ??compactPage_14:
   \   0001B2   7020         JNZ     ??compactPage_13
   \   0001B4   740E         MOV     A,#0xe
   \   0001B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B9   E0           MOVX    A,@DPTR
   \   0001BA   64FF         XRL     A,#0xff
   \   0001BC   7004         JNZ     ??compactPage_15
   \   0001BE   A3           INC     DPTR
   \   0001BF   E0           MOVX    A,@DPTR
   \   0001C0   64FF         XRL     A,#0xff
   \                     ??compactPage_15:
   \   0001C2   7010         JNZ     ??compactPage_13
   \   0001C4   7410         MOV     A,#0x10
   \   0001C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C9   E0           MOVX    A,@DPTR
   \   0001CA   64FF         XRL     A,#0xff
   \   0001CC   7004         JNZ     ??compactPage_16
   \   0001CE   A3           INC     DPTR
   \   0001CF   E0           MOVX    A,@DPTR
   \   0001D0   64FF         XRL     A,#0xff
   \                     ??compactPage_16:
   \   0001D2   6017         JZ      ??compactPage_10
   \                     ??compactPage_13:
   \   0001D4                ; Setup parameters for call to function writeWordD
   \   0001D4   740A         MOV     A,#0xa
   \   0001D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D9   AC82         MOV     R4,DPL
   \   0001DB   AD83         MOV     R5,DPH
   \   0001DD   7AF8         MOV     R2,#-0x8
   \   0001DF   7B07         MOV     R3,#0x7
   \   0001E1   EE           MOV     A,R6
   \   0001E2   F9           MOV     R1,A
   \   0001E3   90....       MOV     DPTR,#(??writeWordD & 0xffff)
   \   0001E6   74..         MOV     A,#((??writeWordD >> 16) & 0xff)
   \   0001E8   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    637          
    638            /* In order to recover from a page compaction that is interrupted,
    639             * the logic in osal_nv_init() depends upon the following order:
    640             * 1. Compacted page is erased.
    641             * 2. State of the target of compaction is changed ePgActive to ePgInUse.
    642             */
    643            erasePage( srcPg );
    644          
    645            // Mark the reserve page as being in use.
    646            setPageUse( pgRes, TRUE );
   \                     ??compactPage_10:
   \   0001EB                ; Setup parameters for call to function setPageUse
   \   0001EB   7A01         MOV     R2,#0x1
   \   0001ED   90....       MOV     DPTR,#??pgRes
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   F9           MOV     R1,A
   \   0001F2   90....       MOV     DPTR,#(??setPageUse & 0xffff)
   \   0001F5   74..         MOV     A,#((??setPageUse >> 16) & 0xff)
   \   0001F7   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    647          
    648            // Mark newly erased page as the new reserve page.
    649            pgRes = srcPg;
   \   0001FA   EE           MOV     A,R6
   \   0001FB   90....       MOV     DPTR,#??pgRes
   \   0001FE   F0           MOVX    @DPTR,A
    650          }
   \   0001FF   7412         MOV     A,#0x12
   \   000201   12....       LCALL   ?DEALLOC_XSTACK8
   \   000204                REQUIRE ?Subroutine68
   \   000204                ; // Fall through to label ?Subroutine68

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \                     ??Subroutine15_0:
   \   000006   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000009   EE           MOV     A,R6
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000009   EE           MOV     A,R6
   \   00000A   F9           MOV     R1,A
   \   00000B                REQUIRE ?Subroutine72
   \   00000B                ; // Fall through to label ?Subroutine72

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   90....       MOV     DPTR,#(??setItem & 0xffff)
   \   000003   74..         MOV     A,#((??setItem >> 16) & 0xff)
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   90....       MOV     DPTR,#??pgRes
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function HalAdcCheckVdd
   \   000001                ; Setup parameters for call to function HalAdcCheckVdd
   \   000001   7904         MOV     R1,#0x4
   \   000003   90....       MOV     DPTR,#(HalAdcCheckVdd & 0xffff)
   \   000006   74..         MOV     A,#((HalAdcCheckVdd >> 16) & 0xff)
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   2408         ADD     A,#0x8
   \   000004   F5..         MOV     ?V0 + 0,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 1,A
   \   00000C   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E8           MOV     A,R0
   \   000001   24..         ADD     A,#(??pgLost & 0xff)
   \   000003   F582         MOV     DPL,A
   \   000005   E9           MOV     A,R1
   \   000006   34..         ADDC    A,#((??pgLost >> 8) & 0xff)
   \   000008   F583         MOV     DPH,A
   \                     ??Subroutine4_0:
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   22           RET
    651          
    652          /*********************************************************************
    653           * @fn      findItem
    654           *
    655           * @brief   Find an item Id in NV and return the page and offset to its data.
    656           *
    657           * @param   id - Valid NV item Id.
    658           *
    659           * @return  Offset of data corresponding to item Id, if found;
    660           *          otherwise OSAL_NV_ITEM_NULL.
    661           *
    662           *          The page containing the item, if found;
    663           *          otherwise no valid assignment made - left equal to item Id.
    664           *
    665           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    666          static uint16 findItem( uint16 id )
   \                     ??findItem:
    667          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    668            uint16 off;
    669            uint8 pg;
    670          
    671            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   000009   75..3C       MOV     ?V0 + 0,#0x3c
    672            {
    673              if ( (off = initPage( pg, id )) != OSAL_NV_ITEM_NULL )
   \                     ??findItem_1:
   \   00000C                ; Setup parameters for call to function initPage
   \   00000C   EE           MOV     A,R6
   \   00000D   FA           MOV     R2,A
   \   00000E   EF           MOV     A,R7
   \   00000F   FB           MOV     R3,A
   \   000010   A9..         MOV     R1,?V0 + 0
   \   000012   90....       MOV     DPTR,#(??initPage & 0xffff)
   \   000015   74..         MOV     A,#((??initPage >> 16) & 0xff)
   \   000017   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001A   EA           MOV     A,R2
   \   00001B   7001         JNZ     ??findItem_2
   \   00001D   EB           MOV     A,R3
   \                     ??findItem_2:
   \   00001E   6008         JZ      ??findItem_3
    674              {
    675                findPg = pg;
   \                     ??findItem_4:
   \   000020   E5..         MOV     A,?V0 + 0
   \   000022   90....       MOV     DPTR,#??findPg
   \   000025   F0           MOVX    @DPTR,A
    676                return off;
   \   000026   802F         SJMP    ??findItem_5
    677              }
    678            }
   \                     ??findItem_3:
   \   000028   05..         INC     ?V0 + 0
   \   00002A   E5..         MOV     A,?V0 + 0
   \   00002C   C3           CLR     C
   \   00002D   943E         SUBB    A,#0x3e
   \   00002F   40DB         JC      ??findItem_1
    679          
    680            // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
    681            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
   \   000031   75..3C       MOV     ?V0 + 0,#0x3c
    682            {
    683              if ( (off = initPage( pg, (id | 0x8000) )) != OSAL_NV_ITEM_NULL )
   \                     ??findItem_6:
   \   000034                ; Setup parameters for call to function initPage
   \   000034   EE           MOV     A,R6
   \   000035   FA           MOV     R2,A
   \   000036   7480         MOV     A,#-0x80
   \   000038   4F           ORL     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   A9..         MOV     R1,?V0 + 0
   \   00003C   74..         MOV     A,#((??initPage >> 16) & 0xff)
   \   00003E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000041   EA           MOV     A,R2
   \   000042   7001         JNZ     ??findItem_7
   \   000044   EB           MOV     A,R3
   \                     ??findItem_7:
   \   000045   70D9         JNZ     ??findItem_4
    684              {
    685                findPg = pg;
    686                return off;
    687              }
    688            }
   \   000047   05..         INC     ?V0 + 0
   \   000049   E5..         MOV     A,?V0 + 0
   \   00004B   C3           CLR     C
   \   00004C   943E         SUBB    A,#0x3e
   \   00004E   40E4         JC      ??findItem_6
    689          
    690            findPg = OSAL_NV_PAGE_NULL;
   \   000050   E4           CLR     A
   \   000051   90....       MOV     DPTR,#??findPg
   \   000054   F0           MOVX    @DPTR,A
    691            return OSAL_NV_ITEM_NULL;
   \   000055   FA           MOV     R2,A
   \   000056   FB           MOV     R3,A
   \                     ??findItem_5:
   \   000057   02....       LJMP    ?Subroutine74 & 0xFFFF
    692          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    693          
    694          /*********************************************************************
    695           * @fn      initItem
    696           *
    697           * @brief   An NV item is created and initialized with the data passed to the function, if any.
    698           *
    699           * @param   id  - Valid NV item Id.
    700           * @param   len - Item data length.
    701           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
    702           *
    703           * @return  TRUE if item write and read back checksums ok; FALSE otherwise.
    704           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    705          static uint8 initItem( uint16 id, uint16 len, void *buf )
   \                     ??initItem:
    706          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   740E         MOV     A,#0xe
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine21 & 0xFFFF
    707            uint16 sz = ((len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
    708                                                                              OSAL_NV_HDR_SIZE;
   \                     ??CrossCallReturnLabel_61:
   \   00000D   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000010   F5..         MOV     ?V0 + 4,A
   \   000012   E4           CLR     A
   \   000013   39           ADDC    A,R1
   \   000014   F5..         MOV     ?V0 + 5,A
    709            uint8 pg = OSAL_NV_PAGE_BEG;
   \   000016   7F3C         MOV     R7,#0x3c
    710            uint8 rtrn = FALSE;
   \   000018   75..00       MOV     ?V0 + 0,#0x0
    711            uint8 idx;
    712          
    713            for ( idx = 0; idx < OSAL_NV_PAGES_USED; idx++, pg++ )
   \   00001B   7E00         MOV     R6,#0x0
    714            {
    715              if ( pg == pgRes )
   \                     ??initItem_1:
   \   00001D   90....       MOV     DPTR,#??pgRes
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6F           XRL     A,R7
   \   000022   601D         JZ      ??initItem_2
    716              {
    717                continue;
    718              }
    719              if ( (pgOff[idx] - pgLost[idx] + sz) <= OSAL_NV_PAGE_FREE )
   \   000024   EE           MOV     A,R6
   \   000025   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000028   C082         PUSH    DPL
   \   00002A   C083         PUSH    DPH
   \   00002C   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00002F   D083         POP     DPH
   \   000031   D082         POP     DPL
   \   000033   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000036   E5..         MOV     A,?V0 + 4
   \   000038   28           ADD     A,R0
   \   000039   F8           MOV     R0,A
   \   00003A   E5..         MOV     A,?V0 + 5
   \   00003C   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   00003F   400D         JC      ??initItem_3
    720              {
    721                break;
    722              }
    723            }
   \                     ??initItem_2:
   \   000041   0E           INC     R6
   \   000042   0F           INC     R7
   \   000043   EE           MOV     A,R6
   \   000044   C3           CLR     C
   \   000045   9402         SUBB    A,#0x2
   \   000047   40D4         JC      ??initItem_1
    724          
    725            if ( idx != OSAL_NV_PAGES_USED )
   \   000049   7402         MOV     A,#0x2
   \   00004B   6E           XRL     A,R6
   \   00004C   6042         JZ      ??initItem_4
    726            {
    727              // Item fits if an old page is compacted.
    728              if ( (pgOff[idx] + sz) > OSAL_NV_PAGE_FREE )
   \                     ??initItem_3:
   \   00004E   EE           MOV     A,R6
   \   00004F   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000052   25..         ADD     A,?V0 + 4
   \   000054   F8           MOV     R0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   35..         ADDC    A,?V0 + 5
   \   000059   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00005C   4005         JC      ??initItem_5
    729              {
    730                pg = pgRes;
   \   00005E   90....       MOV     DPTR,#??pgRes
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FF           MOV     R7,A
    731              }
    732          
    733              // New item is the first one written to the reserved page, then the old page is compacted.
    734              if ( writeItem( pg, id, len, buf ) )
   \                     ??initItem_5:
   \   000063                ; Setup parameters for call to function writeItem
   \   000063   78..         MOV     R0,#?V0 + 2
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000068   EF           MOV     A,R7
   \   000069   F9           MOV     R1,A
   \   00006A   90....       MOV     DPTR,#(??writeItem & 0xffff)
   \   00006D   74..         MOV     A,#((??writeItem >> 16) & 0xff)
   \   00006F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000072   7402         MOV     A,#0x2
   \   000074   12....       LCALL   ?DEALLOC_XSTACK8
   \   000077   E9           MOV     A,R1
   \   000078   6003         JZ      ??initItem_6
    735              {
    736                rtrn = TRUE;
   \   00007A   75..01       MOV     ?V0 + 0,#0x1
    737              }
    738          
    739              if ( pg == pgRes )
   \                     ??initItem_6:
   \   00007D   90....       MOV     DPTR,#??pgRes
   \   000080   E0           MOVX    A,@DPTR
   \   000081   6F           XRL     A,R7
   \   000082   700C         JNZ     ??initItem_4
    740              {
    741                compactPage( OSAL_NV_PAGE_BEG+idx );
   \   000084                ; Setup parameters for call to function compactPage
   \   000084   743C         MOV     A,#0x3c
   \   000086   2E           ADD     A,R6
   \   000087   F9           MOV     R1,A
   \   000088   90....       MOV     DPTR,#(??compactPage & 0xffff)
   \   00008B   74..         MOV     A,#((??compactPage >> 16) & 0xff)
   \   00008D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    742              }
    743            }
    744          
    745            return rtrn;
   \                     ??initItem_4:
   \   000090   A9..         MOV     R1,?V0 + 0
   \   000092   02....       LJMP    ?Subroutine68 & 0xFFFF
    746          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   C3           CLR     C
   \   000001   33           RLC     A
   \   000002   F8           MOV     R0,A
   \   000003   E4           CLR     A
   \   000004   33           RLC     A
   \   000005   F9           MOV     R1,A
   \   000006   E8           MOV     A,R0
   \   000007   24..         ADD     A,#(??pgOff & 0xff)
   \   000009   F582         MOV     DPL,A
   \   00000B   E9           MOV     A,R1
   \   00000C   34..         ADDC    A,#((??pgOff >> 8) & 0xff)
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   7403         MOV     A,#0x3
   \   000002   2C           ADD     A,R4
   \   000003   F8           MOV     R0,A
   \   000004   E4           CLR     A
   \   000005   3D           ADDC    A,R5
   \   000006   F9           MOV     R1,A
   \   000007   74FC         MOV     A,#-0x4
   \   000009   58           ANL     A,R0
   \   00000A   F8           MOV     R0,A
   \   00000B   7408         MOV     A,#0x8
   \   00000D   28           ADD     A,R0
   \   00000E   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   39           ADDC    A,R1
   \   000001   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   98           SUBB    A,R0
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   99           SUBB    A,R1
   \   000007   F9           MOV     R1,A
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 3,A
   \   000007   22           RET
    747          
    748          /*********************************************************************
    749           * @fn      initItem2
    750           *
    751           * @brief   An NV item is created.
    752           *
    753           * @param   id  - Valid NV item Id.
    754           * @param   len - Item data length.
    755           *
    756           * @return  TRUE if item write and read back checksums ok; FALSE otherwise.
    757           *          If return it TRUE, then findPg is set to OSAL_NV_PAGE_NULL if a page compaction is not
    758           *          required; otherwise it is set to the non-NULL page that must be compacted.
    759           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    760          static uint8 initItem2( uint16 id, uint16 len, uint8 *comPg )
   \                     ??initItem2:
    761          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   740C         MOV     A,#0xc
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   00000D   88..         MOV     ?V0 + 0,R0
   \   00000F   89..         MOV     ?V0 + 1,R1
    762            uint16 sz = ((len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
    763                                                                              OSAL_NV_HDR_SIZE;
   \   000011   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000014   F5..         MOV     ?V0 + 2,A
   \   000016   E4           CLR     A
   \   000017   39           ADDC    A,R1
   \   000018   F5..         MOV     ?V0 + 3,A
    764            uint8 pg = OSAL_NV_PAGE_BEG;
   \   00001A   7E3C         MOV     R6,#0x3c
    765            uint8 idx;
    766          
    767            for ( idx = 0; idx < OSAL_NV_PAGES_USED; idx++, pg++ )
   \   00001C   7F00         MOV     R7,#0x0
    768            {
    769              if ( pg == pgRes )
   \                     ??initItem2_1:
   \   00001E   90....       MOV     DPTR,#??pgRes
   \   000021   E0           MOVX    A,@DPTR
   \   000022   6E           XRL     A,R6
   \   000023   601D         JZ      ??initItem2_2
    770              {
    771                continue;
    772              }
    773              if ( (pgOff[idx] - pgLost[idx] + sz) <= OSAL_NV_PAGE_FREE )
   \   000025   EF           MOV     A,R7
   \   000026   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000029   C082         PUSH    DPL
   \   00002B   C083         PUSH    DPH
   \   00002D   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000030   D083         POP     DPH
   \   000032   D082         POP     DPL
   \   000034   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000037   E5..         MOV     A,?V0 + 2
   \   000039   28           ADD     A,R0
   \   00003A   F8           MOV     R0,A
   \   00003B   E5..         MOV     A,?V0 + 3
   \   00003D   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000040   400D         JC      ??initItem2_3
    774              {
    775                break;
    776              }
    777            }
   \                     ??initItem2_2:
   \   000042   0F           INC     R7
   \   000043   0E           INC     R6
   \   000044   EF           MOV     A,R7
   \   000045   C3           CLR     C
   \   000046   9402         SUBB    A,#0x2
   \   000048   40D4         JC      ??initItem2_1
    778          
    779            // Item fits if an old page is compacted.
    780            if ( (idx == OSAL_NV_PAGES_USED) || ((pgOff[idx] + sz) > OSAL_NV_PAGE_FREE) )
   \   00004A   7402         MOV     A,#0x2
   \   00004C   6F           XRL     A,R7
   \   00004D   600E         JZ      ??initItem2_4
   \                     ??initItem2_3:
   \   00004F   EF           MOV     A,R7
   \   000050   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000053   25..         ADD     A,?V0 + 2
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   00005B   4014         JC      ??initItem2_5
    781            {
    782              pg = pgRes;
   \                     ??initItem2_4:
   \   00005D   90....       MOV     DPTR,#??pgRes
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FE           MOV     R6,A
    783          
    784              if ( idx != OSAL_NV_PAGES_USED )
   \   000062   7402         MOV     A,#0x2
   \   000064   6F           XRL     A,R7
   \   000065   600A         JZ      ??initItem2_5
    785              {
    786                *comPg = OSAL_NV_PAGE_BEG+idx;
   \   000067   743C         MOV     A,#0x3c
   \   000069   2F           ADD     A,R7
   \   00006A   85..82       MOV     DPL,?V0 + 0
   \   00006D   85..83       MOV     DPH,?V0 + 1
   \   000070   F0           MOVX    @DPTR,A
    787              }
    788              else
    789              {
    790                // comPg has already been set to the page containing the item, so compact that one.
    791              }
    792            }
    793          
    794            if ( writeItem( pg, id, len, NULL ) )
   \                     ??initItem2_5:
   \   000071                ; Setup parameters for call to function writeItem
   \   000071   75..00       MOV     ?V0 + 0,#0x0
   \   000074   75..00       MOV     ?V0 + 1,#0x0
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   EE           MOV     A,R6
   \   00007D   F9           MOV     R1,A
   \   00007E   90....       MOV     DPTR,#(??writeItem & 0xffff)
   \   000081   74..         MOV     A,#((??writeItem >> 16) & 0xff)
   \   000083   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000086   7402         MOV     A,#0x2
   \   000088   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008B   E9           MOV     A,R1
   \   00008C   6004         JZ      ??initItem2_6
    795            {
    796              return pg;
   \   00008E   EE           MOV     A,R6
   \   00008F   F9           MOV     R1,A
   \   000090   8002         SJMP    ??initItem2_7
    797            }
    798            else
    799            {
    800              return OSAL_NV_PAGE_NULL;
   \                     ??initItem2_6:
   \   000092   7900         MOV     R1,#0x0
   \                     ??initItem2_7:
   \   000094   02....       LJMP    ?Subroutine74 & 0xFFFF
    801            }
    802          }
    803          
    804          /*********************************************************************
    805           * @fn      setItem
    806           *
    807           * @brief   Set an item Id or status to mark its state.
    808           *
    809           * @param   pg - Valid NV page.
    810           * @param   offset - Valid offset into the page of the item data - the header
    811           *                   offset is calculated from this.
    812           * @param   stat - Valid enum value for the item status.
    813           *
    814           * @return  none
    815           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    816          static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
   \                     ??setItem:
    817          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
    818            osalNvHdr_t hdr;
    819          
    820            offset -= OSAL_NV_HDR_SIZE;
   \   00000E   EA           MOV     A,R2
   \   00000F   24F8         ADD     A,#-0x8
   \   000011   F5..         MOV     ?V0 + 2,A
   \   000013   EB           MOV     A,R3
   \   000014   34FF         ADDC    A,#-0x1
   \   000016   F5..         MOV     ?V0 + 3,A
    821            readHdr( pg, offset, (uint8 *)(&hdr) );
   \   000018                ; Setup parameters for call to function readHdr
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   AC82         MOV     R4,DPL
   \   000020   AD83         MOV     R5,DPH
   \   000022   AA..         MOV     R2,?V0 + 2
   \   000024   FB           MOV     R3,A
   \   000025   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   000028   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   00002A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    822          
    823            if ( stat == eNvXfer )
   \   00002D   EE           MOV     A,R6
   \   00002E   7027         JNZ     ??setItem_1
    824            {
    825              hdr.stat = OSAL_NV_ACTIVE;
   \   000030   7406         MOV     A,#0x6
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   F0           MOVX    @DPTR,A
    826              writeWord( pg, offset+OSAL_NV_HDR_CHK, (uint8*)(&(hdr.chk)) );
   \   000039                ; Setup parameters for call to function writeWord
   \   000039   7404         MOV     A,#0x4
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   AC82         MOV     R4,DPL
   \   000040   AD83         MOV     R5,DPH
   \   000042   7404         MOV     A,#0x4
   \   000044   25..         ADD     A,?V0 + 2
   \   000046   FA           MOV     R2,A
   \   000047   E4           CLR     A
   \   000048   35..         ADDC    A,?V0 + 3
   \   00004A   FB           MOV     R3,A
   \   00004B   A9..         MOV     R1,?V0 + 0
   \   00004D   90....       MOV     DPTR,#(??writeWord & 0xffff)
   \   000050   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   000052   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000055   8032         SJMP    ??setItem_2
    827            }
    828            else // if ( stat == eNvZero )
    829            {
    830              uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
    831                                                                                    OSAL_NV_HDR_SIZE;
   \                     ??setItem_1:
   \   000057   7402         MOV     A,#0x2
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00005F   7408         MOV     A,#0x8
   \   000061   28           ADD     A,R0
   \   000062   FE           MOV     R6,A
   \   000063   E4           CLR     A
   \   000064   39           ADDC    A,R1
   \   000065   FF           MOV     R7,A
    832              hdr.id = 0;
   \   000066   12....       LCALL   ?Subroutine29 & 0xFFFF
    833              writeWord( pg, offset, (uint8 *)(&hdr) );
   \                     ??CrossCallReturnLabel_80:
   \   000069   AA..         MOV     R2,?V0 + 2
   \   00006B   AB..         MOV     R3,?V0 + 3
   \   00006D   A9..         MOV     R1,?V0 + 0
   \   00006F   90....       MOV     DPTR,#(??writeWord & 0xffff)
   \   000072   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   000074   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    834              pgLost[pg-OSAL_NV_PAGE_BEG] += sz;
   \   000077   E5..         MOV     A,?V0 + 0
   \   000079   C3           CLR     C
   \   00007A   33           RLC     A
   \   00007B   F8           MOV     R0,A
   \   00007C   E4           CLR     A
   \   00007D   33           RLC     A
   \   00007E   F9           MOV     R1,A
   \   00007F   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2E           ADD     A,R6
   \   000084   F0           MOVX    @DPTR,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   3F           ADDC    A,R7
   \   000088   F0           MOVX    @DPTR,A
    835            }
    836          }
   \                     ??setItem_2:
   \   000089   7408         MOV     A,#0x8
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E                REQUIRE ?Subroutine74
   \   00008E                ; // Fall through to label ?Subroutine74

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000003   F8           MOV     R0,A
   \   000004   22           RET
    837          
    838          /*********************************************************************
    839           * @fn      calcChkB
    840           *
    841           * @brief   Calculates the data checksum over the 'buf' parameter.
    842           *
    843           * @param   pg - A valid NV Flash page.
    844           * @param   offset - A valid offset into the page.
    845           * @param   len - Byte count of the data to be checksummed.
    846           *
    847           * @return  Calculated checksum of the data bytes.
    848           */
    849          static uint16 calcChkB( uint16 len, uint8 *buf )
    850          {
    851            uint16 chk = 0;
    852          
    853            while ( len-- )
    854            {
    855              chk += *buf++;
    856            }
    857          
    858            return chk;
    859          }
    860          
    861          /*********************************************************************
    862           * @fn      calcChkF
    863           *
    864           * @brief   Calculates the data checksum by reading the data bytes from NV.
    865           *
    866           * @param   pg - A valid NV Flash page.
    867           * @param   offset - A valid offset into the page.
    868           * @param   len - Byte count of the data to be checksummed.
    869           *
    870           * @return  Calculated checksum of the data bytes.
    871           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    872          static uint16 calcChkF( byte pg, uint16 offset, uint16 len )
   \                     ??calcChkF:
    873          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    874            uint32 addr = OSAL_NV_PAGE_TO_ADDR( pg ) + offset;
   \   00000E   89..         MOV     ?V0 + 4,R1
   \   000010   75..00       MOV     ?V0 + 5,#0x0
   \   000013   75..00       MOV     ?V0 + 6,#0x0
   \   000016   75..00       MOV     ?V0 + 7,#0x0
   \   000019   740B         MOV     A,#0xb
   \   00001B   78..         MOV     R0,#?V0 + 4
   \   00001D   12....       LCALL   ?L_SHL
   \   000020   8A..         MOV     ?V0 + 0,R2
   \   000022   8B..         MOV     ?V0 + 1,R3
   \   000024   F5..         MOV     ?V0 + 2,A
   \   000026   F5..         MOV     ?V0 + 3,A
   \   000028   78..         MOV     R0,#?V0 + 4
   \   00002A   79..         MOV     R1,#?V0 + 0
   \   00002C   12....       LCALL   ?L_ADD
    875            uint16 chk = 0;
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   F0           MOVX    @DPTR,A
    876            uint8 eFlag = TRUE;
   \   000039   75..01       MOV     ?V0 + 2,#0x1
   \   00003C   802B         SJMP    ??CrossCallReturnLabel_175
    877          
    878            while ( len-- )
    879            {
    880              uint8 ch = GetCodeByte( addr++ );
   \                     ??calcChkF_1:
   \   00003E                ; Setup parameters for call to function GetCodeByte
   \   00003E   AA..         MOV     R2,?V0 + 4
   \   000040   AB..         MOV     R3,?V0 + 5
   \   000042   AC..         MOV     R4,?V0 + 6
   \   000044   AD..         MOV     R5,?V0 + 7
   \   000046   12....       LCALL   GetCodeByte & 0xFFFF
   \   000049   E9           MOV     A,R1
   \   00004A   F5..         MOV     ?V0 + 0,A
   \   00004C   90....       MOV     DPTR,#__Constant_1
   \   00004F   78..         MOV     R0,#?V0 + 4
   \   000051   12....       LCALL   ?L_ADD_X
    881          
    882              if ( ch != OSAL_NV_ERASED )
   \   000054   74FF         MOV     A,#-0x1
   \   000056   65..         XRL     A,?V0 + 0
   \   000058   6003         JZ      ??calcChkF_2
    883              {
    884                eFlag = FALSE;
   \   00005A   75..00       MOV     ?V0 + 2,#0x0
    885              }
    886          
    887              chk += ch;
   \                     ??calcChkF_2:
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   25..         ADD     A,?V0 + 0
   \   000066   12....       LCALL   ?Subroutine70 & 0xFFFF
    888            }
   \                     ??CrossCallReturnLabel_175:
   \   000069   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   00006C   7001         JNZ     ??calcChkF_3
   \   00006E   E9           MOV     A,R1
   \                     ??calcChkF_3:
   \   00006F   70CD         JNZ     ??calcChkF_1
    889          
    890            if ( eFlag )
   \   000071   E5..         MOV     A,?V0 + 2
   \   000073   6006         JZ      ??calcChkF_4
    891            {
    892              return OSAL_NV_ERASED_ID;
   \   000075   7AFF         MOV     R2,#-0x1
   \   000077   7BFF         MOV     R3,#-0x1
   \   000079   8009         SJMP    ??CrossCallReturnLabel_50
    893            }
    894            else
    895            {
    896              return chk;
   \                     ??calcChkF_4:
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000084   02....       LJMP    ?Subroutine75 & 0xFFFF
    897            }
    898          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   7402         MOV     A,#0x2
   \                     ??Subroutine75_0:
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005   7F08         MOV     R7,#0x8
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   EE           MOV     A,R6
   \   000001   F8           MOV     R0,A
   \   000002   EF           MOV     A,R7
   \   000003   F9           MOV     R1,A
   \   000004   74FF         MOV     A,#-0x1
   \   000006   28           ADD     A,R0
   \   000007   1E           DEC     R6
   \   000008   74FF         MOV     A,#-0x1
   \   00000A   39           ADDC    A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   E8           MOV     A,R0
   \   00000D   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   22           RET
    899          
    900          /*********************************************************************
    901           * @fn      readHdr
    902           *
    903           * @brief   Reads "sizeof( osalNvHdr_t )" bytes from NV.
    904           *
    905           * @param   pg - Valid NV page.
    906           * @param   offset - Valid offset into the page.
    907           * @param   buf - Valid buffer space of at least sizeof( osalNvHdr_t ) bytes.
    908           *
    909           * @return  none
    910           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    911          static void readHdr( uint8 pg, uint16 offset, uint8 *buf )
   \                     ??readHdr:
    912          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EC           MOV     A,R4
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   ED           MOV     A,R5
   \   000014   F0           MOVX    @DPTR,A
    913            uint32 addr = OSAL_NV_PAGE_TO_ADDR( pg ) + offset;
   \   000015   89..         MOV     ?V0 + 4,R1
   \   000017   75..00       MOV     ?V0 + 5,#0x0
   \   00001A   75..00       MOV     ?V0 + 6,#0x0
   \   00001D   75..00       MOV     ?V0 + 7,#0x0
   \   000020   740B         MOV     A,#0xb
   \   000022   78..         MOV     R0,#?V0 + 4
   \   000024   12....       LCALL   ?L_SHL
   \   000027   8A..         MOV     ?V0 + 0,R2
   \   000029   8B..         MOV     ?V0 + 1,R3
   \   00002B   F5..         MOV     ?V0 + 2,A
   \   00002D   F5..         MOV     ?V0 + 3,A
   \   00002F   78..         MOV     R0,#?V0 + 4
   \   000031   79..         MOV     R1,#?V0 + 0
   \   000033   12....       LCALL   ?L_ADD
    914            uint8 len = OSAL_NV_HDR_SIZE;
   \   000036   7E08         MOV     R6,#0x8
    915          
    916            do
    917            {
    918              *buf++ = GetCodeByte( addr++ );
   \                     ??readHdr_1:
   \   000038                ; Setup parameters for call to function GetCodeByte
   \   000038   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   00003B   12....       LCALL   ?L_ADD_X
   \   00003E   12....       LCALL   ?Subroutine1 & 0xFFFF
    919            } while ( --len );
   \                     ??CrossCallReturnLabel_188:
   \   000041   1E           DEC     R6
   \   000042   EE           MOV     A,R6
   \   000043   70F3         JNZ     ??readHdr_1
    920          }
   \   000045   02....       LJMP    ?Subroutine75 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2401         ADD     A,#0x1
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   AA..         MOV     R2,?V0 + 4
   \   000002   AB..         MOV     R3,?V0 + 5
   \   000004   AC..         MOV     R4,?V0 + 6
   \   000006   AD..         MOV     R5,?V0 + 7
   \   000008   12....       LCALL   GetCodeByte & 0xFFFF
   \   00000B   90....       MOV     DPTR,#__Constant_1
   \   00000E   78..         MOV     R0,#?V0 + 4
   \   000010   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   02....       LJMP    ?Subroutine71 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    921          
    922          /*********************************************************************
    923           * @fn      readWord
    924           *
    925           * @brief   Reads "sizeof( osalNvHdr_t )" bytes from NV.
    926           *
    927           * @param   pg - Valid NV page.
    928           * @param   offset - Valid offset into the page.
    929           * @param   buf - Valid buffer space of at least sizeof( osalNvHdr_t ) bytes.
    930           *
    931           * @return  none
    932           */
    933          static void readWord( uint8 pg, uint16 offset, uint8 *buf )
    934          {
    935            uint32 addr = OSAL_NV_PAGE_TO_ADDR( pg ) + offset;
    936            uint8 len = OSAL_NV_WORD_SIZE;
    937          
    938            do
    939            {
    940              *buf++ = GetCodeByte( addr++ );
    941            } while ( --len );
    942          }
    943          
    944          
    945          /*********************************************************************
    946           * @fn      writeWord
    947           *
    948           * @brief   Writes a Flash-WORD to NV.
    949           *
    950           * @param   pg - A valid NV Flash page.
    951           * @param   offset - A valid offset into the page.
    952           * @param   buf - Pointer to source buffer.
    953           *
    954           * @return  none
    955           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    956          static void writeWord( uint8 pg, uint16 offset, uint8 *buf )
   \                     ??writeWord:
    957          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
    958            if ( (buf[0] != OSAL_NV_ERASED) || (buf[1] != OSAL_NV_ERASED) ||
    959                 (buf[2] != OSAL_NV_ERASED) || (buf[3] != OSAL_NV_ERASED) )
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   64FF         XRL     A,#0xff
   \   000010   701D         JNZ     ??writeWord_1
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   64FF         XRL     A,#0xff
   \   000016   7017         JNZ     ??writeWord_1
   \   000018   8C82         MOV     DPL,R4
   \   00001A   8D83         MOV     DPH,R5
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   64FF         XRL     A,#0xff
   \   000021   700C         JNZ     ??writeWord_1
   \   000023   8C82         MOV     DPL,R4
   \   000025   8D83         MOV     DPH,R5
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   64FF         XRL     A,#0xff
   \   00002D   6068         JZ      ??writeWord_2
    960            {
    961              offset = (offset >> 2) + ((uint16)pg << 9);
   \                     ??writeWord_1:
   \   00002F   7402         MOV     A,#0x2
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?US_SHR
   \   000036   89..         MOV     ?V0 + 2,R1
   \   000038   F5..         MOV     ?V0 + 3,A
   \   00003A   7409         MOV     A,#0x9
   \   00003C   78..         MOV     R0,#?V0 + 2
   \   00003E   12....       LCALL   ?S_SHL
   \   000041   25..         ADD     A,?V0 + 0
   \   000043   E5..         MOV     A,?V0 + 3
   \   000045   35..         ADDC    A,?V0 + 1
   \   000047   F5..         MOV     ?V0 + 1,A
    962          
    963              FADDRL = (uint8)offset;
   \   000049   E5..         MOV     A,?V0 + 0
   \   00004B   F5AC         MOV     0xac,A
    964              FADDRH = (uint8)(offset >> 8);
   \   00004D   E5..         MOV     A,?V0 + 1
   \   00004F   F5AD         MOV     0xad,A
    965          
    966              FBuff[0] = buf[0];
   \   000051   8C82         MOV     DPL,R4
   \   000053   8D83         MOV     DPH,R5
   \   000055   E0           MOVX    A,@DPTR
   \   000056   90....       MOV     DPTR,#FBuff
   \   000059   12....       LCALL   ?Subroutine31 & 0xFFFF
    967              FBuff[1] = buf[1];
   \                     ??CrossCallReturnLabel_85:
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   90....       MOV     DPTR,#(FBuff + 1)
   \   000060   12....       LCALL   ?Subroutine31 & 0xFFFF
    968              FBuff[2] = buf[2];
   \                     ??CrossCallReturnLabel_86:
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   90....       MOV     DPTR,#(FBuff + 2)
   \   000068   12....       LCALL   ?Subroutine31 & 0xFFFF
    969              FBuff[3] = buf[3];
   \                     ??CrossCallReturnLabel_87:
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   90....       MOV     DPTR,#(FBuff + 3)
   \   000071   12....       LCALL   ?Subroutine37 & 0xFFFF
    970          
    971              execDMA();
   \                     ??CrossCallReturnLabel_100:
   \   000074   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000077   E9           MOV     A,R1
   \   000078   7008         JNZ     ??writeWord_3
   \   00007A   7401         MOV     A,#0x1
   \   00007C   90....       MOV     DPTR,#??failF
   \   00007F   F0           MOVX    @DPTR,A
   \   000080   8015         SJMP    ??writeWord_2
   \                     ??writeWord_3:
   \   000082   53D1FE       ANL     0xd1,#0xfe
   \   000085   75D601       MOV     0xd6,#0x1
   \   000088                ; Setup parameters for call to function halFlashDmaTrigger
   \   000088   12....       LCALL   halFlashDmaTrigger & 0xFFFF
   \                     ??writeWord_4:
   \   00008B   E5D1         MOV     A,0xd1
   \   00008D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00008F   50FA         JNC     ??writeWord_4
   \                     ??writeWord_5:
   \   000091   74C0         MOV     A,#-0x40
   \   000093   55AE         ANL     A,0xae
   \   000095   70FA         JNZ     ??writeWord_5
    972            }
    973          }
   \                     ??writeWord_2:
   \   000097   02....       LJMP    ?Subroutine74 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   A3           INC     DPTR
   \   000006   22           RET
    974          
    975          /*********************************************************************
    976           * @fn      writeWordD
    977           *
    978           * @brief   Writes two Flash-WORDs to NV.
    979           *
    980           * @param   pg - A valid NV Flash page.
    981           * @param   offset - A valid offset into the page.
    982           * @param   buf - Pointer to source buffer.
    983           *
    984           * @return  none
    985           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    986          static void writeWordD( uint8 pg, uint16 offset, uint8 *buf )
   \                     ??writeWordD:
    987          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 2,R4
   \   00000D   8D..         MOV     ?V0 + 3,R5
    988            writeWord( pg, offset, buf );
   \   00000F                ; Setup parameters for call to function writeWord
   \   00000F   90....       MOV     DPTR,#(??writeWord & 0xffff)
   \   000012   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   000014   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    989            writeWord( pg, offset+OSAL_NV_WORD_SIZE, buf+OSAL_NV_WORD_SIZE);
   \   000017                ; Setup parameters for call to function writeWord
   \   000017   E5..         MOV     A,?V0 + 2
   \   000019   2404         ADD     A,#0x4
   \   00001B   FC           MOV     R4,A
   \   00001C   E5..         MOV     A,?V0 + 3
   \   00001E   3400         ADDC    A,#0x0
   \   000020   FD           MOV     R5,A
   \   000021   7404         MOV     A,#0x4
   \   000023   2E           ADD     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   E4           CLR     A
   \   000026   3F           ADDC    A,R7
   \   000027   FB           MOV     R3,A
   \   000028   A9..         MOV     R1,?V0 + 0
   \   00002A   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   00002C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    990          }
   \   00002F   02....       LJMP    ?Subroutine74 & 0xFFFF
    991          
    992          /*********************************************************************
    993           * @fn      writeWordH
    994           *
    995           * @brief   Writes the 1st half of a Flash-WORD to NV (filling 2nd half with 0xffff).
    996           *
    997           * @param   pg - A valid NV Flash page.
    998           * @param   offset - A valid offset into the page.
    999           * @param   buf - Pointer to source buffer.
   1000           *
   1001           * @return  none
   1002           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1003          static void writeWordH( uint8 pg, uint16 offset, uint8 *buf )
   \                     ??writeWordH:
   1004          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1005            uint8 tmp[4];
   1006          
   1007            tmp[0] = buf[0];
   \   00000A   8C82         MOV     DPL,R4
   \   00000C   8D83         MOV     DPH,R5
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   85..82       MOV     DPL,?XSP + 0
   \   000012   85..83       MOV     DPH,?XSP + 1
   \   000015   12....       LCALL   ?Subroutine31 & 0xFFFF
   1008            tmp[1] = buf[1];
   \                     ??CrossCallReturnLabel_88:
   \   000018   E0           MOVX    A,@DPTR
   \   000019   C0E0         PUSH    A
   \   00001B   7401         MOV     A,#0x1
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   D0E0         POP     A
   \   000022   F0           MOVX    @DPTR,A
   1009            tmp[2] = OSAL_NV_ERASED;
   \   000023   7402         MOV     A,#0x2
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   74FF         MOV     A,#-0x1
   \   00002A   F0           MOVX    @DPTR,A
   1010            tmp[3] = OSAL_NV_ERASED;
   \   00002B   7403         MOV     A,#0x3
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   74FF         MOV     A,#-0x1
   \   000032   12....       LCALL   ??Subroutine29_1 & 0xFFFF
   1011          
   1012            writeWord( pg, offset, tmp );
   \                     ??CrossCallReturnLabel_82:
   \   000035   90....       MOV     DPTR,#(??writeWord & 0xffff)
   \   000038   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   00003A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1013          }
   \   00003D   7404         MOV     A,#0x4
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000042   7F01         MOV     R7,#0x1
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
   1014          
   1015          /*********************************************************************
   1016           * @fn      writeBuf
   1017           *
   1018           * @brief   Writes a data buffer to NV.
   1019           *
   1020           * @param   dstPg - A valid NV Flash page.
   1021           * @param   offset - A valid offset into the page.
   1022           * @param   len  - Byte count of the data to write.
   1023           * @param   buf  - The data to write.
   1024           *
   1025           * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
   1026           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1027          static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
   \                     ??writeBuf:
   1028          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7401         MOV     A,#0x1
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E9           MOV     A,R1
   \   000010   F0           MOVX    @DPTR,A
   \   000011   7402         MOV     A,#0x2
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000019   EC           MOV     A,R4
   \   00001A   FE           MOV     R6,A
   \   00001B   ED           MOV     A,R5
   \   00001C   FF           MOV     R7,A
   1029            uint32 addr;
   1030            uint8 idx, rem, tmp[OSAL_NV_WORD_SIZE];
   1031          
   1032            rem = dstOff % OSAL_NV_WORD_SIZE;
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E0           MOVX    A,@DPTR
   \   000023   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000026   F0           MOVX    @DPTR,A
   1033            if ( rem )
   \   000027   7003         JNZ     $+5
   \   000029   02....       LJMP    ??CrossCallReturnLabel_177 & 0xFFFF
   1034            {
   1035              dstOff -= rem;
   \   00002C   F8           MOV     R0,A
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   12....       LCALL   ?Subroutine26 & 0xFFFF
   1036              addr = OSAL_NV_PAGE_TO_ADDR( dstPg ) + dstOff;
   \                     ??CrossCallReturnLabel_70:
   \   000035   7401         MOV     A,#0x1
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00003D   12....       LCALL   ?L_SHL
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000048   12....       LCALL   ?L_ADD
   1037          
   1038              for ( idx = 0; idx < rem; idx++ )
   1039              {
   1040                tmp[idx] = GetCodeByte( addr++ );
   \                     ??writeBuf_1:
   \   00004B                ; Setup parameters for call to function GetCodeByte
   \   00004B   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   00004E   12....       LCALL   ?L_ADD_X
   \   000051   85....       MOV     ?V0 + 0,?V0 + 2
   \   000054   7404         MOV     A,#0x4
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   00005C   12....       LCALL   ?Subroutine30 & 0xFFFF
   1041              }
   \                     ??CrossCallReturnLabel_83:
   \   00005F   40EA         JC      ??writeBuf_1
   1042          
   1043              while ( (idx < OSAL_NV_WORD_SIZE) && len )
   \                     ??writeBuf_2:
   \   000061   E5..         MOV     A,?V0 + 2
   \   000063   C3           CLR     C
   \   000064   9404         SUBB    A,#0x4
   \   000066   503E         JNC     ??CrossCallReturnLabel_101
   \   000068   EE           MOV     A,R6
   \   000069   7001         JNZ     ??writeBuf_3
   \   00006B   EF           MOV     A,R7
   \                     ??writeBuf_3:
   \   00006C   6038         JZ      ??CrossCallReturnLabel_101
   1044              {
   1045                tmp[idx++] = *buf++;
   \   00006E   7418         MOV     A,#0x18
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000076   C0E0         PUSH    A
   \   000078   85....       MOV     ?V0 + 0,?V0 + 2
   \   00007B   7404         MOV     A,#0x4
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000083   D0E0         POP     A
   \   000085   F0           MOVX    @DPTR,A
   \   000086   7418         MOV     A,#0x18
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000094   05..         INC     ?V0 + 2
   1046                len--;
   \   000096   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000099   80C6         SJMP    ??writeBuf_2
   1047              }
   1048          
   1049              while ( idx < OSAL_NV_WORD_SIZE )
   1050              {
   1051                tmp[idx++] = OSAL_NV_ERASED;
   \                     ??writeBuf_4:
   \   00009B   85....       MOV     ?V0 + 0,?V0 + 2
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   12....       LCALL   ?Subroutine38 & 0xFFFF
   1052              }
   \                     ??CrossCallReturnLabel_101:
   \   0000A6   E5..         MOV     A,?V0 + 2
   \   0000A8   C3           CLR     C
   \   0000A9   9404         SUBB    A,#0x4
   \   0000AB   40EE         JC      ??writeBuf_4
   1053          
   1054              writeWord( dstPg, dstOff, tmp );
   \   0000AD                ; Setup parameters for call to function writeWord
   \   0000AD   7404         MOV     A,#0x4
   \   0000AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B2   AC82         MOV     R4,DPL
   \   0000B4   AD83         MOV     R5,DPH
   \   0000B6   7402         MOV     A,#0x2
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0000C4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1055              dstOff += OSAL_NV_WORD_SIZE;
   \   0000C7   7402         MOV     A,#0x2
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   12....       LCALL   ?Subroutine5 & 0xFFFF
   1056            }
   1057          
   1058            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??CrossCallReturnLabel_177:
   \   0000CF   EE           MOV     A,R6
   \   0000D0   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   0000D3   12....       LCALL   ?Subroutine34 & 0xFFFF
   1059            len /= OSAL_NV_WORD_SIZE;
   \                     ??CrossCallReturnLabel_91:
   \   0000D6   12....       LCALL   ?US_SHR
   \   0000D9   AE..         MOV     R6,?V0 + 0
   \   0000DB   AF..         MOV     R7,?V0 + 1
   \   0000DD   8037         SJMP    ??CrossCallReturnLabel_183
   1060          
   1061            while ( len-- )
   1062            {
   1063              writeWord( dstPg, dstOff, buf );
   \                     ??writeBuf_5:
   \   0000DF                ; Setup parameters for call to function writeWord
   \   0000DF   7418         MOV     A,#0x18
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000E7   7402         MOV     A,#0x2
   \   0000E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EC   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   0000EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F2   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   0000F5   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1064              dstOff += OSAL_NV_WORD_SIZE;
   \   0000F8   7402         MOV     A,#0x2
   \   0000FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FD   12....       LCALL   ?Subroutine5 & 0xFFFF
   1065              buf += OSAL_NV_WORD_SIZE;
   \                     ??CrossCallReturnLabel_178:
   \   000100   7418         MOV     A,#0x18
   \   000102   12....       LCALL   ?XSTACK_DISP0_8
   \   000105   E0           MOVX    A,@DPTR
   \   000106   2404         ADD     A,#0x4
   \   000108   F8           MOV     R0,A
   \   000109   A3           INC     DPTR
   \   00010A   E0           MOVX    A,@DPTR
   \   00010B   3400         ADDC    A,#0x0
   \   00010D   F9           MOV     R1,A
   \   00010E   7418         MOV     A,#0x18
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   12....       LCALL   ?Subroutine71 & 0xFFFF
   1066            }
   \                     ??CrossCallReturnLabel_183:
   \   000116   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000119   7001         JNZ     ??writeBuf_6
   \   00011B   E9           MOV     A,R1
   \                     ??writeBuf_6:
   \   00011C   70C1         JNZ     ??writeBuf_5
   1067          
   1068            if ( rem )
   \   00011E   85..82       MOV     DPL,?XSP + 0
   \   000121   85..83       MOV     DPH,?XSP + 1
   \   000124   E0           MOVX    A,@DPTR
   \   000125   605C         JZ      ??writeBuf_7
   1069            {
   1070              for ( idx = 0; idx < rem; idx++ )
   \   000127   75..00       MOV     ?V0 + 2,#0x0
   1071              {
   1072                tmp[idx] = *buf++;
   \                     ??writeBuf_8:
   \   00012A   7418         MOV     A,#0x18
   \   00012C   12....       LCALL   ?XSTACK_DISP0_8
   \   00012F   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000132   C0E0         PUSH    A
   \   000134   85....       MOV     ?V0 + 0,?V0 + 2
   \   000137   7404         MOV     A,#0x4
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   00013F   D0E0         POP     A
   \   000141   F0           MOVX    @DPTR,A
   \   000142   7418         MOV     A,#0x18
   \   000144   12....       LCALL   ?XSTACK_DISP0_8
   \   000147   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00014A   12....       LCALL   ?XSTACK_DISP0_8
   \   00014D   E8           MOV     A,R0
   \   00014E   F0           MOVX    @DPTR,A
   \   00014F   A3           INC     DPTR
   \   000150   12....       LCALL   ?Subroutine30 & 0xFFFF
   1073              }
   \                     ??CrossCallReturnLabel_84:
   \   000153   40D5         JC      ??writeBuf_8
   1074          
   1075              while ( idx < OSAL_NV_WORD_SIZE )
   \                     ??writeBuf_9:
   \   000155   E5..         MOV     A,?V0 + 2
   \   000157   C3           CLR     C
   \   000158   9404         SUBB    A,#0x4
   \   00015A   500D         JNC     ??writeBuf_10
   1076              {
   1077                tmp[idx++] = OSAL_NV_ERASED;
   \   00015C   85....       MOV     ?V0 + 0,?V0 + 2
   \   00015F   7404         MOV     A,#0x4
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000167   80EC         SJMP    ??writeBuf_9
   1078              }
   1079          
   1080              writeWord( dstPg, dstOff, tmp );
   \                     ??writeBuf_10:
   \   000169                ; Setup parameters for call to function writeWord
   \   000169   7404         MOV     A,#0x4
   \   00016B   12....       LCALL   ?XSTACK_DISP0_8
   \   00016E   AC82         MOV     R4,DPL
   \   000170   AD83         MOV     R5,DPH
   \   000172   7402         MOV     A,#0x2
   \   000174   12....       LCALL   ?XSTACK_DISP0_8
   \   000177   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   00017A   12....       LCALL   ?XSTACK_DISP0_8
   \   00017D   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000180   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1081            }
   1082          }
   \                     ??writeBuf_7:
   \   000183   7408         MOV     A,#0x8
   \   000185   02....       LJMP    ??Subroutine75_0 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   5403         ANL     A,#0x3
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   E582         MOV     A,DPL
   \   000002   25..         ADD     A,?V0 + 0
   \   000004                REQUIRE ?Subroutine69
   \   000004                ; // Fall through to label ?Subroutine69

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   F582         MOV     DPL,A
   \   000002   E583         MOV     A,DPH
   \   000004   3400         ADDC    A,#0x0
   \   000006   F583         MOV     DPH,A
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000003   74FF         MOV     A,#-0x1
   \   000005   F0           MOVX    @DPTR,A
   \   000006   05..         INC     ?V0 + 2
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E9           MOV     A,R1
   \   000001   F0           MOVX    @DPTR,A
   \   000002   05..         INC     ?V0 + 2
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FA           MOV     R2,A
   \   00000C   E5..         MOV     A,?V0 + 2
   \   00000E   C3           CLR     C
   \   00000F   9A           SUBB    A,R2
   \   000010   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000003   7418         MOV     A,#0x18
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000003   7401         MOV     A,#0x1
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   EE           MOV     A,R6
   \   000001   24FF         ADD     A,#-0x1
   \   000003   1E           DEC     R6
   \   000004   EF           MOV     A,R7
   \   000005   34FF         ADDC    A,#-0x1
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E..         MOV     ?V0 + 0,R6
   \   000003   8F..         MOV     ?V0 + 1,R7
   \   000005   7402         MOV     A,#0x2
   \   000007   78..         MOV     R0,#?V0 + 0
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   C3           CLR     C
   \   000001   E0           MOVX    A,@DPTR
   \   000002   98           SUBB    A,R0
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   9400         SUBB    A,#0x0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007   75..00       MOV     ?V0 + 2,#0x0
   \   00000A   75..00       MOV     ?V0 + 3,#0x0
   \   00000D   78..         MOV     R0,#?V0 + 4
   \   00000F   79..         MOV     R1,#?V0 + 0
   \   000011   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   90....       MOV     DPTR,#(??writeWord & 0xffff)
   \   000005   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2404         ADD     A,#0x4
   \   000003   02....       LJMP    ?Subroutine70 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   75..00       MOV     ?V0 + 5,#0x0
   \   000006   75..00       MOV     ?V0 + 6,#0x0
   \   000009   75..00       MOV     ?V0 + 7,#0x0
   \   00000C   740B         MOV     A,#0xb
   \   00000E   78..         MOV     R0,#?V0 + 4
   \   000010   22           RET
   1083          
   1084          /*********************************************************************
   1085           * @fn      xferBuf
   1086           *
   1087           * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
   1088           *
   1089           * @return  none
   1090           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1091          static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
   \                     ??xferBuf:
   1092          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E9           MOV     A,R1
   \   000010   F0           MOVX    @DPTR,A
   \   000011   7404         MOV     A,#0x4
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   EC           MOV     A,R4
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   741E         MOV     A,#0x1e
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FE           MOV     R6,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FF           MOV     R7,A
   1093            uint32 addr;
   1094            uint8 idx, rem, tmp[OSAL_NV_WORD_SIZE];
   1095          
   1096            rem = dstOff % OSAL_NV_WORD_SIZE;
   \   00002A   741C         MOV     A,#0x1c
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   5403         ANL     A,#0x3
   \   000032   C0E0         PUSH    A
   \   000034   7401         MOV     A,#0x1
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   D0E0         POP     A
   \   00003B   F0           MOVX    @DPTR,A
   1097            if ( rem )
   \   00003C   7003         JNZ     $+5
   \   00003E   02....       LJMP    ??CrossCallReturnLabel_179 & 0xFFFF
   1098            {
   1099              dstOff -= rem;
   \   000041   F8           MOV     R0,A
   \   000042   741C         MOV     A,#0x1c
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ?Subroutine26 & 0xFFFF
   1100              addr = OSAL_NV_PAGE_TO_ADDR( dstPg ) + dstOff;
   \                     ??CrossCallReturnLabel_71:
   \   00004A   7402         MOV     A,#0x2
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000052   12....       LCALL   ?L_SHL
   \   000055   741C         MOV     A,#0x1c
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   00005D   12....       LCALL   ?L_ADD
   1101          
   1102              for ( idx = 0; idx < rem; idx++ )
   \   000060   E4           CLR     A
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   F0           MOVX    @DPTR,A
   1103              {
   1104                tmp[idx] = GetCodeByte( addr++ );
   \                     ??xferBuf_1:
   \   000068                ; Setup parameters for call to function GetCodeByte
   \   000068   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   00006B   12....       LCALL   ?L_ADD_X
   \   00006E   85..82       MOV     DPL,?XSP + 0
   \   000071   85..83       MOV     DPH,?XSP + 1
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F8           MOV     R0,A
   \   000076   7406         MOV     A,#0x6
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   12....       LCALL   ?Subroutine28 & 0xFFFF
   1105              }
   \                     ??CrossCallReturnLabel_74:
   \   00007E   C0E0         PUSH    A
   \   000080   7401         MOV     A,#0x1
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   E0           MOVX    A,@DPTR
   \   000086   FA           MOV     R2,A
   \   000087   D0E0         POP     A
   \   000089   C3           CLR     C
   \   00008A   9A           SUBB    A,R2
   \   00008B   40DB         JC      ??xferBuf_1
   1106          
   1107              addr = OSAL_NV_PAGE_TO_ADDR( srcPg ) + srcOff;
   \   00008D   7403         MOV     A,#0x3
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000095   12....       LCALL   ?L_SHL
   \   000098   7404         MOV     A,#0x4
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   0000A0   12....       LCALL   ?L_ADD
   \   0000A3   8024         SJMP    ??CrossCallReturnLabel_134
   1108          
   1109              while ( (idx < OSAL_NV_WORD_SIZE) && len )
   1110              {
   1111                tmp[idx++] = GetCodeByte( addr++ );
   \                     ??xferBuf_2:
   \   0000A5                ; Setup parameters for call to function GetCodeByte
   \   0000A5   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   0000A8   12....       LCALL   ?L_ADD_X
   \   0000AB   85..82       MOV     DPL,?XSP + 0
   \   0000AE   85..83       MOV     DPH,?XSP + 1
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F8           MOV     R0,A
   \   0000B3   7406         MOV     A,#0x6
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   12....       LCALL   ?Subroutine28 & 0xFFFF
   1112                srcOff++;
   \                     ??CrossCallReturnLabel_76:
   \   0000BB   7404         MOV     A,#0x4
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   2401         ADD     A,#0x1
   \   0000C3   12....       LCALL   ?Subroutine70 & 0xFFFF
   1113                len--;
   \                     ??CrossCallReturnLabel_176:
   \   0000C6   12....       LCALL   ?Subroutine50 & 0xFFFF
   1114              }
   \                     ??CrossCallReturnLabel_134:
   \   0000C9   85..82       MOV     DPL,?XSP + 0
   \   0000CC   85..83       MOV     DPH,?XSP + 1
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   C3           CLR     C
   \   0000D1   9404         SUBB    A,#0x4
   \   0000D3   5006         JNC     ??xferBuf_3
   \   0000D5   EE           MOV     A,R6
   \   0000D6   7001         JNZ     ??xferBuf_4
   \   0000D8   EF           MOV     A,R7
   \                     ??xferBuf_4:
   \   0000D9   70CA         JNZ     ??xferBuf_2
   1115          
   1116              while ( idx < OSAL_NV_WORD_SIZE )
   \                     ??xferBuf_3:
   \   0000DB   E0           MOVX    A,@DPTR
   \   0000DC   C3           CLR     C
   \   0000DD   9404         SUBB    A,#0x4
   \   0000DF   500F         JNC     ??xferBuf_5
   1117              {
   1118                tmp[idx++] = OSAL_NV_ERASED;
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   F8           MOV     R0,A
   \   0000E3   7406         MOV     A,#0x6
   \   0000E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E8   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   0000EB   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   0000EE   80EB         SJMP    ??xferBuf_3
   1119              }
   1120          
   1121              writeWord( dstPg, dstOff, tmp );
   \                     ??xferBuf_5:
   \   0000F0                ; Setup parameters for call to function writeWord
   \   0000F0   7406         MOV     A,#0x6
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   AC82         MOV     R4,DPL
   \   0000F7   AD83         MOV     R5,DPH
   \   0000F9   741C         MOV     A,#0x1c
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000101   12....       LCALL   ?XSTACK_DISP0_8
   \   000104   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000107   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1122              dstOff += OSAL_NV_WORD_SIZE;
   \   00010A   741C         MOV     A,#0x1c
   \   00010C   12....       LCALL   ?XSTACK_DISP0_8
   \   00010F   12....       LCALL   ?Subroutine5 & 0xFFFF
   1123            }
   1124          
   1125            rem = len % OSAL_NV_WORD_SIZE;
   \                     ??CrossCallReturnLabel_179:
   \   000112   EE           MOV     A,R6
   \   000113   5403         ANL     A,#0x3
   \   000115   C0E0         PUSH    A
   \   000117   7401         MOV     A,#0x1
   \   000119   12....       LCALL   ?XSTACK_DISP0_8
   \   00011C   D0E0         POP     A
   \   00011E   12....       LCALL   ?Subroutine34 & 0xFFFF
   1126            len = len / OSAL_NV_WORD_SIZE;
   \                     ??CrossCallReturnLabel_92:
   \   000121   12....       LCALL   ?US_SHR
   \   000124   AE..         MOV     R6,?V0 + 0
   \   000126   AF..         MOV     R7,?V0 + 1
   \   000128   8078         SJMP    ??CrossCallReturnLabel_181
   1127          
   1128            while ( len-- )
   1129            {
   1130              readWord( srcPg, srcOff, tmp );
   \                     ??xferBuf_6:
   \   00012A   7406         MOV     A,#0x6
   \   00012C   12....       LCALL   ?XSTACK_DISP0_8
   \   00012F   A882         MOV     R0,DPL
   \   000131   A983         MOV     R1,DPH
   \   000133   740A         MOV     A,#0xa
   \   000135   12....       LCALL   ?XSTACK_DISP0_8
   \   000138   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   00013B   7403         MOV     A,#0x3
   \   00013D   12....       LCALL   ?XSTACK_DISP0_8
   \   000140   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000143   12....       LCALL   ?L_SHL
   \   000146   7404         MOV     A,#0x4
   \   000148   12....       LCALL   ?XSTACK_DISP0_8
   \   00014B   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00014E   12....       LCALL   ?L_ADD
   \   000151   75..04       MOV     ?V0 + 0,#0x4
   \                     ??xferBuf_7:
   \   000154                ; Setup parameters for call to function GetCodeByte
   \   000154   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000157   12....       LCALL   ?L_ADD_X
   \   00015A   740A         MOV     A,#0xa
   \   00015C   12....       LCALL   ?XSTACK_DISP0_8
   \   00015F   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000162   740A         MOV     A,#0xa
   \   000164   12....       LCALL   ?XSTACK_DISP0_8
   \   000167   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   00016A   740A         MOV     A,#0xa
   \   00016C   12....       LCALL   ?XSTACK_DISP0_8
   \   00016F   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000172   15..         DEC     ?V0 + 0
   \   000174   E5..         MOV     A,?V0 + 0
   \   000176   70DC         JNZ     ??xferBuf_7
   1131              srcOff += OSAL_NV_WORD_SIZE;
   \   000178   7404         MOV     A,#0x4
   \   00017A   12....       LCALL   ?XSTACK_DISP0_8
   \   00017D   12....       LCALL   ?Subroutine5 & 0xFFFF
   1132              writeWord( dstPg, dstOff, tmp );
   \                     ??CrossCallReturnLabel_180:
   \   000180                ; Setup parameters for call to function writeWord
   \   000180   7406         MOV     A,#0x6
   \   000182   12....       LCALL   ?XSTACK_DISP0_8
   \   000185   AC82         MOV     R4,DPL
   \   000187   AD83         MOV     R5,DPH
   \   000189   741C         MOV     A,#0x1c
   \   00018B   12....       LCALL   ?XSTACK_DISP0_8
   \   00018E   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000191   12....       LCALL   ?XSTACK_DISP0_8
   \   000194   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000197   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1133              dstOff += OSAL_NV_WORD_SIZE;
   \   00019A   741C         MOV     A,#0x1c
   \   00019C   12....       LCALL   ?XSTACK_DISP0_8
   \   00019F   12....       LCALL   ?Subroutine5 & 0xFFFF
   1134            }
   \                     ??CrossCallReturnLabel_181:
   \   0001A2   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   0001A5   7001         JNZ     ??xferBuf_8
   \   0001A7   E9           MOV     A,R1
   \                     ??xferBuf_8:
   \   0001A8   7080         JNZ     ??xferBuf_6
   1135          
   1136            if ( rem )
   \   0001AA   7401         MOV     A,#0x1
   \   0001AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AF   E0           MOVX    A,@DPTR
   \   0001B0   6078         JZ      ??xferBuf_9
   1137            {
   1138              addr = OSAL_NV_PAGE_TO_ADDR( srcPg ) + srcOff;
   \   0001B2   7403         MOV     A,#0x3
   \   0001B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B7   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0001BA   12....       LCALL   ?L_SHL
   \   0001BD   7404         MOV     A,#0x4
   \   0001BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C2   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   0001C5   12....       LCALL   ?L_ADD
   1139          
   1140              for ( idx = 0; idx < rem; idx++ )
   \   0001C8   E4           CLR     A
   \   0001C9   85..82       MOV     DPL,?XSP + 0
   \   0001CC   85..83       MOV     DPH,?XSP + 1
   \   0001CF   F0           MOVX    @DPTR,A
   1141              {
   1142                tmp[idx] = GetCodeByte( addr++ );
   \                     ??xferBuf_10:
   \   0001D0                ; Setup parameters for call to function GetCodeByte
   \   0001D0   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   0001D3   12....       LCALL   ?L_ADD_X
   \   0001D6   85..82       MOV     DPL,?XSP + 0
   \   0001D9   85..83       MOV     DPH,?XSP + 1
   \   0001DC   E0           MOVX    A,@DPTR
   \   0001DD   F8           MOV     R0,A
   \   0001DE   7406         MOV     A,#0x6
   \   0001E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E3   12....       LCALL   ?Subroutine28 & 0xFFFF
   1143              }
   \                     ??CrossCallReturnLabel_75:
   \   0001E6   C0E0         PUSH    A
   \   0001E8   7401         MOV     A,#0x1
   \   0001EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001ED   E0           MOVX    A,@DPTR
   \   0001EE   FA           MOV     R2,A
   \   0001EF   D0E0         POP     A
   \   0001F1   C3           CLR     C
   \   0001F2   9A           SUBB    A,R2
   \   0001F3   40DB         JC      ??xferBuf_10
   1144          
   1145              while ( idx < OSAL_NV_WORD_SIZE )
   \                     ??xferBuf_11:
   \   0001F5   85..82       MOV     DPL,?XSP + 0
   \   0001F8   85..83       MOV     DPH,?XSP + 1
   \   0001FB   E0           MOVX    A,@DPTR
   \   0001FC   C3           CLR     C
   \   0001FD   9404         SUBB    A,#0x4
   \   0001FF   500F         JNC     ??xferBuf_12
   1146              {
   1147                tmp[idx++] = OSAL_NV_ERASED;
   \   000201   E0           MOVX    A,@DPTR
   \   000202   F8           MOV     R0,A
   \   000203   7406         MOV     A,#0x6
   \   000205   12....       LCALL   ?XSTACK_DISP0_8
   \   000208   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   00020B   12....       LCALL   ??Subroutine28_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   00020E   80E5         SJMP    ??xferBuf_11
   1148              }
   1149          
   1150              writeWord( dstPg, dstOff, tmp );
   \                     ??xferBuf_12:
   \   000210                ; Setup parameters for call to function writeWord
   \   000210   7406         MOV     A,#0x6
   \   000212   12....       LCALL   ?XSTACK_DISP0_8
   \   000215   AC82         MOV     R4,DPL
   \   000217   AD83         MOV     R5,DPH
   \   000219   741C         MOV     A,#0x1c
   \   00021B   12....       LCALL   ?XSTACK_DISP0_8
   \   00021E   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000221   12....       LCALL   ?XSTACK_DISP0_8
   \   000224   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000227   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1151            }
   1152          }
   \                     ??xferBuf_9:
   \   00022A   740C         MOV     A,#0xc
   \   00022C   80..         SJMP    ??Subroutine75_0

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   AA..         MOV     R2,?V0 + 0
   \   000002   AB..         MOV     R3,?V0 + 1
   \   000004   AC..         MOV     R4,?V0 + 2
   \   000006   AD..         MOV     R5,?V0 + 3
   \   000008   12....       LCALL   GetCodeByte & 0xFFFF
   \   00000B   90....       MOV     DPTR,#__Constant_1
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000003   74FF         MOV     A,#-0x1
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000003   E9           MOV     A,R1
   \                     ??Subroutine28_0:
   \   000004   F0           MOVX    @DPTR,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   04           INC     A
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E582         MOV     A,DPL
   \   000002   28           ADD     A,R0
   \   000003   02....       LJMP    ?Subroutine69 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000003                REQUIRE ?Subroutine73
   \   000003                ; // Fall through to label ?Subroutine73

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   78..         MOV     R0,#?V0 + 0
   \   000002   79..         MOV     R1,#?V0 + 4
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000003   75..00       MOV     ?V0 + 6,#0x0
   \   000006   75..00       MOV     ?V0 + 7,#0x0
   \   000009   80..         SJMP    ?Subroutine73

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 0,A
   \   000003   75..00       MOV     ?V0 + 1,#0x0
   \   000006   75..00       MOV     ?V0 + 2,#0x0
   \   000009   75..00       MOV     ?V0 + 3,#0x0
   \   00000C   740B         MOV     A,#0xb
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   22           RET
   1153          
   1154          /*********************************************************************
   1155           * @fn      writeItem
   1156           *
   1157           * @brief   Writes an item header/data combo to the specified NV page.
   1158           *
   1159           * @param   pg - Valid NV Flash page.
   1160           * @param   id - Valid NV item Id.
   1161           * @param   len  - Byte count of the data to write.
   1162           * @param   buf  - The data to write. If NULL, no data/checksum write.
   1163           *
   1164           * @return  TRUE if header/data to write matches header/data read back, else FALSE.
   1165           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1166          static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf )
   \                     ??writeItem:
   1167          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   8A..         MOV     ?V0 + 6,R2
   \   00000E   8B..         MOV     ?V0 + 7,R3
   \   000010   8C..         MOV     ?V0 + 4,R4
   \   000012   8D..         MOV     ?V0 + 5,R5
   \   000014   741A         MOV     A,#0x1a
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ?Subroutine21 & 0xFFFF
   1168            uint16 offset = pgOff[pg-OSAL_NV_PAGE_BEG];
   \                     ??CrossCallReturnLabel_62:
   \   00001C   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00001F   12....       LCALL   ?Subroutine19 & 0xFFFF
   1169            uint8 rtrn = FALSE;
   \                     ??CrossCallReturnLabel_56:
   \   000022   7F00         MOV     R7,#0x0
   1170            osalNvHdr_t hdr;
   1171            uint16 sz;
   1172          
   1173            if ( pg == pgRes )
   \   000024   90....       MOV     DPTR,#??pgRes
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6E           XRL     A,R6
   \   000029   700C         JNZ     ??writeItem_1
   1174            {
   1175              /* Mark reserve page as being active, in process of receiving items.
   1176               * Invoking function must effect a page compaction.
   1177               */
   1178              setPageUse( pg, FALSE );
   \   00002B                ; Setup parameters for call to function setPageUse
   \   00002B   7A00         MOV     R2,#0x0
   \   00002D   EE           MOV     A,R6
   \   00002E   F9           MOV     R1,A
   \   00002F   90....       MOV     DPTR,#(??setPageUse & 0xffff)
   \   000032   74..         MOV     A,#((??setPageUse >> 16) & 0xff)
   \   000034   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1179            }
   1180          
   1181            hdr.id = id;
   \                     ??writeItem_1:
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E5..         MOV     A,?V0 + 6
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   E5..         MOV     A,?V0 + 7
   \   000042   F0           MOVX    @DPTR,A
   1182            hdr.len = len;
   \   000043   7404         MOV     A,#0x4
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E5..         MOV     A,?V0 + 4
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E5..         MOV     A,?V0 + 5
   \   00004E   F0           MOVX    @DPTR,A
   1183          
   1184            writeWord( pg, offset, (uint8 *)&hdr );
   \   00004F                ; Setup parameters for call to function writeWord
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   AC82         MOV     R4,DPL
   \   000056   AD83         MOV     R5,DPH
   \   000058   AA..         MOV     R2,?V0 + 0
   \   00005A   AB..         MOV     R3,?V0 + 1
   \   00005C   EE           MOV     A,R6
   \   00005D   F9           MOV     R1,A
   \   00005E   90....       MOV     DPTR,#(??writeWord & 0xffff)
   \   000061   74..         MOV     A,#((??writeWord >> 16) & 0xff)
   \   000063   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1185            readHdr( pg, offset, (uint8 *)(&hdr) );
   \   000066                ; Setup parameters for call to function readHdr
   \   000066   7402         MOV     A,#0x2
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   AC82         MOV     R4,DPL
   \   00006D   AD83         MOV     R5,DPH
   \   00006F   AA..         MOV     R2,?V0 + 0
   \   000071   AB..         MOV     R3,?V0 + 1
   \   000073   EE           MOV     A,R6
   \   000074   F9           MOV     R1,A
   \   000075   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   000078   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   00007A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1186          
   1187            if ( (hdr.id == id) && (hdr.len == len) )
   \   00007D   7402         MOV     A,#0x2
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   E0           MOVX    A,@DPTR
   \   000083   65..         XRL     A,?V0 + 6
   \   000085   7004         JNZ     ??writeItem_2
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   65..         XRL     A,?V0 + 7
   \                     ??writeItem_2:
   \   00008B   6003         JZ      $+5
   \   00008D   02....       LJMP    ??writeItem_3 & 0xFFFF
   \   000090   7404         MOV     A,#0x4
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   E0           MOVX    A,@DPTR
   \   000096   65..         XRL     A,?V0 + 4
   \   000098   7004         JNZ     ??writeItem_4
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   65..         XRL     A,?V0 + 5
   \                     ??writeItem_4:
   \   00009E   6003         JZ      $+5
   \   0000A0   02....       LJMP    ??writeItem_3 & 0xFFFF
   1188            {
   1189              if ( buf != NULL )
   \   0000A3   E5..         MOV     A,?V0 + 2
   \   0000A5   7002         JNZ     ??writeItem_5
   \   0000A7   E5..         MOV     A,?V0 + 3
   \                     ??writeItem_5:
   \   0000A9   7003         JNZ     $+5
   \   0000AB   02....       LJMP    ??writeItem_6 & 0xFFFF
   1190              {
   1191                uint16 chk = calcChkB( len, buf );
   \   0000AE   85..82       MOV     DPL,?V0 + 2
   \   0000B1   85..83       MOV     DPH,?V0 + 3
   \   0000B4   A8..         MOV     R0,?V0 + 4
   \   0000B6   A9..         MOV     R1,?V0 + 5
   \   0000B8   7C00         MOV     R4,#0x0
   \   0000BA   7D00         MOV     R5,#0x0
   \   0000BC   800A         SJMP    ??writeItem_7
   \                     ??writeItem_8:
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   FA           MOV     R2,A
   \   0000C0   EC           MOV     A,R4
   \   0000C1   2A           ADD     A,R2
   \   0000C2   FC           MOV     R4,A
   \   0000C3   ED           MOV     A,R5
   \   0000C4   3400         ADDC    A,#0x0
   \   0000C6   FD           MOV     R5,A
   \   0000C7   A3           INC     DPTR
   \                     ??writeItem_7:
   \   0000C8   E8           MOV     A,R0
   \   0000C9   FA           MOV     R2,A
   \   0000CA   E9           MOV     A,R1
   \   0000CB   FB           MOV     R3,A
   \   0000CC   74FF         MOV     A,#-0x1
   \   0000CE   2A           ADD     A,R2
   \   0000CF   18           DEC     R0
   \   0000D0   74FF         MOV     A,#-0x1
   \   0000D2   3B           ADDC    A,R3
   \   0000D3   F9           MOV     R1,A
   \   0000D4   EA           MOV     A,R2
   \   0000D5   7001         JNZ     ??writeItem_9
   \   0000D7   EB           MOV     A,R3
   \                     ??writeItem_9:
   \   0000D8   70E4         JNZ     ??writeItem_8
   \   0000DA   85..82       MOV     DPL,?XSP + 0
   \   0000DD   85..83       MOV     DPH,?XSP + 1
   \   0000E0   EC           MOV     A,R4
   \   0000E1   F0           MOVX    @DPTR,A
   \   0000E2   A3           INC     DPTR
   \   0000E3   ED           MOV     A,R5
   \   0000E4   F0           MOVX    @DPTR,A
   1192          
   1193                offset += OSAL_NV_HDR_SIZE;
   \   0000E5   12....       LCALL   ?Subroutine43 & 0xFFFF
   1194                writeBuf( pg, offset, len, buf );
   \                     ??CrossCallReturnLabel_115:
   \   0000E8                ; Setup parameters for call to function writeBuf
   \   0000E8   78..         MOV     R0,#?V0 + 2
   \   0000EA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000ED   AC..         MOV     R4,?V0 + 4
   \   0000EF   AD..         MOV     R5,?V0 + 5
   \   0000F1   AA..         MOV     R2,?V0 + 0
   \   0000F3   AB..         MOV     R3,?V0 + 1
   \   0000F5   EE           MOV     A,R6
   \   0000F6   F9           MOV     R1,A
   \   0000F7   90....       MOV     DPTR,#(??writeBuf & 0xffff)
   \   0000FA   74..         MOV     A,#((??writeBuf >> 16) & 0xff)
   \   0000FC   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000FF   7402         MOV     A,#0x2
   \   000101   12....       LCALL   ?DEALLOC_XSTACK8
   1195          
   1196                if ( chk == calcChkF( pg, offset, len ) )
   \   000104                ; Setup parameters for call to function calcChkF
   \   000104   AC..         MOV     R4,?V0 + 4
   \   000106   AD..         MOV     R5,?V0 + 5
   \   000108   AA..         MOV     R2,?V0 + 0
   \   00010A   AB..         MOV     R3,?V0 + 1
   \   00010C   EE           MOV     A,R6
   \   00010D   F9           MOV     R1,A
   \   00010E   90....       MOV     DPTR,#(??calcChkF & 0xffff)
   \   000111   74..         MOV     A,#((??calcChkF >> 16) & 0xff)
   \   000113   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000116   8A..         MOV     ?V0 + 2,R2
   \   000118   8B..         MOV     ?V0 + 3,R3
   \   00011A   A8..         MOV     R0,?V0 + 2
   \   00011C   A9..         MOV     R1,?V0 + 3
   \   00011E   85..82       MOV     DPL,?XSP + 0
   \   000121   85..83       MOV     DPH,?XSP + 1
   \   000124   E0           MOVX    A,@DPTR
   \   000125   68           XRL     A,R0
   \   000126   7003         JNZ     ??writeItem_10
   \   000128   A3           INC     DPTR
   \   000129   E0           MOVX    A,@DPTR
   \   00012A   69           XRL     A,R1
   \                     ??writeItem_10:
   \   00012B   7045         JNZ     ??writeItem_3
   1197                {
   1198                  writeWordH( pg, (offset-OSAL_NV_WORD_SIZE), (uint8 *)&chk );
   \   00012D                ; Setup parameters for call to function writeWordH
   \   00012D   85..82       MOV     DPL,?XSP + 0
   \   000130   85..83       MOV     DPH,?XSP + 1
   \   000133   AC82         MOV     R4,DPL
   \   000135   AD83         MOV     R5,DPH
   \   000137   74FC         MOV     A,#-0x4
   \   000139   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   00013C   90....       MOV     DPTR,#(??writeWordH & 0xffff)
   \   00013F   74..         MOV     A,#((??writeWordH >> 16) & 0xff)
   \   000141   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1199                  readHdr( pg, (offset-OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \   000144                ; Setup parameters for call to function readHdr
   \   000144   7402         MOV     A,#0x2
   \   000146   12....       LCALL   ?XSTACK_DISP0_8
   \   000149   AC82         MOV     R4,DPL
   \   00014B   AD83         MOV     R5,DPH
   \   00014D   74F8         MOV     A,#-0x8
   \   00014F   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000152   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   000155   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   000157   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1200          
   1201                  if ( chk == hdr.chk )
   \   00015A   85..82       MOV     DPL,?XSP + 0
   \   00015D   85..83       MOV     DPH,?XSP + 1
   \   000160   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000163   7406         MOV     A,#0x6
   \   000165   12....       LCALL   ?XSTACK_DISP0_8
   \   000168   E0           MOVX    A,@DPTR
   \   000169   68           XRL     A,R0
   \   00016A   7003         JNZ     ??writeItem_11
   \   00016C   A3           INC     DPTR
   \   00016D   E0           MOVX    A,@DPTR
   \   00016E   69           XRL     A,R1
   \                     ??writeItem_11:
   \   00016F   7001         JNZ     ??writeItem_3
   1202                  {
   1203                    rtrn = TRUE;
   \                     ??writeItem_6:
   \   000171   0F           INC     R7
   1204                  }
   1205                }
   1206              }
   1207              else
   1208              {
   1209                rtrn = TRUE;
   1210              }
   1211            }
   1212          
   1213            sz = ((len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
   1214                                                                       OSAL_NV_HDR_SIZE;
   1215            pgOff[pg-OSAL_NV_PAGE_BEG] += sz;
   \                     ??writeItem_3:
   \   000172   7403         MOV     A,#0x3
   \   000174   25..         ADD     A,?V0 + 4
   \   000176   F8           MOV     R0,A
   \   000177   E4           CLR     A
   \   000178   35..         ADDC    A,?V0 + 5
   \   00017A   F9           MOV     R1,A
   \   00017B   74FC         MOV     A,#-0x4
   \   00017D   58           ANL     A,R0
   \   00017E   F8           MOV     R0,A
   \   00017F   7408         MOV     A,#0x8
   \   000181   28           ADD     A,R0
   \   000182   FA           MOV     R2,A
   \   000183   E4           CLR     A
   \   000184   39           ADDC    A,R1
   \   000185   FB           MOV     R3,A
   \   000186   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   2A           ADD     A,R2
   \   00018B   F0           MOVX    @DPTR,A
   \   00018C   A3           INC     DPTR
   \   00018D   E0           MOVX    A,@DPTR
   \   00018E   3B           ADDC    A,R3
   \   00018F   F0           MOVX    @DPTR,A
   1216          
   1217            return rtrn;
   \   000190   EF           MOV     A,R7
   \   000191   F9           MOV     R1,A
   \   000192   740A         MOV     A,#0xa
   \   000194   02....       LJMP    ??Subroutine75_0 & 0xFFFF
   1218          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   25..         ADD     A,?V0 + 0
   \   000002   FA           MOV     R2,A
   \   000003   74FF         MOV     A,#-0x1
   \   000005   35..         ADDC    A,?V0 + 1
   \   000007   FB           MOV     R3,A
   \   000008   EE           MOV     A,R6
   \   000009   F9           MOV     R1,A
   \   00000A   22           RET
   1219          
   1220          /*********************************************************************
   1221           * @fn      osal_nv_init
   1222           *
   1223           * @brief   Initialize NV service.
   1224           *
   1225           * @param   p - Not used.
   1226           *
   1227           * @return  none
   1228           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1229          void osal_nv_init( void *p )
   \                     osal_nv_init:
   1230          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1231            (void)p;  // Suppress Lint warning.
   1232          
   1233            // Set Flash write timing based on CPU speed.
   1234          #ifdef CPU16MHZ
   1235            FWT = 0x15;
   1236          #else
   1237            FWT = 0x2A;
   \   000004   75AB2A       MOV     0xab,#0x2a
   1238          #endif
   1239          
   1240            initDMA();
   \   000007   74DF         MOV     A,#-0x21
   \   000009   90....       MOV     DPTR,#(dmaCh0 + 2)
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   74AF         MOV     A,#-0x51
   \   00000F   90....       MOV     DPTR,#(dmaCh0 + 3)
   \   000012   F0           MOVX    @DPTR,A
   \   000013   74..         MOV     A,#((FBuff >> 8) & 0xff)
   \   000015   90....       MOV     DPTR,#dmaCh0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   74..         MOV     A,#(FBuff & 0xff)
   \   00001B   90....       MOV     DPTR,#(dmaCh0 + 1)
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   90....       MOV     DPTR,#(dmaCh0 + 4)
   \   000022   E0           MOVX    A,@DPTR
   \   000023   541F         ANL     A,#0x1f
   \   000025   F0           MOVX    @DPTR,A
   \   000026   7404         MOV     A,#0x4
   \   000028   90....       MOV     DPTR,#(dmaCh0 + 5)
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   90....       MOV     DPTR,#(dmaCh0 + 4)
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   54E0         ANL     A,#0xe0
   \   000032   F0           MOVX    @DPTR,A
   \   000033   7412         MOV     A,#0x12
   \   000035   90....       MOV     DPTR,#(dmaCh0 + 6)
   \   000038   F0           MOVX    @DPTR,A
   \   000039   7442         MOV     A,#0x42
   \   00003B   90....       MOV     DPTR,#(dmaCh0 + 7)
   \   00003E   F0           MOVX    @DPTR,A
   1241          
   1242            (void)initNV();  // Always returns TRUE after pages have been erased.
   \   00003F                ; Setup parameters for call to function initNV
   \   00003F   90....       MOV     DPTR,#(??initNV & 0xffff)
   \   000042   74..         MOV     A,#((??initNV >> 16) & 0xff)
   \   000044   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1243          }
   \   000047   02....       LJMP    ?Subroutine67 & 0xFFFF
   1244          
   1245          /*********************************************************************
   1246           * @fn      osal_nv_item_init
   1247           *
   1248           * @brief   If the NV item does not already exist, it is created and
   1249           *          initialized with the data passed to the function, if any.
   1250           *          This function must be called before calling osal_nv_read() or
   1251           *          osal_nv_write().
   1252           *
   1253           * @param   id  - Valid NV item Id.
   1254           * @param   len - Item length.
   1255           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
   1256           *
   1257           * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
   1258           *          ZSUCCESS       - Id already existed, no action taken.
   1259           *          NV_OPER_FAILED - Failure to find or create Id.
   1260           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1261          uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
   \                     osal_nv_item_init:
   1262          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   740E         MOV     A,#0xe
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine21 & 0xFFFF
   1263            failF = FALSE;
   \                     ??CrossCallReturnLabel_63:
   \   000015   E4           CLR     A
   \   000016   90....       MOV     DPTR,#??failF
   \   000019   F0           MOVX    @DPTR,A
   1264          
   1265            /* ZCD_NV_EXTADDR is the only item maintained without an osalNvHdr_t,
   1266             * so it is always already initialized.
   1267             */
   1268            if ( (id == ZCD_NV_EXTADDR) || (findItem( id ) != OSAL_NV_ITEM_NULL) )
   \   00001A   7401         MOV     A,#0x1
   \   00001C   6E           XRL     A,R6
   \   00001D   7001         JNZ     ??osal_nv_item_init_0
   \   00001F   EF           MOV     A,R7
   \                     ??osal_nv_item_init_0:
   \   000020   600E         JZ      ??osal_nv_item_init_1
   \   000022                ; Setup parameters for call to function findItem
   \   000022   90....       MOV     DPTR,#(??findItem & 0xffff)
   \   000025   74..         MOV     A,#((??findItem >> 16) & 0xff)
   \   000027   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00002A   EA           MOV     A,R2
   \   00002B   7001         JNZ     ??osal_nv_item_init_2
   \   00002D   EB           MOV     A,R3
   \                     ??osal_nv_item_init_2:
   \   00002E   6004         JZ      ??osal_nv_item_init_3
   1269            {
   1270              return ZSUCCESS;
   \                     ??osal_nv_item_init_1:
   \   000030   7900         MOV     R1,#0x0
   \   000032   802D         SJMP    ??osal_nv_item_init_4
   1271            }
   1272            else if ( initItem( id, len, buf ) != OSAL_NV_PAGE_NULL )
   \                     ??osal_nv_item_init_3:
   \   000034                ; Setup parameters for call to function initItem
   \   000034   78..         MOV     R0,#?V0 + 2
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   AC..         MOV     R4,?V0 + 0
   \   00003B   AD..         MOV     R5,?V0 + 1
   \   00003D   EE           MOV     A,R6
   \   00003E   FA           MOV     R2,A
   \   00003F   EF           MOV     A,R7
   \   000040   FB           MOV     R3,A
   \   000041   90....       MOV     DPTR,#(??initItem & 0xffff)
   \   000044   74..         MOV     A,#((??initItem >> 16) & 0xff)
   \   000046   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000049   7402         MOV     A,#0x2
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004E   E9           MOV     A,R1
   \   00004F   600E         JZ      ??osal_nv_item_init_5
   1273            {
   1274              if ( failF )
   \   000051   90....       MOV     DPTR,#??failF
   \   000054   E0           MOVX    A,@DPTR
   \   000055   600D         JZ      ??osal_nv_item_init_6
   1275              {
   1276                (void)initNV();  // See comment at the declaration of failF.
   \   000057                ; Setup parameters for call to function initNV
   \   000057   90....       MOV     DPTR,#(??initNV & 0xffff)
   \   00005A   74..         MOV     A,#((??initNV >> 16) & 0xff)
   \   00005C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1277                return NV_OPER_FAILED;
   1278              }
   1279              else
   1280              {
   1281                return NV_ITEM_UNINIT;
   1282              }
   1283            }
   1284            else
   1285            {
   1286              return NV_OPER_FAILED;
   \                     ??osal_nv_item_init_5:
   \   00005F   7910         MOV     R1,#0x10
   \                     ??osal_nv_item_init_4:
   \   000061   02....       LJMP    ?Subroutine68 & 0xFFFF
   1287            }
   \                     ??osal_nv_item_init_6:
   \   000064   790F         MOV     R1,#0xf
   \   000066   80F9         SJMP    ??osal_nv_item_init_4
   1288          }
   1289          
   1290          /*********************************************************************
   1291           * @fn      osal_nv_item_len
   1292           *
   1293           * @brief   Get the data length of the item stored in NV memory.
   1294           *
   1295           * @param   id  - Valid NV item Id.
   1296           *
   1297           * @return  Item length, if found; zero otherwise.
   1298           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1299          uint16 osal_nv_item_len( uint16 id )
   \                     osal_nv_item_len:
   1300          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1301            if ( id == ZCD_NV_EXTADDR )
   \   00000A   7401         MOV     A,#0x1
   \   00000C   6A           XRL     A,R2
   \   00000D   7001         JNZ     ??osal_nv_item_len_0
   \   00000F   EB           MOV     A,R3
   \                     ??osal_nv_item_len_0:
   \   000010   7006         JNZ     ??osal_nv_item_len_1
   1302            {
   1303              return Z_EXTADDR_LEN;
   \   000012   7A08         MOV     R2,#0x8
   \                     ??osal_nv_item_len_2:
   \   000014   7B00         MOV     R3,#0x0
   \   000016   8041         SJMP    ??CrossCallReturnLabel_51
   1304            }
   1305            else
   1306            {
   1307              uint16 offset = findItem( id );
   \                     ??osal_nv_item_len_1:
   \   000018                ; Setup parameters for call to function findItem
   \   000018   90....       MOV     DPTR,#(??findItem & 0xffff)
   \   00001B   74..         MOV     A,#((??findItem >> 16) & 0xff)
   \   00001D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000020   8A..         MOV     ?V0 + 0,R2
   \   000022   8B..         MOV     ?V0 + 1,R3
   \   000024   A8..         MOV     R0,?V0 + 0
   \   000026   A9..         MOV     R1,?V0 + 1
   1308          
   1309              if ( offset == OSAL_NV_ITEM_NULL )
   \   000028   E8           MOV     A,R0
   \   000029   7001         JNZ     ??osal_nv_item_len_3
   \   00002B   E9           MOV     A,R1
   \                     ??osal_nv_item_len_3:
   \   00002C   7004         JNZ     ??osal_nv_item_len_4
   1310              {
   1311                return 0;
   \   00002E   7A00         MOV     R2,#0x0
   \   000030   80E2         SJMP    ??osal_nv_item_len_2
   1312              }
   1313              else
   1314              {
   1315                osalNvHdr_t hdr;
   1316                readHdr( findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_item_len_4:
   \   000032                ; Setup parameters for call to function readHdr
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   74F8         MOV     A,#-0x8
   \   00003E   28           ADD     A,R0
   \   00003F   FA           MOV     R2,A
   \   000040   74FF         MOV     A,#-0x1
   \   000042   39           ADDC    A,R1
   \   000043   FB           MOV     R3,A
   \   000044   90....       MOV     DPTR,#??findPg
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F9           MOV     R1,A
   \   000049   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   00004C   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   00004E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1317                return hdr.len;
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000059   7408         MOV     A,#0x8
   \   00005B   02....       LJMP    ?Subroutine66 & 0xFFFF
   1318              }
   1319            }
   1320          }
   1321          
   1322          /*********************************************************************
   1323           * @fn      osal_nv_write
   1324           *
   1325           * @brief   Write a data item to NV. Function can write an entire item to NV or
   1326           *          an element of an item by indexing into the item with an offset.
   1327           *
   1328           * @param   id  - Valid NV item Id.
   1329           * @param   ndx - Index offset into item
   1330           * @param   len - Length of data to write.
   1331           * @param  *buf - Data to write.
   1332           *
   1333           * @return  ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
   1334           *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
   1335           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1336          uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_write:
   1337          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7408         MOV     A,#0x8
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000012   7403         MOV     A,#0x3
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   EC           MOV     A,R4
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   ED           MOV     A,R5
   \   00001B   F0           MOVX    @DPTR,A
   1338            uint8 rtrn = ZSUCCESS;
   \   00001C   E4           CLR     A
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   F0           MOVX    @DPTR,A
   1339          
   1340            /* Global fail flag for fail due to low bus voltage has less impact on code
   1341             * size than passing back a return value all the way from the lowest level.
   1342             */
   1343            failF = FALSE;
   \   000024   90....       MOV     DPTR,#??failF
   \   000027   F0           MOVX    @DPTR,A
   1344          
   1345            if ( id == ZCD_NV_EXTADDR )
   \   000028   7408         MOV     A,#0x8
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6401         XRL     A,#0x1
   \   000030   7002         JNZ     ??osal_nv_write_0
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \                     ??osal_nv_write_0:
   \   000034   6003         JZ      $+5
   \   000036   02....       LJMP    ??osal_nv_write_1 & 0xFFFF
   1346            {
   1347              osalNvHdr_t hdr;
   1348              readHdr( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, (uint8 *)(&hdr) );
   \   000039                ; Setup parameters for call to function readHdr
   \   000039   740A         MOV     A,#0xa
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   AC82         MOV     R4,DPL
   \   000040   AD83         MOV     R5,DPH
   \   000042   7AF8         MOV     R2,#-0x8
   \   000044   7B07         MOV     R3,#0x7
   \   000046   793F         MOV     R1,#0x3f
   \   000048   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   00004B   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   00004D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1349          
   1350              if ( (hdr.id == OSAL_NV_ERASED_ID) &&
   1351                   (hdr.len == OSAL_NV_ERASED_ID) &&
   1352                   (hdr.chk == OSAL_NV_ERASED_ID) &&
   1353                   (hdr.stat == OSAL_NV_ERASED_ID) )
   \   000050   740A         MOV     A,#0xa
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   E0           MOVX    A,@DPTR
   \   000056   64FF         XRL     A,#0xff
   \   000058   7004         JNZ     ??osal_nv_write_2
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_2:
   \   00005E   7055         JNZ     ??osal_nv_write_3
   \   000060   740C         MOV     A,#0xc
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   E0           MOVX    A,@DPTR
   \   000066   64FF         XRL     A,#0xff
   \   000068   7004         JNZ     ??osal_nv_write_4
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_4:
   \   00006E   7045         JNZ     ??osal_nv_write_3
   \   000070   740E         MOV     A,#0xe
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E0           MOVX    A,@DPTR
   \   000076   64FF         XRL     A,#0xff
   \   000078   7004         JNZ     ??osal_nv_write_5
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_5:
   \   00007E   7035         JNZ     ??osal_nv_write_3
   \   000080   7410         MOV     A,#0x10
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   E0           MOVX    A,@DPTR
   \   000086   64FF         XRL     A,#0xff
   \   000088   7004         JNZ     ??osal_nv_write_6
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   64FF         XRL     A,#0xff
   \                     ??osal_nv_write_6:
   \   00008E   7025         JNZ     ??osal_nv_write_3
   1354              {
   1355                writeWordD( OSAL_NV_IEEE_PAGE, OSAL_NV_IEEE_OFFSET, buf );
   \   000090                ; Setup parameters for call to function writeWordD
   \   000090   7424         MOV     A,#0x24
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000098   7AF8         MOV     R2,#-0x8
   \   00009A   7B07         MOV     R3,#0x7
   \   00009C   793F         MOV     R1,#0x3f
   \   00009E   90....       MOV     DPTR,#(??writeWordD & 0xffff)
   \   0000A1   74..         MOV     A,#((??writeWordD >> 16) & 0xff)
   \   0000A3   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1356                return ((failF) ? NV_OPER_FAILED : ZSUCCESS);
   \   0000A6   90....       MOV     DPTR,#??failF
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   6004         JZ      ??osal_nv_write_7
   \   0000AC   7910         MOV     R1,#0x10
   \   0000AE   8002         SJMP    ??osal_nv_write_8
   \                     ??osal_nv_write_7:
   \   0000B0   7900         MOV     R1,#0x0
   \                     ??osal_nv_write_8:
   \   0000B2   02....       LJMP    ??osal_nv_write_9 & 0xFFFF
   1357              }
   1358              else
   1359              {
   1360                return NV_OPER_FAILED;
   \                     ??osal_nv_write_3:
   \   0000B5   7910         MOV     R1,#0x10
   \   0000B7   02....       LJMP    ??osal_nv_write_9 & 0xFFFF
   1361              }
   1362            }
   1363          
   1364            if ( len != 0 )
   \                     ??osal_nv_write_1:
   \   0000BA   7422         MOV     A,#0x22
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   7002         JNZ     ??osal_nv_write_10
   \   0000C2   A3           INC     DPTR
   \   0000C3   E0           MOVX    A,@DPTR
   \                     ??osal_nv_write_10:
   \   0000C4   7003         JNZ     $+5
   \   0000C6   02....       LJMP    ??osal_nv_write_11 & 0xFFFF
   1365            {
   1366              osalNvHdr_t hdr;
   1367              uint32 addr;
   1368              uint16 srcOff;
   1369              uint16 cnt;
   1370              uint8 *ptr;
   1371          
   1372              srcOff = findItem( id );
   \   0000C9                ; Setup parameters for call to function findItem
   \   0000C9   7408         MOV     A,#0x8
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000D1   90....       MOV     DPTR,#(??findItem & 0xffff)
   \   0000D4   74..         MOV     A,#((??findItem >> 16) & 0xff)
   \   0000D6   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000D9   7401         MOV     A,#0x1
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   12....       LCALL   ?Subroutine35 & 0xFFFF
   1373              if ( srcOff == OSAL_NV_ITEM_NULL )
   \                     ??CrossCallReturnLabel_97:
   \   0000E1   7401         MOV     A,#0x1
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   7002         JNZ     ??osal_nv_write_12
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \                     ??osal_nv_write_12:
   \   0000EB   7005         JNZ     ??osal_nv_write_13
   1374              {
   1375                return NV_ITEM_UNINIT;
   \   0000ED   790F         MOV     R1,#0xf
   \   0000EF   02....       LJMP    ??osal_nv_write_9 & 0xFFFF
   1376              }
   1377          
   1378              readHdr( findPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_write_13:
   \   0000F2                ; Setup parameters for call to function readHdr
   \   0000F2   740A         MOV     A,#0xa
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   AC82         MOV     R4,DPL
   \   0000F9   AD83         MOV     R5,DPH
   \   0000FB   7401         MOV     A,#0x1
   \   0000FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000100   E0           MOVX    A,@DPTR
   \   000101   24F8         ADD     A,#-0x8
   \   000103   FA           MOV     R2,A
   \   000104   A3           INC     DPTR
   \   000105   E0           MOVX    A,@DPTR
   \   000106   34FF         ADDC    A,#-0x1
   \   000108   FB           MOV     R3,A
   \   000109   90....       MOV     DPTR,#??findPg
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   F9           MOV     R1,A
   \   00010E   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   000111   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   000113   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1379              if ( hdr.len < (ndx + len) )
   \   000116   740C         MOV     A,#0xc
   \   000118   12....       LCALL   ?XSTACK_DISP0_8
   \   00011B   C082         PUSH    DPL
   \   00011D   C083         PUSH    DPH
   \   00011F   7403         MOV     A,#0x3
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   C082         PUSH    DPL
   \   000126   C083         PUSH    DPH
   \   000128   7422         MOV     A,#0x22
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000130   D083         POP     DPH
   \   000132   D082         POP     DPL
   \   000134   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000137   D083         POP     DPH
   \   000139   D082         POP     DPL
   \   00013B   C3           CLR     C
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   98           SUBB    A,R0
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   99           SUBB    A,R1
   \   000141   5003         JNC     $+5
   \   000143   02....       LJMP    ??osal_nv_write_3 & 0xFFFF
   1380              {
   1381                return NV_OPER_FAILED;
   1382              }
   1383          
   1384              addr = OSAL_NV_PAGE_TO_ADDR( findPg ) + srcOff + ndx;
   \   000146   90....       MOV     DPTR,#??findPg
   \   000149   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00014C   12....       LCALL   ?L_SHL
   \   00014F   7401         MOV     A,#0x1
   \   000151   12....       LCALL   ?XSTACK_DISP0_8
   \   000154   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000157   12....       LCALL   ?L_ADD
   \   00015A   7403         MOV     A,#0x3
   \   00015C   12....       LCALL   ?XSTACK_DISP0_8
   \   00015F   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000162   12....       LCALL   ?L_ADD
   1385              ptr = buf;
   \   000165   7424         MOV     A,#0x24
   \   000167   12....       LCALL   ?XSTACK_DISP0_8
   \   00016A   12....       LCALL   ?Subroutine57 & 0xFFFF
   1386              cnt = len;
   \                     ??CrossCallReturnLabel_153:
   \   00016D   7422         MOV     A,#0x22
   \   00016F   12....       LCALL   ?XSTACK_DISP0_8
   \   000172   E0           MOVX    A,@DPTR
   \   000173   FE           MOV     R6,A
   \   000174   A3           INC     DPTR
   \   000175   E0           MOVX    A,@DPTR
   \   000176   FF           MOV     R7,A
   1387              do
   1388              {
   1389                if ( GetCodeByte( addr++ ) != *ptr++ )
   \                     ??osal_nv_write_14:
   \   000177                ; Setup parameters for call to function GetCodeByte
   \   000177   AA..         MOV     R2,?V0 + 0
   \   000179   AB..         MOV     R3,?V0 + 1
   \   00017B   AC..         MOV     R4,?V0 + 2
   \   00017D   AD..         MOV     R5,?V0 + 3
   \   00017F   12....       LCALL   GetCodeByte & 0xFFFF
   \   000182   E9           MOV     A,R1
   \   000183   FA           MOV     R2,A
   \   000184   90....       MOV     DPTR,#__Constant_1
   \   000187   78..         MOV     R0,#?V0 + 0
   \   000189   12....       LCALL   ?L_ADD_X
   \   00018C   A8..         MOV     R0,?V0 + 4
   \   00018E   A9..         MOV     R1,?V0 + 5
   \   000190   8882         MOV     DPL,R0
   \   000192   8983         MOV     DPH,R1
   \   000194   A3           INC     DPTR
   \   000195   8582..       MOV     ?V0 + 4,DPL
   \   000198   8583..       MOV     ?V0 + 5,DPH
   \   00019B   8882         MOV     DPL,R0
   \   00019D   8983         MOV     DPH,R1
   \   00019F   E0           MOVX    A,@DPTR
   \   0001A0   6A           XRL     A,R2
   \   0001A1   7009         JNZ     ??osal_nv_write_15
   1390                {
   1391                  break;
   1392                }
   1393              } while ( --cnt );
   \   0001A3   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   0001A6   EE           MOV     A,R6
   \   0001A7   7001         JNZ     ??osal_nv_write_16
   \   0001A9   EF           MOV     A,R7
   \                     ??osal_nv_write_16:
   \   0001AA   70CB         JNZ     ??osal_nv_write_14
   1394          
   1395              if ( cnt != 0 )  // If the buffer to write is different in one or more bytes.
   \                     ??osal_nv_write_15:
   \   0001AC   EE           MOV     A,R6
   \   0001AD   7001         JNZ     ??osal_nv_write_17
   \   0001AF   EF           MOV     A,R7
   \                     ??osal_nv_write_17:
   \   0001B0   7003         JNZ     $+5
   \   0001B2   02....       LJMP    ??osal_nv_write_18 & 0xFFFF
   1396              {
   1397                uint8 comPg, srcPg;
   1398          
   1399                comPg = srcPg = findPg;
   \   0001B5   90....       MOV     DPTR,#??findPg
   \   0001B8   E0           MOVX    A,@DPTR
   \   0001B9   F5..         MOV     ?V0 + 1,A
   \   0001BB   7407         MOV     A,#0x7
   \   0001BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C0   E5..         MOV     A,?V0 + 1
   \   0001C2   F0           MOVX    @DPTR,A
   1400                // initItem2() can change the findPg and it advances pgOff[] of the dstPg.
   1401                uint8 dstPg = initItem2( id, hdr.len, &comPg );
   \   0001C3                ; Setup parameters for call to function initItem2
   \   0001C3   8582..       MOV     ?V0 + 2,DPL
   \   0001C6   8583..       MOV     ?V0 + 3,DPH
   \   0001C9   78..         MOV     R0,#?V0 + 2
   \   0001CB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001CE   740E         MOV     A,#0xe
   \   0001D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D3   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0001D6   740A         MOV     A,#0xa
   \   0001D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DB   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0001DE   90....       MOV     DPTR,#(??initItem2 & 0xffff)
   \   0001E1   74..         MOV     A,#((??initItem2 >> 16) & 0xff)
   \   0001E3   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0001E6   7402         MOV     A,#0x2
   \   0001E8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001EB   E9           MOV     A,R1
   \   0001EC   F5..         MOV     ?V0 + 0,A
   1402          
   1403                if ( dstPg != OSAL_NV_PAGE_NULL )
   \   0001EE   7003         JNZ     $+5
   \   0001F0   02....       LJMP    ??osal_nv_write_19 & 0xFFFF
   1404                {
   1405                  uint16 tmp = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
   \   0001F3   740C         MOV     A,#0xc
   \   0001F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F8   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   0001FB   7405         MOV     A,#0x5
   \   0001FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000200   12....       LCALL   ?Subroutine71 & 0xFFFF
   1406                  uint16 dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \                     ??CrossCallReturnLabel_186:
   \   000203   E5..         MOV     A,?V0 + 0
   \   000205   C3           CLR     C
   \   000206   33           RLC     A
   \   000207   F8           MOV     R0,A
   \   000208   E4           CLR     A
   \   000209   33           RLC     A
   \   00020A   F9           MOV     R1,A
   \   00020B   E8           MOV     A,R0
   \   00020C   24..         ADD     A,#((??pgOff + 136) & 0xff)
   \   00020E   F5..         MOV     ?V0 + 4,A
   \   000210   E9           MOV     A,R1
   \   000211   34..         ADDC    A,#(((??pgOff - 120) >> 8) & 0xff)
   \   000213   F5..         MOV     ?V0 + 5,A
   \   000215   85..82       MOV     DPL,?V0 + 4
   \   000218   F583         MOV     DPH,A
   \   00021A   C082         PUSH    DPL
   \   00021C   C083         PUSH    DPH
   \   00021E   7405         MOV     A,#0x5
   \   000220   12....       LCALL   ?XSTACK_DISP0_8
   \   000223   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000226   D083         POP     DPH
   \   000228   D082         POP     DPL
   \   00022A   12....       LCALL   ?Subroutine27 & 0xFFFF
   1407                  uint16 origOff = srcOff;
   1408          
   1409                  setItem( srcPg, srcOff, eNvXfer );
   \                     ??CrossCallReturnLabel_72:
   \   00022D                ; Setup parameters for call to function setItem
   \   00022D   7C00         MOV     R4,#0x0
   \   00022F   7401         MOV     A,#0x1
   \   000231   12....       LCALL   ?XSTACK_DISP0_8
   \   000234   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000237   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1410          
   1411                  xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
   \   00023A                ; Setup parameters for call to function xferBuf
   \   00023A   7403         MOV     A,#0x3
   \   00023C   12....       LCALL   ?XSTACK_DISP0_8
   \   00023F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000242   8E..         MOV     ?V0 + 2,R6
   \   000244   8F..         MOV     ?V0 + 3,R7
   \   000246   78..         MOV     R0,#?V0 + 2
   \   000248   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00024B   AC..         MOV     R4,?V0 + 0
   \   00024D   7405         MOV     A,#0x5
   \   00024F   12....       LCALL   ?XSTACK_DISP0_8
   \   000252   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000255   A9..         MOV     R1,?V0 + 1
   \   000257   90....       MOV     DPTR,#(??xferBuf & 0xffff)
   \   00025A   74..         MOV     A,#((??xferBuf >> 16) & 0xff)
   \   00025C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00025F   7404         MOV     A,#0x4
   \   000261   12....       LCALL   ?DEALLOC_XSTACK8
   1412                  srcOff += ndx;
   1413                  dstOff += ndx;
   \   000264   7403         MOV     A,#0x3
   \   000266   12....       LCALL   ?XSTACK_DISP0_8
   \   000269   E0           MOVX    A,@DPTR
   \   00026A   2E           ADD     A,R6
   \   00026B   FE           MOV     R6,A
   \   00026C   A3           INC     DPTR
   \   00026D   E0           MOVX    A,@DPTR
   \   00026E   3F           ADDC    A,R7
   \   00026F   FF           MOV     R7,A
   1414          
   1415                  writeBuf( dstPg, dstOff, len, buf );
   \   000270                ; Setup parameters for call to function writeBuf
   \   000270   7424         MOV     A,#0x24
   \   000272   12....       LCALL   ?XSTACK_DISP0_8
   \   000275   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000278   7424         MOV     A,#0x24
   \   00027A   12....       LCALL   ?XSTACK_DISP0_8
   \   00027D   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000280   90....       MOV     DPTR,#(??writeBuf & 0xffff)
   \   000283   74..         MOV     A,#((??writeBuf >> 16) & 0xff)
   \   000285   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000288   7402         MOV     A,#0x2
   \   00028A   12....       LCALL   ?DEALLOC_XSTACK8
   1416                  srcOff += len;
   1417                  dstOff += len;
   1418          
   1419                  xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
   \   00028D                ; Setup parameters for call to function xferBuf
   \   00028D   740C         MOV     A,#0xc
   \   00028F   12....       LCALL   ?XSTACK_DISP0_8
   \   000292   C082         PUSH    DPL
   \   000294   C083         PUSH    DPH
   \   000296   7403         MOV     A,#0x3
   \   000298   12....       LCALL   ?XSTACK_DISP0_8
   \   00029B   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00029E   D083         POP     DPH
   \   0002A0   D082         POP     DPL
   \   0002A2   E0           MOVX    A,@DPTR
   \   0002A3   C3           CLR     C
   \   0002A4   98           SUBB    A,R0
   \   0002A5   FA           MOV     R2,A
   \   0002A6   A3           INC     DPTR
   \   0002A7   E0           MOVX    A,@DPTR
   \   0002A8   99           SUBB    A,R1
   \   0002A9   FB           MOV     R3,A
   \   0002AA   7422         MOV     A,#0x22
   \   0002AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AF   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0002B2   EA           MOV     A,R2
   \   0002B3   C3           CLR     C
   \   0002B4   98           SUBB    A,R0
   \   0002B5   F5..         MOV     ?V0 + 2,A
   \   0002B7   EB           MOV     A,R3
   \   0002B8   99           SUBB    A,R1
   \   0002B9   F5..         MOV     ?V0 + 3,A
   \   0002BB   78..         MOV     R0,#?V0 + 2
   \   0002BD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002C0   7424         MOV     A,#0x24
   \   0002C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C5   E0           MOVX    A,@DPTR
   \   0002C6   2E           ADD     A,R6
   \   0002C7   F5..         MOV     ?V0 + 2,A
   \   0002C9   A3           INC     DPTR
   \   0002CA   E0           MOVX    A,@DPTR
   \   0002CB   3F           ADDC    A,R7
   \   0002CC   F5..         MOV     ?V0 + 3,A
   \   0002CE   78..         MOV     R0,#?V0 + 2
   \   0002D0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002D3   AC..         MOV     R4,?V0 + 0
   \   0002D5   7405         MOV     A,#0x5
   \   0002D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002DA   C082         PUSH    DPL
   \   0002DC   C083         PUSH    DPH
   \   0002DE   7407         MOV     A,#0x7
   \   0002E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E3   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0002E6   D083         POP     DPH
   \   0002E8   D082         POP     DPL
   \   0002EA   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0002ED   7426         MOV     A,#0x26
   \   0002EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F2   E0           MOVX    A,@DPTR
   \   0002F3   28           ADD     A,R0
   \   0002F4   FA           MOV     R2,A
   \   0002F5   A3           INC     DPTR
   \   0002F6   E0           MOVX    A,@DPTR
   \   0002F7   39           ADDC    A,R1
   \   0002F8   FB           MOV     R3,A
   \   0002F9   A9..         MOV     R1,?V0 + 1
   \   0002FB   90....       MOV     DPTR,#(??xferBuf & 0xffff)
   \   0002FE   74..         MOV     A,#((??xferBuf >> 16) & 0xff)
   \   000300   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000303   7404         MOV     A,#0x4
   \   000305   12....       LCALL   ?DEALLOC_XSTACK8
   1420          
   1421                  // Calculate and write the new checksum.
   1422                  dstOff = pgOff[dstPg-OSAL_NV_PAGE_BEG] - tmp;
   \   000308   85..82       MOV     DPL,?V0 + 4
   \   00030B   85..83       MOV     DPH,?V0 + 5
   \   00030E   C082         PUSH    DPL
   \   000310   C083         PUSH    DPH
   \   000312   7405         MOV     A,#0x5
   \   000314   12....       LCALL   ?XSTACK_DISP0_8
   \   000317   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00031A   D083         POP     DPH
   \   00031C   D082         POP     DPL
   \   00031E   12....       LCALL   ?Subroutine27 & 0xFFFF
   1423                  tmp = calcChkF( dstPg, dstOff, hdr.len );
   \                     ??CrossCallReturnLabel_73:
   \   000321                ; Setup parameters for call to function calcChkF
   \   000321   740C         MOV     A,#0xc
   \   000323   12....       LCALL   ?XSTACK_DISP0_8
   \   000326   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000329   90....       MOV     DPTR,#(??calcChkF & 0xffff)
   \   00032C   74..         MOV     A,#((??calcChkF >> 16) & 0xff)
   \   00032E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000331   7405         MOV     A,#0x5
   \   000333   12....       LCALL   ?XSTACK_DISP0_8
   \   000336   12....       LCALL   ?Subroutine35 & 0xFFFF
   1424                  dstOff -= OSAL_NV_HDR_SIZE;
   \                     ??CrossCallReturnLabel_98:
   \   000339   EE           MOV     A,R6
   \   00033A   24F8         ADD     A,#-0x8
   \   00033C   FE           MOV     R6,A
   \   00033D   EF           MOV     A,R7
   \   00033E   34FF         ADDC    A,#-0x1
   \   000340   FF           MOV     R7,A
   1425                  writeWordH( dstPg, (dstOff+OSAL_NV_HDR_CHK), (uint8 *)&tmp );
   \   000341                ; Setup parameters for call to function writeWordH
   \   000341   7405         MOV     A,#0x5
   \   000343   12....       LCALL   ?XSTACK_DISP0_8
   \   000346   AC82         MOV     R4,DPL
   \   000348   AD83         MOV     R5,DPH
   \   00034A   7404         MOV     A,#0x4
   \   00034C   2E           ADD     A,R6
   \   00034D   FA           MOV     R2,A
   \   00034E   E4           CLR     A
   \   00034F   3F           ADDC    A,R7
   \   000350   FB           MOV     R3,A
   \   000351   A9..         MOV     R1,?V0 + 0
   \   000353   90....       MOV     DPTR,#(??writeWordH & 0xffff)
   \   000356   74..         MOV     A,#((??writeWordH >> 16) & 0xff)
   \   000358   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1426                  readHdr( dstPg, dstOff, (uint8 *)(&hdr) );
   \   00035B                ; Setup parameters for call to function readHdr
   \   00035B   740A         MOV     A,#0xa
   \   00035D   12....       LCALL   ?XSTACK_DISP0_8
   \   000360   AC82         MOV     R4,DPL
   \   000362   AD83         MOV     R5,DPH
   \   000364   EE           MOV     A,R6
   \   000365   FA           MOV     R2,A
   \   000366   EF           MOV     A,R7
   \   000367   FB           MOV     R3,A
   \   000368   A9..         MOV     R1,?V0 + 0
   \   00036A   90....       MOV     DPTR,#(??readHdr & 0xffff)
   \   00036D   74..         MOV     A,#((??readHdr >> 16) & 0xff)
   \   00036F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1427          
   1428                  if ( tmp == hdr.chk )
   \   000372   7405         MOV     A,#0x5
   \   000374   12....       LCALL   ?XSTACK_DISP0_8
   \   000377   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00037A   740E         MOV     A,#0xe
   \   00037C   12....       LCALL   ?XSTACK_DISP0_8
   \   00037F   E0           MOVX    A,@DPTR
   \   000380   68           XRL     A,R0
   \   000381   7003         JNZ     ??osal_nv_write_20
   \   000383   A3           INC     DPTR
   \   000384   E0           MOVX    A,@DPTR
   \   000385   69           XRL     A,R1
   \                     ??osal_nv_write_20:
   \   000386   700E         JNZ     ??osal_nv_write_21
   1429                  {
   1430                    setItem( srcPg, origOff, eNvZero );
   \   000388                ; Setup parameters for call to function setItem
   \   000388   7C01         MOV     R4,#0x1
   \   00038A   EC           MOV     A,R4
   \   00038B   12....       LCALL   ?XSTACK_DISP0_8
   \   00038E   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000391   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000394   8009         SJMP    ??osal_nv_write_22
   1431                  }
   1432                  else
   1433                  {
   1434                    rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_21:
   \   000396   7410         MOV     A,#0x10
   \   000398   85..82       MOV     DPL,?XSP + 0
   \   00039B   85..83       MOV     DPH,?XSP + 1
   \   00039E   F0           MOVX    @DPTR,A
   1435                  }
   1436          
   1437                  if ( dstPg == pgRes )
   \                     ??osal_nv_write_22:
   \   00039F   90....       MOV     DPTR,#??pgRes
   \   0003A2   E0           MOVX    A,@DPTR
   \   0003A3   65..         XRL     A,?V0 + 0
   \   0003A5   701A         JNZ     ??osal_nv_write_18
   1438                  {
   1439                    compactPage( comPg );
   \   0003A7                ; Setup parameters for call to function compactPage
   \   0003A7   7407         MOV     A,#0x7
   \   0003A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0003AC   E0           MOVX    A,@DPTR
   \   0003AD   F9           MOV     R1,A
   \   0003AE   90....       MOV     DPTR,#(??compactPage & 0xffff)
   \   0003B1   74..         MOV     A,#((??compactPage >> 16) & 0xff)
   \   0003B3   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0003B6   8009         SJMP    ??osal_nv_write_18
   1440                  }
   1441                }
   1442                else
   1443                {
   1444                  rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_19:
   \   0003B8   7410         MOV     A,#0x10
   \   0003BA   85..82       MOV     DPL,?XSP + 0
   \   0003BD   85..83       MOV     DPH,?XSP + 1
   \   0003C0   F0           MOVX    @DPTR,A
   1445                }
   1446              }
   1447            }
   1448          
   1449            if ( failF )
   \                     ??osal_nv_write_18:
   \   0003C1   90....       MOV     DPTR,#??failF
   \   0003C4   E0           MOVX    A,@DPTR
   \   0003C5   6011         JZ      ??osal_nv_write_11
   1450            {
   1451              (void)initNV();  // See comment at the declaration of failF.
   \   0003C7                ; Setup parameters for call to function initNV
   \   0003C7   90....       MOV     DPTR,#(??initNV & 0xffff)
   \   0003CA   74..         MOV     A,#((??initNV >> 16) & 0xff)
   \   0003CC   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1452              rtrn = NV_OPER_FAILED;
   \   0003CF   7410         MOV     A,#0x10
   \   0003D1   85..82       MOV     DPL,?XSP + 0
   \   0003D4   85..83       MOV     DPH,?XSP + 1
   \   0003D7   F0           MOVX    @DPTR,A
   1453            }
   1454          
   1455            return rtrn;
   \                     ??osal_nv_write_11:
   \   0003D8   85..82       MOV     DPL,?XSP + 0
   \   0003DB   85..83       MOV     DPH,?XSP + 1
   \   0003DE   E0           MOVX    A,@DPTR
   \   0003DF   F9           MOV     R1,A
   \                     ??osal_nv_write_9:
   \   0003E0   7412         MOV     A,#0x12
   \   0003E2   02....       LJMP    ??Subroutine75_0 & 0xFFFF
   1456          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   98           SUBB    A,R0
   \   000003   FE           MOV     R6,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   99           SUBB    A,R1
   \   000007   FF           MOV     R7,A
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   EE           MOV     A,R6
   \   000006   FA           MOV     R2,A
   \   000007   EF           MOV     A,R7
   \   000008   FB           MOV     R3,A
   \   000009   A9..         MOV     R1,?V0 + 0
   \   00000B   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000003   A9..         MOV     R1,?V0 + 1
   \   000005   02....       LJMP    ?Subroutine72 & 0xFFFF
   1457          
   1458          /*********************************************************************
   1459           * @fn      osal_nv_read
   1460           *
   1461           * @brief   Read data from NV.  This function can be used to read an
   1462           *          entire item from NV or an element of an item by indexing
   1463           *          into the item with an offset.  Read data is copied into
   1464           *          *buf.
   1465           *
   1466           * @param   id     - Valid NV item Id.
   1467           *
   1468           * @param   ndx - Index offset into item
   1469           *
   1470           * @param   len    - Length of data to read.
   1471           *
   1472           * @param   *buf  - Data is read into this buffer.
   1473           *
   1474           * @return  ZSUCCESS if NV data was copied to the parameter 'buf'.
   1475           *          Otherwise, NV_OPER_FAILED for failure.
   1476           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1477          uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_read:
   1478          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EC           MOV     A,R4
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   ED           MOV     A,R5
   \   000013   F0           MOVX    @DPTR,A
   \   000014   7414         MOV     A,#0x14
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FE           MOV     R6,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FF           MOV     R7,A
   \   00001E   7416         MOV     A,#0x16
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ??Subroutine4_0 & 0xFFFF
   1479            uint32 addr;
   1480            uint16 offset;
   1481            uint8 *ptr = (uint8 *)buf;
   \                     ??CrossCallReturnLabel_19:
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   12....       LCALL   ?Subroutine71 & 0xFFFF
   1482          
   1483            if ( id == ZCD_NV_EXTADDR )
   \                     ??CrossCallReturnLabel_187:
   \   00002F   7401         MOV     A,#0x1
   \   000031   6A           XRL     A,R2
   \   000032   7001         JNZ     ??osal_nv_read_0
   \   000034   EB           MOV     A,R3
   \                     ??osal_nv_read_0:
   \   000035   7031         JNZ     ??osal_nv_read_1
   1484            {
   1485              offset = OSAL_NV_IEEE_OFFSET;
   \   000037   75..F8       MOV     ?V0 + 0,#-0x8
   \   00003A   75..07       MOV     ?V0 + 1,#0x7
   1486              findPg = OSAL_NV_IEEE_PAGE;
   \   00003D   743F         MOV     A,#0x3f
   \   00003F   90....       MOV     DPTR,#??findPg
   \   000042   F0           MOVX    @DPTR,A
   1487            }
   1488            else
   1489            {
   1490              offset = findItem( id );
   1491            }
   1492          
   1493            if ( offset == OSAL_NV_ITEM_NULL )
   1494            {
   1495              return NV_OPER_FAILED;
   1496            }
   1497          
   1498            addr = OSAL_NV_PAGE_TO_ADDR( findPg ) + offset + ndx;
   \                     ??osal_nv_read_2:
   \   000043   90....       MOV     DPTR,#??findPg
   \   000046   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000049   12....       LCALL   ?L_SHL
   \   00004C   F5..         MOV     ?V0 + 2,A
   \   00004E   F5..         MOV     ?V0 + 3,A
   \   000050   78..         MOV     R0,#?V0 + 4
   \   000052   79..         MOV     R1,#?V0 + 0
   \   000054   12....       LCALL   ?L_ADD
   \   000057   7402         MOV     A,#0x2
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00005F   78..         MOV     R0,#?V0 + 4
   \   000061   79..         MOV     R1,#?V0 + 0
   \   000063   12....       LCALL   ?L_ADD
   \   000066   801F         SJMP    ??CrossCallReturnLabel_189
   \                     ??osal_nv_read_1:
   \   000068                ; Setup parameters for call to function findItem
   \   000068   90....       MOV     DPTR,#(??findItem & 0xffff)
   \   00006B   74..         MOV     A,#((??findItem >> 16) & 0xff)
   \   00006D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000070   8A..         MOV     ?V0 + 0,R2
   \   000072   8B..         MOV     ?V0 + 1,R3
   \   000074   EA           MOV     A,R2
   \   000075   7001         JNZ     ??osal_nv_read_3
   \   000077   EB           MOV     A,R3
   \                     ??osal_nv_read_3:
   \   000078   70C9         JNZ     ??osal_nv_read_2
   \   00007A   7910         MOV     R1,#0x10
   \   00007C   8013         SJMP    ??osal_nv_read_4
   1499            while ( len-- )
   1500            {
   1501              *ptr++ = GetCodeByte( addr++ );
   \                     ??osal_nv_read_5:
   \   00007E                ; Setup parameters for call to function GetCodeByte
   \   00007E   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000081   12....       LCALL   ?L_ADD_X
   \   000084   12....       LCALL   ?Subroutine1 & 0xFFFF
   1502            }
   \                     ??CrossCallReturnLabel_189:
   \   000087   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   00008A   7001         JNZ     ??osal_nv_read_6
   \   00008C   E9           MOV     A,R1
   \                     ??osal_nv_read_6:
   \   00008D   70EF         JNZ     ??osal_nv_read_5
   1503          
   1504            return ZSUCCESS;
   \   00008F   7900         MOV     R1,#0x0
   \                     ??osal_nv_read_4:
   \   000091   7404         MOV     A,#0x4
   \   000093   02....       LJMP    ??Subroutine75_0 & 0xFFFF
   1505          }

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_1:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_1>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_1>`:
   \   000000   01000000     DD 1
   1506          
   1507          /*********************************************************************
   1508          *********************************************************************/

   Maximum stack usage in bytes:

     Function                ISTACK PSTACK XSTACK
     --------                ------ ------ ------
     calcChkF                    0      0     52
       -> GetCodeByte            0      0     36
     compactPage                 2      0     70
       -> writeWordH             0      0     64
       -> calcChkF               0      0     64
       -> setItem                0      0     64
       -> writeBuf               0      0     68
       -> xferBuf                0      0     72
       -> setItem                0      0     64
       -> readHdr                0      0     64
       -> HalAdcCheckVdd         0      0     64
       -> readHdr                0      0     64
       -> writeWordD             0      0     64
       -> setPageUse             0      0     64
     findItem                    0      0     46
       -> initPage               0      0     24
       -> initPage               0      0     24
     initItem                    2      0     32
       -> writeItem              0      0     32
       -> compactPage            0      0     28
     initItem2                   2      0     50
       -> writeItem              0      0     28
     initNV                      2      0     60
       -> readHdr                0      0     52
       -> readHdr                0      0     52
       -> setPageUse             0      0     52
       -> initPage               0      0     52
       -> readHdr                0      0     52
       -> writeWordD             0      0     52
       -> writeWordD             0      0     52
       -> setPageUse             0      0     52
       -> compactPage            0      0     52
     initPage                    0      0     51
       -> setItem                0      0     50
       -> readHdr                0      0     50
       -> calcChkF               0      0     50
       -> findItem               0      0     50
       -> setItem                0      0     50
     osal_nv_init                2      0      0
       -> initNV                 4      0      0
     osal_nv_item_init           0      0     18
       -> findItem               0      0     28
       -> initItem               0      0     32
       -> initNV                 0      0     28
     osal_nv_item_len            0      0     18
       -> findItem               0      0     36
       -> readHdr                0      0     36
     osal_nv_read                1      0     24
       -> findItem               0      0     40
       -> GetCodeByte            0      0     40
     osal_nv_write               4      0     42
       -> readHdr                0      0     68
       -> writeWordD             0      0     68
       -> findItem               0      0     68
       -> readHdr                0      0     68
       -> GetCodeByte            0      0     68
       -> initItem2              0      0     72
       -> setItem                0      0     68
       -> xferBuf                0      0     76
       -> writeBuf               0      0     72
       -> xferBuf                0      0     76
       -> calcChkF               0      0     68
       -> writeWordH             0      0     68
       -> readHdr                0      0     68
       -> setItem                0      0     68
       -> compactPage            0      0     68
       -> initNV                 0      0     68
     readHdr                     1      0     52
       -> GetCodeByte            0      0     36
     setItem                     0      0     54
       -> readHdr                0      0     40
       -> writeWord              0      0     40
       -> writeWord              0      0     40
     setPageUse                  2      0     40
       -> writeWord              4      0     16
     writeBuf                    1      0     60
       -> GetCodeByte            0      0     48
       -> writeWord              0      0     48
       -> writeWord              0      0     48
       -> writeWord              0      0     48
     writeItem                   0      0     44
       -> setPageUse             0      0     52
       -> writeWord              0      0     52
       -> readHdr                0      0     52
       -> writeBuf               0      0     56
       -> calcChkF               0      0     52
       -> writeWordH             0      0     52
       -> readHdr                0      0     52
     writeWord                   2      0     40
       -> HalAdcCheckVdd         0      0     24
       -> halFlashDmaTrigger     0      0     24
     writeWordD                  0      0     46
       -> writeWord              0      0     24
       -> writeWord              0      0     24
     writeWordH                  1      0     47
       -> writeWord              0      0     26
     xferBuf                     1      0     66
       -> GetCodeByte            0      0     56
       -> GetCodeByte            0      0     56
       -> writeWord              0      0     56
       -> GetCodeByte            0      0     56
       -> writeWord              0      0     56
       -> GetCodeByte            0      0     56
       -> writeWord              0      0     56


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     FWT                               1
     FADDRL                            1
     FADDRH                            1
     FCTL                              1
     DMAIRQ                            1
     DMAARM                            1
     FBuff                             4
     pgOff                             4
     pgLost                            4
     pgRes                             1
     findPg                            1
     failF                             1
     initNV                          499
     ?Subroutine66                     8
     setPageUse                       57
     ?Subroutine67                     7
     ?Subroutine29                    21
     initPage                        447
     ?Subroutine45                     5
     ?Subroutine32                     5
     ?Subroutine63                    11
     ?Subroutine10                     4
     ?Subroutine56                    13
     ?Subroutine62                    17
     ?Subroutine47                     6
     ?Subroutine61                     9
     ?Subroutine14                     6
     ?Subroutine35                     6
     compactPage                     516
     ?Subroutine68                     5
     ?Subroutine15                    12
     ?Subroutine11                    11
     ?Subroutine72                     6
     ?Subroutine7                      8
     ?Subroutine70                     7
     ?Subroutine37                     9
     ?Subroutine43                    13
     ?Subroutine19                     8
     ?Subroutine55                     6
     ?Subroutine20                     8
     ?Subroutine4                     16
     findItem                         90
     ?Subroutine74                     5
     initItem                        149
     ?Subroutine52                     4
     ?Subroutine64                    17
     ?Subroutine51                     5
     ?Subroutine46                    15
     ?Subroutine44                     5
     ?Subroutine25                     9
     ?Subroutine21                     8
     initItem2                       151
     setItem                         142
     ?Subroutine9                      5
     calcChkF                        135
     ?Subroutine75                    10
     ?Subroutine40                    14
     ?Subroutine18                     4
     readHdr                          72
     ?Subroutine54                    10
     ?Subroutine48                    17
     ?Subroutine71                     6
     ?Subroutine1                     27
     ?Subroutine58                     6
     ?Subroutine65                     9
     writeWord                       154
     ?Subroutine31                     7
     writeWordD                       50
     writeWordH                       71
     writeBuf                        392
     ?Subroutine53                     9
     ?Subroutine39                     4
     ?Subroutine59                     4
     ?Subroutine69                     9
     ?Subroutine38                     9
     ?Subroutine30                    17
     ?Subroutine24                     5
     ?Subroutine22                     6
     ?Subroutine16                     6
     ?Subroutine50                     9
     ?Subroutine34                    10
     ?Subroutine26                    10
     ?Subroutine8                     18
     ?Subroutine6                      8
     ?Subroutine5                      6
     ?Subroutine3                     17
     xferBuf                         558
     ?Subroutine49                    17
     ?Subroutine41                     6
     ?Subroutine28                    15
     ?Subroutine60                     6
     ?Subroutine17                     6
     ?Subroutine23                     3
     ?Subroutine73                     5
     ?Subroutine57                     8
     ?Subroutine2                     11
     ?Subroutine0                     17
     writeItem                       407
     ?Subroutine42                    11
     osal_nv_init                     74
     osal_nv_item_init               104
     osal_nv_item_len                 94
     osal_nv_write                   997
     ?Subroutine27                     9
     ?Subroutine13                    12
     ?Subroutine12                     8
     osal_nv_read                    150
     __Constant_1                      4
     ?<Initializer for __Constant_1>
                                       4

 
 6 000 bytes in segment BANKED_CODE
     6 bytes in segment SFR_AN
     4 bytes in segment XDATA_I
     4 bytes in segment XDATA_ID
    15 bytes in segment XDATA_Z
 
 6 000 bytes of CODE  memory (+ 4 bytes shared)
     0 bytes of DATA  memory (+ 6 bytes shared)
    15 bytes of XDATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
