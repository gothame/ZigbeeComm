##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   24/Jan/2013  14:47:48 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  D:\Texas Instruments\ZStack-1.4.2-1.1.0\Component #
#                          s\stack\zdo\ZDApp.c                               #
#    Command line       =  -f E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç #
#                          ¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006 #
#                          -´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8 #
#                          wRouter.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR          #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TR #
#                          UE -DRTR_NWK -DBLINK_LEDS "-DCONST=const __code"  #
#                          -DGENERIC=__generic) -f                           #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                    #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\ -I                           #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\Source\ -I                 #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mt\ #
#                           -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂ #
#                          ç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee200 #
#                          6-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\Components #
#                          \hal\include\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª· #
#                          ¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2 #
#                          006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projec #
#                          ts\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\ #
#                          ..\Components\hal\target\CC2430EB\ -I             #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\osa #
#                          l\mcu\ccsoc\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢ #
#                          ×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee20 #
#                          06\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Project #
#                          s\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\. #
#                          .\Components\osal\include\ -I                     #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\sta #
#                          ck\af\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\Î #
#                          ÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\Zig #
#                          Bee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zsta #
#                          ck\Samples\SampleApp\CC2430DB\..\..\..\..\..\Comp #
#                          onents\stack\nwk\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC243 #
#                          0¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zig #
#                          Bee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2430DB\..\..\.. #
#                          \..\..\Components\stack\sec\ -I                   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\sta #
#                          ck\sys\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ #
#                          ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\Zi #
#                          gBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Com #
#                          ponents\stack\zdo\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC24 #
#                          30¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zi #
#                          gBee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\P #
#                          rojects\zstack\Samples\SampleApp\CC2430DB\..\..\. #
#                          .\..\..\Components\zmac\f8w\ -I                   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍ #
#                          øÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2 #
#                          006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\services\saddr\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC24 #
#                          30¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zi #
#                          gBee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\P #
#                          rojects\zstack\Samples\SampleApp\CC2430DB\..\..\. #
#                          .\..\..\Components\services\sdata\ -I             #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mac #
#                          \include\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁ #
#                          Ï\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ #
#                          ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\mac\high_level\ -I                      #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mac #
#                          \low_level\srf03\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC243 #
#                          0¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zig #
#                          Bee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2430DB\..\..\.. #
#                          \..\..\Components\mac\low_level\srf03\single_chip #
#                          \ -D CC2430EB -D ZTOOL_P1 -D MT_TASK -lC          #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\ -lA            #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\                #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç #
#                          ¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006 #
#                          -´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\RouterEB\Obj\ -e           #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          "D:\Texas Instruments\ZStack-1.4.2-1.1.0\Componen #
#                          ts\stack\zdo\ZDApp.c"                             #
#    List file          =  E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\ZDApp.lst       #
#    Object file        =  E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\Obj\ZDApp.r51        #
#                                                                            #
#                                                                            #
##############################################################################

D:\Texas Instruments\ZStack-1.4.2-1.1.0\Components\stack\zdo\ZDApp.c
      1          /*********************************************************************
      2              Filename:       ZDApp.c
      3              Revised:        $Date: 2007-05-31 15:56:04 -0700 (Thu, 31 May 2007) $
      4              Revision:       $Revision: 14490 $
      5          
      6              Description:
      7          
      8                This file contains the interface to the Zigbee Device Application.
      9                This is the Application part that the use can change. This also
     10                contains the Task functions.
     11          
     12              Notes:
     13          
     14              Copyright (c) 2006 by Texas Instruments, Inc.
     15              All Rights Reserved.  Permission to use, reproduce, copy, prepare
     16              derivative works, modify, distribute, perform, display or sell this
     17              software and/or its documentation for any purpose is prohibited
     18              without the express written consent of Texas Instruments, Inc.
     19          *********************************************************************/
     20          
     21          /*********************************************************************
     22           * INCLUDES
     23           */
     24          #include "ZComDef.h"
     25          #include "ZMac.h"
     26          #include "OSAL.h"
     27          #include "OSAL_Tasks.h"
     28          #include "OSAL_PwrMgr.h"
     29          #include "OSAL_Nv.h"
     30          #include "AF.h"
     31          #include "APSMEDE.h"
     32          #include "NLMEDE.h"
     33          #include "AddrMgr.h"
     34          #include "ZDCache.h"
     35          #include "ZDProfile.h"
     36          #include "ZDObject.h"
     37          #include "ZDConfig.h"
     38          #include "ZDSecMgr.h"
     39          #include "ZDApp.h"
     40          #include "DebugTrace.h"
     41          #include "nwk_util.h"
     42          #include "OnBoard.h"

   \                                 In segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1
     43          #include "ZGlobals.h"
     44          
     45          #if   ( SECURE != 0  )
     46            #include "ssp.h"
     47          #endif
     48          
     49          #if defined( MT_ZDO_FUNC )
     50            #include "MT_ZDO.h"
     51          #endif
     52          
     53          /* HAL */
     54          #include "hal_led.h"
     55          #include "hal_lcd.h"
     56          #include "hal_key.h"
     57          
     58          #if defined( MT_MAC_FUNC ) || defined( MT_MAC_CB_FUNC )
     59            #error "ERROR! MT_MAC functionalities should be disabled on ZDO devices"
     60          #endif
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          #if !defined( NWK_START_DELAY )
     69            #define NWK_START_DELAY             100   // in milliseconds
     70          #endif
     71          
     72          #if !defined( EXTENDED_JOINING_RANDOM_MASK )
     73            #define EXTENDED_JOINING_RANDOM_MASK 0x007F
     74          #endif
     75          
     76          #if !defined( BEACON_REQUEST_DELAY )
     77            #define BEACON_REQUEST_DELAY        100   // in milliseconds
     78          #endif
     79          
     80          #if !defined( BEACON_REQ_DELAY_MASK )
     81            #define BEACON_REQ_DELAY_MASK       0x007F
     82          #endif
     83          
     84          #if defined (AUTO_SOFT_START)
     85            #define MAX_RESUME_RETRY            3
     86            #define NUM_DISC_ATTEMPTS           3
     87          #else
     88            #define MAX_RESUME_RETRY            1
     89          #endif
     90          
     91          #define MAX_DEVICE_UNAUTH_TIMEOUT   5000  // 5 seconds
     92          
     93          // Beacon Order Settings (see NLMEDE.h)
     94          #define DEFAULT_BEACON_ORDER        BEACON_ORDER_NO_BEACONS
     95          #define DEFAULT_SUPERFRAME_ORDER    DEFAULT_BEACON_ORDER
     96          
     97          #if ( SECURE != 0 )
     98            #if !defined( MAX_NWK_FRAMECOUNTER_CHANGES )
     99              // The number of times the frame counter can change before
    100              // saving to NV
    101              #define MAX_NWK_FRAMECOUNTER_CHANGES    1000
    102            #endif
    103          #endif
    104          
    105          // Leave control bits
    106          #define ZDAPP_LEAVE_CTRL_INIT 0
    107          #define ZDAPP_LEAVE_CTRL_SET  1
    108          #define ZDAPP_LEAVE_CTRL_RA   2
    109          
    110          // Standard time to update NWK NV data
    111          #define ZDAPP_UPDATE_NWK_NV_TIME 100
    112          
    113          // Address Manager Stub Implementation
    114          #define ZDApp_NwkWriteNVRequest AddrMgrWriteNVRequest
    115          
    116          /*********************************************************************
    117           * TYPEDEFS
    118           */
    119          
    120          /*********************************************************************
    121           * GLOBAL VARIABLES
    122           */
    123          

   \                                 In segment XDATA_I, align 1, keep-with-next
    124          byte zdoDiscCounter = 1;
   \                     zdoDiscCounter:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zdoDiscCounter>`
   \   000001                REQUIRE __INIT_XDATA_I
    125          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    126          zAddrType_t ZDAppNwkAddr;
   \                     ZDAppNwkAddr:
   \   000000                DS 9
    127          
    128          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
    129            byte zdappMgmtNwkDiscRspTransSeq;
    130            byte zdappMgmtNwkDiscReqInProgress = FALSE;
    131            zAddrType_t zdappMgmtNwkDiscRspAddr;
    132            byte zdappMgmtNwkDiscStartIndex;
    133            byte zdappMgmtSavedNwkState;
    134          #endif
    135          
    136          #if ( SECURE != 0 )
    137            uint16 nwkFrameCounterChanges = 0;
    138          #endif
    139          
    140          #if defined ( SOFT_START )
    141            static uint8 softStartAllowCoord = TRUE;
    142          #endif
    143          

   \                                 In segment XDATA_I, align 1, keep-with-next
    144          uint8 continueJoining = TRUE;
   \                     continueJoining:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for continueJoining>`
   \   000001                REQUIRE __INIT_XDATA_I
    145          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    146          byte  _tmpRejoinState;
   \                     _tmpRejoinState:
   \   000000                DS 1
    147          
    148          /*********************************************************************
    149           * EXTERNAL VARIABLES
    150           */
    151          
    152          /*********************************************************************
    153           * EXTERNAL FUNCTIONS
    154           */
    155          
    156          /*********************************************************************
    157           * LOCAL FUNCTIONS
    158           */
    159          
    160          void ZDApp_NetworkStartEvt( void );
    161          void ZDApp_DeviceAuthEvt( void );
    162          void ZDApp_SaveNetworkStateEvt( void );
    163          
    164          uint8 ZDApp_ReadNetworkRestoreState( void );
    165          uint8 ZDApp_RestoreNetworkState( void );
    166          void ZDAppDetermineDeviceType( void );
    167          void ZDAppSetupProtoVersion( void );
    168          void ZDApp_InitUserDesc( void );
    169          void ZDAppCheckForHoldKey( void );
    170          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr );
    171          void ZDApp_ProcessNetworkJoin( void );
    172          void ZDApp_SetCoordAddress( byte endPoint, byte dstEP );
    173          void ZDApp_SendNewDstAddr( byte dstEP, zAddrType_t *dstAddr,
    174                         cId_t clusterID, byte removeFlag, byte task_id, byte endpoint );
    175          
    176          #if ( SECURE != 0 )
    177            void ZDApp_SaveNwkKey( void );
    178            byte ZDApp_RestoreNwkKey( void );
    179          #endif
    180          
    181          void ZDApp_SendMsg( byte taskID, byte cmd, byte len, byte *buf );
    182          
    183          #if defined ( ZDO_BIND_UNBIND_RESPONSE ) && !defined ( REFLECTOR )
    184            extern void ZDApp_AppBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
    185                                byte SrcEndPoint, cId_t ClusterID, byte *DstAddress,
    186                                byte DstEndPoint, byte SecurityUse, uint8 Type );
    187          #endif
    188          
    189          void ZDApp_ResetTimerStart( uint16 delay );
    190          void ZDApp_ResetTimerCancel( void );
    191          void ZDApp_LeaveCtrlInit( void );
    192          void ZDApp_LeaveCtrlSet( uint8 ra );
    193          uint8 ZDApp_LeaveCtrlBypass( void );
    194          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay );
    195          void ZDApp_LeaveReset( uint8 ra );
    196          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
    197                                  uint8 removeChildren );
    198          void ZDApp_NodeProfileSync( ZDO_NetworkDiscoveryCfm_t* cfm );
    199          
    200          /*********************************************************************
    201           * LOCAL VARIABLES
    202           */
    203          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    204          byte ZDAppTaskID;
   \                     ZDAppTaskID:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    205          byte nwkStatus;
   \                     nwkStatus:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    206          endPointDesc_t *ZDApp_AutoFindMode_epDesc = (endPointDesc_t *)NULL;
   \                     ZDApp_AutoFindMode_epDesc:
   \   000000                DS 2

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    207          uint8 ZDApp_LeaveCtrl;
   \                     ZDApp_LeaveCtrl:
   \   000000                DS 1
    208          
    209          #if defined( HOLD_AUTO_START )
    210            devStates_t devState = DEV_HOLD;
    211          #else

   \                                 In segment XDATA_I, align 1, keep-with-next
    212            devStates_t devState = DEV_INIT;
   \                     devState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for devState>`
   \   000001                REQUIRE __INIT_XDATA_I
    213          #endif
    214          
    215          #if defined( ZDO_COORDINATOR ) && !defined( SOFT_START )
    216            // Set the default to coodinator
    217            devStartModes_t devStartMode = MODE_HARD;
    218          #else

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    219            devStartModes_t devStartMode = MODE_JOIN;     // Assume joining
   \                     devStartMode:
   \   000000                DS 1
    220            //devStartModes_t devStartMode = MODE_RESUME; // if already "directly joined"
    221                                  // to parent. Set to make the device do an Orphan scan.
    222          #endif
    223          
    224          #if defined ( ZDO_IEEEADDR_REQUEST )
    225            static byte ZDApp_IEEEAddrRsp_TaskID = 0;  // Initialized to NO TASK
    226          #endif
    227          
    228          #if defined ( ZDO_NWKADDR_REQUEST )
    229            static byte ZDApp_NwkAddrRsp_TaskID = 0;  // Initialized to NO TASK
    230          #endif
    231          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    232          static byte ZDApp_MatchDescRsp_TaskID = 0;  // Initialized to NO TASK
   \                     ??ZDApp_MatchDescRsp_TaskID:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    233          static byte ZDApp_EndDeviceAnnounce_TaskID = 0;  // Initialized to NO TASK
   \                     ??ZDApp_EndDeviceAnnounce_TaskID:
   \   000000                DS 1
    234          
    235          #if defined ( ZDO_BIND_UNBIND_REQUEST )
    236            static byte ZDApp_BindUnbindRsp_TaskID = TASK_NO_TASK;
    237          #endif
    238          
    239          #if defined ( ZDO_BIND_UNBIND_RESPONSE ) && !defined ( REFLECTOR )
    240            static byte ZDApp_BindReq_TaskID = 0;  // Initialized to NO TASK
    241          #endif
    242          
    243          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && !defined ( REFLECTOR )
    244            static byte ZDApp_MgmtBindReq_TaskID = 0;  // Initialized to NO TASK
    245          #endif
    246          
    247          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    248            static uint8 retryCnt;
   \                     ??retryCnt:
   \   000000                DS 1
    249          #endif
    250          
    251          // a little awkward -- this is will hold the list of versions that are legal given other
    252          // constraints such as NV value, macro values etc. list used in ZDO_NetworkDiscoveryConfirmCB()
    253          // when a joining device is deciding which network to join.

   \                                 In segment XDATA_I, align 1, keep-with-next
    254          static byte sPVerList[] = {ZB_PROT_V1_1, ZB_PROT_V1_0};
   \                     ??sPVerList:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for sPVerList>`
   \   000002                REQUIRE __INIT_XDATA_I
    255          

   \                                 In segment XDATA_I, align 1, keep-with-next
    256          endPointDesc_t ZDApp_epDesc =
   \                     ZDApp_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for ZDApp_epDesc>`
   \   000006                REQUIRE __INIT_XDATA_I
    257          {
    258            ZDO_EP,
    259            &ZDAppTaskID,
    260            (SimpleDescriptionFormat_t *)NULL,  // No Simple description for ZDO
    261            (afNetworkLatencyReq_t)0            // No Network Latency req
    262          };
    263          
    264          /*********************************************************************
    265           * @fn      ZDApp_Init
    266           *
    267           * @brief   ZDApp Initialization function.
    268           *
    269           * @param   task_id - ZDApp Task ID
    270           *
    271           * @return  None
    272           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    273          void ZDApp_Init( byte task_id )
   \                     ZDApp_Init:
    274          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    275            uint8 capabilities;
    276          
    277            // Save the task ID
    278            ZDAppTaskID = task_id;
   \   000009   E9           MOV     A,R1
   \   00000A   90....       MOV     DPTR,#ZDAppTaskID
   \   00000D   F0           MOVX    @DPTR,A
    279          
    280            // Initialize the ZDO global device short address storage
    281            ZDAppNwkAddr.addrMode = Addr16Bit;
   \   00000E   7402         MOV     A,#0x2
   \   000010   90....       MOV     DPTR,#(ZDAppNwkAddr + 8)
   \   000013   F0           MOVX    @DPTR,A
    282            ZDAppNwkAddr.addr.shortAddr = INVALID_NODE_ADDR;
   \   000014   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000017   74FE         MOV     A,#-0x2
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   74FF         MOV     A,#-0x1
   \   00001D   F0           MOVX    @DPTR,A
    283            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
   \   00001E                ; Setup parameters for call to function NLME_GetExtAddr
   \   00001E   90....       MOV     DPTR,#(NLME_GetExtAddr & 0xffff)
   \   000021   74..         MOV     A,#((NLME_GetExtAddr >> 16) & 0xff)
   \   000023   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    284          
    285            // Check for manual "Hold Auto Start"
    286            ZDAppCheckForHoldKey();
   \   000026                ; Setup parameters for call to function ZDAppCheckForHoldKey
   \   000026   90....       MOV     DPTR,#(ZDAppCheckForHoldKey & 0xffff)
   \   000029   74..         MOV     A,#((ZDAppCheckForHoldKey >> 16) & 0xff)
   \   00002B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    287          
    288            // Initialize ZDO items and setup the device - type of device to create.
    289            ZDO_Init();
   \   00002E                ; Setup parameters for call to function ZDO_Init
   \   00002E   90....       MOV     DPTR,#(ZDO_Init & 0xffff)
   \   000031   74..         MOV     A,#((ZDO_Init >> 16) & 0xff)
   \   000033   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    290          
    291            // Register the endpoint description with the AF
    292            // This task doesn't have a Simple description, but we still need
    293            // to register the endpoint.
    294            afRegister( (endPointDesc_t *)&ZDApp_epDesc );
   \   000036                ; Setup parameters for call to function afRegister
   \   000036   7A..         MOV     R2,#(ZDApp_epDesc & 0xff)
   \   000038   7B..         MOV     R3,#((ZDApp_epDesc >> 8) & 0xff)
   \   00003A   90....       MOV     DPTR,#(afRegister & 0xffff)
   \   00003D   74..         MOV     A,#((afRegister >> 16) & 0xff)
   \   00003F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    295          
    296          #if defined( ZDO_USERDESC_RESPONSE )
    297            ZDApp_InitUserDesc();
    298          #endif // ZDO_USERDESC_RESPONSE
    299          
    300          #if defined( ZDO_CACHE )
    301            ZDCacheInit();
    302          #endif
    303          
    304            // Setup the Zigbee Network Protocol Version
    305            ZDAppSetupProtoVersion();
   \   000042                ; Setup parameters for call to function ZDAppSetupProtoVersion
   \   000042   90....       MOV     DPTR,#(ZDAppSetupProtoVersion & 0xffff)
   \   000045   74..         MOV     A,#((ZDAppSetupProtoVersion >> 16) & 0xff)
   \   000047   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    306          
    307            // set broadcast address mask to support broadcast filtering
    308            NLME_GetRequest(nwkCapabilityInfo, 0, &capabilities);
   \   00004A                ; Setup parameters for call to function NLME_GetRequest
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   7A00         MOV     R2,#0x0
   \   000056   7B00         MOV     R3,#0x0
   \   000058   798F         MOV     R1,#-0x71
   \   00005A   90....       MOV     DPTR,#(NLME_GetRequest & 0xffff)
   \   00005D   74..         MOV     A,#((NLME_GetRequest >> 16) & 0xff)
   \   00005F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    309            NLME_SetBroadcastFilter( capabilities );
   \   000062                ; Setup parameters for call to function NLME_SetBroadcastFilter
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F9           MOV     R1,A
   \   00006A   90....       MOV     DPTR,#(NLME_SetBroadcastFilter & 0xffff)
   \   00006D   74..         MOV     A,#((NLME_SetBroadcastFilter >> 16) & 0xff)
   \   00006F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    310          
    311            // Start the device?
    312            if ( devState != DEV_HOLD )
   \   000072   90....       MOV     DPTR,#devState
   \   000075   E0           MOVX    A,@DPTR
   \   000076   600B         JZ      ??ZDApp_Init_0
    313            {
    314              ZDOInitDevice( 0 );
   \   000078                ; Setup parameters for call to function ZDOInitDevice
   \   000078   7A00         MOV     R2,#0x0
   \   00007A   7B00         MOV     R3,#0x0
   \   00007C   90....       MOV     DPTR,#(ZDOInitDevice & 0xffff)
   \   00007F   74..         MOV     A,#((ZDOInitDevice >> 16) & 0xff)
   \   000081   800F         SJMP    ??ZDApp_Init_1
    315            }
    316            else
    317            {
    318              // Blink LED to indicate HOLD_START
    319              HalLedBlink ( HAL_LED_4, 0, 50, 500 );
   \                     ??ZDApp_Init_0:
   \   000083                ; Setup parameters for call to function HalLedBlink
   \   000083   7CF4         MOV     R4,#-0xc
   \   000085   7D01         MOV     R5,#0x1
   \   000087   7B32         MOV     R3,#0x32
   \   000089   7A00         MOV     R2,#0x0
   \   00008B   7908         MOV     R1,#0x8
   \   00008D   90....       MOV     DPTR,#(HalLedBlink & 0xffff)
   \   000090   74..         MOV     A,#((HalLedBlink >> 16) & 0xff)
   \                     ??ZDApp_Init_1:
   \   000092   02....       LJMP    ?Subroutine25 & 0xFFFF
    320            }
    321          } /* ZDO_Init() */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000003   7401         MOV     A,#0x1
   \   000005   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine25_0:
   \   000008   D083         POP     DPH
   \   00000A   D082         POP     DPL
   \   00000C   02....       LJMP    ?BRET
    322          
    323          /*********************************************************************
    324           * @fn      ZDApp_event_loop()
    325           *
    326           * @brief   Main event loop for Zigbee device objects task. This function
    327           *          should be called at periodic intervals.
    328           *
    329           * @param   task_id - Task ID
    330           * @param   events  - Bitmap of events
    331           *
    332           * @return  none
    333           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    334          UINT16 ZDApp_event_loop( byte task_id, UINT16 events )
   \                     ZDApp_event_loop:
    335          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    336            uint8 *msg_ptr;
    337          
    338            if ( events & SYS_EVENT_MSG )
   \   000009   7480         MOV     A,#-0x80
   \   00000B   5F           ANL     A,R7
   \   00000C   F9           MOV     R1,A
   \   00000D   E4           CLR     A
   \   00000E   7001         JNZ     ??ZDApp_event_loop_0
   \   000010   E9           MOV     A,R1
   \                     ??ZDApp_event_loop_0:
   \   000011   7040         JNZ     ??ZDApp_event_loop_1
    339            {
    340              while ( (msg_ptr = osal_msg_receive( ZDAppTaskID )) )
    341              {
    342                ZDApp_ProcessOSALMsg( (osal_event_hdr_t *)msg_ptr );
    343          
    344                // Release the memory
    345                osal_msg_deallocate( msg_ptr );
    346              }
    347          
    348              // Return unprocessed events
    349              return (events ^ SYS_EVENT_MSG);
    350            }
    351          
    352            if ( events & ZDO_NETWORK_INIT )
   \   000013   EE           MOV     A,R6
   \   000014   A2E0         MOV     C,0xE0 /* A   */.0
   \   000016   5059         JNC     ??ZDApp_event_loop_2
    353            {
    354              // Initialize apps and start the network
    355              devState = DEV_INIT;
   \   000018   7401         MOV     A,#0x1
   \   00001A   90....       MOV     DPTR,#devState
   \   00001D   F0           MOVX    @DPTR,A
    356              ZDO_StartDevice( (uint8)ZDO_Config_Node_Descriptor.LogicalType, devStartMode,
    357                               DEFAULT_BEACON_ORDER, DEFAULT_SUPERFRAME_ORDER );
   \   00001E                ; Setup parameters for call to function ZDO_StartDevice
   \   00001E   7C0F         MOV     R4,#0xf
   \   000020   7B0F         MOV     R3,#0xf
   \   000022   90....       MOV     DPTR,#devStartMode
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FA           MOV     R2,A
   \   000027   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   5407         ANL     A,#0x7
   \   00002D   F9           MOV     R1,A
   \   00002E   90....       MOV     DPTR,#(ZDO_StartDevice & 0xffff)
   \   000031   74..         MOV     A,#((ZDO_StartDevice >> 16) & 0xff)
   \   000033   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    358          
    359              // Return unprocessed events
    360              return (events ^ ZDO_NETWORK_INIT);
   \   000036   7401         MOV     A,#0x1
   \                     ??ZDApp_event_loop_3:
   \   000038   6E           XRL     A,R6
   \   000039   FA           MOV     R2,A
   \   00003A   EF           MOV     A,R7
   \                     ??ZDApp_event_loop_4:
   \   00003B   FB           MOV     R3,A
   \   00003C   02....       LJMP    ??ZDApp_event_loop_5 & 0xFFFF
    361            }
   \                     ??ZDApp_event_loop_6:
   \   00003F                ; Setup parameters for call to function ZDApp_ProcessOSALMsg
   \   00003F   90....       MOV     DPTR,#(ZDApp_ProcessOSALMsg & 0xffff)
   \   000042   74..         MOV     A,#((ZDApp_ProcessOSALMsg >> 16) & 0xff)
   \   000044   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000047                ; Setup parameters for call to function osal_msg_deallocate
   \   000047   AA..         MOV     R2,?V0 + 0
   \   000049   AB..         MOV     R3,?V0 + 1
   \   00004B   90....       MOV     DPTR,#(osal_msg_deallocate & 0xffff)
   \   00004E   74..         MOV     A,#((osal_msg_deallocate >> 16) & 0xff)
   \   000050   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_event_loop_1:
   \   000053                ; Setup parameters for call to function osal_msg_receive
   \   000053   90....       MOV     DPTR,#ZDAppTaskID
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   90....       MOV     DPTR,#(osal_msg_receive & 0xffff)
   \   00005B   74..         MOV     A,#((osal_msg_receive >> 16) & 0xff)
   \   00005D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000060   8A..         MOV     ?V0 + 0,R2
   \   000062   8B..         MOV     ?V0 + 1,R3
   \   000064   EA           MOV     A,R2
   \   000065   7001         JNZ     ??ZDApp_event_loop_7
   \   000067   EB           MOV     A,R3
   \                     ??ZDApp_event_loop_7:
   \   000068   70D5         JNZ     ??ZDApp_event_loop_6
   \   00006A   EE           MOV     A,R6
   \   00006B   FA           MOV     R2,A
   \   00006C   7480         MOV     A,#-0x80
   \                     ??ZDApp_event_loop_8:
   \   00006E   6F           XRL     A,R7
   \   00006F   80CA         SJMP    ??ZDApp_event_loop_4
    362          
    363          #if defined (RTR_NWK)
    364            if ( events & ZDO_NETWORK_START )
   \                     ??ZDApp_event_loop_2:
   \   000071   5402         ANL     A,#0x2
   \   000073   600C         JZ      ??ZDApp_event_loop_9
    365            {
    366              ZDApp_NetworkStartEvt();
   \   000075                ; Setup parameters for call to function ZDApp_NetworkStartEvt
   \   000075   90....       MOV     DPTR,#(ZDApp_NetworkStartEvt & 0xffff)
   \   000078   74..         MOV     A,#((ZDApp_NetworkStartEvt >> 16) & 0xff)
   \   00007A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    367          
    368              // Return unprocessed events
    369              return (events ^ ZDO_NETWORK_START);
   \   00007D   7402         MOV     A,#0x2
   \                     ??ZDApp_event_loop_10:
   \   00007F   80B7         SJMP    ??ZDApp_event_loop_3
    370            }
    371          #endif  //RTR_NWK
    372          
    373          #if defined ( RTR_NWK )
    374            if ( events & ZDO_ROUTER_START )
   \                     ??ZDApp_event_loop_9:
   \   000081   EE           MOV     A,R6
   \   000082   5420         ANL     A,#0x20
   \   000084   6025         JZ      ??ZDApp_event_loop_11
    375            {
    376              if ( nwkStatus == ZSuccess )
   \   000086   90....       MOV     DPTR,#nwkStatus
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   7015         JNZ     ??ZDApp_event_loop_12
    377              {
    378                if ( devState == DEV_END_DEVICE )
   \   00008C   90....       MOV     DPTR,#devState
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   6406         XRL     A,#0x6
   \   000092   7003         JNZ     ??ZDApp_event_loop_13
    379                  devState = DEV_ROUTER;
   \   000094   7407         MOV     A,#0x7
   \   000096   F0           MOVX    @DPTR,A
    380          
    381                osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
   \                     ??ZDApp_event_loop_13:
   \   000097                ; Setup parameters for call to function osal_pwrmgr_device
   \   000097   7900         MOV     R1,#0x0
   \   000099   90....       MOV     DPTR,#(osal_pwrmgr_device & 0xffff)
   \   00009C   74..         MOV     A,#((osal_pwrmgr_device >> 16) & 0xff)
   \   00009E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    382              }
    383              else
    384              {
    385                // remain as end device!!
    386              }
    387              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \                     ??ZDApp_event_loop_12:
   \   0000A1                ; Setup parameters for call to function osal_set_event
   \   0000A1   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0000A4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    388          
    389              // Return unprocessed events
    390              return (events ^ ZDO_ROUTER_START);
   \   0000A7   7420         MOV     A,#0x20
   \   0000A9   808D         SJMP    ??ZDApp_event_loop_3
    391            }
    392          #endif  // RTR
    393          
    394            if ( events & ZDO_STATE_CHANGE_EVT )
   \                     ??ZDApp_event_loop_11:
   \   0000AB   EE           MOV     A,R6
   \   0000AC   5410         ANL     A,#0x10
   \   0000AE   6011         JZ      ??ZDApp_event_loop_14
    395            {
    396              ZDO_UpdateNwkStatus( devState );
   \   0000B0                ; Setup parameters for call to function ZDO_UpdateNwkStatus
   \   0000B0   90....       MOV     DPTR,#devState
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   F9           MOV     R1,A
   \   0000B5   90....       MOV     DPTR,#(ZDO_UpdateNwkStatus & 0xffff)
   \   0000B8   74..         MOV     A,#((ZDO_UpdateNwkStatus >> 16) & 0xff)
   \   0000BA   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    397          
    398              // Return unprocessed events
    399              return (events ^ ZDO_STATE_CHANGE_EVT);
   \   0000BD   7410         MOV     A,#0x10
   \   0000BF   80BE         SJMP    ??ZDApp_event_loop_10
    400            }
    401          
    402            if ( events & ZDO_COMMAND_CNF )
   \                     ??ZDApp_event_loop_14:
   \   0000C1   EE           MOV     A,R6
   \   0000C2   5408         ANL     A,#0x8
   \   0000C4   6006         JZ      ??ZDApp_event_loop_15
    403            {
    404              // User defined logic
    405          
    406              // Return unprocessed events
    407              return (events ^ ZDO_COMMAND_CNF);
   \   0000C6   7408         MOV     A,#0x8
   \   0000C8   6E           XRL     A,R6
   \   0000C9   FA           MOV     R2,A
   \   0000CA   8022         SJMP    ??ZDApp_event_loop_5
    408            }
    409          
    410          #if defined( ZDSECMGR_SECURE ) && defined( RTR_NWK )
    411            if ( events & ZDO_NEW_DEVICE )
    412            {
    413              // process the new device event
    414              if ( ZDSecMgrNewDeviceEvent() == TRUE )
    415              {
    416                osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 1000 );
    417              }
    418          
    419              // Return unprocessed events
    420              return (events ^ ZDO_NEW_DEVICE);
    421            }
    422          #endif  // ZDSECMGR_SECURE && RTR
    423          
    424          #if defined ( ZDSECMGR_COMMERCIAL )
    425            if ( events & ZDO_SECMGR_EVENT )
    426            {
    427              ZDSecMgrEvent();
    428          
    429              // Return unprocessed events
    430              return (events ^ ZDO_SECMGR_EVENT);
    431            }
    432          #endif // defined( ZDSECMGR_COMMERCIAL )
    433          
    434          #if   ( SECURE != 0  )
    435            if ( events & ZDO_DEVICE_AUTH )
    436            {
    437              ZDApp_DeviceAuthEvt();
    438          
    439              // Return unprocessed events
    440              return (events ^ ZDO_DEVICE_AUTH);
    441            }
    442          #endif  // SECURE
    443          
    444            if ( events & ZDO_NWK_UPDATE_NV )
   \                     ??ZDApp_event_loop_15:
   \   0000CC   7402         MOV     A,#0x2
   \   0000CE   5F           ANL     A,R7
   \   0000CF   F9           MOV     R1,A
   \   0000D0   E4           CLR     A
   \   0000D1   7001         JNZ     ??ZDApp_event_loop_16
   \   0000D3   E9           MOV     A,R1
   \                     ??ZDApp_event_loop_16:
   \   0000D4   6004         JZ      ??ZDApp_event_loop_17
    445            {
    446              ZDApp_SaveNetworkStateEvt();
    447          
    448              // Return unprocessed events
    449              return (events ^ ZDO_NWK_UPDATE_NV);
   \   0000D6   7402         MOV     A,#0x2
   \   0000D8   8094         SJMP    ??ZDApp_event_loop_8
    450            }
    451          
    452          #if ( SECURE != 0  )
    453            if ( events & ZDO_FRAMECOUNTER_CHANGE )
    454            {
    455              if ( nwkFrameCounterChanges++ > MAX_NWK_FRAMECOUNTER_CHANGES )
    456                ZDApp_SaveNwkKey();
    457          
    458              // Return unprocessed events
    459              return (events ^ ZDO_FRAMECOUNTER_CHANGE);
    460            }
    461          #endif
    462          
    463            if ( events & ZDO_DEVICE_RESET )
   \                     ??ZDApp_event_loop_17:
   \   0000DA   EE           MOV     A,R6
   \   0000DB   5404         ANL     A,#0x4
   \   0000DD   600B         JZ      ??ZDApp_event_loop_18
    464            {
    465              // The device has been in the UNAUTH state, so reset
    466              // Note: there will be no return from this call
    467              SystemReset();
   \   0000DF   C2AF         CLR     0xa8.7
   \   0000E1   75C9AB       MOV     0xc9,#-0x55
   \   0000E4   75C95B       MOV     0xc9,#0x5b
   \                     ??ZDApp_event_loop_19:
   \   0000E7   00           NOP
   \   0000E8   80FD         SJMP    ??ZDApp_event_loop_19
    468            }
    469          
    470            // Discard or make more handlers
    471            return 0;
   \                     ??ZDApp_event_loop_18:
   \   0000EA   7A00         MOV     R2,#0x0
   \   0000EC   7B00         MOV     R3,#0x0
   \                     ??ZDApp_event_loop_5:
   \   0000EE   02....       LJMP    ??Subroutine26_1 & 0xFFFF
    472          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   7402         MOV     A,#0x2
   \                     ??Subroutine26_0:
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine26_1:
   \   000005   7F02         MOV     R7,#0x2
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   90....       MOV     DPTR,#ZDAppTaskID
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F9           MOV     R1,A
   \   000007   90....       MOV     DPTR,#(osal_set_event & 0xffff)
   \   00000A   74..         MOV     A,#((osal_set_event >> 16) & 0xff)
   \   00000C   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7A10         MOV     R2,#0x10
   \   000002   02....       LJMP    ?Subroutine28 & 0xFFFF
    473          
    474          /*********************************************************************
    475           * Application Functions
    476           */
    477          
    478          /*********************************************************************
    479           * @fn      ZDOInitDevice
    480           *
    481           * @brief   Start the device in the network.  This function will read
    482           *   ZCD_NV_STARTUP_OPTION (NV item) to determine whether or not to
    483           *   restore the network state of the device.
    484           *
    485           * @param   startDelay - timeDelay to start device (in milliseconds).
    486           *      There is a jitter added to this delay:
    487           *              ((NWK_START_DELAY + startDelay)
    488           *              + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK))
    489           *
    490           * NOTE:    If the application would like to force a "new" join, the
    491           *          application should set the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    492           *          bit in the ZCD_NV_STARTUP_OPTION NV item before calling
    493           *          this function. "new" join means to not restore the network
    494           *          state of the device. Use zgWriteStartupOptions() to set these
    495           *          options.
    496           *
    497           * @return
    498           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    499           *          restored.
    500           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was initialized.
    501           *          This could mean that ZCD_NV_STARTUP_OPTION said to not restore, or
    502           *          it could mean that there was no network state to restore.
    503           *    ZDO_INITDEV_LEAVE_NOT_STARTED - Before the reset, a network leave was issued
    504           *          with the rejoin option set to TRUE.  So, the device was not
    505           *          started in the network (one time only).  The next time this
    506           *          function is called it will start.
    507           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    508          uint8 ZDOInitDevice( uint16 startDelay )
   \                     ZDOInitDevice:
    509          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
    510            uint8 networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    511            uint16 extendedDelay = 0;
    512          
    513            devState = DEV_INIT;    // Remove the Hold state
   \   000015   7401         MOV     A,#0x1
   \   000017   90....       MOV     DPTR,#devState
   \   00001A   F0           MOVX    @DPTR,A
    514          
    515            // Initialize leave control logic
    516            ZDApp_LeaveCtrlInit();
   \   00001B                ; Setup parameters for call to function ZDApp_LeaveCtrlInit
   \   00001B   90....       MOV     DPTR,#(ZDApp_LeaveCtrlInit & 0xffff)
   \   00001E   74..         MOV     A,#((ZDApp_LeaveCtrlInit >> 16) & 0xff)
   \   000020   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    517          
    518            // Check leave control reset settings
    519            ZDApp_LeaveCtrlStartup( &devState, &startDelay );
   \   000023                ; Setup parameters for call to function ZDApp_LeaveCtrlStartup
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   AC82         MOV     R4,DPL
   \   00002B   AD83         MOV     R5,DPH
   \   00002D   7A..         MOV     R2,#(devState & 0xff)
   \   00002F   7B..         MOV     R3,#((devState >> 8) & 0xff)
   \   000031   90....       MOV     DPTR,#(ZDApp_LeaveCtrlStartup & 0xffff)
   \   000034   74..         MOV     A,#((ZDApp_LeaveCtrlStartup >> 16) & 0xff)
   \   000036   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    520          
    521            // Leave may make the hold state come back
    522            if ( devState == DEV_HOLD )
   \   000039   90....       MOV     DPTR,#devState
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   7004         JNZ     ??ZDOInitDevice_0
    523              return ( ZDO_INITDEV_LEAVE_NOT_STARTED );   // Don't join - (one time).
   \   00003F   7902         MOV     R1,#0x2
   \   000041   802F         SJMP    ??ZDOInitDevice_1
    524          
    525          #if defined ( NV_RESTORE )
    526            // Get Keypad directly to see if a reset nv is needed.
    527            // Hold down the SW_BYPASS_NV key (defined in OnBoard.h)
    528            // while booting to skip past NV Restore.
    529            if ( HalKeyRead() == SW_BYPASS_NV )
    530              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    531            else
    532            {
    533              // Determine if NV should be restored
    534              networkStateNV = ZDApp_ReadNetworkRestoreState();
    535            }
    536          
    537            if ( networkStateNV == ZDO_INITDEV_RESTORED_NETWORK_STATE )
    538            {
    539              networkStateNV = ZDApp_RestoreNetworkState();
    540            }
    541            else
    542            {
    543              // Wipe out the network state in NV
    544              NLME_InitNV();
    545              NLME_SetDefaultNV();
    546              ZDAppSetupProtoVersion();
    547            }
    548          #endif
    549          
    550            if ( networkStateNV == ZDO_INITDEV_NEW_NETWORK_STATE )
    551            {
    552              ZDAppDetermineDeviceType();
    553          
    554              // Only delay if joining network - not restoring network state
    555              extendedDelay = (uint16)((NWK_START_DELAY + startDelay)
    556                        + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK));
   \                     ??ZDOInitDevice_0:
   \   000043                ; Setup parameters for call to function osal_rand
   \   000043   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   000046   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   000048   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00004B   8A..         MOV     ?V0 + 0,R2
   \   00004D   A8..         MOV     R0,?V0 + 0
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   747F         MOV     A,#0x7f
   \   000057   58           ANL     A,R0
   \   000058   F8           MOV     R0,A
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   28           ADD     A,R0
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   3400         ADDC    A,#0x0
   \   000060   F9           MOV     R1,A
   \   000061   7464         MOV     A,#0x64
   \   000063   28           ADD     A,R0
   \   000064   FA           MOV     R2,A
   \   000065   E4           CLR     A
   \   000066   39           ADDC    A,R1
   \   000067   FB           MOV     R3,A
    557            }
    558          
    559            // Trigger the network start
    560            ZDApp_NetworkInit( extendedDelay );
   \   000068                ; Setup parameters for call to function ZDApp_NetworkInit
   \   000068   90....       MOV     DPTR,#(ZDApp_NetworkInit & 0xffff)
   \   00006B   74..         MOV     A,#((ZDApp_NetworkInit >> 16) & 0xff)
   \   00006D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    561          
    562            return ( networkStateNV );
   \   000070   7901         MOV     R1,#0x1
   \                     ??ZDOInitDevice_1:
   \   000072   02....       LJMP    ?Subroutine26 & 0xFFFF
    563          }
    564          
    565          /*********************************************************************
    566           * @fn      ZDApp_ReadNetworkRestoreState
    567           *
    568           * @brief   Read the ZCD_NV_STARTUP_OPTION NV Item to state whether
    569           *          or not to restore the network state.
    570           *          If the read value has the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    571           *          bit set return the ZDO_INITDEV_NEW_NETWORK_STATE.
    572           *
    573           * @param   none
    574           *
    575           * @return  ZDO_INITDEV_NEW_NETWORK_STATE
    576           *          or ZDO_INITDEV_RESTORED_NETWORK_STATE based on whether or
    577           *          not ZCD_STARTOPT_DEFAULT_NETWORK_STATE bit is set in
    578           *          ZCD_NV_STARTUP_OPTION
    579           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    580          uint8 ZDApp_ReadNetworkRestoreState( void )
   \                     ZDApp_ReadNetworkRestoreState:
    581          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    582            uint8 networkStateNV = ZDO_INITDEV_RESTORED_NETWORK_STATE;
   \   000005   7E00         MOV     R6,#0x0
    583          
    584            // Look for the New Network State option.
    585            if ( zgReadStartupOptions() & ZCD_STARTOPT_DEFAULT_NETWORK_STATE )
   \   000007                ; Setup parameters for call to function zgReadStartupOptions
   \   000007   90....       MOV     DPTR,#(zgReadStartupOptions & 0xffff)
   \   00000A   74..         MOV     A,#((zgReadStartupOptions >> 16) & 0xff)
   \   00000C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000F   E9           MOV     A,R1
   \   000010   A2E1         MOV     C,0xE0 /* A   */.1
   \   000012   5001         JNC     ??ZDApp_ReadNetworkRestoreState_0
    586            {
    587              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
   \   000014   0E           INC     R6
    588            }
    589          
    590            return ( networkStateNV );
   \                     ??ZDApp_ReadNetworkRestoreState_0:
   \   000015   EE           MOV     A,R6
   \   000016   F9           MOV     R1,A
   \   000017   80..         SJMP    ??Subroutine27_0
    591          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??Subroutine27_0:
   \   000003   7F01         MOV     R7,#0x1
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    592          
    593          /*********************************************************************
    594           * @fn      ZDAppDetermineDeviceType()
    595           *
    596           * @brief   Determines the type of device to start.  Right now
    597           *          this only works with the SOFT_START feature.  So it doesn't
    598           *          support the end device type.
    599           *
    600           *          Looks at zgDeviceLogicalType and determines what type of
    601           *          device to start.  The types are:
    602           *            ZG_DEVICETYPE_COORDINATOR
    603           *            ZG_DEVICETYPE_ROUTER
    604           *            ZG_DEVICETYPE_ENDDEVICE - not supported yet.
    605           *            ZG_DEVICETYPE_SOFT - looks for coordinator, if one doesn't
    606           *               exist, becomes one.  This option is should only be used
    607           *               if the system is manually configured and you are insured
    608           *               that the first device is started before all the other
    609           *               devices are started.
    610           *
    611           * @param   none
    612           *
    613           * @return  none
    614           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    615          void ZDAppDetermineDeviceType( void )
   \                     ZDAppDetermineDeviceType:
    616          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    617            if ( zgDeviceLogicalType == ZG_DEVICETYPE_ENDDEVICE )
   \   000000   02....       LJMP    ?BRET
    618              return;
    619          
    620          #if defined ( SOFT_START )
    621            if ( zgDeviceLogicalType == ZG_DEVICETYPE_COORDINATOR )
    622            {
    623              devStartMode = MODE_HARD;     // Start as a coordinator
    624              ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
    625            }
    626            else
    627            {
    628              if ( zgDeviceLogicalType == ZG_DEVICETYPE_ROUTER )
    629              {
    630                softStartAllowCoord = FALSE;  // Don't allow coord to start
    631                continueJoining = TRUE;
    632              }
    633              devStartMode = MODE_JOIN;     // Assume joining
    634            }
    635          #endif // SOFT_START
    636          }
    637          
    638          /*********************************************************************
    639           * @fn      ZDApp_NetworkStartEvt()
    640           *
    641           * @brief   Process the Network Start Event
    642           *
    643           * @param   none
    644           *
    645           * @return  none
    646           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    647          void ZDApp_NetworkStartEvt( void )
   \                     ZDApp_NetworkStartEvt:
    648          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    649            if ( nwkStatus == ZSuccess )
   \   000004   90....       MOV     DPTR,#nwkStatus
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7017         JNZ     ??ZDApp_NetworkStartEvt_0
    650            {
    651              // Successfully started a ZigBee network
    652              if ( devState == DEV_COORD_STARTING )
   \   00000A   90....       MOV     DPTR,#devState
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6408         XRL     A,#0x8
   \   000010   7003         JNZ     ??ZDApp_NetworkStartEvt_1
    653              {
    654                devState = DEV_ZB_COORD;
   \   000012   7409         MOV     A,#0x9
   \   000014   F0           MOVX    @DPTR,A
    655          
    656          #if ( SECURE != 0 )
    657                // Initialize keys
    658                SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
    659                SSP_SwitchNwkKey( 0 );
    660          #endif
    661              }
    662          
    663              osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
   \                     ??ZDApp_NetworkStartEvt_1:
   \   000015                ; Setup parameters for call to function osal_pwrmgr_device
   \   000015   7900         MOV     R1,#0x0
   \   000017   90....       MOV     DPTR,#(osal_pwrmgr_device & 0xffff)
   \   00001A   74..         MOV     A,#((osal_pwrmgr_device >> 16) & 0xff)
   \   00001C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    664              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00001F                ; Setup parameters for call to function osal_set_event
   \   00001F   8039         SJMP    ??ZDApp_NetworkStartEvt_2
    665            }
    666            else
    667            {
    668              // Try again with a higher energy threshold !!
    669              if ( ( NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT ) < 0xff )
   \                     ??ZDApp_NetworkStartEvt_0:
   \   000021                ; Setup parameters for call to function NLME_GetEnergyThreshold
   \   000021   90....       MOV     DPTR,#(NLME_GetEnergyThreshold & 0xffff)
   \   000024   74..         MOV     A,#((NLME_GetEnergyThreshold >> 16) & 0xff)
   \   000026   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000029   E9           MOV     A,R1
   \   00002A   F8           MOV     R0,A
   \   00002B   7410         MOV     A,#0x10
   \   00002D   28           ADD     A,R0
   \   00002E   F8           MOV     R0,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   94FF         SUBB    A,#-0x1
   \   000036   E9           MOV     A,R1
   \   000037   9400         SUBB    A,#0x0
   \   000039   C3           CLR     C
   \   00003A   65D0         XRL     A,PSW
   \   00003C   33           RLC     A
   \   00003D   5015         JNC     ??ZDApp_NetworkStartEvt_3
    670              {
    671                NLME_SetEnergyThreshold( (uint8)(NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT) );
   \   00003F                ; Setup parameters for call to function NLME_SetEnergyThreshold
   \   00003F                ; Setup parameters for call to function NLME_GetEnergyThreshold
   \   00003F   74..         MOV     A,#((NLME_GetEnergyThreshold >> 16) & 0xff)
   \   000041   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000044   E9           MOV     A,R1
   \   000045   2410         ADD     A,#0x10
   \   000047   F9           MOV     R1,A
   \   000048   90....       MOV     DPTR,#(NLME_SetEnergyThreshold & 0xffff)
   \   00004B   74..         MOV     A,#((NLME_SetEnergyThreshold >> 16) & 0xff)
   \   00004D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    672                osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   \   000050                ; Setup parameters for call to function osal_set_event
   \   000050   7A01         MOV     R2,#0x1
   \   000052   8008         SJMP    ??ZDApp_NetworkStartEvt_4
    673              }
    674              else
    675              {
    676                // Failed to start network. Enter a dormant state (until user intervenes)
    677                devState = DEV_INIT;
   \                     ??ZDApp_NetworkStartEvt_3:
   \   000054   7401         MOV     A,#0x1
   \   000056   90....       MOV     DPTR,#devState
   \   000059   F0           MOVX    @DPTR,A
    678                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00005A                ; Setup parameters for call to function osal_set_event
   \                     ??ZDApp_NetworkStartEvt_2:
   \   00005A   7A10         MOV     R2,#0x10
   \                     ??ZDApp_NetworkStartEvt_4:
   \   00005C   02....       LJMP    ?Subroutine31 & 0xFFFF
    679              }
    680            }
    681          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??Subroutine31_0:
   \   000003   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000006   02....       LJMP    ??Subroutine25_0 & 0xFFFF
    682          
    683          #if ( SECURE != 0 )
    684          /*********************************************************************
    685           * @fn      ZDApp_DeviceAuthEvt()
    686           *
    687           * @brief   Process the Device Authentic Event
    688           *
    689           * @param   none
    690           *
    691           * @return  none
    692           */
    693          void ZDApp_DeviceAuthEvt( void )
    694          {
    695            // received authentication from trust center
    696            if ( devState == DEV_END_DEVICE_UNAUTH )
    697            {
    698              // Stop the reset timer so it doesn't reset
    699              ZDApp_ResetTimerCancel();
    700          
    701              devState = DEV_END_DEVICE;
    702              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    703          
    704              // Set the Power Manager Device
    705          #if defined ( POWER_SAVING )
    706              osal_pwrmgr_device( PWRMGR_BATTERY );
    707          #endif
    708          
    709          #if defined ( RTR_NWK )
    710              if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
    711              {
    712                // NOTE: first two parameters are not used, see NLMEDE.h for details
    713                NLME_StartRouterRequest( 0, 0, false );
    714              }
    715          #endif  // RTR
    716          
    717                // Notify to save info into NV
    718              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 100 );
    719          
    720              // Save off the security
    721              ZDApp_SaveNwkKey();
    722          
    723          #if defined ( ZDO_ENDDEVICE_ANNCE_GENERATE )
    724              ZDP_EndDeviceAnnce( ZDAppNwkAddr.addr.shortAddr, saveExtAddr,
    725                                 ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
    726          #endif
    727            }
    728            else
    729            {
    730              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
    731            }
    732          }
    733          #endif
    734          
    735          /*********************************************************************
    736           * @fn      ZDApp_SaveNetworkStateEvt()
    737           *
    738           * @brief   Process the Save the Network State Event
    739           *
    740           * @param   none
    741           *
    742           * @return  none
    743           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    744          void ZDApp_SaveNetworkStateEvt( void )
   \                     ZDApp_SaveNetworkStateEvt:
    745          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    746          #if defined ( NV_RESTORE )
    747           #if defined ( NV_TURN_OFF_RADIO )
    748            // Turn off the radio's receiver during an NV update
    749            byte RxOnIdle;
    750            byte x = false;
    751            ZMacGetReq( ZMacRxOnIdle, &RxOnIdle );
    752            ZMacSetReq( ZMacRxOnIdle, &x );
    753           #endif
    754          
    755            // Update the Network State in NV
    756            NLME_UpdateNV( NWK_NV_NIB_ENABLE        |
    757                           NWK_NV_DEVICELIST_ENABLE |
    758                           NWK_NV_BINDING_ENABLE    |
    759                           NWK_NV_ADDRMGR_ENABLE );
    760          
    761            // Reset the NV startup option to resume from NV by
    762            // clearing the "New" join option.
    763            zgWriteStartupOptions( FALSE, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
    764          
    765           #if defined ( NV_TURN_OFF_RADIO )
    766            ZMacSetReq( ZMacRxOnIdle, &RxOnIdle );
    767           #endif
    768          #endif  // NV_RESTORE
    769          }
   \   000000   02....       LJMP    ?BRET
    770          
    771          /*********************************************************************
    772           * @fn      ZDApp_RestoreNetworkState()
    773           *
    774           * @brief   This function will restore the network state of the
    775           *          device if the network state is stored in NV.
    776           *
    777           * @param   none
    778           *
    779           * @return
    780           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    781           *          restored.
    782           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was not used.
    783           *          This could mean that zgStartupOption said to not restore, or
    784           *          it could mean that there was no network state to restore.
    785           *
    786           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    787          uint8 ZDApp_RestoreNetworkState( void )
   \                     ZDApp_RestoreNetworkState:
    788          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    789            byte nvStat;
    790          #if ( SECURE != 0 )
    791            nwkActiveKeyItems keyItems;
    792          #endif
    793          
    794            // Initialize NWK NV items
    795            nvStat = NLME_InitNV();
   \   000005                ; Setup parameters for call to function NLME_InitNV
   \   000005   90....       MOV     DPTR,#(NLME_InitNV & 0xffff)
   \   000008   74..         MOV     A,#((NLME_InitNV >> 16) & 0xff)
   \   00000A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000D   E9           MOV     A,R1
   \   00000E   FE           MOV     R6,A
    796          
    797            if ( nvStat != NV_OPER_FAILED )
   \   00000F   7410         MOV     A,#0x10
   \   000011   6E           XRL     A,R6
   \   000012   6032         JZ      ??ZDApp_RestoreNetworkState_0
    798            {
    799              if ( NLME_RestoreFromNV() )
   \   000014                ; Setup parameters for call to function NLME_RestoreFromNV
   \   000014   90....       MOV     DPTR,#(NLME_RestoreFromNV & 0xffff)
   \   000017   74..         MOV     A,#((NLME_RestoreFromNV >> 16) & 0xff)
   \   000019   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001C   E9           MOV     A,R1
   \   00001D   602E         JZ      ??ZDApp_RestoreNetworkState_1
    800              {
    801                // Are we a coordinator
    802                ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
   \   00001F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00001F   90....       MOV     DPTR,#(NLME_GetShortAddr & 0xffff)
   \   000022   74..         MOV     A,#((NLME_GetShortAddr >> 16) & 0xff)
   \   000024   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000027   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00002A   EA           MOV     A,R2
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   EB           MOV     A,R3
   \   00002E   F0           MOVX    @DPTR,A
    803                if ( ZDAppNwkAddr.addr.shortAddr == 0 )
   \   00002F   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000032   E0           MOVX    A,@DPTR
   \   000033   7002         JNZ     ??ZDApp_RestoreNetworkState_2
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \                     ??ZDApp_RestoreNetworkState_2:
   \   000037   7007         JNZ     ??ZDApp_RestoreNetworkState_3
    804                {
    805                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   \   000039   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   54F8         ANL     A,#0xf8
   \   00003F   F0           MOVX    @DPTR,A
    806                }
    807                devStartMode = MODE_RESUME;
   \                     ??ZDApp_RestoreNetworkState_3:
   \   000040   7401         MOV     A,#0x1
   \   000042   90....       MOV     DPTR,#devStartMode
   \   000045   F0           MOVX    @DPTR,A
    808              }
    809              else
    810                nvStat = NV_ITEM_UNINIT;
    811          
    812          #if   ( SECURE != 0  )
    813              nwkFrameCounterChanges = 0;
    814              osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
    815              osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
    816          
    817            #if defined ( ZDO_COORDINATOR )
    818              ZDApp_RestoreNwkKey();
    819            #endif // ZDO_COORDINATOR
    820          #endif // SECURE
    821          
    822              // The default for RxOnWhenIdle is true for RTR_NWK and false for end devices
    823              // [setup in the NLME_RestoreFromNV()].  Change it here if you want something
    824              // other than default.
    825            }
    826          
    827            if ( nvStat == ZSUCCESS )
   \                     ??ZDApp_RestoreNetworkState_0:
   \   000046   EE           MOV     A,R6
   \   000047   7004         JNZ     ??ZDApp_RestoreNetworkState_1
    828              return ( ZDO_INITDEV_RESTORED_NETWORK_STATE );
   \   000049   7900         MOV     R1,#0x0
   \   00004B   8002         SJMP    ??ZDApp_RestoreNetworkState_4
    829            else
    830              return ( ZDO_INITDEV_NEW_NETWORK_STATE );
   \                     ??ZDApp_RestoreNetworkState_1:
   \   00004D   7901         MOV     R1,#0x1
   \                     ??ZDApp_RestoreNetworkState_4:
   \   00004F   02....       LJMP    ??Subroutine27_0 & 0xFFFF
    831          }
    832          
    833          /*********************************************************************
    834           * @fn      ZDAppSetupProtoVersion()
    835           *
    836           * @brief   Setup the Network Protocol version
    837           *
    838           * NOTES:
    839           *   Take care of setting initial protocol value if we're possibly a
    840           *   Coordinator.
    841           *
    842           *   If DEF_PROTO_VERS macro is not defined get version
    843           *   from NV. if the NV version isn't valid default to Version 1.1.
    844           *
    845           *   if DEF_PROTO_VERS macro is defined respect it.
    846           *
    847           *   This initialization section works for End Devices as well.
    848           *
    849           *   There are two chores: make sure that if we're the Coordinator we start
    850           *   the correct network version, and set things up so that if we're a
    851           *   joining device we join the correct network. In both cases this init
    852           *   function runs so take care of both cases here.
    853           *
    854           * @param   none
    855           *
    856           * @return  none
    857           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    858          void ZDAppSetupProtoVersion( void )
   \                     ZDAppSetupProtoVersion:
    859          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    860            uint8 restore = 1;  // update NV or not: could save a flash erase cycle
    861          
    862          #if !defined ( DEF_PROTO_VERS )
    863            uint8 protoVer = NLME_GetProtocolVersion(); // get  protocol version from NV
   \   000009                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   000009   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   00000C   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   00000E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000011   E9           MOV     A,R1
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   F0           MOVX    @DPTR,A
    864          
    865            // it is possible that it is uninitialized.
    866            if ((protoVer != ZB_PROT_V1_0) && (protoVer != ZB_PROT_V1_1))
   \   000019   6401         XRL     A,#0x1
   \   00001B   6019         JZ      ??ZDAppSetupProtoVersion_0
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   6402         XRL     A,#0x2
   \   000020   6014         JZ      ??ZDAppSetupProtoVersion_0
    867            {
    868              // NV value not valid. 'protoVer' must be set.
    869          
    870              // For Coordinator behavior
    871              // CUSTOMER NOTE: change the following to default the started network
    872              // to a protocol version other than 1.1
    873              protoVer = ZB_PROT_V1_1;
   \   000022   7402         MOV     A,#0x2
   \   000024   F0           MOVX    @DPTR,A
    874            }
    875            else
    876            {
    877              // NV valid. 'protoVer' is valid.
    878              restore = 0;  // no need to update NV
    879          
    880              // For joining device behavior. Respect the NV version by making
    881              // all entries in the version array the same as the NV value.
    882              osal_memset(sPVerList, protoVer, sizeof(sPVerList));
    883            }
    884          #else
    885            // macro defined. respect it.
    886          
    887            // don't compile if defined to an illegal value.
    888            #if (DEF_PROTO_VERS != ZB_PROT_V1_0) && (DEF_PROTO_VERS != ZB_PROT_V1_1)
    889              #error  No legal value for default protocol version
    890            #endif
    891            uint8 protoVer = DEF_PROTO_VERS;
    892          
    893            // For joining device behavior. respect the NV version by making
    894            // all entries in the version array the same as the macro value.
    895            osal_memset(sPVerList, protoVer, sizeof(sPVerList));
    896          #endif   // DEF_PROTO_VERS
    897          
    898            // if we are or can be the Coordinator then we must update
    899            // it here. if we're going to be a joining device setting will be done in the
    900            // confirm callback if necessary.
    901            if (restore)
    902            {
    903              // we need to set NV to a (possibly) new value
    904              NLME_SetRequest(nwkProtocolVersion, 0, &protoVer);
   \   000025                ; Setup parameters for call to function NLME_SetRequest
   \   000025   AC82         MOV     R4,DPL
   \   000027   AD83         MOV     R5,DPH
   \   000029   7A00         MOV     R2,#0x0
   \   00002B   7B00         MOV     R3,#0x0
   \   00002D   7998         MOV     R1,#-0x68
   \   00002F   90....       MOV     DPTR,#(NLME_SetRequest & 0xffff)
   \   000032   74..         MOV     A,#((NLME_SetRequest >> 16) & 0xff)
   \   000034   800D         SJMP    ??ZDAppSetupProtoVersion_1
    905            }
   \                     ??ZDAppSetupProtoVersion_0:
   \   000036                ; Setup parameters for call to function osal_memset
   \   000036   7C02         MOV     R4,#0x2
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7A..         MOV     R2,#(??sPVerList & 0xff)
   \   00003C   7B..         MOV     R3,#((??sPVerList >> 8) & 0xff)
   \   00003E   90....       MOV     DPTR,#(osal_memset & 0xffff)
   \   000041   74..         MOV     A,#((osal_memset >> 16) & 0xff)
   \                     ??ZDAppSetupProtoVersion_1:
   \   000043   02....       LJMP    ?Subroutine25 & 0xFFFF
    906          }
    907          
    908          /*********************************************************************
    909           * @fn      ZDApp_InitUserDesc()
    910           *
    911           * @brief   Initialize the User Descriptor, the descriptor is read from NV
    912           *          when needed.  If you want to initialize the User descriptor to
    913           *          something other than all zero, do it here.
    914           *
    915           * @param   none
    916           *
    917           * @return  none
    918           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    919          void ZDApp_InitUserDesc( void )
   \                     ZDApp_InitUserDesc:
    920          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    921            UserDescriptorFormat_t ZDO_DefaultUserDescriptor;
    922          
    923            // Initialize the User Descriptor, the descriptor is read from NV
    924            // when needed.  If you want to initialize the User descriptor to something
    925            // other than all zero, do it here.
    926            osal_memset( &ZDO_DefaultUserDescriptor, 0, sizeof( UserDescriptorFormat_t ) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C11         MOV     R4,#0x11
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   90....       MOV     DPTR,#(osal_memset & 0xffff)
   \   00001D   74..         MOV     A,#((osal_memset >> 16) & 0xff)
   \   00001F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    927            if ( ZSUCCESS == osal_nv_item_init( ZCD_NV_USERDESC,
    928                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
   \   000022                ; Setup parameters for call to function osal_nv_item_init
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   8582..       MOV     ?V0 + 0,DPL
   \   00002B   8583..       MOV     ?V0 + 1,DPH
   \   00002E   78..         MOV     R0,#?V0 + 0
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   7C11         MOV     R4,#0x11
   \   000035   7D00         MOV     R5,#0x0
   \   000037   7A81         MOV     R2,#-0x7f
   \   000039   7B00         MOV     R3,#0x0
   \   00003B   90....       MOV     DPTR,#(osal_nv_item_init & 0xffff)
   \   00003E   74..         MOV     A,#((osal_nv_item_init >> 16) & 0xff)
   \   000040   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   E9           MOV     A,R1
   \   000049   7038         JNZ     ??ZDApp_InitUserDesc_0
    929            {
    930              if ( ZSUCCESS == osal_nv_read( ZCD_NV_USERDESC, 0,
    931                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
   \   00004B                ; Setup parameters for call to function osal_nv_read
   \   00004B   78..         MOV     R0,#?V0 + 0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   75..11       MOV     ?V0 + 0,#0x11
   \   000053   75..00       MOV     ?V0 + 1,#0x0
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7C00         MOV     R4,#0x0
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7A81         MOV     R2,#-0x7f
   \   000061   7B00         MOV     R3,#0x0
   \   000063   90....       MOV     DPTR,#(osal_nv_read & 0xffff)
   \   000066   74..         MOV     A,#((osal_nv_read >> 16) & 0xff)
   \   000068   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00006B   7404         MOV     A,#0x4
   \   00006D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000070   E9           MOV     A,R1
   \   000071   7010         JNZ     ??ZDApp_InitUserDesc_0
    932              {
    933                if ( ZDO_DefaultUserDescriptor.len != 0 )
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   6007         JZ      ??ZDApp_InitUserDesc_0
    934                {
    935                  ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   \   00007C   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   D2E4         SETB    0xE0 /* A   */.4
   \   000082   F0           MOVX    @DPTR,A
    936                }
    937              }
    938            }
    939          }
   \                     ??ZDApp_InitUserDesc_0:
   \   000083   7411         MOV     A,#0x11
   \   000085   02....       LJMP    ??Subroutine26_0 & 0xFFFF
    940          
    941          /*********************************************************************
    942           * @fn      ZDAppCheckForHoldKey()
    943           *
    944           * @brief   Check for key to set the device into Hold Auto Start
    945           *
    946           * @param   none
    947           *
    948           * @return  none
    949           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    950          void ZDAppCheckForHoldKey( void )
   \                     ZDAppCheckForHoldKey:
    951          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    952          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    953            // Get Keypad directly to see if a HOLD_START is needed.
    954            // Hold down the SW_BYPASS_START key (see OnBoard.h)
    955            // while booting to avoid starting up the device.
    956            if ( HalKeyRead () == SW_BYPASS_START)
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   90....       MOV     DPTR,#(HalKeyRead & 0xffff)
   \   000007   74..         MOV     A,#((HalKeyRead >> 16) & 0xff)
   \   000009   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00000C   E9           MOV     A,R1
   \   00000D   6401         XRL     A,#0x1
   \   00000F   7005         JNZ     ??ZDAppCheckForHoldKey_0
    957            {
    958              // Change the device state to HOLD on start up
    959              devState = DEV_HOLD;
   \   000011   E4           CLR     A
   \   000012   90....       MOV     DPTR,#devState
   \   000015   F0           MOVX    @DPTR,A
    960            }
    961          #endif // HAL_KEY
    962          }
   \                     ??ZDAppCheckForHoldKey_0:
   \   000016   02....       LJMP    ??Subroutine25_0 & 0xFFFF
    963          
    964          /*********************************************************************
    965           * @fn      ZDApp_ProcessOSALMsg()
    966           *
    967           * @brief   Process the incoming task message.
    968           *
    969           * @param   msgPtr - message to process
    970           *
    971           * @return  none
    972           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    973          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr )
   \                     ZDApp_ProcessOSALMsg:
    974          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    975            // Data Confirmation message fields
    976            byte sentEP;       // This should always be 0
    977            byte sentStatus;
    978            afDataConfirm_t *afDataConfirm;
    979          
    980            switch ( msgPtr->event )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for ZDApp_ProcessOSALMsg>_0`:
   \   000011   00           DB        0
   \   000012   04           DB        4
   \   000013   01           DB        1
   \   000014   ....         DW        ??ZDApp_ProcessOSALMsg_0
   \   000016   02           DB        2
   \   000017   ....         DW        ??ZDApp_ProcessOSALMsg_1
   \   000019   03           DB        3
   \   00001A   ....         DW        ??ZDApp_ProcessOSALMsg_2
   \   00001C   1A           DB        26
   \   00001D   ....         DW        ??ZDApp_ProcessOSALMsg_3
   \   00001F   ....         DW        ??ZDApp_ProcessOSALMsg_4
    981            {
    982              // Incoming ZDO Message
    983              case AF_INCOMING_MSG_CMD:
    984                ZDP_IncomingData( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??ZDApp_ProcessOSALMsg_3:
   \   000021                ; Setup parameters for call to function ZDP_IncomingData
   \   000021   90....       MOV     DPTR,#(ZDP_IncomingData & 0xffff)
   \   000024   74..         MOV     A,#((ZDP_IncomingData >> 16) & 0xff)
   \   000026   02....       LJMP    ??CrossCallReturnLabel_69 & 0xFFFF
    985                break;
    986          
    987              case AF_DATA_CONFIRM_CMD:
    988                // This message is received as a confirmation of a data packet sent.
    989                // The status is of ZStatus_t type [defined in NLMEDE.h]
    990                // The message fields are defined in AF.h
    991                afDataConfirm = (afDataConfirm_t *)msgPtr;
    992                sentEP = afDataConfirm->endpoint;
    993                sentStatus = afDataConfirm->hdr.status;
    994          
    995                // Action taken when confirmation is received.
    996                /* Put code here */
    997          #if !defined ( RTR_NWK )
    998                if ( sentStatus == ZMacNoACK )
    999                {
   1000                  //ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_REQ, sizeof(osal_event_hdr_t), NULL );
   1001                }
   1002          #else
   1003               (void)sentStatus;
   1004          #endif
   1005                break;
   1006          
   1007              case ZDO_NWK_DISC_CNF:
   1008                if (devState != DEV_NWK_DISC)
   \                     ??ZDApp_ProcessOSALMsg_0:
   \   000029   90....       MOV     DPTR,#devState
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   6402         XRL     A,#0x2
   \   00002F   6003         JZ      $+5
   \   000031   02....       LJMP    ??ZDApp_ProcessOSALMsg_4 & 0xFFFF
   1009                {
   1010                }
   1011          #if !defined ( ZDO_COORDINATOR ) || defined ( SOFT_START )
   1012            #if defined ( MANAGED_SCAN )
   1013                else if ( (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status == ZDO_SUCCESS) && (zdoDiscCounter > NUM_DISC_ATTEMPTS) )
   1014            #else
   1015                else if ( (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status == ZDO_SUCCESS) && (zdoDiscCounter++ > NUM_DISC_ATTEMPTS) )
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6003         JZ      $+5
   \   00003C   02....       LJMP    ??ZDApp_ProcessOSALMsg_5 & 0xFFFF
   \   00003F   90....       MOV     DPTR,#zdoDiscCounter
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FA           MOV     R2,A
   \   000044   7401         MOV     A,#0x1
   \   000046   2A           ADD     A,R2
   \   000047   F0           MOVX    @DPTR,A
   \   000048   EA           MOV     A,R2
   \   000049   C3           CLR     C
   \   00004A   9403         SUBB    A,#0x3
   \   00004C   5003         JNC     $+5
   \   00004E   02....       LJMP    ??ZDApp_ProcessOSALMsg_5 & 0xFFFF
   1016            #endif
   1017                {
   1018                  if ( devStartMode == MODE_JOIN )
   \   000051   90....       MOV     DPTR,#devStartMode
   \   000054   E0           MOVX    A,@DPTR
   \   000055   704B         JNZ     ??ZDApp_ProcessOSALMsg_6
   1019                  {
   1020                    devState = DEV_NWK_JOINING;
   \   000057   7403         MOV     A,#0x3
   \   000059   90....       MOV     DPTR,#devState
   \   00005C   F0           MOVX    @DPTR,A
   1021          
   1022                    ZDApp_NodeProfileSync((ZDO_NetworkDiscoveryCfm_t *)msgPtr);
   \   00005D                ; Setup parameters for call to function ZDApp_NodeProfileSync
   \   00005D   EE           MOV     A,R6
   \   00005E   FA           MOV     R2,A
   \   00005F   90....       MOV     DPTR,#(ZDApp_NodeProfileSync & 0xffff)
   \   000062   74..         MOV     A,#((ZDApp_NodeProfileSync >> 16) & 0xff)
   \   000064   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1023          
   1024                    if ( NLME_JoinRequest( ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->extendedPANID,
   1025                         BUILD_UINT16( ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdLSB, ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdMSB ),
   1026                         ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->logicalChannel,
   1027                         ZDO_Config_Node_Descriptor.CapabilityFlags ) != ZSuccess )
   \   000067                ; Setup parameters for call to function NLME_JoinRequest
   \   000067   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   00006A   12....       LCALL   ??Subroutine12_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FC           MOV     R4,A
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FB           MOV     R3,A
   \   000085   E4           CLR     A
   \   000086   2C           ADD     A,R4
   \   000087   EB           MOV     A,R3
   \   000088   3400         ADDC    A,#0x0
   \   00008A   FD           MOV     R5,A
   \   00008B   EE           MOV     A,R6
   \   00008C   2406         ADD     A,#0x6
   \   00008E   FA           MOV     R2,A
   \   00008F   EF           MOV     A,R7
   \   000090   3400         ADDC    A,#0x0
   \   000092   FB           MOV     R3,A
   \   000093   90....       MOV     DPTR,#(NLME_JoinRequest & 0xffff)
   \   000096   74..         MOV     A,#((NLME_JoinRequest >> 16) & 0xff)
   \   000098   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00009B   7401         MOV     A,#0x1
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A0   8012         SJMP    ??ZDApp_ProcessOSALMsg_7
   1028                    {
   1029                      ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1030                          + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1031                    }
   1032                  }
   1033                  else if ( devStartMode == MODE_REJOIN )
   \                     ??ZDApp_ProcessOSALMsg_6:
   \   0000A2   6403         XRL     A,#0x3
   \   0000A4   701F         JNZ     ??ZDApp_ProcessOSALMsg_8
   1034                  {
   1035                    devState = DEV_NWK_REJOIN;
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   90....       MOV     DPTR,#devState
   \   0000AB   F0           MOVX    @DPTR,A
   1036                    if ( NLME_ReJoinRequest() != ZSuccess )
   \   0000AC                ; Setup parameters for call to function NLME_ReJoinRequest
   \   0000AC   90....       MOV     DPTR,#(NLME_ReJoinRequest & 0xffff)
   \   0000AF   74..         MOV     A,#((NLME_ReJoinRequest >> 16) & 0xff)
   \   0000B1   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_ProcessOSALMsg_7:
   \   0000B4   E9           MOV     A,R1
   \   0000B5   600E         JZ      ??ZDApp_ProcessOSALMsg_8
   1037                    {
   1038                      ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1039                          + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   \   0000B7                ; Setup parameters for call to function ZDApp_NetworkInit
   \   0000B7                ; Setup parameters for call to function osal_rand
   \   0000B7   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   0000BA   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   0000BC   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000BF   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   0000C2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1040                    }
   1041                  }
   1042          
   1043                  if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   \                     ??ZDApp_ProcessOSALMsg_8:
   \   0000C5   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   A2E3         MOV     C,0xE0 /* A   */.3
   \   0000CB   5070         JNC     ??ZDApp_ProcessOSALMsg_4
   1044                  {
   1045                    // The receiver is on, turn network layer polling off.
   1046                    NLME_SetPollRate( 0 );
   \   0000CD                ; Setup parameters for call to function NLME_SetPollRate
   \   0000CD   7A00         MOV     R2,#0x0
   \   0000CF   7B00         MOV     R3,#0x0
   \   0000D1   90....       MOV     DPTR,#(NLME_SetPollRate & 0xffff)
   \   0000D4   74..         MOV     A,#((NLME_SetPollRate >> 16) & 0xff)
   \   0000D6   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1047                    NLME_SetQueuedPollRate( 0 );
   \   0000D9                ; Setup parameters for call to function NLME_SetQueuedPollRate
   \   0000D9   7A00         MOV     R2,#0x0
   \   0000DB   7B00         MOV     R3,#0x0
   \   0000DD   90....       MOV     DPTR,#(NLME_SetQueuedPollRate & 0xffff)
   \   0000E0   74..         MOV     A,#((NLME_SetQueuedPollRate >> 16) & 0xff)
   \   0000E2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1048                    NLME_SetResponseRate( 0 );
   \   0000E5                ; Setup parameters for call to function NLME_SetResponseRate
   \   0000E5   7A00         MOV     R2,#0x0
   \   0000E7   7B00         MOV     R3,#0x0
   \   0000E9   90....       MOV     DPTR,#(NLME_SetResponseRate & 0xffff)
   \   0000EC   74..         MOV     A,#((NLME_SetResponseRate >> 16) & 0xff)
   \   0000EE   804A         SJMP    ??CrossCallReturnLabel_69
   1049                  }
   1050                }
   1051                else
   1052                {
   1053          #if defined ( SOFT_START ) && !defined ( VIRTKEY_SOFT_START )
   1054            #if defined ( MANAGED_SCAN )
   1055                  if ( (softStartAllowCoord)
   1056                      && (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status != ZDO_SUCCESS )
   1057                        && (zdoDiscCounter > NUM_DISC_ATTEMPTS) )
   1058            #else
   1059                  if ( (softStartAllowCoord)
   1060                      && (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status != ZDO_SUCCESS )
   1061                        && (zdoDiscCounter++ > NUM_DISC_ATTEMPTS) )
   1062            #endif
   1063                  {
   1064                    ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   1065                    devStartMode = MODE_HARD;
   1066                  }
   1067                  else if ( continueJoining == FALSE )
   1068                  {
   1069                    devState = DEV_HOLD;
   1070                    osal_stop_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT );
   1071                    break;    // Don't init
   1072                  }
   1073          #endif
   1074            #if defined ( MANAGED_SCAN )
   1075                  ZDApp_NetworkInit( MANAGEDSCAN_DELAY_BETWEEN_SCANS );
   1076            #else
   1077                  if ( continueJoining )
   \                     ??ZDApp_ProcessOSALMsg_5:
   \   0000F0   90....       MOV     DPTR,#continueJoining
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   6047         JZ      ??ZDApp_ProcessOSALMsg_4
   1078                  {
   1079                    ZDApp_NetworkInit( (uint16)(BEACON_REQUEST_DELAY
   1080                        + ((uint16)(osal_rand()& BEACON_REQ_DELAY_MASK))) );
   \   0000F6                ; Setup parameters for call to function ZDApp_NetworkInit
   \   0000F6                ; Setup parameters for call to function osal_rand
   \   0000F6   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   0000F9   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   0000FB   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000FE   8A..         MOV     ?V0 + 0,R2
   \   000100   74FF         MOV     A,#-0x1
   \   000102   55..         ANL     A,?V0 + 0
   \   000104   F8           MOV     R0,A
   \   000105   7464         MOV     A,#0x64
   \   000107   28           ADD     A,R0
   \   000108   FA           MOV     R2,A
   \   000109   E4           CLR     A
   \   00010A   3400         ADDC    A,#0x0
   \   00010C   FB           MOV     R3,A
   \   00010D   90....       MOV     DPTR,#(ZDApp_NetworkInit & 0xffff)
   \   000110   74..         MOV     A,#((ZDApp_NetworkInit >> 16) & 0xff)
   \   000112   8026         SJMP    ??CrossCallReturnLabel_69
   1081                  }
   1082            #endif
   1083                }
   1084          #endif  // !ZDO_COORDINATOR
   1085                break;
   1086          
   1087          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )
   1088              case ZDO_NWK_JOIN_IND:
   1089                ZDApp_ProcessNetworkJoin();
   \                     ??ZDApp_ProcessOSALMsg_1:
   \   000114                ; Setup parameters for call to function ZDApp_ProcessNetworkJoin
   \   000114   90....       MOV     DPTR,#(ZDApp_ProcessNetworkJoin & 0xffff)
   \   000117   74..         MOV     A,#((ZDApp_ProcessNetworkJoin >> 16) & 0xff)
   \   000119   801F         SJMP    ??CrossCallReturnLabel_69
   1090                break;
   1091          
   1092              case ZDO_NWK_JOIN_REQ:
   1093                retryCnt = 0;
   \                     ??ZDApp_ProcessOSALMsg_2:
   \   00011B   E4           CLR     A
   \   00011C   90....       MOV     DPTR,#??retryCnt
   \   00011F   F0           MOVX    @DPTR,A
   1094                devStartMode = MODE_RESUME;
   \   000120   7401         MOV     A,#0x1
   \   000122   90....       MOV     DPTR,#devStartMode
   \   000125   F0           MOVX    @DPTR,A
   1095                _tmpRejoinState = true;
   \   000126   90....       MOV     DPTR,#_tmpRejoinState
   \   000129   F0           MOVX    @DPTR,A
   1096                zgDefaultStartingScanDuration = BEACON_ORDER_60_MSEC;
   \   00012A   7402         MOV     A,#0x2
   \   00012C   90....       MOV     DPTR,#zgDefaultStartingScanDuration
   \   00012F   12....       LCALL   ?Subroutine2 & 0xFFFF
   1097                ZDApp_NetworkInit( 0 );
   \                     ??CrossCallReturnLabel_59:
   \   000132   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1098          
   1099                // indicate state change to apps
   1100                devState = DEV_INIT;
   \   000135   7401         MOV     A,#0x1
   \   000137   12....       LCALL   ?Subroutine0 & 0xFFFF
   1101                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \                     ??CrossCallReturnLabel_69:
   \   00013A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1102                break;
   1103          #endif  // !ZDO_COORDINATOR
   1104          
   1105          #if defined ( ZDSECMGR_SECURE )
   1106            #if defined ( ZDSECMGR_COMMERCIAL )
   1107                  case ZDO_ESTABLISH_KEY_CFM:
   1108                    ZDSecMgrEstablishKeyCfm
   1109                      ( (ZDO_EstablishKeyCfm_t*)msgPtr );
   1110                    break;
   1111            #endif
   1112          
   1113            #if defined ( ZDSECMGR_COMMERCIAL )
   1114              #if !defined ( ZDO_COORDINATOR ) || defined ( SOFT_START )
   1115                  case ZDO_ESTABLISH_KEY_IND:
   1116                    ZDSecMgrEstablishKeyInd
   1117                      ( (ZDO_EstablishKeyInd_t*)msgPtr );
   1118                    break;
   1119              #endif
   1120            #endif
   1121          
   1122            #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
   1123                  case ZDO_TRANSPORT_KEY_IND:
   1124                    ZDSecMgrTransportKeyInd
   1125                      ( (ZDO_TransportKeyInd_t*)msgPtr );
   1126                    break;
   1127            #endif
   1128          
   1129            #if defined ( ZDO_COORDINATOR )
   1130                  case ZDO_UPDATE_DEVICE_IND:
   1131                    ZDSecMgrUpdateDeviceInd
   1132                      ( (ZDO_UpdateDeviceInd_t*)msgPtr );
   1133                    break;
   1134            #endif
   1135          
   1136            #if defined ( RTR_NWK )
   1137              #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
   1138                  case ZDO_REMOVE_DEVICE_IND:
   1139                    ZDSecMgrRemoveDeviceInd
   1140                      ( (ZDO_RemoveDeviceInd_t*)msgPtr );
   1141                    break;
   1142              #endif
   1143            #endif
   1144          
   1145            #if defined ( ZDSECMGR_COMMERCIAL )
   1146              #if defined ( ZDO_COORDINATOR )
   1147                  case ZDO_REQUEST_KEY_IND:
   1148                    ZDSecMgrRequestKeyInd
   1149                      ( (ZDO_RequestKeyInd_t*)msgPtr );
   1150                    break;
   1151              #endif
   1152            #endif
   1153          
   1154            #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
   1155                  case ZDO_SWITCH_KEY_IND:
   1156                    ZDSecMgrSwitchKeyInd
   1157                      ( (ZDO_SwitchKeyInd_t*)msgPtr );
   1158                    break;
   1159            #endif
   1160          
   1161          #endif // defined ( ZDSECMGR_SECURE )
   1162          
   1163              default:
   1164                break;
   1165            }
   1166          
   1167            (void)sentEP;
   1168          }
   \                     ??ZDApp_ProcessOSALMsg_4:
   \   00013D   80..         SJMP    ??Subroutine26_1

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   8A..         MOV     ?V0 + 0,R2
   \   000002   747F         MOV     A,#0x7f
   \   000004   55..         ANL     A,?V0 + 0
   \   000006   F8           MOV     R0,A
   \   000007   7464         MOV     A,#0x64
   \   000009   28           ADD     A,R0
   \   00000A   FA           MOV     R2,A
   \   00000B                REQUIRE ?Subroutine29
   \   00000B                ; // Fall through to label ?Subroutine29

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   90....       MOV     DPTR,#(ZDApp_NetworkInit & 0xffff)
   \   000005   74..         MOV     A,#((ZDApp_NetworkInit >> 16) & 0xff)
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   90....       MOV     DPTR,#devState
   \   000003   F0           MOVX    @DPTR,A
   \   000004                ; Setup parameters for call to function osal_set_event
   \   000004                ; Setup parameters for call to function osal_set_event
   \   000004   7A10         MOV     R2,#0x10
   \   000006                REQUIRE ?Subroutine28
   \   000006                ; // Fall through to label ?Subroutine28

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??Subroutine12_0:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F5..         MOV     ?V0 + 0,A
   \   000006   78..         MOV     R0,#?V0 + 0
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F9           MOV     R1,A
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDApp_NetworkInit
   \   000001                ; Setup parameters for call to function ZDApp_NetworkInit
   \   000001   7A00         MOV     R2,#0x0
   \   000003   02....       LJMP    ?Subroutine29 & 0xFFFF
   1169          
   1170          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )
   1171          /*********************************************************************
   1172           * @fn      ZDApp_ProcessNetworkJoin()
   1173           *
   1174           * @brief
   1175           *
   1176           *   Save off the Network key information.
   1177           *
   1178           * @param   none
   1179           *
   1180           * @return  none
   1181           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1182          void ZDApp_ProcessNetworkJoin( void )
   \                     ZDApp_ProcessNetworkJoin:
   1183          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1184            if ( (devState == DEV_NWK_JOINING) ||
   1185                ((devState == DEV_NWK_ORPHAN)  &&
   1186                 (ZDO_Config_Node_Descriptor.LogicalType == NODETYPE_ROUTER)) )
   \   00000A   90....       MOV     DPTR,#devState
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6403         XRL     A,#0x3
   \   000010   6015         JZ      ??ZDApp_ProcessNetworkJoin_0
   \   000012   E0           MOVX    A,@DPTR
   \   000013   640A         XRL     A,#0xa
   \   000015   6003         JZ      $+5
   \   000017   02....       LJMP    ??ZDApp_ProcessNetworkJoin_1 & 0xFFFF
   \   00001A   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   5407         ANL     A,#0x7
   \   000020   6401         XRL     A,#0x1
   \   000022   6003         JZ      $+5
   \   000024   02....       LJMP    ??ZDApp_ProcessNetworkJoin_2 & 0xFFFF
   1187            {
   1188              // Result of a Join attempt by this device.
   1189              if ( nwkStatus == ZSuccess )
   \                     ??ZDApp_ProcessNetworkJoin_0:
   \   000027   90....       MOV     DPTR,#nwkStatus
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   703F         JNZ     ??ZDApp_ProcessNetworkJoin_3
   1190              {
   1191                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00002D                ; Setup parameters for call to function osal_set_event
   \   00002D   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000030   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1192          
   1193          #if defined ( POWER_SAVING )
   1194                osal_pwrmgr_device( PWRMGR_BATTERY );
   1195          #endif
   1196          
   1197          #if   ( SECURE != 0  )
   1198                if ( _NIB.SecurityLevel && (ZDApp_RestoreNwkKey() == false ) )
   1199                {
   1200                  // wait for auth from trust center!!
   1201                  devState = DEV_END_DEVICE_UNAUTH;
   1202          
   1203                  // Start the reset timer for MAX UNAUTH time
   1204                  ZDApp_ResetTimerStart( MAX_DEVICE_UNAUTH_TIMEOUT );
   1205                }
   1206                else
   1207          #endif  // SECURE
   1208                {
   1209          #if defined ( RTR_NWK )
   1210                  if ( devState == DEV_NWK_ORPHAN
   1211                      && ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   \   000033   90....       MOV     DPTR,#devState
   \   000036   E0           MOVX    A,@DPTR
   \   000037   640A         XRL     A,#0xa
   \   000039   7010         JNZ     ??ZDApp_ProcessNetworkJoin_4
   \   00003B   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   5407         ANL     A,#0x7
   \   000041   6402         XRL     A,#0x2
   \   000043   6006         JZ      ??ZDApp_ProcessNetworkJoin_4
   1212                  {
   1213                    // Change NIB state to router for restore
   1214                    _NIB.nwkState = NWK_ROUTER;
   \   000045   7408         MOV     A,#0x8
   \   000047   90....       MOV     DPTR,#(_NIB + 35)
   \   00004A   F0           MOVX    @DPTR,A
   1215                  }
   1216          #endif
   1217                  devState = DEV_END_DEVICE;
   \                     ??ZDApp_ProcessNetworkJoin_4:
   \   00004B   7406         MOV     A,#0x6
   \   00004D   90....       MOV     DPTR,#devState
   \   000050   F0           MOVX    @DPTR,A
   1218          #if defined ( RTR_NWK )
   1219                  // NOTE: first two parameters are not used, see NLMEDE.h for details
   1220            #if !defined (AUTO_SOFT_START)
   1221                  if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   \   000051   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   000054   E0           MOVX    A,@DPTR
   \   000055   5407         ANL     A,#0x7
   \   000057   6402         XRL     A,#0x2
   \   000059   7003         JNZ     $+5
   \   00005B   02....       LJMP    ??ZDApp_ProcessNetworkJoin_5 & 0xFFFF
   1222                  {
   1223                    NLME_StartRouterRequest( 0, 0, false );
   \   00005E                ; Setup parameters for call to function NLME_StartRouterRequest
   \   00005E   7B00         MOV     R3,#0x0
   \   000060   7A00         MOV     R2,#0x0
   \   000062   7900         MOV     R1,#0x0
   \   000064   90....       MOV     DPTR,#(NLME_StartRouterRequest & 0xffff)
   \   000067   74..         MOV     A,#((NLME_StartRouterRequest >> 16) & 0xff)
   \   000069   02....       LJMP    ??CrossCallReturnLabel_62 & 0xFFFF
   1224                  }
   1225            #endif // AUTO_SOFT_START
   1226          #endif  // RTR
   1227          
   1228          #if defined ( ZDO_ENDDEVICE_ANNCE_GENERATE )
   1229                  ZDP_EndDeviceAnnce( ZDAppNwkAddr.addr.shortAddr, saveExtAddr,
   1230                                     ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
   1231          #endif
   1232                }
   1233              }
   1234              else
   1235              {
   1236                if ( (devStartMode == MODE_RESUME) && (++retryCnt >= MAX_RESUME_RETRY) )
   \                     ??ZDApp_ProcessNetworkJoin_3:
   \   00006C   90....       MOV     DPTR,#devStartMode
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   6401         XRL     A,#0x1
   \   000072   7036         JNZ     ??ZDApp_ProcessNetworkJoin_6
   \   000074   90....       MOV     DPTR,#??retryCnt
   \   000077   E0           MOVX    A,@DPTR
   \   000078   04           INC     A
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   602E         JZ      ??ZDApp_ProcessNetworkJoin_6
   1237                {
   1238                  if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   \   00007C   90....       MOV     DPTR,#(_NIB + 33)
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   64FF         XRL     A,#0xff
   \   000082   7004         JNZ     ??ZDApp_ProcessNetworkJoin_7
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_7:
   \   000088   600E         JZ      ??ZDApp_ProcessNetworkJoin_8
   \   00008A   90....       MOV     DPTR,#(_NIB + 33)
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   64FE         XRL     A,#0xfe
   \   000090   7004         JNZ     ??ZDApp_ProcessNetworkJoin_9
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_9:
   \   000096   7006         JNZ     ??ZDApp_ProcessNetworkJoin_10
   1239                    devStartMode = MODE_JOIN;
   \                     ??ZDApp_ProcessNetworkJoin_8:
   \   000098   E4           CLR     A
   \   000099   90....       MOV     DPTR,#devStartMode
   \   00009C   800B         SJMP    ??ZDApp_ProcessNetworkJoin_11
   1240                  else
   1241                  {
   1242                    devStartMode = MODE_REJOIN;
   \                     ??ZDApp_ProcessNetworkJoin_10:
   \   00009E   7403         MOV     A,#0x3
   \   0000A0   90....       MOV     DPTR,#devStartMode
   \   0000A3   F0           MOVX    @DPTR,A
   1243                    _tmpRejoinState = true;
   \   0000A4   7401         MOV     A,#0x1
   \   0000A6   90....       MOV     DPTR,#_tmpRejoinState
   \                     ??ZDApp_ProcessNetworkJoin_11:
   \   0000A9   F0           MOVX    @DPTR,A
   1244                  }
   1245                }
   1246          
   1247                if ( (NLME_GetShortAddr() != INVALID_NODE_ADDR) ||
   1248                     (_NIB.nwkDevAddress != INVALID_NODE_ADDR) )
   \                     ??ZDApp_ProcessNetworkJoin_6:
   \   0000AA                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000AA   90....       MOV     DPTR,#(NLME_GetShortAddr & 0xffff)
   \   0000AD   74..         MOV     A,#((NLME_GetShortAddr >> 16) & 0xff)
   \   0000AF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000B2   8A..         MOV     ?V0 + 0,R2
   \   0000B4   8B..         MOV     ?V0 + 1,R3
   \   0000B6   74FE         MOV     A,#-0x2
   \   0000B8   65..         XRL     A,?V0 + 0
   \   0000BA   7004         JNZ     ??ZDApp_ProcessNetworkJoin_12
   \   0000BC   74FF         MOV     A,#-0x1
   \   0000BE   65..         XRL     A,?V0 + 1
   \                     ??ZDApp_ProcessNetworkJoin_12:
   \   0000C0   700E         JNZ     ??ZDApp_ProcessNetworkJoin_13
   \   0000C2   90....       MOV     DPTR,#(_NIB + 20)
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   64FE         XRL     A,#0xfe
   \   0000C8   7004         JNZ     ??ZDApp_ProcessNetworkJoin_14
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_14:
   \   0000CE   6022         JZ      ??ZDApp_ProcessNetworkJoin_15
   1249                {
   1250                  uint16 addr = INVALID_NODE_ADDR;
   \                     ??ZDApp_ProcessNetworkJoin_13:
   \   0000D0   85..82       MOV     DPL,?XSP + 0
   \   0000D3   85..83       MOV     DPH,?XSP + 1
   \   0000D6   74FE         MOV     A,#-0x2
   \   0000D8   F0           MOVX    @DPTR,A
   \   0000D9   A3           INC     DPTR
   \   0000DA   74FF         MOV     A,#-0x1
   \   0000DC   F0           MOVX    @DPTR,A
   1251                  // Invalidate nwk addr so end device does not use in its data reqs.
   1252                  _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   \   0000DD   90....       MOV     DPTR,#(_NIB + 20)
   \   0000E0   74FE         MOV     A,#-0x2
   \   0000E2   F0           MOVX    @DPTR,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   74FF         MOV     A,#-0x1
   \   0000E6   12....       LCALL   ?Subroutine1 & 0xFFFF
   1253                  ZMacSetReq( ZMacShortAddress, (byte *)&addr );
   \                     ??CrossCallReturnLabel_0:
   \   0000E9   AA82         MOV     R2,DPL
   \   0000EB   AB83         MOV     R3,DPH
   \   0000ED   7953         MOV     R1,#0x53
   \   0000EF   12....       LCALL   ZMacSetReq & 0xFFFF
   1254                }
   1255          
   1256                zdoDiscCounter = 1;
   \                     ??ZDApp_ProcessNetworkJoin_15:
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   90....       MOV     DPTR,#zdoDiscCounter
   \   0000F7   807E         SJMP    ??ZDApp_ProcessNetworkJoin_16
   \   0000F9                ; Setup parameters for call to function ZDApp_NetworkInit
   \   0000F9                ; Setup parameters for call to function osal_rand
   1257          
   1258          //      ZDApp_NetworkInit( (uint16)
   1259          //                         ((NWK_START_DELAY * (osal_rand() & 0x0F)) +
   1260          //                          (NWK_START_DELAY * 5)) );
   1261                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1262                     + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1263              }
   1264            }
   1265            else if ( devState == DEV_NWK_ORPHAN || devState == DEV_NWK_REJOIN )
   \                     ??ZDApp_ProcessNetworkJoin_1:
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   6404         XRL     A,#0x4
   \   0000FC   6003         JZ      $+5
   \   0000FE   02....       LJMP    ??ZDApp_ProcessNetworkJoin_5 & 0xFFFF
   1266            {
   1267              // results of an orphaning attempt by this device
   1268              if (nwkStatus == ZSuccess)
   \                     ??ZDApp_ProcessNetworkJoin_2:
   \   000101   90....       MOV     DPTR,#nwkStatus
   \   000104   E0           MOVX    A,@DPTR
   \   000105   7033         JNZ     ??ZDApp_ProcessNetworkJoin_17
   1269              {
   1270          #if ( SECURE != 0 )
   1271                ZDApp_RestoreNwkKey();
   1272          #endif
   1273                devState = DEV_END_DEVICE;
   \   000107   7406         MOV     A,#0x6
   \   000109   12....       LCALL   ?Subroutine0 & 0xFFFF
   1274                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \                     ??CrossCallReturnLabel_70:
   \   00010C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1275                // setup Power Manager Device
   1276          #if defined ( POWER_SAVING )
   1277                osal_pwrmgr_device( PWRMGR_BATTERY );
   1278          #endif
   1279          
   1280                if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   \   00010F   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   000112   E0           MOVX    A,@DPTR
   \   000113   A2E3         MOV     C,0xE0 /* A   */.3
   \   000115   506F         JNC     ??ZDApp_ProcessNetworkJoin_5
   1281                {
   1282                  // The receiver is on, turn network layer polling off.
   1283                  NLME_SetPollRate( 0 );
   \   000117                ; Setup parameters for call to function NLME_SetPollRate
   \   000117   7A00         MOV     R2,#0x0
   \   000119   7B00         MOV     R3,#0x0
   \   00011B   90....       MOV     DPTR,#(NLME_SetPollRate & 0xffff)
   \   00011E   74..         MOV     A,#((NLME_SetPollRate >> 16) & 0xff)
   \   000120   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1284                  NLME_SetQueuedPollRate( 0 );
   \   000123                ; Setup parameters for call to function NLME_SetQueuedPollRate
   \   000123   7A00         MOV     R2,#0x0
   \   000125   7B00         MOV     R3,#0x0
   \   000127   90....       MOV     DPTR,#(NLME_SetQueuedPollRate & 0xffff)
   \   00012A   74..         MOV     A,#((NLME_SetQueuedPollRate >> 16) & 0xff)
   \   00012C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1285                  NLME_SetResponseRate( 0 );
   \   00012F                ; Setup parameters for call to function NLME_SetResponseRate
   \   00012F   7A00         MOV     R2,#0x0
   \   000131   7B00         MOV     R3,#0x0
   \   000133   90....       MOV     DPTR,#(NLME_SetResponseRate & 0xffff)
   \   000136   74..         MOV     A,#((NLME_SetResponseRate >> 16) & 0xff)
   \   000138   8049         SJMP    ??CrossCallReturnLabel_62
   1286                }
   1287          
   1288          #if defined ( ZDO_ENDDEVICE_ANNCE_GENERATE )
   1289                ZDP_EndDeviceAnnce( ZDAppNwkAddr.addr.shortAddr, saveExtAddr,
   1290                                   ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
   1291          #endif
   1292          
   1293              }
   1294              else
   1295              {
   1296                if ( (devStartMode == MODE_RESUME) && (++retryCnt >= MAX_RESUME_RETRY) )
   \                     ??ZDApp_ProcessNetworkJoin_17:
   \   00013A   90....       MOV     DPTR,#devStartMode
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   6401         XRL     A,#0x1
   \   000140   7036         JNZ     ??ZDApp_ProcessNetworkJoin_18
   \   000142   90....       MOV     DPTR,#??retryCnt
   \   000145   E0           MOVX    A,@DPTR
   \   000146   04           INC     A
   \   000147   F0           MOVX    @DPTR,A
   \   000148   602E         JZ      ??ZDApp_ProcessNetworkJoin_18
   1297                {
   1298                  if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   \   00014A   90....       MOV     DPTR,#(_NIB + 33)
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   64FF         XRL     A,#0xff
   \   000150   7004         JNZ     ??ZDApp_ProcessNetworkJoin_19
   \   000152   A3           INC     DPTR
   \   000153   E0           MOVX    A,@DPTR
   \   000154   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_19:
   \   000156   600E         JZ      ??ZDApp_ProcessNetworkJoin_20
   \   000158   90....       MOV     DPTR,#(_NIB + 33)
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   64FE         XRL     A,#0xfe
   \   00015E   7004         JNZ     ??ZDApp_ProcessNetworkJoin_21
   \   000160   A3           INC     DPTR
   \   000161   E0           MOVX    A,@DPTR
   \   000162   64FF         XRL     A,#0xff
   \                     ??ZDApp_ProcessNetworkJoin_21:
   \   000164   7006         JNZ     ??ZDApp_ProcessNetworkJoin_22
   1299                    devStartMode = MODE_JOIN;
   \                     ??ZDApp_ProcessNetworkJoin_20:
   \   000166   E4           CLR     A
   \   000167   90....       MOV     DPTR,#devStartMode
   \   00016A   800B         SJMP    ??ZDApp_ProcessNetworkJoin_16
   1300                  else
   1301                  {
   1302                    devStartMode = MODE_REJOIN;
   \                     ??ZDApp_ProcessNetworkJoin_22:
   \   00016C   7403         MOV     A,#0x3
   \   00016E   90....       MOV     DPTR,#devStartMode
   \   000171   F0           MOVX    @DPTR,A
   1303                    _tmpRejoinState = true;
   \   000172   7401         MOV     A,#0x1
   \   000174   90....       MOV     DPTR,#_tmpRejoinState
   \                     ??ZDApp_ProcessNetworkJoin_16:
   \   000177   F0           MOVX    @DPTR,A
   1304                  }
   1305                }
   1306          
   1307                // setup a retry for later...
   1308                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1309                     + (osal_rand()& EXTENDED_JOINING_RANDOM_MASK)) );
   \                     ??ZDApp_ProcessNetworkJoin_18:
   \   000178                ; Setup parameters for call to function ZDApp_NetworkInit
   \   000178                ; Setup parameters for call to function osal_rand
   \   000178   90....       MOV     DPTR,#(osal_rand & 0xffff)
   \   00017B   74..         MOV     A,#((osal_rand >> 16) & 0xff)
   \   00017D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000180   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000183   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1310              }
   1311            }
   1312            else
   1313            {
   1314              // this is an error case!!
   1315            }
   1316          }
   \                     ??ZDApp_ProcessNetworkJoin_5:
   \   000186   02....       LJMP    ?Subroutine26 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZMacSetReq
   \   000001                ; Setup parameters for call to function osal_memcpy
   \   000001                ; Setup parameters for call to function ZDApp_SendMsg
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET
   1317          #endif // !ZDO_COORDINATOR
   1318          
   1319          #if ( SECURE != 0 )
   1320          /*********************************************************************
   1321           * @fn      ZDApp_SaveNwkKey()
   1322           *
   1323           * @brief   Save off the Network key information.
   1324           *
   1325           * @param   none
   1326           *
   1327           * @return  none
   1328           */
   1329          void ZDApp_SaveNwkKey( void )
   1330          {
   1331            nwkActiveKeyItems keyItems;
   1332          
   1333            SSP_ReadNwkActiveKey( &keyItems );
   1334            keyItems.frameCounter++;
   1335          
   1336            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1337                          (void *)&keyItems );
   1338          
   1339            nwkFrameCounterChanges = 0;
   1340          }
   1341          
   1342          /*********************************************************************
   1343           * @fn      ZDApp_ResetNwkKey()
   1344           *
   1345           * @brief   Reset the Network key information in NV.
   1346           *
   1347           * @param   none
   1348           *
   1349           * @return  none
   1350           */
   1351          void ZDApp_ResetNwkKey( void )
   1352          {
   1353            nwkActiveKeyItems keyItems;
   1354          
   1355            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   1356            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1357                          (void *)&keyItems );
   1358          }
   1359          #endif
   1360          
   1361          #if ( SECURE != 0 )
   1362          /*********************************************************************
   1363           * @fn      ZDApp_RestoreNwkKey()
   1364           *
   1365           * @brief
   1366           *
   1367           *   Save off the Network key information.
   1368           *
   1369           * @param   none
   1370           *
   1371           * @return  true if restored from NV, false if not
   1372           */
   1373          byte ZDApp_RestoreNwkKey( void )
   1374          {
   1375            nwkActiveKeyItems keyItems;
   1376            byte ret = false;
   1377          
   1378            if ( osal_nv_read( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), (void*)&keyItems )
   1379                == ZSUCCESS )
   1380            {
   1381              if ( keyItems.frameCounter > 0 )
   1382              {
   1383                // Restore the key information
   1384                keyItems.frameCounter += MAX_NWK_FRAMECOUNTER_CHANGES;
   1385                SSP_WriteNwkActiveKey( &keyItems );
   1386                ret = true;
   1387              }
   1388              nwkFrameCounterChanges = MAX_NWK_FRAMECOUNTER_CHANGES; // Force a save for the first
   1389            }
   1390            return ( ret );
   1391          }
   1392          #endif
   1393          
   1394          /*********************************************************************
   1395           * @fn      ZDApp_SendEndDeviceBindReq()
   1396           *
   1397           * @brief
   1398           *
   1399           *   This function will look up the endpoint description
   1400           *   and send an End Device Bind Request message.
   1401           *
   1402           * @param  endPoint - Endpoint to auto find
   1403           *
   1404           * @return  none
   1405           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1406          void ZDApp_SendEndDeviceBindReq( byte endPoint )
   \                     ZDApp_SendEndDeviceBindReq:
   1407          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   1408          #if defined ( ZDO_ENDDEVICEBIND_REQUEST )
   1409            zAddrType_t dstAddr;
   1410            SimpleDescriptionFormat_t *sDesc;
   1411            byte free;
   1412            if ( (endPoint == ZDO_EP) || (endPoint > MAX_ENDPOINTS) )
   \   00000C   7003         JNZ     $+5
   \   00000E   02....       LJMP    ??ZDApp_SendEndDeviceBindReq_0 & 0xFFFF
   \   000011   C3           CLR     C
   \   000012   94F1         SUBB    A,#-0xf
   \   000014   4003         JC      $+5
   \   000016   02....       LJMP    ??ZDApp_SendEndDeviceBindReq_0 & 0xFFFF
   1413            {
   1414              return;   // Can't do for ZDO
   1415            }
   1416          
   1417            HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   000019                ; Setup parameters for call to function HalLedSet
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7908         MOV     R1,#0x8
   \   00001D   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000020   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000022   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1418          
   1419            free = afFindSimpleDesc( &sDesc, endPoint );
   \   000025                ; Setup parameters for call to function afFindSimpleDesc
   \   000025   EF           MOV     A,R7
   \   000026   F9           MOV     R1,A
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   AA82         MOV     R2,DPL
   \   00002F   AB83         MOV     R3,DPH
   \   000031   90....       MOV     DPTR,#(afFindSimpleDesc & 0xffff)
   \   000034   74..         MOV     A,#((afFindSimpleDesc >> 16) & 0xff)
   \   000036   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000039   E9           MOV     A,R1
   \   00003A   FE           MOV     R6,A
   1420            if ( sDesc != NULL )
   \   00003B   85..82       MOV     DPL,?XSP + 0
   \   00003E   85..83       MOV     DPH,?XSP + 1
   \   000041   E0           MOVX    A,@DPTR
   \   000042   7002         JNZ     ??ZDApp_SendEndDeviceBindReq_1
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \                     ??ZDApp_SendEndDeviceBindReq_1:
   \   000046   7003         JNZ     $+5
   \   000048   02....       LJMP    ??ZDApp_SendEndDeviceBindReq_0 & 0xFFFF
   1421            {
   1422              dstAddr.addrMode = Addr16Bit;
   \   00004B   740A         MOV     A,#0xa
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   7402         MOV     A,#0x2
   \   000052   F0           MOVX    @DPTR,A
   1423              dstAddr.addr.shortAddr = 0;   // Zigbee Coordinator
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   E4           CLR     A
   \   000057   F0           MOVX    @DPTR,A
   \   000058   A3           INC     DPTR
   \   000059   F0           MOVX    @DPTR,A
   1424              ZDP_EndDeviceBindReq( &dstAddr,
   1425          #if defined ( REFLECTOR  )
   1426                          // We have a reflector, so tell the coordinator to send
   1427                          // binding messages this way
   1428                          NLME_GetShortAddr(),
   1429          #else
   1430                          // tell the coordinator to store if available
   1431                          NWK_PAN_COORD_ADDR,
   1432          #endif
   1433                          endPoint,sDesc->AppProfId,
   1434                          sDesc->AppNumOutClusters, sDesc->pAppOutClusterList,
   1435                          sDesc->AppNumInClusters, sDesc->pAppInClusterList,
   1436                          0 );
   \   00005A                ; Setup parameters for call to function ZDP_EndDeviceBindReq
   \   00005A   F5..         MOV     ?V0 + 0,A
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000061   7401         MOV     A,#0x1
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000069   A3           INC     DPTR
   \   00006A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00006D   7403         MOV     A,#0x3
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000075   12....       LCALL   ??Subroutine12_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000078   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007B   7404         MOV     A,#0x4
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000083   A3           INC     DPTR
   \   000084   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000087   7406         MOV     A,#0x6
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00008F   12....       LCALL   ??Subroutine12_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000092   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000095   7407         MOV     A,#0x7
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   12....       LCALL   ??Subroutine11_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00009D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000A0   EF           MOV     A,R7
   \   0000A1   F9           MOV     R1,A
   \   0000A2   7C00         MOV     R4,#0x0
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   740B         MOV     A,#0xb
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   90....       MOV     DPTR,#(ZDP_EndDeviceBindReq & 0xffff)
   \   0000B2   74..         MOV     A,#((ZDP_EndDeviceBindReq >> 16) & 0xff)
   \   0000B4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000B7   7409         MOV     A,#0x9
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   1437          
   1438              if ( free )
   \   0000BC   EE           MOV     A,R6
   \   0000BD   6013         JZ      ??ZDApp_SendEndDeviceBindReq_0
   1439              {
   1440                osal_mem_free( sDesc );
   \   0000BF                ; Setup parameters for call to function osal_mem_free
   \   0000BF   85..82       MOV     DPL,?XSP + 0
   \   0000C2   85..83       MOV     DPH,?XSP + 1
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   FA           MOV     R2,A
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   FB           MOV     R3,A
   \   0000CA   90....       MOV     DPTR,#(osal_mem_free & 0xffff)
   \   0000CD   74..         MOV     A,#((osal_mem_free >> 16) & 0xff)
   \   0000CF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_SendEndDeviceBindReq_0:
   \   0000D2   740B         MOV     A,#0xb
   \   0000D4   02....       LJMP    ?Subroutine27 & 0xFFFF
   1441              }
   1442            }
   1443            else
   1444            {
   1445          
   1446            }
   1447          #endif // ZDO_ENDDEVICEBIND_REQUEST
   1448          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \                     ??Subroutine11_0:
   \   000003   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
   1449          
   1450          /*********************************************************************
   1451           * @fn      ZDApp_AutoFindDestination()
   1452           *
   1453           * @brief
   1454           *
   1455           *   This function will try to find the Input Match for this device's
   1456           *   (endpoint passed in) outputs.
   1457           *
   1458           * @param  endPoint - Endpoint to auto find
   1459           * @param  task_id  - task ID override, if NULL use endpoint desc's
   1460           *                    task_id
   1461           *
   1462           * @return  none
   1463           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1464          void ZDApp_AutoFindDestinationEx( byte endPoint, uint8 *task_id )
   \                     ZDApp_AutoFindDestinationEx:
   1465          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   1466          #if defined ( ZDO_MATCH_REQUEST )
   1467            zAddrType_t dstAddr;
   1468            SimpleDescriptionFormat_t *sDesc;
   1469            endPointDesc_t *tmpDesc;
   1470            if ( endPoint == ZDO_EP )
   \   000010   7003         JNZ     $+5
   \   000012   02....       LJMP    ??ZDApp_AutoFindDestinationEx_0 & 0xFFFF
   1471              return;   // Can't do for ZDO
   1472          
   1473            HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \   000015                ; Setup parameters for call to function HalLedSet
   \   000015   7A00         MOV     R2,#0x0
   \   000017   7908         MOV     R1,#0x8
   \   000019   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   00001C   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   00001E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1474          
   1475            tmpDesc = afFindEndPointDesc( endPoint );
   \   000021                ; Setup parameters for call to function afFindEndPointDesc
   \   000021   EE           MOV     A,R6
   \   000022   F9           MOV     R1,A
   \   000023   90....       MOV     DPTR,#(afFindEndPointDesc & 0xffff)
   \   000026   74..         MOV     A,#((afFindEndPointDesc >> 16) & 0xff)
   \   000028   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00002B   8A..         MOV     ?V0 + 2,R2
   \   00002D   8B..         MOV     ?V0 + 3,R3
   \   00002F   AE..         MOV     R6,?V0 + 2
   \   000031   AF..         MOV     R7,?V0 + 3
   1476            if ( tmpDesc )
   \   000033   EE           MOV     A,R6
   \   000034   7001         JNZ     ??ZDApp_AutoFindDestinationEx_1
   \   000036   EF           MOV     A,R7
   \                     ??ZDApp_AutoFindDestinationEx_1:
   \   000037   7003         JNZ     $+5
   \   000039   02....       LJMP    ??ZDApp_AutoFindDestinationEx_0 & 0xFFFF
   1477            {
   1478              if ( ZDApp_AutoFindMode_epDesc == NULL )
   \   00003C   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   7002         JNZ     ??ZDApp_AutoFindDestinationEx_2
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \                     ??ZDApp_AutoFindDestinationEx_2:
   \   000044   7014         JNZ     ??ZDApp_AutoFindDestinationEx_3
   1479              {
   1480                ZDApp_AutoFindMode_epDesc = (endPointDesc_t *)osal_mem_alloc( sizeof ( endPointDesc_t ) );
   \   000046                ; Setup parameters for call to function osal_mem_alloc
   \   000046   7A06         MOV     R2,#0x6
   \   000048   7B00         MOV     R3,#0x0
   \   00004A   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   00004D   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   00004F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000052   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   000055   EA           MOV     A,R2
   \   000056   F0           MOVX    @DPTR,A
   \   000057   A3           INC     DPTR
   \   000058   EB           MOV     A,R3
   \   000059   F0           MOVX    @DPTR,A
   1481              }
   1482          
   1483              if ( ZDApp_AutoFindMode_epDesc )
   \                     ??ZDApp_AutoFindDestinationEx_3:
   \   00005A   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   7002         JNZ     ??ZDApp_AutoFindDestinationEx_4
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \                     ??ZDApp_AutoFindDestinationEx_4:
   \   000062   7003         JNZ     $+5
   \   000064   02....       LJMP    ??ZDApp_AutoFindDestinationEx_0 & 0xFFFF
   1484              {
   1485                osal_memcpy( ZDApp_AutoFindMode_epDesc, tmpDesc, sizeof( endPointDesc_t ) );
   \   000067                ; Setup parameters for call to function osal_memcpy
   \   000067   8E..         MOV     ?V0 + 4,R6
   \   000069   8F..         MOV     ?V0 + 5,R7
   \   00006B   75..00       MOV     ?V0 + 6,#0x0
   \   00006E   78..         MOV     R0,#?V0 + 4
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000073   7C06         MOV     R4,#0x6
   \   000075   7D00         MOV     R5,#0x0
   \   000077   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   FA           MOV     R2,A
   \   00007C   A3           INC     DPTR
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   FB           MOV     R3,A
   \   00007F   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000082   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   000084   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000087   7403         MOV     A,#0x3
   \   000089   12....       LCALL   ?DEALLOC_XSTACK8
   1486                if ( task_id )
   \   00008C   E5..         MOV     A,?V0 + 0
   \   00008E   7002         JNZ     ??ZDApp_AutoFindDestinationEx_5
   \   000090   E5..         MOV     A,?V0 + 1
   \                     ??ZDApp_AutoFindDestinationEx_5:
   \   000092   600A         JZ      ??ZDApp_AutoFindDestinationEx_6
   1487                {
   1488                  // Override the Task ID, if needed.
   1489                  ZDApp_AutoFindMode_epDesc->task_id = task_id;
   \   000094   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000097   E5..         MOV     A,?V0 + 0
   \   000099   F0           MOVX    @DPTR,A
   \   00009A   A3           INC     DPTR
   \   00009B   E5..         MOV     A,?V0 + 1
   \   00009D   F0           MOVX    @DPTR,A
   1490                }
   1491          
   1492                sDesc = ZDApp_AutoFindMode_epDesc->simpleDesc;
   \                     ??ZDApp_AutoFindDestinationEx_6:
   \   00009E   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000A1   A3           INC     DPTR
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F8           MOV     R0,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F9           MOV     R1,A
   \   0000A8   E8           MOV     A,R0
   \   0000A9   FA           MOV     R2,A
   \   0000AA   E9           MOV     A,R1
   \   0000AB   FB           MOV     R3,A
   1493          
   1494                // This message is sent to everyone
   1495                dstAddr.addrMode = AddrBroadcast;
   \   0000AC   7408         MOV     A,#0x8
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   740F         MOV     A,#0xf
   \   0000B3   12....       LCALL   ?Subroutine1 & 0xFFFF
   1496                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
   \                     ??CrossCallReturnLabel_1:
   \   0000B6   74FF         MOV     A,#-0x1
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   F0           MOVX    @DPTR,A
   1497                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR, sDesc->AppProfId,
   1498                                  sDesc->AppNumOutClusters, sDesc->pAppOutClusterList,
   1499                                  sDesc->AppNumInClusters, sDesc->pAppInClusterList, 0 );
   \   0000BB                ; Setup parameters for call to function ZDP_MatchDescReq
   \   0000BB   75..00       MOV     ?V0 + 0,#0x0
   \   0000BE   78..         MOV     R0,#?V0 + 0
   \   0000C0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C3   8A82         MOV     DPL,R2
   \   0000C5   8B83         MOV     DPH,R3
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D1   8A82         MOV     DPL,R2
   \   0000D3   8B83         MOV     DPH,R3
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   12....       LCALL   ??Subroutine12_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   0000DE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E1   8A82         MOV     DPL,R2
   \   0000E3   8B83         MOV     DPH,R3
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000F2   8A82         MOV     DPL,R2
   \   0000F4   8B83         MOV     DPH,R3
   \   0000F6   A3           INC     DPTR
   \   0000F7   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000FA   8A82         MOV     DPL,R2
   \   0000FC   8B83         MOV     DPH,R3
   \   0000FE   A3           INC     DPTR
   \   0000FF   A3           INC     DPTR
   \   000100   A3           INC     DPTR
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   A3           INC     DPTR
   \   000105   A3           INC     DPTR
   \   000106   A3           INC     DPTR
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F9           MOV     R1,A
   \   000109   7CFF         MOV     R4,#-0x1
   \   00010B   7DFF         MOV     R5,#-0x1
   \   00010D   7408         MOV     A,#0x8
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   AA82         MOV     R2,DPL
   \   000114   AB83         MOV     R3,DPH
   \   000116   90....       MOV     DPTR,#(ZDP_MatchDescReq & 0xffff)
   \   000119   74..         MOV     A,#((ZDP_MatchDescReq >> 16) & 0xff)
   \   00011B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00011E   7408         MOV     A,#0x8
   \   000120   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??ZDApp_AutoFindDestinationEx_0:
   \   000123   7409         MOV     A,#0x9
   \   000125   12....       LCALL   ?DEALLOC_XSTACK8
   \   000128   7F07         MOV     R7,#0x7
   \   00012A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1500          
   1501              }
   1502            }
   1503            else
   1504            {
   1505            }
   1506          #endif // ZDO_MATCH_REQUEST
   1507          }
   1508          
   1509          /*********************************************************************
   1510           * @fn      ZDApp_ResetTimerStart
   1511           *
   1512           * @brief   Start the reset timer.
   1513           *
   1514           * @param   delay - delay time(ms) before reset
   1515           *
   1516           * @return  none
   1517           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1518          void ZDApp_ResetTimerStart( uint16 delay )
   \                     ZDApp_ResetTimerStart:
   1519          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1520            // Start the rest timer
   1521            osal_start_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET, delay );
   \   000004                ; Setup parameters for call to function osal_start_timerEx
   \   000004   EA           MOV     A,R2
   \   000005   FC           MOV     R4,A
   \   000006   EB           MOV     A,R3
   \   000007   FD           MOV     R5,A
   \   000008   7A04         MOV     R2,#0x4
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00000F   02....       LJMP    ??Subroutine31_0 & 0xFFFF
   1522          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7CE8         MOV     R4,#-0x18
   \   000002   7D03         MOV     R5,#0x3
   \                     ??Subroutine5_0:
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7B02         MOV     R3,#0x2
   \                     ??Subroutine5_1:
   \   000008   90....       MOV     DPTR,#ZDAppTaskID
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   90....       MOV     DPTR,#(osal_start_timerEx & 0xffff)
   \   000010   74..         MOV     A,#((osal_start_timerEx >> 16) & 0xff)
   \   000012   22           RET
   1523          
   1524          /*********************************************************************
   1525           * @fn      ZDApp_ResetTimerCancel
   1526           *
   1527           * @brief   Cancel the reset timer.
   1528           *
   1529           * @param   none
   1530           *
   1531           * @return  none
   1532           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1533          void ZDApp_ResetTimerCancel( void )
   \                     ZDApp_ResetTimerCancel:
   1534          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1535            // Cancel the reset timer
   1536            osal_stop_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET );
   \   000004                ; Setup parameters for call to function osal_stop_timerEx
   \   000004   7A04         MOV     R2,#0x4
   \   000006   7B00         MOV     R3,#0x0
   \   000008   90....       MOV     DPTR,#ZDAppTaskID
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   90....       MOV     DPTR,#(osal_stop_timerEx & 0xffff)
   \   000010   74..         MOV     A,#((osal_stop_timerEx >> 16) & 0xff)
   \   000012   02....       LJMP    ??Subroutine31_0 & 0xFFFF
   1537          }
   1538          
   1539          /*********************************************************************
   1540           * @fn      ZDApp_LeaveCtrlInit
   1541           *
   1542           * @brief   Initialize the leave control logic.
   1543           *
   1544           * @param   none
   1545           *
   1546           * @return  none
   1547           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1548          void ZDApp_LeaveCtrlInit( void )
   \                     ZDApp_LeaveCtrlInit:
   1549          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1550            uint8 status;
   1551          
   1552          
   1553            // Initialize control state
   1554            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   \   000005   12....       LCALL   ?Subroutine3 & 0xFFFF
   1555          
   1556            status = osal_nv_item_init( ZCD_NV_LEAVE_CTRL,
   1557                                        sizeof(ZDApp_LeaveCtrl),
   1558                                        &ZDApp_LeaveCtrl );
   1559          
   1560            if ( status == ZSUCCESS )
   \                     ??CrossCallReturnLabel_4:
   \   000008   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000B   7C01         MOV     R4,#0x1
   \   00000D   7D00         MOV     R5,#0x0
   \   00000F   7A85         MOV     R2,#-0x7b
   \   000011   7B00         MOV     R3,#0x0
   \   000013   90....       MOV     DPTR,#(osal_nv_item_init & 0xffff)
   \   000016   74..         MOV     A,#((osal_nv_item_init >> 16) & 0xff)
   \   000018   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000020   E9           MOV     A,R1
   \   000021   7025         JNZ     ??ZDApp_LeaveCtrlInit_0
   1561            {
   1562              // Read saved control
   1563              osal_nv_read( ZCD_NV_LEAVE_CTRL,
   1564                            0,
   1565                            sizeof( uint8 ),
   1566                            &ZDApp_LeaveCtrl);
   \   000023                ; Setup parameters for call to function osal_nv_read
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   75..01       MOV     ?V0 + 0,#0x1
   \   00002B   75..00       MOV     ?V0 + 1,#0x0
   \   00002E   78..         MOV     R0,#?V0 + 0
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   7C00         MOV     R4,#0x0
   \   000035   7D00         MOV     R5,#0x0
   \   000037   7A85         MOV     R2,#-0x7b
   \   000039   7B00         MOV     R3,#0x0
   \   00003B   90....       MOV     DPTR,#(osal_nv_read & 0xffff)
   \   00003E   74..         MOV     A,#((osal_nv_read >> 16) & 0xff)
   \   000040   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000043   7404         MOV     A,#0x4
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   1567            }
   1568          }
   \                     ??ZDApp_LeaveCtrlInit_0:
   \   000048   02....       LJMP    ??Subroutine26_1 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E4           CLR     A
   \   000001   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005                ; Setup parameters for call to function osal_nv_write
   \   000005   75....       MOV     ?V0 + 0,#(ZDApp_LeaveCtrl & 0xff)
   \   000008   75....       MOV     ?V0 + 1,#((ZDApp_LeaveCtrl >> 8) & 0xff)
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   22           RET
   1569          
   1570          /*********************************************************************
   1571           * @fn      ZDApp_LeaveCtrlSet
   1572           *
   1573           * @brief   Set the leave control logic.
   1574           *
   1575           * @param   ra - reassociate flag
   1576           *
   1577           * @return  none
   1578           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1579          void ZDApp_LeaveCtrlSet( uint8 ra )
   \                     ZDApp_LeaveCtrlSet:
   1580          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1581            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_SET;
   \   000005   7401         MOV     A,#0x1
   \   000007   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   00000A   F0           MOVX    @DPTR,A
   1582          
   1583            if ( ra == TRUE )
   \   00000B   69           XRL     A,R1
   \   00000C   7003         JNZ     ??ZDApp_LeaveCtrlSet_0
   1584            {
   1585              ZDApp_LeaveCtrl |= ZDAPP_LEAVE_CTRL_RA;
   \   00000E   7403         MOV     A,#0x3
   \   000010   F0           MOVX    @DPTR,A
   1586            }
   1587          
   1588            // Write the leave control
   1589            osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1590                           0,
   1591                           sizeof( uint8 ),
   1592                           &ZDApp_LeaveCtrl);
   \                     ??ZDApp_LeaveCtrlSet_0:
   \   000011                ; Setup parameters for call to function osal_nv_write
   \   000011   75....       MOV     ?V0 + 0,#(ZDApp_LeaveCtrl & 0xff)
   \   000014   75....       MOV     ?V0 + 1,#((ZDApp_LeaveCtrl >> 8) & 0xff)
   \   000017   78..         MOV     R0,#?V0 + 0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   75..01       MOV     ?V0 + 0,#0x1
   \   00001F   75..00       MOV     ?V0 + 1,#0x0
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   7C00         MOV     R4,#0x0
   \   000029   7D00         MOV     R5,#0x0
   \   00002B   7A85         MOV     R2,#-0x7b
   \   00002D   7B00         MOV     R3,#0x0
   \   00002F   90....       MOV     DPTR,#(osal_nv_write & 0xffff)
   \   000032   74..         MOV     A,#((osal_nv_write >> 16) & 0xff)
   \   000034   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000037   7404         MOV     A,#0x4
   \   000039   02....       LJMP    ??Subroutine26_0 & 0xFFFF
   1593          }
   1594          
   1595          /*********************************************************************
   1596           * @fn      ZDApp_LeaveCtrlBypass
   1597           *
   1598           * @brief   Check if NV restore should be skipped during a leave reset.
   1599           *
   1600           * @param   none
   1601           *
   1602           * @return  uint8 - (TRUE bypass:FALSE do not bypass)
   1603           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1604          uint8 ZDApp_LeaveCtrlBypass( void )
   \                     ZDApp_LeaveCtrlBypass:
   1605          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1606            uint8 bypass;
   1607          
   1608            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   1609            {
   1610              bypass = TRUE;
   1611            }
   1612            else
   1613            {
   1614              bypass = FALSE;
   1615            }
   1616          
   1617            return bypass;
   \   000004   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   000007   E0           MOVX    A,@DPTR
   \   000008   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000A   E4           CLR     A
   \   00000B   92E0         MOV     0xE0 /* A   */.0,C
   \   00000D   F9           MOV     R1,A
   \   00000E   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   1618          }
   1619          
   1620          /*********************************************************************
   1621           * @fn      ZDApp_LeaveCtrlStartup
   1622           *
   1623           * @brief   Check for startup conditions during a leave reset.
   1624           *
   1625           * @param   state      - devState_t determined by leave control logic
   1626           * @param   startDelay - startup delay
   1627           *
   1628           * @return  none
   1629           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1630          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay )
   \                     ZDApp_LeaveCtrlStartup:
   1631          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1632            *startDelay = 0;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   1633          
   1634            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   \   00000D   90....       MOV     DPTR,#ZDApp_LeaveCtrl
   \   000010   E0           MOVX    A,@DPTR
   \   000011   A2E0         MOV     C,0xE0 /* A   */.0
   \   000013   503C         JNC     ??ZDApp_LeaveCtrlStartup_0
   1635            {
   1636              if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_RA )
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   500C         JNC     ??ZDApp_LeaveCtrlStartup_1
   1637              {
   1638                *startDelay = 5000;
   \   000019   8C82         MOV     DPL,R4
   \   00001B   8D83         MOV     DPH,R5
   \   00001D   7488         MOV     A,#-0x78
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   7413         MOV     A,#0x13
   \   000023   8005         SJMP    ??ZDApp_LeaveCtrlStartup_2
   1639              }
   1640              else
   1641              {
   1642                *state = DEV_HOLD;
   \                     ??ZDApp_LeaveCtrlStartup_1:
   \   000025   E4           CLR     A
   \   000026   8A82         MOV     DPL,R2
   \   000028   8B83         MOV     DPH,R3
   \                     ??ZDApp_LeaveCtrlStartup_2:
   \   00002A   F0           MOVX    @DPTR,A
   1643              }
   1644          
   1645              // Set leave control to initialized state
   1646              ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   \   00002B   12....       LCALL   ?Subroutine3 & 0xFFFF
   1647          
   1648              // Write initialized control
   1649              osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1650                            0,
   1651                            sizeof( uint8 ),
   1652                            &ZDApp_LeaveCtrl);
   \                     ??CrossCallReturnLabel_5:
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   75..01       MOV     ?V0 + 0,#0x1
   \   000034   75..00       MOV     ?V0 + 1,#0x0
   \   000037   78..         MOV     R0,#?V0 + 0
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003C   7C00         MOV     R4,#0x0
   \   00003E   7D00         MOV     R5,#0x0
   \   000040   7A85         MOV     R2,#-0x7b
   \   000042   7B00         MOV     R3,#0x0
   \   000044   90....       MOV     DPTR,#(osal_nv_write & 0xffff)
   \   000047   74..         MOV     A,#((osal_nv_write >> 16) & 0xff)
   \   000049   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00004C   7404         MOV     A,#0x4
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   1653            }
   1654          }
   \                     ??ZDApp_LeaveCtrlStartup_0:
   \   000051   02....       LJMP    ??Subroutine26_1 & 0xFFFF
   1655          
   1656          /*********************************************************************
   1657           * @fn      ZDApp_LeaveReset
   1658           *
   1659           * @brief   Setup a device reset due to a leave indication/confirm.
   1660           *
   1661           * @param   ra - reassociate flag
   1662           *
   1663           * @return  none
   1664           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1665          void ZDApp_LeaveReset( uint8 ra )
   \                     ZDApp_LeaveReset:
   1666          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1667            ZDApp_LeaveCtrlSet( ra );
   \   000004                ; Setup parameters for call to function ZDApp_LeaveCtrlSet
   \   000004   90....       MOV     DPTR,#(ZDApp_LeaveCtrlSet & 0xffff)
   \   000007   74..         MOV     A,#((ZDApp_LeaveCtrlSet >> 16) & 0xff)
   \   000009   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1668          
   1669            ZDApp_ResetTimerStart( 5000 );
   \   00000C                ; Setup parameters for call to function ZDApp_ResetTimerStart
   \   00000C   7A88         MOV     R2,#-0x78
   \   00000E   7B13         MOV     R3,#0x13
   \   000010   90....       MOV     DPTR,#(ZDApp_ResetTimerStart & 0xffff)
   \   000013   74..         MOV     A,#((ZDApp_ResetTimerStart >> 16) & 0xff)
   \   000015   80..         SJMP    ??Subroutine31_0
   1670          }
   1671          
   1672          /*********************************************************************
   1673           * @fn      ZDApp_LeaveUpdate
   1674           *
   1675           * @brief   Update local device data related to leaving device.
   1676           *
   1677           * @param   nwkAddr        - NWK address of leaving device
   1678           * @param   extAddr        - EXT address of leaving device
   1679           * @param   removeChildren - remove children of leaving device
   1680           *
   1681           * @return  none
   1682           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1683          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
   \                     ZDApp_LeaveUpdate:
   1684                                  uint8 removeChildren )
   1685          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EC           MOV     A,R4
   \   000005   FA           MOV     R2,A
   \   000006   ED           MOV     A,R5
   \   000007   FB           MOV     R3,A
   1686            /*
   1687            AddrMgrEntry_t entry;
   1688            */
   1689          
   1690          
   1691            // Remove if child
   1692            NLME_RemoveChild( extAddr, removeChildren );
   \   000008                ; Setup parameters for call to function NLME_RemoveChild
   \   000008   90....       MOV     DPTR,#(NLME_RemoveChild & 0xffff)
   \   00000B   74..         MOV     A,#((NLME_RemoveChild >> 16) & 0xff)
   \   00000D   80..         SJMP    ??Subroutine31_0
   1693          
   1694            /*
   1695            // Set NWK address to invalid
   1696            entry.user    = ADDRMGR_USER_DEFAULT;
   1697            entry.nwkAddr = INVALID_NODE_ADDR;
   1698            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   1699            AddrMgrEntryUpdate( &entry );
   1700          
   1701            // Check
   1702            if ( removeChildren == TRUE )
   1703            {
   1704              // Set index to INVALID_NODE_ADDR to start search
   1705              entry.index = INVALID_NODE_ADDR;
   1706          
   1707              // Get first entry
   1708              AddrMgrEntryGetNext( &entry );
   1709          
   1710              // Remove all descendents
   1711              while ( entry.index != INVALID_NODE_ADDR )
   1712              {
   1713                // Check NWK address allocation algorithm
   1714                if ( RTG_ANCESTOR( entry.nwkAddr, thisAddr ) != 0 )
   1715                {
   1716                  // Set NWK address to invalid
   1717                  entry.nwkAddr = INVALID_NODE_ADDR;
   1718                  AddrMgrEntryUpdate( &entry );
   1719                }
   1720          
   1721                // Get next entry
   1722                AddrMgrEntryGetNext( &entry );
   1723              }
   1724            }
   1725            */
   1726          }
   1727          
   1728          /*********************************************************************
   1729           * CALLBACK FUNCTIONS
   1730           */
   1731          
   1732          #if defined ( ZDO_COORDINATOR )
   1733          /*********************************************************************
   1734           * @fn      ZDApp_EndDeviceBindReqCB()
   1735           *
   1736           * @brief
   1737           *
   1738           *   Called by ZDO when an End Device Bind Request message is received.
   1739           *
   1740           * @param  bindReq  - binding request information
   1741           * @param  SecurityUse - Security enable/disable
   1742           *
   1743           * @return  none
   1744           */
   1745          void ZDApp_EndDeviceBindReqCB( ZDEndDeviceBind_t *bindReq )
   1746          {
   1747          #if defined ( COORDINATOR_BINDING )
   1748            if ( bindReq->localCoordinator == 0x0000 )
   1749            {
   1750              ZDO_DoEndDeviceBind( bindReq );
   1751            }
   1752            else
   1753          #endif // COORDINATOR_BINDING
   1754            {
   1755              ZDO_MatchEndDeviceBind( bindReq );
   1756            }
   1757          }
   1758          #endif // ZDO_COORDINATOR
   1759          
   1760          #if !defined ( REFLECTOR ) && defined ( ZDO_BIND_UNBIND_RESPONSE )
   1761          /*********************************************************************
   1762           * @fn      ZDApp_AppBindReq()
   1763           *
   1764           * @brief
   1765           *
   1766           *   Called to send an App Bind Request message.
   1767           *
   1768           * @param  SrcAddr     - Source address ( who sent the message )
   1769           * @param  SrcAddress  - Source Address (64 bit)
   1770           * @param  SrcEndPoint - Source endpoint
   1771           * @param  ClusterID   - Cluster ID
   1772           * @param  DstAddress  - Destination Address (64 bit)
   1773           * @param  DstEndPoint - Destination endpoint
   1774           * @param  SecurityUse - Security enable/disable
   1775           *
   1776           * @return  none
   1777           */
   1778          void ZDApp_AppBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
   1779                                byte SrcEndPoint, cId_t ClusterID, byte *DstAddress,
   1780                                byte DstEndPoint, byte SecurityUse, uint8 Type )
   1781          {
   1782            ZDO_BindReq_t *pBindReq;
   1783          
   1784            if ( ZDApp_BindReq_TaskID )
   1785            {
   1786              // Send the IEEE Address response structure to the registered task
   1787              pBindReq = (ZDO_BindReq_t *)osal_msg_allocate( sizeof( ZDO_BindReq_t ) );
   1788              if ( pBindReq )
   1789              {
   1790                pBindReq->event_hdr.event = Type;
   1791          
   1792                // Build the structure
   1793                pBindReq->hdr.srcAddr = SrcAddr->addr.shortAddr;
   1794                pBindReq->hdr.transSeq = TransSeq;
   1795                pBindReq->hdr.SecurityUse = SecurityUse;
   1796          
   1797                osal_cpyExtAddr( pBindReq->srcAddr, SrcAddress );
   1798                pBindReq->srcEP = SrcEndPoint;
   1799                pBindReq->clusterID = ClusterID;
   1800                osal_cpyExtAddr( pBindReq->dstAddr, DstAddress );
   1801                pBindReq->dstEP = DstEndPoint;
   1802          
   1803                osal_msg_send( ZDApp_BindReq_TaskID, (uint8 *)pBindReq );
   1804              }
   1805            }
   1806          }
   1807          #endif // !REFLECTOR && ZDO_BIND_UNBIND_RESPONSE
   1808          
   1809          #if defined ( REFLECTOR ) || defined ( ZDO_BIND_UNBIND_RESPONSE )
   1810          /*********************************************************************
   1811           * @fn      ZDApp_BindReqCB()
   1812           *
   1813           * @brief
   1814           *
   1815           *   Called by ZDO when a Bind Request message is received.
   1816           *
   1817           * @param  SrcAddr     - Source address ( who sent the message )
   1818           * @param  SrcAddress  - Source Address (64 bit)
   1819           * @param  SrcEndPoint - Source endpoint
   1820           * @param  ClusterID   - Cluster ID
   1821           * @param  DstAddress  - Destination Address (64 bit)
   1822           * @param  DstEndPoint - Destination endpoint
   1823           * @param  SecurityUse - Security enable/disable
   1824           *
   1825           * @return  none
   1826           */
   1827          void ZDApp_BindReqCB( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
   1828                                byte SrcEndPoint, cId_t ClusterID, zAddrType_t *DstAddress,
   1829                                byte DstEndPoint, byte SecurityUse )
   1830          {
   1831          #if defined ( REFLECTOR )
   1832            zAddrType_t SourceAddr;       // Binding Source addres
   1833            byte bindStat;
   1834          
   1835            SourceAddr.addrMode = Addr64Bit;
   1836            osal_cpyExtAddr( SourceAddr.addr.extAddr, SrcAddress );
   1837          
   1838            if ( DstAddress->addrMode != Addr64Bit &&
   1839                   DstAddress->addrMode != AddrGroup )
   1840            {
   1841              bindStat = ZDP_NOT_SUPPORTED;
   1842            }
   1843          
   1844            else
   1845            { // Check source endpoints
   1846              if ( SrcEndPoint == 0 || SrcEndPoint > MAX_ENDPOINTS )
   1847              {
   1848                bindStat = ZDP_INVALID_EP;
   1849              }
   1850              // Check the destination endpoints for ext address mode
   1851              else if ( ( DstAddress->addrMode == Addr64Bit ) &&
   1852                      ( DstEndPoint == 0 || DstEndPoint > MAX_ENDPOINTS ) )
   1853              {
   1854                bindStat = ZDP_INVALID_EP;
   1855              }
   1856          
   1857              else
   1858              {
   1859          #if defined ( ZDO_NWKADDR_REQUEST )
   1860                {
   1861                  uint16 nwkAddr;
   1862          
   1863                  // Check for the source address
   1864                  if ( APSME_LookupNwkAddr( SrcAddress, &nwkAddr ) == FALSE )
   1865                  {
   1866                    ZDP_NwkAddrReq( SrcAddress, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   1867                  }
   1868          
   1869                  // Check for the destination address
   1870                  if ( DstAddress->addrMode == Addr64Bit )
   1871                  {
   1872                    if ( APSME_LookupNwkAddr( DstAddress->addr.extAddr, &nwkAddr ) == FALSE )
   1873                    {
   1874                      ZDP_NwkAddrReq( DstAddress->addr.extAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   1875                    }
   1876                  }
   1877                }
   1878          #endif
   1879          
   1880                if ( APSME_BindRequest( &SourceAddr, SrcEndPoint, ClusterID,
   1881                               DstAddress, DstEndPoint ) == ZSuccess )
   1882                {
   1883                  bindStat = ZDP_SUCCESS;
   1884                  // Notify to save info into NV
   1885                  osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
   1886                }
   1887                else
   1888                  bindStat = ZDP_TABLE_FULL;
   1889              }
   1890            }
   1891            // Send back a response message
   1892            ZDP_BindRsp( TransSeq, SrcAddr, bindStat, SecurityUse );
   1893          
   1894          #else  // must be ZDO_BIND_UNBIND_RESPONSE
   1895          
   1896            ZDApp_AppBindReq( TransSeq, SrcAddr, SrcAddress, SrcEndPoint, ClusterID,
   1897                              DstAddress->addr.extAddr, DstEndPoint, SecurityUse, ZDO_BIND_REQUEST );
   1898          
   1899          #endif // REFLECTOR
   1900          }
   1901          #endif // REFLECTOR OR ZDO_BIND_UNBIND_RESPONSE
   1902          
   1903          #if defined ( REFLECTOR ) || defined ( ZDO_BIND_UNBIND_RESPONSE )
   1904          /*********************************************************************
   1905           * @fn      ZDApp_UnbindReqCB()
   1906           *
   1907           * @brief
   1908           *
   1909           *   Called by ZDO when an Unbind Request message is received.
   1910           *
   1911           * @param  SrcAddr  - Source address
   1912           * @param  SrcAddress - Source Address (64 bit)
   1913           * @param  SrcEndPoint - Source endpoint
   1914           * @param  ClusterID - Cluster ID
   1915           * @param  DstAddress - Destination Address (64 bit)
   1916           * @param  DstEndPoint - Destination endpoint
   1917           * @param  SecurityUse - Security enable/disable
   1918           *
   1919           * @return  none
   1920           */
   1921          void ZDApp_UnbindReqCB( byte TransSeq, zAddrType_t *SrcAddr, byte *SrcAddress,
   1922                                  byte SrcEndPoint, cId_t ClusterID, zAddrType_t *DstAddress,
   1923                                  byte DstEndPoint, byte SecurityUse )
   1924          {
   1925          #if defined ( REFLECTOR )
   1926            zAddrType_t SourceAddr;       // Binding Source addres
   1927            byte bindStat;
   1928          
   1929            SourceAddr.addrMode = Addr64Bit;
   1930            osal_cpyExtAddr( SourceAddr.addr.extAddr, SrcAddress );
   1931          
   1932            // Check endpoints
   1933            if ( SrcEndPoint == 0 || SrcEndPoint > MAX_ENDPOINTS ||
   1934                 DstEndPoint == 0 || DstEndPoint > MAX_ENDPOINTS )
   1935            {
   1936              bindStat = ZDP_INVALID_EP;
   1937            }
   1938          
   1939            else
   1940            {
   1941              if ( APSME_UnBindRequest( &SourceAddr, SrcEndPoint, ClusterID,
   1942                                       DstAddress, DstEndPoint ) == ZSuccess )
   1943              {
   1944                bindStat = ZDP_SUCCESS;
   1945          
   1946                // Notify to save info into NV
   1947                osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
   1948              }
   1949              else
   1950                bindStat = ZDP_NO_ENTRY;
   1951            }
   1952          
   1953            // Send back a response message
   1954            ZDP_UnbindRsp( TransSeq, SrcAddr, bindStat, SecurityUse );
   1955          
   1956          #else // Must be ZDO_BIND_UNBIND_RESPONSE
   1957          
   1958            ZDApp_AppBindReq( TransSeq, SrcAddr, SrcAddress, SrcEndPoint, ClusterID,
   1959                              DstAddress->addr.extAddr, DstEndPoint, SecurityUse, ZDO_UNBIND_REQUEST );
   1960          
   1961          #endif // ZDO_BIND_UNBIND_RESPONSE
   1962          }
   1963          #endif // REFLECTOR OR ZDO_BIND_UNBIND_RESPONSE
   1964          
   1965          /*********************************************************************
   1966           * @fn      ZDApp_SendNewDstAddr()
   1967           *
   1968           * @brief
   1969           *
   1970           *   Used to send an OSAL message to an application that contains a
   1971           *   new destination address
   1972           *
   1973           * @param  dstEP  - Destination endpoint
   1974           * @param  dstAddr - response status
   1975           * @param  clusterID - relavent cluster for this dst address
   1976           * @param  removeFlag - false if add, true to remove
   1977           * @param  task_id - What task to send it to
   1978           * @param  endpoint - who the new address is for
   1979           *
   1980           * @return  none
   1981           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1982          void ZDApp_SendNewDstAddr( byte dstEP, zAddrType_t *dstAddr,
   \                     ZDApp_SendNewDstAddr:
   1983                             cId_t clusterID, byte removeFlag, byte task_id, byte endpoint )
   1984          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 2,R1
   \   000017   EC           MOV     A,R4
   \   000018   FE           MOV     R6,A
   \   000019   ED           MOV     A,R5
   \   00001A   FF           MOV     R7,A
   \   00001B   7412         MOV     A,#0x12
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 7,A
   \   000023   7413         MOV     A,#0x13
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 3,A
   \   00002B   7414         MOV     A,#0x14
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F5..         MOV     ?V0 + 6,A
   1985            byte bufLen;
   1986            ZDO_NewDstAddr_t *msgPtr;
   1987          
   1988            // Send the address to the task
   1989            bufLen = sizeof(ZDO_NewDstAddr_t);
   1990          
   1991            msgPtr = (ZDO_NewDstAddr_t *)osal_msg_allocate( bufLen );
   \   000033                ; Setup parameters for call to function osal_msg_allocate
   \   000033   7A10         MOV     R2,#0x10
   \   000035   7B00         MOV     R3,#0x0
   \   000037   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   00003A   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   00003C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00003F   8A..         MOV     ?V0 + 4,R2
   \   000041   8B..         MOV     ?V0 + 5,R3
   1992            if ( msgPtr )
   \   000043   EA           MOV     A,R2
   \   000044   7001         JNZ     ??ZDApp_SendNewDstAddr_0
   \   000046   EB           MOV     A,R3
   \                     ??ZDApp_SendNewDstAddr_0:
   \   000047   6067         JZ      ??ZDApp_SendNewDstAddr_1
   1993            {
   1994              msgPtr->hdr.event = ZDO_NEW_DSTADDR;
   \   000049   74D0         MOV     A,#-0x30
   \   00004B   8A82         MOV     DPL,R2
   \   00004D   8B83         MOV     DPH,R3
   \   00004F   F0           MOVX    @DPTR,A
   1995              msgPtr->dstAddrDstEP = dstEP;
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   E5..         MOV     A,?V0 + 2
   \   000054   12....       LCALL   ?Subroutine1 & 0xFFFF
   1996              osal_memcpy(&msgPtr->dstAddr, dstAddr, sizeof( zAddrType_t ) );
   \                     ??CrossCallReturnLabel_2:
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F5..         MOV     ?V0 + 0,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F5..         MOV     ?V0 + 1,A
   \   00005E   75..00       MOV     ?V0 + 2,#0x0
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000066   7C09         MOV     R4,#0x9
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   EA           MOV     A,R2
   \   00006B   2403         ADD     A,#0x3
   \   00006D   0A           INC     R2
   \   00006E   0A           INC     R2
   \   00006F   0A           INC     R2
   \   000070   EB           MOV     A,R3
   \   000071   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000074   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   1997              msgPtr->dstAddrClusterIDLSB = LO_UINT16( clusterID );
   \   00007C   E5..         MOV     A,?V0 + 4
   \   00007E   240C         ADD     A,#0xc
   \   000080   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000083   EE           MOV     A,R6
   \   000084   F0           MOVX    @DPTR,A
   1998              msgPtr->dstAddrClusterIDMSB = HI_UINT16( clusterID );
   \   000085   E5..         MOV     A,?V0 + 4
   \   000087   240D         ADD     A,#0xd
   \   000089   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00008C   EF           MOV     A,R7
   \   00008D   F0           MOVX    @DPTR,A
   1999              msgPtr->dstAddrRemove = removeFlag;
   \   00008E   E5..         MOV     A,?V0 + 4
   \   000090   240E         ADD     A,#0xe
   \   000092   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000095   E5..         MOV     A,?V0 + 7
   \   000097   F0           MOVX    @DPTR,A
   2000              msgPtr->dstAddrEP = endpoint;
   \   000098   E5..         MOV     A,?V0 + 4
   \   00009A   240F         ADD     A,#0xf
   \   00009C   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00009F   E5..         MOV     A,?V0 + 6
   \   0000A1   F0           MOVX    @DPTR,A
   2001          
   2002              osal_msg_send( task_id, (uint8 *)msgPtr );
   \   0000A2                ; Setup parameters for call to function osal_msg_send
   \   0000A2   AA..         MOV     R2,?V0 + 4
   \   0000A4   AB..         MOV     R3,?V0 + 5
   \   0000A6   A9..         MOV     R1,?V0 + 3
   \   0000A8   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   0000AB   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   0000AD   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2003            }
   2004          }
   \                     ??ZDApp_SendNewDstAddr_1:
   \   0000B0   7402         MOV     A,#0x2
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5                REQUIRE ?Subroutine30
   \   0000B5                ; // Fall through to label ?Subroutine30

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FB           MOV     R3,A
   \   000003   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000006   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F582         MOV     DPL,A
   \   000002   E5..         MOV     A,?V0 + 5
   \                     ??Subroutine22_0:
   \   000004   3400         ADDC    A,#0x0
   \   000006   F583         MOV     DPH,A
   \   000008   22           RET
   2005          
   2006          /*********************************************************************
   2007           * @fn      ZDApp_SendEventMsg()
   2008           *
   2009           * @brief
   2010           *
   2011           *   Sends a Network Join message
   2012           *
   2013           * @param  cmd - command ID
   2014           * @param  len - length (in bytes) of the buf field
   2015           * @param  buf - buffer for the rest of the message.
   2016           *
   2017           * @return  none
   2018           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2019          void ZDApp_SendEventMsg( byte cmd, byte len, byte *buf )
   \                     ZDApp_SendEventMsg:
   2020          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2021            ZDApp_SendMsg( ZDAppTaskID, cmd, len, buf );
   \   000004                ; Setup parameters for call to function ZDApp_SendMsg
   \   000004   EA           MOV     A,R2
   \   000005   FB           MOV     R3,A
   \   000006   E9           MOV     A,R1
   \   000007   FA           MOV     R2,A
   \   000008                REQUIRE ?Subroutine32
   \   000008                ; // Fall through to label ?Subroutine32
   2022          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000003   02....       LJMP    ??Subroutine31_0 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   90....       MOV     DPTR,#ZDAppTaskID
   \                     ??Subroutine8_0:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   90....       MOV     DPTR,#(ZDApp_SendMsg & 0xffff)
   \   000008   74..         MOV     A,#((ZDApp_SendMsg >> 16) & 0xff)
   \   00000A   22           RET
   2023          
   2024          /*********************************************************************
   2025           * @fn      ZDApp_SendMsg()
   2026           *
   2027           * @brief   Sends a OSAL message
   2028           *
   2029           * @param  taskID - Where to send the message
   2030           * @param  cmd - command ID
   2031           * @param  len - length (in bytes) of the buf field
   2032           * @param  buf - buffer for the rest of the message.
   2033           *
   2034           * @return  none
   2035           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2036          void ZDApp_SendMsg( byte taskID, byte cmd, byte len, byte *buf )
   \                     ZDApp_SendMsg:
   2037          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8A..         MOV     ?V0 + 3,R2
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 6,R4
   \   00000D   8D..         MOV     ?V0 + 7,R5
   2038            osal_event_hdr_t *msgPtr;
   2039          
   2040            // Send the address to the task
   2041            msgPtr = (osal_event_hdr_t *)osal_msg_allocate( len );
   \   00000F                ; Setup parameters for call to function osal_msg_allocate
   \   00000F   FA           MOV     R2,A
   \   000010   7B00         MOV     R3,#0x0
   \   000012   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000015   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000017   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001A   8A..         MOV     ?V0 + 4,R2
   \   00001C   8B..         MOV     ?V0 + 5,R3
   2042            if ( msgPtr )
   \   00001E   EA           MOV     A,R2
   \   00001F   7001         JNZ     ??ZDApp_SendMsg_0
   \   000021   EB           MOV     A,R3
   \                     ??ZDApp_SendMsg_0:
   \   000022   6041         JZ      ??ZDApp_SendMsg_1
   2043            {
   2044              if ( (len > 0) && (buf != NULL) )
   \   000024   EF           MOV     A,R7
   \   000025   6027         JZ      ??ZDApp_SendMsg_2
   \   000027   E5..         MOV     A,?V0 + 6
   \   000029   7002         JNZ     ??ZDApp_SendMsg_3
   \   00002B   E5..         MOV     A,?V0 + 7
   \                     ??ZDApp_SendMsg_3:
   \   00002D   601F         JZ      ??ZDApp_SendMsg_2
   2045                osal_memcpy( msgPtr, buf, len );
   \   00002F                ; Setup parameters for call to function osal_memcpy
   \   00002F   85....       MOV     ?V0 + 0,?V0 + 6
   \   000032   85....       MOV     ?V0 + 1,?V0 + 7
   \   000035   75..00       MOV     ?V0 + 2,#0x0
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00003D   EF           MOV     A,R7
   \   00003E   FC           MOV     R4,A
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000044   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   000046   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000049   7403         MOV     A,#0x3
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   2046          
   2047              msgPtr->event = cmd;
   \                     ??ZDApp_SendMsg_2:
   \   00004E   85..82       MOV     DPL,?V0 + 4
   \   000051   85..83       MOV     DPH,?V0 + 5
   \   000054   E5..         MOV     A,?V0 + 3
   \   000056   F0           MOVX    @DPTR,A
   2048              osal_msg_send( taskID, (byte *)msgPtr );
   \   000057                ; Setup parameters for call to function osal_msg_send
   \   000057   AA..         MOV     R2,?V0 + 4
   \   000059   AB..         MOV     R3,?V0 + 5
   \   00005B   EE           MOV     A,R6
   \   00005C   F9           MOV     R1,A
   \   00005D   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   000060   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   000062   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2049            }
   2050          }
   \                     ??ZDApp_SendMsg_1:
   \   000065   02....       LJMP    ?Subroutine30 & 0xFFFF
   2051          
   2052          #if defined ( ZDO_NWKADDR_REQUEST )
   2053          /*********************************************************************
   2054           * @fn      ZDApp_NwkAddrRspCB()
   2055           *
   2056           * @brief
   2057           *
   2058           *   Called by ZDO when a NWK_addr_rsp message is received.
   2059           *
   2060           * @param  SrcAddr  - Source address
   2061           * @param  Status - response status
   2062           * @param  IEEEAddr - 64 bit IEEE address of device
   2063           * @param  aoi - 16 bit network address of interest.
   2064           * @param  NumAssocDev - number of associated devices to reporting device
   2065           * @param  AssocDevList - array short addresses of associated devices
   2066           *
   2067           * @return  none
   2068           */
   2069          void ZDApp_NwkAddrRspCB( zAddrType_t *SrcAddr, byte Status, byte *IEEEAddr,
   2070                                   uint16 nwkAddr, byte NumAssocDev,
   2071                                   byte StartIndex, uint16 *AssocDevList )
   2072          {
   2073            uint8 bufLen;
   2074            ZDO_NwkAddrResp_t *pNwkAddrRsp;
   2075          
   2076          #if defined ( MT_ZDO_FUNC )
   2077            /* First check if MT has subscribed for this callback. If so , pass it as
   2078            a event to MonitorTest and return control to calling function after that */
   2079            if ( _zdoCallbackSub & CB_ID_ZDO_NWK_ADDR_RSP )
   2080            {
   2081              zdo_MTCB_NwkIEEEAddrRspCB( SPI_CB_ZDO_NWK_ADDR_RSP, SrcAddr, Status,
   2082                            IEEEAddr, nwkAddr, NumAssocDev, StartIndex, AssocDevList );
   2083              return;
   2084            }
   2085          #endif  //MT_ZDO_FUNC
   2086          
   2087            if ( ZDApp_NwkAddrRsp_TaskID )
   2088            {
   2089              // Send the NWK Address response structure to the registered task
   2090              bufLen = sizeof( ZDO_NwkAddrResp_t ) + sizeof( uint16 ) * NumAssocDev;
   2091          
   2092              pNwkAddrRsp = (ZDO_NwkAddrResp_t *)osal_msg_allocate( bufLen );
   2093          
   2094              if ( pNwkAddrRsp )
   2095              {
   2096                pNwkAddrRsp->hdr.event = ZDO_NWK_ADDR_RESP;
   2097          
   2098                // Build the structure
   2099                pNwkAddrRsp->nwkAddr = nwkAddr;
   2100                osal_cpyExtAddr( pNwkAddrRsp->extAddr, IEEEAddr );
   2101                pNwkAddrRsp->numAssocDevs = NumAssocDev;
   2102                pNwkAddrRsp->startIndex = StartIndex;
   2103                osal_memcpy( pNwkAddrRsp->devList, AssocDevList, (sizeof( uint16 ) * NumAssocDev) );
   2104          
   2105                osal_msg_send( ZDApp_NwkAddrRsp_TaskID, (uint8 *)pNwkAddrRsp );
   2106              }
   2107            }
   2108          }
   2109          #endif // ZDO_NWKADDR_REQUEST
   2110          
   2111          #if defined ( ZDO_IEEEADDR_REQUEST )
   2112          /*********************************************************************
   2113           * @fn      ZDApp_IEEEAddrRspCB()
   2114           *
   2115           * @brief
   2116           *
   2117           *   Called by ZDO when a NWK_addr_rsp message is received.
   2118           *
   2119           * @param  SrcAddr  - Source address
   2120           * @param  Status - response status
   2121           * @param  IEEEAddr - 64 bit IEEE address of device
   2122           * @param  aoi - 16 bit network address of interest.
   2123           * @param  NumAssocDev - number of associated devices to reporting device
   2124           * @param  AssocDevList - array short addresses of associated devices
   2125           *
   2126           * @return  none
   2127           */
   2128          void ZDApp_IEEEAddrRspCB( zAddrType_t *SrcAddr, byte Status, byte *IEEEAddr,
   2129                                    uint16 aoi, byte NumAssocDev,
   2130                                    byte StartIndex, uint16 *AssocDevList )
   2131          {
   2132            uint8 bufLen;
   2133            ZDO_IEEEAddrResp_t *pIEEEAddrRsp;
   2134          
   2135          #if defined ( MT_ZDO_FUNC )
   2136            /* First check if MT has subscribed for this callback. If so , pass it as
   2137            a event to MonitorTest and return control to calling function after that */
   2138            if ( _zdoCallbackSub & CB_ID_ZDO_IEEE_ADDR_RSP )
   2139            {
   2140              zdo_MTCB_NwkIEEEAddrRspCB( SPI_CB_ZDO_IEEE_ADDR_RSP, SrcAddr, Status,
   2141                            IEEEAddr, 0, NumAssocDev, StartIndex, AssocDevList );
   2142              return;
   2143            }
   2144          #endif  //MT_ZDO_FUNC
   2145          
   2146            if ( ZDApp_IEEEAddrRsp_TaskID )
   2147            {
   2148              // Send the IEEE Address response structure to the registered task
   2149              bufLen = sizeof( ZDO_IEEEAddrResp_t ) + sizeof( uint16 ) * NumAssocDev;
   2150          
   2151              pIEEEAddrRsp = (ZDO_IEEEAddrResp_t *)osal_msg_allocate( bufLen );
   2152              if ( pIEEEAddrRsp )
   2153              {
   2154                pIEEEAddrRsp->hdr.event = ZDO_IEEE_ADDR_RESP;
   2155          
   2156                // Build the structure
   2157                pIEEEAddrRsp->nwkAddr = aoi;
   2158                osal_cpyExtAddr( pIEEEAddrRsp->extAddr, IEEEAddr );
   2159                pIEEEAddrRsp->numAssocDevs = NumAssocDev;
   2160                pIEEEAddrRsp->startIndex = StartIndex;
   2161                osal_memcpy( pIEEEAddrRsp->devList, AssocDevList, (sizeof( uint16 ) * NumAssocDev) );
   2162          
   2163                osal_msg_send( ZDApp_IEEEAddrRsp_TaskID, (uint8 *)pIEEEAddrRsp );
   2164              }
   2165            }
   2166          }
   2167          #endif // ZDO_IEEEADDR_REQUEST
   2168          
   2169          #if defined ( ZDO_NODEDESC_REQUEST )
   2170          /*********************************************************************
   2171           * @fn      ZDApp_NodeDescRspCB()
   2172           *
   2173           * @brief
   2174           *
   2175           *   Called by ZDO when a Node_Desc_rsp message is received.
   2176           *
   2177           * @param  SrcAddr  - Source address
   2178           * @param  Status - response status
   2179           * @param  aoi - 16 bit network address of interest.
   2180           * @param  pNodeDesc - pointer to the devices Node Descriptor
   2181           *                     NULL if Status != ZDP_SUCCESS
   2182           *
   2183           * @return  none
   2184           */
   2185          void ZDApp_NodeDescRspCB( zAddrType_t *SrcAddr, byte Status, uint16 aoi,
   2186                                    NodeDescriptorFormat_t *pNodeDesc )
   2187          {
   2188          #if defined ( MT_ZDO_FUNC )
   2189            /* First check if MT has subscribed for this callback. If so , pass it as
   2190            a event to MonitorTest and return control to calling function after that */
   2191            if ( _zdoCallbackSub & CB_ID_ZDO_NODE_DESC_RSP )
   2192            {
   2193              zdo_MTCB_NodeDescRspCB( SrcAddr, Status, aoi, pNodeDesc );
   2194              return;
   2195            }
   2196          #endif  //MT_ZDO_FUNC
   2197          }
   2198          #endif
   2199          
   2200          #if defined ( ZDO_POWERDESC_REQUEST )
   2201          /*********************************************************************
   2202           * @fn      ZDApp_PowerDescRspCB()
   2203           *
   2204           * @brief
   2205           *
   2206           *   Called by ZDO when a Power_Desc_rsp message is received.
   2207           *
   2208           * @param  SrcAddr  - Source address
   2209           * @param  Status - response status
   2210           * @param  aoi - 16 bit network address of interest.
   2211           * @param  pPwrDesc - pointer to the devices Power Descriptor
   2212           *                     NULL if Status != ZDP_SUCCESS
   2213           *
   2214           * @return  none
   2215           */
   2216          void ZDApp_PowerDescRspCB( zAddrType_t *SrcAddr, byte Status,
   2217                                      uint16 aoi, NodePowerDescriptorFormat_t *pPwrDesc )
   2218          {
   2219          #if defined ( MT_ZDO_FUNC )
   2220            /* First check if MT has subscribed for this callback. If so , pass it as
   2221            a event to MonitorTest and return control to calling function after that */
   2222            if ( _zdoCallbackSub & CB_ID_ZDO_POWER_DESC_RSP )
   2223            {
   2224              zdo_MTCB_PowerDescRspCB( SrcAddr, Status, aoi, pPwrDesc );
   2225              return;
   2226            }
   2227          #endif  //MT_ZDO_FUNC
   2228          }
   2229          #endif // ZDO_POWERDESC_REQUEST
   2230          
   2231          #if defined ( ZDO_SIMPLEDESC_REQUEST )
   2232          /*********************************************************************
   2233           * @fn      ZDApp_SimpleDescRspCB()
   2234           *
   2235           * @brief
   2236           *
   2237           *   Called by ZDO when a Simple_Desc_rsp message is received.
   2238           *
   2239           * @param  SrcAddr  - Source address
   2240           * @param  Status - response status
   2241           * @param  aoi - 16 bit network address of interest.
   2242           * @param  endPoint - Endpoint for description
   2243           * @param  pSimpleDesc - pointer to the devices Simple Descriptor
   2244           *                     NULL if Status != ZDP_SUCCESS
   2245           *
   2246           * @return  none
   2247           */
   2248          void ZDApp_SimpleDescRspCB( zAddrType_t *SrcAddr, byte Status,
   2249                                      uint16 aoi, byte endPoint,
   2250                                      SimpleDescriptionFormat_t *pSimpleDesc )
   2251          {
   2252          #if defined ( MT_ZDO_FUNC )
   2253            /* First check if MT has subscribed for this callback. If so , pass it as
   2254            a event to MonitorTest and return control to calling function after that */
   2255            if ( _zdoCallbackSub & CB_ID_ZDO_SIMPLE_DESC_RSP )
   2256            {
   2257              zdo_MTCB_SimpleDescRspCB( SrcAddr, Status, aoi, endPoint, pSimpleDesc );
   2258              return;
   2259            }
   2260          #endif  //MT_ZDO_FUNC
   2261          }
   2262          #endif // ZDO_SIMPLEDESC_REQUEST
   2263          
   2264          #if defined ( ZDO_ACTIVEEP_REQUEST )
   2265          /*********************************************************************
   2266           * @fn      ZDApp_ActiveEPRspCB()
   2267           *
   2268           * @brief
   2269           *
   2270           *   Called by ZDO when a Active_EP_rsp message is received.
   2271           *
   2272           * @param  src    - Device's short address that this response describes
   2273           * @param  Status - response status
   2274           * @param  epCnt  - number of epList items
   2275           * @param  epList - array of active endpoint.
   2276           *
   2277           * @return  none
   2278           */
   2279          void ZDApp_ActiveEPRspCB( zAddrType_t *src, byte Status,
   2280                                                               byte epCnt, byte *epList )
   2281          {
   2282          #if defined ( MT_ZDO_FUNC )
   2283            /* First check if MT has subscribed for this callback. If so , pass it as
   2284            a event to MonitorTest and return control to calling function after that */
   2285            if ( _zdoCallbackSub & CB_ID_ZDO_ACTIVE_EPINT_RSP )
   2286            {
   2287              zdo_MTCB_MatchActiveEPRspCB( SPI_CB_ZDO_ACTIVE_EPINT_RSP, src,
   2288                                            src->addr.shortAddr, Status, epCnt, epList );
   2289              return;
   2290            }
   2291          #endif  //MT_ZDO_FUNC
   2292          }
   2293          #endif // ZDO_ACTIVEEP_REQUEST
   2294          
   2295          #if defined ( ZDO_MATCH_REQUEST )
   2296          /*********************************************************************
   2297           * @fn      ZDApp_MatchDescRspCB()
   2298           *
   2299           * @brief
   2300           *
   2301           *   Called by ZDO when a Match_Desc_rsp message is received.
   2302           *
   2303           * NOTE:  Currently, this function accepts any responding device as THE
   2304           *        match and updates the endpoint (requested) destination's
   2305           *        address.  So, the last response received is the application's
   2306           *        match.
   2307           *
   2308           *        This function could be changed to do further device discovery
   2309           *        and/or accept multiple responses.
   2310           *
   2311           * @param  src     - Device's short address that this response describes
   2312           * @param  Status  - response status
   2313           * @param  epCnt   - number of epList items
   2314           * @param  epList  - array of active endpoint
   2315           *
   2316           * @return  none
   2317           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2318          void ZDApp_MatchDescRspCB( zAddrType_t *src, byte Status,
   \                     ZDApp_MatchDescRspCB:
   2319                                                               byte epCnt, byte *epList )
   2320          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 6,R2
   \   000007   8B..         MOV     ?V0 + 7,R3
   \   000009   8C..         MOV     ?V0 + 3,R4
   \   00000B   7410         MOV     A,#0x10
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 4,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 5,A
   2321          #if defined ( MT_ZDO_FUNC )
   2322            /* First check if MT has subscribed for this callback. If so , pass it as
   2323            a event to MonitorTest and return control to calling function after that */
   2324            if ( _zdoCallbackSub & CB_ID_ZDO_MATCH_DESC_RSP )
   2325            {
   2326              zdo_MTCB_MatchActiveEPRspCB( SPI_CB_ZDO_MATCH_DESC_RSP, src,
   2327                                            src->addr.shortAddr, Status, epCnt, epList );
   2328              return;
   2329            }
   2330          #endif  //MT_ZDO_FUNC
   2331          
   2332            if ( (Status != ZDP_SUCCESS) || (epCnt == 0) )
   \   000017   E9           MOV     A,R1
   \   000018   6003         JZ      $+5
   \   00001A   02....       LJMP    ??ZDApp_MatchDescRspCB_0 & 0xFFFF
   \   00001D   EC           MOV     A,R4
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDApp_MatchDescRspCB_0 & 0xFFFF
   2333            {
   2334              return;
   2335            }
   2336          
   2337            if ( ZDApp_MatchDescRsp_TaskID )
   \   000023   90....       MOV     DPTR,#??ZDApp_MatchDescRsp_TaskID
   \   000026   E0           MOVX    A,@DPTR
   \   000027   606C         JZ      ??ZDApp_MatchDescRspCB_1
   2338            {
   2339              // Send the IEEE Address response structure to the registered task.
   2340              uint8 bufLen = sizeof( ZDO_MatchDescResp_t ) + epCnt;
   2341              ZDO_MatchDescResp_t *pMatchDescRsp = (ZDO_MatchDescResp_t *)osal_msg_allocate( bufLen );
   \   000029                ; Setup parameters for call to function osal_msg_allocate
   \   000029   7405         MOV     A,#0x5
   \   00002B   25..         ADD     A,?V0 + 3
   \   00002D   FA           MOV     R2,A
   \   00002E   7B00         MOV     R3,#0x0
   \   000030   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000033   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000035   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000038   8A..         MOV     ?V0 + 0,R2
   \   00003A   8B..         MOV     ?V0 + 1,R3
   \   00003C   AE..         MOV     R6,?V0 + 0
   \   00003E   AF..         MOV     R7,?V0 + 1
   2342          
   2343              if ( pMatchDescRsp )
   \   000040   EE           MOV     A,R6
   \   000041   7001         JNZ     ??ZDApp_MatchDescRspCB_2
   \   000043   EF           MOV     A,R7
   \                     ??ZDApp_MatchDescRspCB_2:
   \   000044   604F         JZ      ??ZDApp_MatchDescRspCB_1
   2344              {
   2345                pMatchDescRsp->hdr.event = ZDO_MATCH_DESC_RESP;
   \   000046   74D4         MOV     A,#-0x2c
   \   000048   8E82         MOV     DPL,R6
   \   00004A   8F83         MOV     DPH,R7
   \   00004C   F0           MOVX    @DPTR,A
   2346          
   2347                // Build the structure.
   2348                pMatchDescRsp->nwkAddr = src->addr.shortAddr;
   \   00004D   85..82       MOV     DPL,?V0 + 6
   \   000050   85..83       MOV     DPH,?V0 + 7
   \   000053   E0           MOVX    A,@DPTR
   \   000054   F8           MOV     R0,A
   \   000055   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000058   E8           MOV     A,R0
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   E9           MOV     A,R1
   \   00005C   12....       LCALL   ?Subroutine4 & 0xFFFF
   2349                pMatchDescRsp->epCnt = epCnt;
   \                     ??CrossCallReturnLabel_6:
   \   00005F   E5..         MOV     A,?V0 + 3
   \   000061   F0           MOVX    @DPTR,A
   2350                osal_memcpy( pMatchDescRsp->epList, epList, epCnt );
   \   000062                ; Setup parameters for call to function osal_memcpy
   \   000062   85....       MOV     ?V0 + 0,?V0 + 4
   \   000065   85....       MOV     ?V0 + 1,?V0 + 5
   \   000068   75..00       MOV     ?V0 + 2,#0x0
   \   00006B   78..         MOV     R0,#?V0 + 0
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000070   AC..         MOV     R4,?V0 + 3
   \   000072   7D00         MOV     R5,#0x0
   \   000074   EE           MOV     A,R6
   \   000075   2405         ADD     A,#0x5
   \   000077   FA           MOV     R2,A
   \   000078   EF           MOV     A,R7
   \   000079   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   00007C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00007F   7403         MOV     A,#0x3
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   2351          
   2352                osal_msg_send( ZDApp_MatchDescRsp_TaskID, (uint8 *)pMatchDescRsp );
   \   000084                ; Setup parameters for call to function osal_msg_send
   \   000084   EE           MOV     A,R6
   \   000085   FA           MOV     R2,A
   \   000086   EF           MOV     A,R7
   \   000087   FB           MOV     R3,A
   \   000088   90....       MOV     DPTR,#??ZDApp_MatchDescRsp_TaskID
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F9           MOV     R1,A
   \   00008D   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   000090   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   000092   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2353              }
   2354            }
   2355          
   2356            if ( ZDApp_AutoFindMode_epDesc )
   \                     ??ZDApp_MatchDescRspCB_1:
   \   000095   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   000098   E0           MOVX    A,@DPTR
   \   000099   7002         JNZ     ??ZDApp_MatchDescRspCB_3
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \                     ??ZDApp_MatchDescRspCB_3:
   \   00009D   6043         JZ      ??ZDApp_MatchDescRspCB_0
   2357            {
   2358              ZDApp_SendNewDstAddr( *epList, src, 0, false,
   2359                                    *(ZDApp_AutoFindMode_epDesc->task_id),
   2360                                      ZDApp_AutoFindMode_epDesc->endPoint );
   \   00009F                ; Setup parameters for call to function ZDApp_SendNewDstAddr
   \   00009F   90....       MOV     DPTR,#ZDApp_AutoFindMode_epDesc
   \   0000A2   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   0000A5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A8   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0000AB   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B1   75..00       MOV     ?V0 + 0,#0x0
   \   0000B4   78..         MOV     R0,#?V0 + 0
   \   0000B6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B9   7C00         MOV     R4,#0x0
   \   0000BB   7D00         MOV     R5,#0x0
   \   0000BD   AA..         MOV     R2,?V0 + 6
   \   0000BF   AB..         MOV     R3,?V0 + 7
   \   0000C1   85..82       MOV     DPL,?V0 + 4
   \   0000C4   85..83       MOV     DPH,?V0 + 5
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F9           MOV     R1,A
   \   0000C9   90....       MOV     DPTR,#(ZDApp_SendNewDstAddr & 0xffff)
   \   0000CC   74..         MOV     A,#((ZDApp_SendNewDstAddr >> 16) & 0xff)
   \   0000CE   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000D1   7403         MOV     A,#0x3
   \   0000D3   12....       LCALL   ?DEALLOC_XSTACK8
   2361          
   2362              HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   0000D6                ; Setup parameters for call to function HalLedSet
   \   0000D6   7A01         MOV     R2,#0x1
   \   0000D8   7908         MOV     R1,#0x8
   \   0000DA   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   0000DD   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   0000DF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDApp_MatchDescRspCB_0:
   \   0000E2   02....       LJMP    ?Subroutine30 & 0xFFFF
   2363            }
   2364          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   22           RET
   2365          #endif // ZDO_MATCH_REQUEST
   2366          
   2367          #if defined ( ZDO_ENDDEVICEBIND_REQUEST )
   2368          /*********************************************************************
   2369           * @fn      ZDApp_EndDeviceBindRsp()
   2370           *
   2371           * @brief
   2372           *
   2373           *   Called by ZDO when a End_Device_Bind_rsp message is received.
   2374           *
   2375           * @param  SrcAddr  - Source address
   2376           * @param  Status - response status
   2377           *
   2378           * @return  none
   2379           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2380          void ZDApp_EndDeviceBindRsp( zAddrType_t *SrcAddr, byte Status )
   \                     ZDApp_EndDeviceBindRsp:
   2381          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2382          #if defined ( MT_ZDO_FUNC )
   2383            /* First check if MT has subscribed for this callback. If so , pass it as
   2384            a event to MonitorTest and return control to calling function after that */
   2385            if ( _zdoCallbackSub & CB_ID_ZDO_END_DEVICE_BIND_RSP )
   2386            {
   2387              zdo_MTCB_BindRspCB( SPI_CB_ZDO_END_DEVICE_BIND_RSP, SrcAddr, Status );
   2388              return;
   2389            }
   2390          #endif  //MT_ZDO_FUNC
   2391          
   2392            if ( Status == ZDP_SUCCESS )
   \   000004   E9           MOV     A,R1
   \   000005   7004         JNZ     ??ZDApp_EndDeviceBindRsp_0
   2393              HalLedSet ( HAL_LED_4, HAL_LED_MODE_ON );
   \   000007                ; Setup parameters for call to function HalLedSet
   \   000007   7A01         MOV     R2,#0x1
   \   000009   8002         SJMP    ??ZDApp_EndDeviceBindRsp_1
   2394          #if defined(BLINK_LEDS)
   2395            else
   2396              // Flash LED to show failure
   2397              HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
   \                     ??ZDApp_EndDeviceBindRsp_0:
   \   00000B                ; Setup parameters for call to function HalLedSet
   \   00000B   7A04         MOV     R2,#0x4
   \                     ??ZDApp_EndDeviceBindRsp_1:
   \   00000D   7908         MOV     R1,#0x8
   \   00000F   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000012   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000014   02....       LJMP    ??Subroutine31_0 & 0xFFFF
   2398          #endif
   2399          }
   2400          #endif // ZDO_ENDDEVICEBIND_REQUEST
   2401          
   2402          #if defined ( ZDO_BIND_UNBIND_REQUEST )
   2403          /*********************************************************************
   2404           * @fn      ZDApp_BindRsp()
   2405           *
   2406           * @brief
   2407           *
   2408           *   Called by ZDO when a Bind_rsp message is received.
   2409           *
   2410           * @param  SrcAddr  - Source address
   2411           * @param  Status - response status
   2412           *
   2413           * @return  none
   2414           */
   2415          void ZDApp_BindRsp( zAddrType_t *SrcAddr, byte Status )
   2416          {
   2417            ZDO_BindRsp_t bindRsp;
   2418          
   2419          #if defined ( MT_ZDO_FUNC )
   2420            /* First check if MT has subscribed for this callback. If so , pass it as
   2421            a event to MonitorTest and return control to calling function after that */
   2422            if ( _zdoCallbackSub & CB_ID_ZDO_BIND_RSP )
   2423            {
   2424              zdo_MTCB_BindRspCB( SPI_CB_ZDO_BIND_RSP, SrcAddr, Status );
   2425              return;
   2426            }
   2427          #endif  //MT_ZDO_FUNC
   2428          
   2429            if ( ZDApp_BindUnbindRsp_TaskID != TASK_NO_TASK )
   2430            {
   2431              // Send the response structure to the registered task
   2432              bindRsp.nwkAddr = SrcAddr->addr.shortAddr;
   2433              bindRsp.status  = Status;
   2434          
   2435              ZDApp_SendMsg( ZDApp_BindUnbindRsp_TaskID,
   2436                             ZDO_BIND_RESP,
   2437                             sizeof(ZDO_BindRsp_t),
   2438                             (byte*)(&bindRsp) );
   2439            }
   2440          }
   2441          #endif // ZDO_BIND_UNBIND_REQUEST
   2442          
   2443          #if defined ( ZDO_BIND_UNBIND_REQUEST )
   2444          /*********************************************************************
   2445           * @fn      ZDApp_UnbindRsp()
   2446           *
   2447           * @brief
   2448           *
   2449           *   Called by ZDO when a Unbind_rsp message is received.
   2450           *
   2451           * @param  SrcAddr  - Source address
   2452           * @param  Status - response status
   2453           *
   2454           * @return  none
   2455           */
   2456          void ZDApp_UnbindRsp( zAddrType_t *SrcAddr, byte Status )
   2457          {
   2458            ZDO_UnbindRsp_t unbindRsp;
   2459          
   2460          #if defined ( MT_ZDO_FUNC )
   2461            /* First check if MT has subscribed for this callback. If so , pass it as
   2462            a event to MonitorTest and return control to calling function after that */
   2463            if ( _zdoCallbackSub & CB_ID_ZDO_UNBIND_RSP )
   2464            {
   2465              zdo_MTCB_BindRspCB( SPI_CB_ZDO_UNBIND_RSP, SrcAddr, Status );
   2466              return;
   2467            }
   2468          #endif  //MT_ZDO_FUNC
   2469          
   2470            if ( ZDApp_BindUnbindRsp_TaskID != TASK_NO_TASK )
   2471            {
   2472              // Send the response structure to the registered task
   2473              unbindRsp.nwkAddr = SrcAddr->addr.shortAddr;
   2474              unbindRsp.status  = Status;
   2475          
   2476              ZDApp_SendMsg( ZDApp_BindUnbindRsp_TaskID,
   2477                             ZDO_UNBIND_RESP,
   2478                             sizeof(ZDO_UnbindRsp_t),
   2479                             (byte*)(&unbindRsp) );
   2480            }
   2481          }
   2482          #endif // ZDO_BIND_UNBIND_REQUEST
   2483          
   2484          /*********************************************************************
   2485           * Call Back Functions from NWK  - API
   2486           */
   2487          
   2488          /*********************************************************************
   2489           * @fn          ZDO_NetworkDiscoveryConfirmCB
   2490           *
   2491           * @brief       This function returns a choice of PAN to join.
   2492           *
   2493           * @param       ResultCount - Number of routers discovered
   2494           * @param               NetworkList - Pointer to list of network descriptors
   2495           *
   2496           * @return      ZStatus_t
   2497           */
   2498          #define STACK_PROFILE_MAX 2

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2499          ZStatus_t ZDO_NetworkDiscoveryConfirmCB( byte ResultCount,
   \                     ZDO_NetworkDiscoveryConfirmCB:
   2500                                                   networkDesc_t *NetworkList )
   2501          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FC           MOV     R4,A
   2502            networkDesc_t *pNwkDesc;
   2503            ZDO_NetworkDiscoveryCfm_t msg;
   2504            byte  i, j;
   2505            uint8 stackProfile;
   2506            uint8 stackProfilePro;
   2507            uint8 selected;
   2508          
   2509          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   2510            if ( zdappMgmtNwkDiscReqInProgress )
   2511            {
   2512              zdappMgmtNwkDiscReqInProgress = false;
   2513              ZDO_FinishProcessingMgmtNwkDiscReq( ResultCount, NetworkList );
   2514              return ( ZSuccess );
   2515            }
   2516          #endif
   2517          
   2518            // process discovery results
   2519            stackProfilePro = FALSE;
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
   2520            selected = FALSE;
   2521          
   2522            for ( stackProfile = 0; stackProfile < STACK_PROFILE_MAX; stackProfile++ )
   \   00000F   7D00         MOV     R5,#0x0
   2523            {
   2524              for ( j = 0; j < (sizeof(sPVerList)/sizeof(sPVerList[0])); ++j )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_0:
   \   000011   75..00       MOV     ?V0 + 0,#0x0
   2525              {
   2526                pNwkDesc = NetworkList;
   \                     ??ZDO_NetworkDiscoveryConfirmCB_1:
   \   000014   EA           MOV     A,R2
   \   000015   FE           MOV     R6,A
   \   000016   EB           MOV     A,R3
   \   000017   FF           MOV     R7,A
   2527                for ( i = 0; i < ResultCount; i++, pNwkDesc = pNwkDesc->nextDesc )
   \   000018   75..00       MOV     ?V0 + 4,#0x0
   \   00001B   8044         SJMP    ??ZDO_NetworkDiscoveryConfirmCB_2
   2528                {
   2529                  if ( zgConfigPANID != 0xFFFF )
   2530                  {
   2531                    // PAN Id is preconfigured. check if it matches
   2532                    // only 14 bits of pan id is used
   2533                    if ( pNwkDesc->panId != ( zgConfigPANID & 0x3FFF ) )
   2534                      continue;
   2535                    #if !defined ( DEF_PROTO_VERS )
   2536                    // If the macro was not defined ensure we join the version supported by
   2537                    // this PAN by forcing a match below. We need this statement because we
   2538                    // want to (possibly) override the NV value if the PAN was pre-defined.
   2539                    // See App Note 026.
   2540                    sPVerList[j] = pNwkDesc->version;
   2541                    #endif
   2542                  }
   2543          
   2544                  // check that network is allowing joining
   2545                  //------------------------------------------------------------
   2546                  #if defined( RTR_NWK )
   2547                  //------------------------------------------------------------
   2548                  if ( stackProfilePro == FALSE )
   2549                  {
   2550                    if ( !pNwkDesc->routerCapacity )
   2551                    {
   2552                      continue;
   2553                    }
   2554                  }
   2555                  else
   2556                  {
   2557                    if ( !pNwkDesc->deviceCapacity )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_3:
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6034         JZ      ??ZDO_NetworkDiscoveryConfirmCB_4
   2558                    {
   2559                      continue;
   2560                    }
   2561                  }
   2562                  //------------------------------------------------------------
   2563                  #else
   2564                  //------------------------------------------------------------
   2565                  if ( !pNwkDesc->deviceCapacity )
   2566                  {
   2567                    continue;
   2568                  }
   2569                  //------------------------------------------------------------
   2570                  #endif
   2571                  //------------------------------------------------------------
   2572          
   2573                  // check version of zigbee protocol
   2574                  if ( pNwkDesc->version != sPVerList[j] )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_5:
   \   000021   8E82         MOV     DPL,R6
   \   000023   8F83         MOV     DPH,R7
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000031   68           XRL     A,R0
   \   000032   7021         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_4
   2575                    continue;
   2576          
   2577                  // check version of stack profile
   2578                  if ( pNwkDesc->stackProfile != zgStackProfile )
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F8           MOV     R0,A
   \   000042   90....       MOV     DPTR,#zgStackProfile
   \   000045   E0           MOVX    A,@DPTR
   \   000046   68           XRL     A,R0
   \   000047   7003         JNZ     $+5
   \   000049   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_6 & 0xFFFF
   2579                  {
   2580                    stackProfilePro = TRUE;
   \   00004C   75..01       MOV     ?V0 + 1,#0x1
   2581          
   2582                    if ( stackProfile == 0 )
   \   00004F   ED           MOV     A,R5
   \   000050   6003         JZ      $+5
   \   000052   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_6 & 0xFFFF
   2583                    {
   2584                      continue;
   2585                    }
   2586                  }
   \                     ??ZDO_NetworkDiscoveryConfirmCB_4:
   \   000055   05..         INC     ?V0 + 4
   \   000057   EE           MOV     A,R6
   \   000058   2414         ADD     A,#0x14
   \   00005A   12....       LCALL   ??Subroutine17_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00005D   FE           MOV     R6,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   FF           MOV     R7,A
   \                     ??ZDO_NetworkDiscoveryConfirmCB_2:
   \   000061   E5..         MOV     A,?V0 + 4
   \   000063   C3           CLR     C
   \   000064   9C           SUBB    A,R4
   \   000065   5051         JNC     ??ZDO_NetworkDiscoveryConfirmCB_7
   \   000067   90....       MOV     DPTR,#zgConfigPANID
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   64FF         XRL     A,#0xff
   \   00006D   7004         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_8
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   64FF         XRL     A,#0xff
   \                     ??ZDO_NetworkDiscoveryConfirmCB_8:
   \   000073   602B         JZ      ??ZDO_NetworkDiscoveryConfirmCB_9
   \   000075   90....       MOV     DPTR,#zgConfigPANID
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F8           MOV     R0,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   543F         ANL     A,#0x3f
   \   00007E   F9           MOV     R1,A
   \   00007F   8F83         MOV     DPH,R7
   \   000081   8E82         MOV     DPL,R6
   \   000083   E0           MOVX    A,@DPTR
   \   000084   68           XRL     A,R0
   \   000085   7003         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_10
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   69           XRL     A,R1
   \                     ??ZDO_NetworkDiscoveryConfirmCB_10:
   \   00008A   70C9         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_4
   \   00008C   8E82         MOV     DPL,R6
   \   00008E   8F83         MOV     DPH,R7
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   C0E0         PUSH    A
   \   00009A   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00009D   D0E0         POP     A
   \   00009F   F0           MOVX    @DPTR,A
   \                     ??ZDO_NetworkDiscoveryConfirmCB_9:
   \   0000A0   E5..         MOV     A,?V0 + 1
   \   0000A2   8E82         MOV     DPL,R6
   \   0000A4   8F83         MOV     DPH,R7
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   6003         JZ      $+5
   \   0000AD   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_3 & 0xFFFF
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   6003         JZ      $+5
   \   0000B3   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_5 & 0xFFFF
   \   0000B6   809D         SJMP    ??ZDO_NetworkDiscoveryConfirmCB_4
   2587          
   2588                  // check if beacon order is the right value..
   2589              //  if ( pNwkDesc->beaconOrder < ZDO_CONFIG_MAX_BO )
   2590              //    continue;
   2591          
   2592                  // choose this pan for joining
   2593                  break;
   2594                }
   2595                if (i < ResultCount)
   2596                {
   2597                  selected = TRUE;
   2598                  break;
   2599                }
   2600              }
   \                     ??ZDO_NetworkDiscoveryConfirmCB_7:
   \   0000B8   05..         INC     ?V0 + 0
   \   0000BA   E5..         MOV     A,?V0 + 0
   \   0000BC   C3           CLR     C
   \   0000BD   9402         SUBB    A,#0x2
   \   0000BF   5003         JNC     $+5
   \   0000C1   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_1 & 0xFFFF
   2601          
   2602              // break if selected or stack profile pro wasn't found
   2603              if ( (selected == TRUE) || (stackProfilePro == FALSE) )
   \   0000C4   E5..         MOV     A,?V0 + 1
   \   0000C6   600A         JZ      ??ZDO_NetworkDiscoveryConfirmCB_11
   2604              {
   2605                break;
   2606              }
   2607            }
   \   0000C8   0D           INC     R5
   \   0000C9   ED           MOV     A,R5
   \   0000CA   C3           CLR     C
   \   0000CB   9402         SUBB    A,#0x2
   \   0000CD   5003         JNC     $+5
   \   0000CF   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_0 & 0xFFFF
   2608          
   2609            if ( i == ResultCount )
   \                     ??ZDO_NetworkDiscoveryConfirmCB_11:
   \   0000D2   EC           MOV     A,R4
   \   0000D3   65..         XRL     A,?V0 + 4
   \   0000D5   700B         JNZ     ??ZDO_NetworkDiscoveryConfirmCB_6
   2610            {
   2611              msg.hdr.status = ZDO_FAIL;   // couldn't find appropriate PAN to join !
   \   0000D7   7401         MOV     A,#0x1
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   7401         MOV     A,#0x1
   \   0000DE   F0           MOVX    @DPTR,A
   \   0000DF   02....       LJMP    ??ZDO_NetworkDiscoveryConfirmCB_12 & 0xFFFF
   2612            }
   2613            else
   2614            {
   2615              // (possibly) reset NV network version we're running under.
   2616              if (NLME_GetProtocolVersion() != sPVerList[j])
   \                     ??ZDO_NetworkDiscoveryConfirmCB_6:
   \   0000E2                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   0000E2   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   0000E5   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   0000E7   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000EA   E9           MOV     A,R1
   \   0000EB   FA           MOV     R2,A
   \   0000EC   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000EF   6A           XRL     A,R2
   \   0000F0   601D         JZ      ??ZDO_NetworkDiscoveryConfirmCB_13
   2617              {
   2618                NLME_SetRequest(nwkProtocolVersion, 0, &sPVerList[j]);
   \   0000F2                ; Setup parameters for call to function NLME_SetRequest
   \   0000F2   E5..         MOV     A,?V0 + 0
   \   0000F4   24..         ADD     A,#(??sPVerList & 0xff)
   \   0000F6   FC           MOV     R4,A
   \   0000F7   E4           CLR     A
   \   0000F8   34..         ADDC    A,#((??sPVerList >> 8) & 0xff)
   \   0000FA   FD           MOV     R5,A
   \   0000FB   7A00         MOV     R2,#0x0
   \   0000FD   7B00         MOV     R3,#0x0
   \   0000FF   7998         MOV     R1,#-0x68
   \   000101   90....       MOV     DPTR,#(NLME_SetRequest & 0xffff)
   \   000104   74..         MOV     A,#((NLME_SetRequest >> 16) & 0xff)
   \   000106   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2619                // make sure we update NV
   2620                osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 1000 );
   \   000109                ; Setup parameters for call to function osal_start_timerEx
   \   000109   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   00010C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2621              }
   2622          
   2623              msg.hdr.status = ZDO_SUCCESS;
   \                     ??ZDO_NetworkDiscoveryConfirmCB_13:
   \   00010F   7401         MOV     A,#0x1
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   E4           CLR     A
   \   000115   F0           MOVX    @DPTR,A
   2624              msg.panIdLSB = LO_UINT16( pNwkDesc->panId );
   \   000116   8E82         MOV     DPL,R6
   \   000118   8F83         MOV     DPH,R7
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   C0E0         PUSH    A
   \   00011D   7402         MOV     A,#0x2
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   D0E0         POP     A
   \   000124   12....       LCALL   ?Subroutine19 & 0xFFFF
   2625              msg.panIdMSB = HI_UINT16( pNwkDesc->panId );
   \                     ??CrossCallReturnLabel_42:
   \   000127   E0           MOVX    A,@DPTR
   \   000128   C0E0         PUSH    A
   \   00012A   7403         MOV     A,#0x3
   \   00012C   12....       LCALL   ?XSTACK_DISP0_8
   \   00012F   D0E0         POP     A
   \   000131   12....       LCALL   ?Subroutine19 & 0xFFFF
   2626              msg.logicalChannel = pNwkDesc->logicalChannel;
   \                     ??CrossCallReturnLabel_43:
   \   000134   A3           INC     DPTR
   \   000135   E0           MOVX    A,@DPTR
   \   000136   C0E0         PUSH    A
   \   000138   7404         MOV     A,#0x4
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   D0E0         POP     A
   \   00013F   12....       LCALL   ?Subroutine4 & 0xFFFF
   2627              msg.version = pNwkDesc->version;
   \                     ??CrossCallReturnLabel_7:
   \   000142   A3           INC     DPTR
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   E0           MOVX    A,@DPTR
   \   000146   C0E0         PUSH    A
   \   000148   7405         MOV     A,#0x5
   \   00014A   12....       LCALL   ?XSTACK_DISP0_8
   \   00014D   D0E0         POP     A
   \   00014F   F0           MOVX    @DPTR,A
   2628              osal_cpyExtAddr( msg.extendedPANID, pNwkDesc->extendedPANID );
   \   000150                ; Setup parameters for call to function osal_cpyExtAddr
   \   000150   EE           MOV     A,R6
   \   000151   240C         ADD     A,#0xc
   \   000153   FC           MOV     R4,A
   \   000154   EF           MOV     A,R7
   \   000155   3400         ADDC    A,#0x0
   \   000157   FD           MOV     R5,A
   \   000158   7406         MOV     A,#0x6
   \   00015A   12....       LCALL   ?XSTACK_DISP0_8
   \   00015D   AA82         MOV     R2,DPL
   \   00015F   AB83         MOV     R3,DPH
   \   000161   90....       MOV     DPTR,#(osal_cpyExtAddr & 0xffff)
   \   000164   74..         MOV     A,#((osal_cpyExtAddr >> 16) & 0xff)
   \   000166   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2629            }
   2630          
   2631            ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_DISC_CNF, sizeof(ZDO_NetworkDiscoveryCfm_t), (byte *)&msg );
   \                     ??ZDO_NetworkDiscoveryConfirmCB_12:
   \   000169                ; Setup parameters for call to function ZDApp_SendMsg
   \   000169   85..82       MOV     DPL,?XSP + 0
   \   00016C   85..83       MOV     DPH,?XSP + 1
   \   00016F   AC82         MOV     R4,DPL
   \   000171   AD83         MOV     R5,DPH
   \   000173   7B0E         MOV     R3,#0xe
   \   000175   7A01         MOV     R2,#0x1
   \   000177   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00017A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2632          
   2633            return (ZSuccess);
   \   00017D   7900         MOV     R1,#0x0
   \   00017F   740E         MOV     A,#0xe
   \   000181   12....       LCALL   ?DEALLOC_XSTACK8
   \   000184   7F05         MOV     R7,#0x5
   \   000186   02....       LJMP    ?BANKED_LEAVE_XDATA
   2634          }  // ZDO_NetworkDiscoveryConfirmCB

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85....       MOV     ?V0 + 2,?V0 + 0
   \   000003   E5..         MOV     A,?V0 + 2
   \   000005   24..         ADD     A,#(??sPVerList & 0xff)
   \   000007   F582         MOV     DPL,A
   \   000009   E4           CLR     A
   \   00000A   34..         ADDC    A,#((??sPVerList >> 8) & 0xff)
   \   00000C   F583         MOV     DPH,A
   \   00000E   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   EE           MOV     A,R6
   \   000001   240B         ADD     A,#0xb
   \                     ??Subroutine17_0:
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   12....       LCALL   ??Subroutine22_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
   2635          
   2636          /*********************************************************************
   2637           * @fn          ZDO_NetworkFormationConfirmCB
   2638           *
   2639           * @brief       This function reports the results of the request to
   2640           *              initialize a coordinator in a network.
   2641           *
   2642           * @param       Status - Result of NLME_NetworkFormationRequest()
   2643           *
   2644           * @return      none
   2645           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2646          void ZDO_NetworkFormationConfirmCB( ZStatus_t Status )
   \                     ZDO_NetworkFormationConfirmCB:
   2647          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2648          #if defined(ZDO_COORDINATOR)
   2649            nwkStatus = (byte)Status;
   2650          
   2651            if ( Status == ZSUCCESS )
   2652            {
   2653              // LED on shows Coordinator started
   2654              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   2655          
   2656              // LED off forgets HOLD_AUTO_START
   2657              HalLedSet (HAL_LED_4, HAL_LED_MODE_OFF);
   2658          
   2659          #if defined ( ZBIT )
   2660              SIM_SetColor(0xd0ffd0);
   2661          #endif
   2662          
   2663              if ( devState == DEV_HOLD )
   2664              {
   2665                // Began with HOLD_AUTO_START
   2666                devState = DEV_COORD_STARTING;
   2667              }
   2668            }
   2669          #if defined(BLINK_LEDS)
   2670            else
   2671              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   2672          #endif
   2673          
   2674            osal_set_event( ZDAppTaskID, ZDO_NETWORK_START );
   2675          #endif  //ZDO_COORDINATOR
   2676          }
   \   000000   02....       LJMP    ?BRET
   2677          
   2678          #if defined(RTR_NWK)
   2679          /*********************************************************************
   2680           * @fn          ZDO_StartRouterConfirmCB
   2681           *
   2682           * @brief       This function reports the results of the request to
   2683           *              start functioning as a router in a network.
   2684           *
   2685           * @param       Status - Result of NLME_StartRouterRequest()
   2686           *
   2687           * @return      none
   2688           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2689          void ZDO_StartRouterConfirmCB( ZStatus_t Status )
   \                     ZDO_StartRouterConfirmCB:
   2690          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2691            nwkStatus = (byte)Status;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#nwkStatus
   \   000008   F0           MOVX    @DPTR,A
   2692          
   2693            if ( Status == ZSUCCESS )
   \   000009   7020         JNZ     ??ZDO_StartRouterConfirmCB_0
   2694            {
   2695              // LED on shows Router started
   2696              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   \   00000B                ; Setup parameters for call to function HalLedSet
   \   00000B   7A01         MOV     R2,#0x1
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000012   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000014   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2697              // LED off forgets HOLD_AUTO_START
   2698              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   \   000017                ; Setup parameters for call to function HalLedSet
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7908         MOV     R1,#0x8
   \   00001B   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   00001D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2699              if ( devState == DEV_HOLD )
   \   000020   90....       MOV     DPTR,#devState
   \   000023   E0           MOVX    A,@DPTR
   \   000024   7011         JNZ     ??ZDO_StartRouterConfirmCB_1
   2700              {
   2701                // Began with HOLD_AUTO_START
   2702                devState = DEV_END_DEVICE;
   \   000026   7406         MOV     A,#0x6
   \   000028   F0           MOVX    @DPTR,A
   \   000029   800C         SJMP    ??ZDO_StartRouterConfirmCB_1
   2703              }
   2704            }
   2705          #if defined(BLINK_LEDS)
   2706            else
   2707              HalLedSet( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   \                     ??ZDO_StartRouterConfirmCB_0:
   \   00002B                ; Setup parameters for call to function HalLedSet
   \   00002B   7A04         MOV     R2,#0x4
   \   00002D   7904         MOV     R1,#0x4
   \   00002F   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000032   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000034   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2708          #endif
   2709          
   2710            osal_set_event( ZDAppTaskID, ZDO_ROUTER_START );
   \                     ??ZDO_StartRouterConfirmCB_1:
   \   000037                ; Setup parameters for call to function osal_set_event
   \   000037   7A20         MOV     R2,#0x20
   \   000039   02....       LJMP    ?Subroutine31 & 0xFFFF
   2711          }
   2712          #endif  //RTR_NWK
   2713          
   2714          /*********************************************************************
   2715           * @fn          ZDO_JoinConfirmCB
   2716           *
   2717           * @brief       This function allows the next hight layer to be notified
   2718           *              of the results of its request to join itself or another
   2719           *              device to a network.
   2720           *
   2721           * @param       Status - Result of NLME_JoinRequest()
   2722           *
   2723           * @return      none
   2724           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2725          void ZDO_JoinConfirmCB( uint16 PanId, ZStatus_t Status )
   \                     ZDO_JoinConfirmCB:
   2726          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2727            nwkStatus = (byte)Status;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#nwkStatus
   \   000008   F0           MOVX    @DPTR,A
   2728          
   2729            if ( Status == ZSUCCESS )
   \   000009   7027         JNZ     ??ZDO_JoinConfirmCB_0
   2730            {
   2731              // LED on shows device joined
   2732              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   \   00000B                ; Setup parameters for call to function HalLedSet
   \   00000B   7A01         MOV     R2,#0x1
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000012   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   000014   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2733              // LED off forgets HOLD_AUTO_START
   2734              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   \   000017                ; Setup parameters for call to function HalLedSet
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7908         MOV     R1,#0x8
   \   00001B   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \   00001D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2735              if ( (devState == DEV_HOLD) )
   \   000020   90....       MOV     DPTR,#devState
   \   000023   E0           MOVX    A,@DPTR
   \   000024   7003         JNZ     ??ZDO_JoinConfirmCB_1
   2736              {
   2737                // Began with HOLD_AUTO_START
   2738                devState = DEV_NWK_JOINING;
   \   000026   7403         MOV     A,#0x3
   \   000028   F0           MOVX    @DPTR,A
   2739              }
   2740          #if !  ( SECURE != 0  )
   2741              // Notify to save info into NV
   2742              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 100 );
   \                     ??ZDO_JoinConfirmCB_1:
   \   000029                ; Setup parameters for call to function osal_start_timerEx
   \   000029   7C64         MOV     R4,#0x64
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000030   8009         SJMP    ??ZDO_JoinConfirmCB_2
   2743          #endif
   2744            }
   2745          #if defined(BLINK_LEDS)
   2746            else
   2747              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   \                     ??ZDO_JoinConfirmCB_0:
   \   000032                ; Setup parameters for call to function HalLedSet
   \   000032   7A04         MOV     R2,#0x4
   \   000034   7904         MOV     R1,#0x4
   \   000036   90....       MOV     DPTR,#(HalLedSet & 0xffff)
   \   000039   74..         MOV     A,#((HalLedSet >> 16) & 0xff)
   \                     ??ZDO_JoinConfirmCB_2:
   \   00003B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2748          #endif
   2749          
   2750            // Notify ZDApp
   2751            ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_IND, sizeof(osal_event_hdr_t), (byte*)NULL );
   \   00003E                ; Setup parameters for call to function ZDApp_SendMsg
   \   00003E   7C00         MOV     R4,#0x0
   \   000040   7D00         MOV     R5,#0x0
   \   000042   7B02         MOV     R3,#0x2
   \   000044   7A02         MOV     R2,#0x2
   \   000046   02....       LJMP    ?Subroutine32 & 0xFFFF
   2752          }
   2753          
   2754          /*********************************************************************
   2755           * @fn          ZDO_JoinIndicationCB
   2756           *
   2757           * @brief       This function allows the next higher layer of a
   2758           *              coordinator to be notified of a remote join request.
   2759           *
   2760           * @param       ShortAddress - 16-bit address
   2761           * @param       ExtendedAddress - IEEE (64-bit) address
   2762           * @param       CapabilityInformation - Association Capability Information
   2763           *
   2764           * @return      ZStatus_t
   2765           */
   2766          #if defined(RTR_NWK)

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2767          ZStatus_t ZDO_JoinIndicationCB( uint16 ShortAddress, byte *ExtendedAddress,
   \                     ZDO_JoinIndicationCB:
   2768                                                   byte CapabilityInformation )
   2769          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2770          #if defined (AUTO_SOFT_START)
   2771              ZDX_PostCoordinatorIEEE(ShortAddress);
   2772          #endif
   2773          
   2774            // Notify to save info into NV
   2775            osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 1000 );
   \   000004                ; Setup parameters for call to function osal_start_timerEx
   \   000004   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000007   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2776          
   2777          #if   ( SECURE != 0  )
   2778            // send notification to TC of new device..
   2779            if ( _NIB.SecurityLevel )
   2780              osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 600 );
   2781          #endif  // SECURE
   2782          
   2783            return ( ZSuccess );
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   2784          }
   2785          #endif  //RTR_NWK
   2786          
   2787          /*********************************************************************
   2788           * @fn          ZDO_LeaveCnf
   2789           *
   2790           * @brief       This function allows the next higher layer to be
   2791           *              notified of the results of its request for this or
   2792           *              a child device to leave the network.
   2793           *
   2794           * @param       cnf - NLME_LeaveCnf_t
   2795           *
   2796           * @return      none
   2797           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2798          void ZDO_LeaveCnf( NLME_LeaveCnf_t* cnf )
   \                     ZDO_LeaveCnf:
   2799          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2800            // Check for this device
   2801            if ( osal_ExtAddrEqual( cnf->extAddr,
   2802                                    NLME_GetExtAddr() ) == TRUE )
   \   000009                ; Setup parameters for call to function osal_ExtAddrEqual
   \   000009                ; Setup parameters for call to function NLME_GetExtAddr
   \   000009   90....       MOV     DPTR,#(NLME_GetExtAddr & 0xffff)
   \   00000C   74..         MOV     A,#((NLME_GetExtAddr >> 16) & 0xff)
   \   00000E   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000011   EA           MOV     A,R2
   \   000012   FC           MOV     R4,A
   \   000013   EB           MOV     A,R3
   \   000014   FD           MOV     R5,A
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   FB           MOV     R3,A
   \   00001D   90....       MOV     DPTR,#(osal_ExtAddrEqual & 0xffff)
   \   000020   74..         MOV     A,#((osal_ExtAddrEqual >> 16) & 0xff)
   \   000022   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000025   E9           MOV     A,R1
   \   000026   6401         XRL     A,#0x1
   \   000028   7008         JNZ     ??ZDO_LeaveCnf_0
   2803            {
   2804              // Prepare to leave with reset
   2805              ZDApp_LeaveReset( cnf->rejoin );
   \   00002A                ; Setup parameters for call to function ZDApp_LeaveReset
   \   00002A   EE           MOV     A,R6
   \   00002B   240B         ADD     A,#0xb
   \   00002D   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000030   8011         SJMP    ??CrossCallReturnLabel_16
   2806            }
   2807            //------------------------------------------------------------------
   2808            #if defined( RTR_NWK )
   2809            //------------------------------------------------------------------
   2810            else
   2811            {
   2812              // Remove device address(optionally descendents) from data
   2813              ZDApp_LeaveUpdate( cnf->dstAddr,
   2814                                 cnf->extAddr,
   2815                                 cnf->removeChildren );
   \                     ??ZDO_LeaveCnf_0:
   \   000032                ; Setup parameters for call to function NLME_RemoveChild
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000043   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2816            }
   2817            //------------------------------------------------------------------
   2818            #endif
   2819            //------------------------------------------------------------------
   2820          }
   \   000046   02....       LJMP    ??Subroutine27_0 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003   12....       LCALL   ??Subroutine22_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   90....       MOV     DPTR,#(ZDApp_LeaveReset & 0xffff)
   \   00000B   74..         MOV     A,#((ZDApp_LeaveReset >> 16) & 0xff)
   \   00000D   22           RET
   2821          
   2822          /*********************************************************************
   2823           * @fn          ZDO_LeaveInd
   2824           *
   2825           * @brief       This function allows the next higher layer of a
   2826           *              device to be notified of a remote leave request or
   2827           *              indication.
   2828           *
   2829           * @param       ind - NLME_LeaveInd_t
   2830           *
   2831           * @return      none
   2832           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2833          void ZDO_LeaveInd( NLME_LeaveInd_t* ind )
   \                     ZDO_LeaveInd:
   2834          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2835            uint8 leave;
   2836          
   2837          
   2838            // Parent is requesting the leave - NWK layer filters out illegal
   2839            // requests
   2840            if ( ind->request == TRUE )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6401         XRL     A,#0x1
   \   00001F   7028         JNZ     ??ZDO_LeaveInd_0
   2841            {
   2842              // Notify network of leave
   2843              //----------------------------------------------------------------
   2844              #if defined( RTR_NWK )
   2845              //----------------------------------------------------------------
   2846              NLME_LeaveRsp_t rsp;
   2847              rsp.rejoin         = ind->rejoin;
   \   000021   EE           MOV     A,R6
   \   000022   240C         ADD     A,#0xc
   \   000024   12....       LCALL   ??Subroutine17_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000027   C0E0         PUSH    A
   \   000029   7401         MOV     A,#0x1
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   D0E0         POP     A
   \   000030   F0           MOVX    @DPTR,A
   2848              rsp.removeChildren = ind->removeChildren;
   \   000031   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   F0           MOVX    @DPTR,A
   2849              NLME_LeaveRsp( &rsp );
   \   00003B                ; Setup parameters for call to function NLME_LeaveRsp
   \   00003B   AA82         MOV     R2,DPL
   \   00003D   AB83         MOV     R3,DPH
   \   00003F   90....       MOV     DPTR,#(NLME_LeaveRsp & 0xffff)
   \   000042   74..         MOV     A,#((NLME_LeaveRsp >> 16) & 0xff)
   \   000044   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000047   8034         SJMP    ??ZDO_LeaveInd_1
   2850              //----------------------------------------------------------------
   2851              #endif
   2852              //----------------------------------------------------------------
   2853          
   2854              // Prepare to leave with reset
   2855              ZDApp_LeaveReset( ind->rejoin );
   2856            }
   2857            else
   2858            {
   2859              leave = FALSE;
   2860          
   2861              // Check if this device needs to leave as a child or descendent
   2862              if ( ind->srcAddr == NLME_GetCoordShortAddr() )
   \                     ??ZDO_LeaveInd_0:
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   C082         PUSH    DPL
   \   00004F   C083         PUSH    DPH
   \   000051                ; Setup parameters for call to function NLME_GetCoordShortAddr
   \   000051   90....       MOV     DPTR,#(NLME_GetCoordShortAddr & 0xffff)
   \   000054   74..         MOV     A,#((NLME_GetCoordShortAddr >> 16) & 0xff)
   \   000056   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000059   8A..         MOV     ?V0 + 0,R2
   \   00005B   8B..         MOV     ?V0 + 1,R3
   \   00005D   D083         POP     DPH
   \   00005F   D082         POP     DPL
   \   000061   E0           MOVX    A,@DPTR
   \   000062   65..         XRL     A,?V0 + 0
   \   000064   7004         JNZ     ??ZDO_LeaveInd_2
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   65..         XRL     A,?V0 + 1
   \                     ??ZDO_LeaveInd_2:
   \   00006A   7019         JNZ     ??ZDO_LeaveInd_3
   2863              {
   2864                if ( ( ind->removeChildren == TRUE               ) ||
   2865                     ( ZDO_Config_Node_Descriptor.LogicalType ==
   2866                       NODETYPE_DEVICE                           )    )
   \   00006C   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00006F   6401         XRL     A,#0x1
   \   000071   600A         JZ      ??ZDO_LeaveInd_1
   \   000073   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   000076   E0           MOVX    A,@DPTR
   \   000077   5407         ANL     A,#0x7
   \   000079   6402         XRL     A,#0x2
   \   00007B   7008         JNZ     ??ZDO_LeaveInd_3
   2867                {
   2868                  leave = TRUE;
   2869                }
   2870              }
   2871              else if ( ind->removeChildren == TRUE )
   2872              {
   2873                // Check NWK address allocation algorithm
   2874                //leave = RTG_ANCESTOR(nwkAddr,thisAddr);
   2875              }
   2876          
   2877              if ( leave == TRUE )
   2878              {
   2879                // Prepare to leave with reset
   2880                ZDApp_LeaveReset( ind->rejoin );
   \                     ??ZDO_LeaveInd_1:
   \   00007D                ; Setup parameters for call to function ZDApp_LeaveReset
   \   00007D   EE           MOV     A,R6
   \   00007E   240C         ADD     A,#0xc
   \   000080   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000083   800C         SJMP    ??CrossCallReturnLabel_17
   2881              }
   2882              else
   2883              {
   2884                // Remove device address(optionally descendents) from data
   2885                ZDApp_LeaveUpdate( ind->srcAddr,
   2886                                   ind->extAddr,
   2887                                   ind->removeChildren );
   \                     ??ZDO_LeaveInd_3:
   \   000085                ; Setup parameters for call to function NLME_RemoveChild
   \   000085   EE           MOV     A,R6
   \   000086   240B         ADD     A,#0xb
   \   000088   F582         MOV     DPL,A
   \   00008A   EF           MOV     A,R7
   \   00008B   12....       LCALL   ??Subroutine22_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   00008E   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000091   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2888              }
   2889            }
   2890          }
   \   000094   02....       LJMP    ?Subroutine26 & 0xFFFF
   2891          
   2892          /*********************************************************************
   2893           * @fn          ZDO_SyncIndicationCB
   2894           *
   2895           * @brief       This function allows the next higher layer of a
   2896           *              coordinator to be notified of a loss of synchronization
   2897           *                          with the parent/child device.
   2898           *
   2899           * @param       type: 0 - child; 1 - parent
   2900           *
   2901           *
   2902           * @return      none
   2903           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2904          void ZDO_SyncIndicationCB( byte type, uint16 shortAddr )
   \                     ZDO_SyncIndicationCB:
   2905          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2906          
   2907          #if !defined ( RTR_NWK )
   2908              if ( type == 1 )
   2909              {
   2910                ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_REQ, sizeof(osal_event_hdr_t), NULL );
   2911              }
   2912          #endif
   2913            return;
   \   000000   02....       LJMP    ?BRET
   2914          }
   2915          
   2916          /*********************************************************************
   2917           * @fn          ZDO_PollConfirmCB
   2918           *
   2919           * @brief       This function allows the next higher layer to be
   2920           *              notified of a Poll Confirm.
   2921           *
   2922           * @param       none
   2923           *
   2924           * @return      none
   2925           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2926          void ZDO_PollConfirmCB( byte status )
   \                     ZDO_PollConfirmCB:
   2927          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2928            return;
   \   000000   02....       LJMP    ?BRET
   2929          }
   2930          
   2931          /******************************************************************************
   2932           * @fn          ZDApp_NwkWriteNVRequest (stubs AddrMgrWriteNVRequest)
   2933           *
   2934           * @brief       Stub routine implemented by NHLE. NHLE should call
   2935           *              <AddrMgrWriteNV> when appropriate.
   2936           *
   2937           * @param       none
   2938           *
   2939           * @return      none
   2940           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2941          void ZDApp_NwkWriteNVRequest( void )
   \                     AddrMgrWriteNVRequest:
   2942          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2943            if ( !osal_get_timeoutEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV ) )
   \   000005                ; Setup parameters for call to function osal_get_timeoutEx
   \   000005   7A00         MOV     R2,#0x0
   \   000007   7B02         MOV     R3,#0x2
   \   000009   90....       MOV     DPTR,#ZDAppTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   90....       MOV     DPTR,#(osal_get_timeoutEx & 0xffff)
   \   000011   74..         MOV     A,#((osal_get_timeoutEx >> 16) & 0xff)
   \   000013   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000016   EA           MOV     A,R2
   \   000017   7001         JNZ     ??AddrMgrWriteNVRequest_0
   \   000019   EB           MOV     A,R3
   \                     ??AddrMgrWriteNVRequest_0:
   \   00001A   700A         JNZ     ??AddrMgrWriteNVRequest_1
   2944            {
   2945              // Trigger to save info into NV
   2946              osal_start_timerEx( ZDAppTaskID,
   2947                                  ZDO_NWK_UPDATE_NV,
   2948                                  ZDAPP_UPDATE_NWK_NV_TIME );
   \   00001C                ; Setup parameters for call to function osal_start_timerEx
   \   00001C   7C64         MOV     R4,#0x64
   \   00001E   7D00         MOV     R5,#0x0
   \   000020   12....       LCALL   ??Subroutine5_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000023   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   2949            }
   2950          }
   \                     ??AddrMgrWriteNVRequest_1:
   \   000026   02....       LJMP    ??Subroutine26_1 & 0xFFFF
   2951          
   2952          /*********************************************************************
   2953           * Call Back Functions from Security  - API
   2954           */
   2955          
   2956          #if defined( ZDO_COORDINATOR )
   2957           /*********************************************************************
   2958           * @fn          ZDO_UpdateDeviceIndication
   2959           *
   2960           * @brief       This function notifies the "Trust Center" of a
   2961           *              network when a device joins or leaves the network.
   2962           *
   2963           * @param       extAddr - pointer to 64 bit address of new device
   2964           * @param       status  - 0 if a new device joined securely
   2965           *                      - 1 if a new device joined un-securely
   2966           *                      - 2 if a device left the network
   2967           *
   2968           * @return      true if newly joined device should be allowed to
   2969           *                                              remain on network
   2970           */
   2971          ZStatus_t ZDO_UpdateDeviceIndication( byte *extAddr, byte status )
   2972          {
   2973          
   2974          #if   ( SECURE != 0  )
   2975            // can implement a network access policy based on the
   2976            // IEEE address of newly joining devices...
   2977          #endif  // Trust Center
   2978          
   2979            return ZSuccess;
   2980          }
   2981          #endif // ZDO
   2982          
   2983          /*********************************************************************
   2984           * @fn          ZDApp_InMsgCB
   2985           *
   2986           * @brief       This function is called to pass up any message that is
   2987           *              not yet supported.  This allows for the developer to
   2988           *              support features themselves..
   2989           *
   2990           * @return      none
   2991           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2992          void ZDApp_InMsgCB( byte TransSeq, zAddrType_t *srcAddr, byte wasBroadcast,
   \                     ZDApp_InMsgCB:
   2993                            cId_t clusterID, byte asduLen, byte *asdu, byte SecurityUse )
   2994          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   740A         MOV     A,#0xa
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FE           MOV     R6,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FF           MOV     R7,A
   \   00000F   740E         MOV     A,#0xe
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FD           MOV     R5,A
   2995            if ( clusterID & ZDO_RESPONSE_BIT )
   \   000016   7480         MOV     A,#-0x80
   \   000018   5F           ANL     A,R7
   \   000019   F5..         MOV     ?V0 + 1,A
   \   00001B   E4           CLR     A
   \   00001C   7002         JNZ     ??ZDApp_InMsgCB_0
   \   00001E   E5..         MOV     A,?V0 + 1
   \                     ??ZDApp_InMsgCB_0:
   \   000020   7032         JNZ     ??ZDApp_InMsgCB_1
   2996            {
   2997              // Handle the response message
   2998            }
   2999            else
   3000            {
   3001              // Handle the request message by sending a generic "not supported".
   3002              // End Device Announce doesn't have a response.
   3003              if ( !wasBroadcast && clusterID != End_Device_annce )
   \   000022   EC           MOV     A,R4
   \   000023   702F         JNZ     ??ZDApp_InMsgCB_1
   \   000025   7413         MOV     A,#0x13
   \   000027   6E           XRL     A,R6
   \   000028   7001         JNZ     ??ZDApp_InMsgCB_2
   \   00002A   EF           MOV     A,R7
   \                     ??ZDApp_InMsgCB_2:
   \   00002B   6027         JZ      ??ZDApp_InMsgCB_1
   3004              {
   3005                ZDP_GenericRsp( TransSeq, srcAddr, ZDP_NOT_SUPPORTED, 0,
   3006                                (uint16)(clusterID | ZDO_RESPONSE_BIT), SecurityUse );
   \   00002D                ; Setup parameters for call to function ZDP_GenericRsp
   \   00002D   EE           MOV     A,R6
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   7480         MOV     A,#-0x80
   \   000032   4F           ORL     A,R7
   \   000033   F5..         MOV     ?V0 + 1,A
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003A   75..00       MOV     ?V0 + 0,#0x0
   \   00003D   75..00       MOV     ?V0 + 1,#0x0
   \   000040   78..         MOV     R0,#?V0 + 0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   7C84         MOV     R4,#-0x7c
   \   000047   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   00004A   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   00004C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00004F   7404         MOV     A,#0x4
   \   000051   12....       LCALL   ?DEALLOC_XSTACK8
   3007              }
   3008            }
   3009          }
   \                     ??ZDApp_InMsgCB_1:
   \   000054   02....       LJMP    ??Subroutine26_1 & 0xFFFF
   3010          
   3011          #if defined ( ZDO_MGMT_LQI_REQUEST )
   3012          /*********************************************************************
   3013           * @fn          ZDApp_MgmtLqiRspCB
   3014           *
   3015           * @brief       This function handles Management LQI response for the
   3016           *              Device Object application.
   3017           *
   3018           * @param       Status - ZSuccess or other for failure
   3019           * @param       NeighborLqiEntries - number of possible entries on
   3020           *                       the device
   3021           * @param       StartIndex - where this list start in possible entries
   3022           * @param       NeighborLqiCount - number of entries in this list
   3023           * @param       pList - pointer to the list of LQI items.
   3024           * @param       SecurityUse -
   3025           *
   3026           * @return      none
   3027           */
   3028          void ZDApp_MgmtLqiRspCB( uint16 SrcAddr, byte Status, byte NeighborLqiEntries,
   3029                                   byte StartIndex, byte NeighborLqiCount,
   3030                                   neighborLqiItem_t *pList )
   3031          {
   3032            byte x;
   3033          
   3034          #if defined ( MT_ZDO_FUNC )
   3035            /* First check if MT has subscribed for this callback. If so , pass it as
   3036            a event to MonitorTest and return control to calling function after that */
   3037            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_LQI_RSP )
   3038            {
   3039              zdo_MTCB_MgmtLqiRspCB( SrcAddr, Status, NeighborLqiEntries, StartIndex,
   3040                                                  NeighborLqiCount, pList );
   3041              return;
   3042            }
   3043          #endif  //MT_ZDO_FUNC
   3044          
   3045            if ( Status == ZSuccess )
   3046            {
   3047              for ( x = 0; x < NeighborLqiCount; x++, pList++ )
   3048              {
   3049                // Do something with the results
   3050              }
   3051            }
   3052            else
   3053            {
   3054              // Error
   3055            }
   3056          }
   3057          #endif // ZDO_MGMT_LQI_REQUEST
   3058          
   3059          #if defined ( ZDO_MGMT_NWKDISC_REQUEST )
   3060          /*********************************************************************
   3061           * @fn          ZDApp_MgmtNwkDiscRspCB
   3062           *
   3063           * @brief       This function handles Management Network Discovery
   3064           *              response for the Device Object application.
   3065           *
   3066           * @param       SrcAddr - source of the message
   3067           * @param       Status - ZSuccess or other for failure
   3068           * @param       NetworkCount - number of possible entries on
   3069           *                       the device
   3070           * @param       StartIndex - where this list start in possible entries
   3071           * @param       networkListCount - number of entries in this list
   3072           * @param       pList - pointer to the list of Network Discover items.
   3073           * @param       SecurityUse -
   3074           *
   3075           * @return      none
   3076           */
   3077          void ZDApp_MgmtNwkDiscRspCB( uint16 SrcAddr, byte Status, byte NetworkCount,
   3078                                       byte StartIndex, byte networkListCount,
   3079                                       mgmtNwkDiscItem_t *pList )
   3080          {
   3081            byte x;
   3082          
   3083          #if defined ( MT_ZDO_FUNC )
   3084            /* First check if MT has subscribed for this callback. If so , pass it as
   3085            a event to MonitorTest and return control to calling function after that */
   3086            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_NWKDISC_RSP )
   3087            {
   3088              zdo_MTCB_MgmtNwkDiscRspCB( SrcAddr, Status, NetworkCount, StartIndex,
   3089                                                  networkListCount, pList );
   3090              return;
   3091            }
   3092          #endif  //MT_ZDO_FUNC
   3093          
   3094            if ( Status == ZSuccess )
   3095            {
   3096              for ( x = 0; x < networkListCount; x++, pList++ )
   3097              {
   3098                // Do something with the results
   3099              }
   3100            }
   3101            else
   3102            {
   3103              // Error
   3104            }
   3105          }
   3106          #endif // ZDO_MGMT_NWKDISC_REQUEST
   3107          
   3108          #if defined ( ZDO_MGMT_RTG_REQUEST )
   3109          /*********************************************************************
   3110           * @fn          ZDApp_MgmtRtgRspCB
   3111           *
   3112           * @brief       This function handles Management Routing response for the
   3113           *              Device Object application.
   3114           *
   3115           * @param       SrcAddr - source of the message
   3116           * @param       Status - ZSuccess or other for failure
   3117           * @param       rtgCount - number of possible entries on
   3118           *                       the device
   3119           * @param       StartIndex - where this list start in possible entries
   3120           * @param       rtgCount - number of entries in this list
   3121           * @param       pList - pointer to the list of Network Discover items.
   3122           * @param       SecurityUse -
   3123           *
   3124           * @return      none
   3125           */
   3126          void ZDApp_MgmtRtgRspCB( uint16 SrcAddr, byte Status, byte rtgCount,
   3127                                   byte StartIndex, byte rtgListCount,
   3128                                   rtgItem_t *pList )
   3129          {
   3130            byte x;
   3131          
   3132          #if defined ( MT_ZDO_FUNC )
   3133            /* First check if MT has subscribed for this callback. If so , pass it as
   3134            a event to MonitorTest and return control to calling function after that */
   3135            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_RTG_RSP )
   3136            {
   3137              zdo_MTCB_MgmtRtgRspCB( SrcAddr, Status, rtgCount, StartIndex,
   3138                                                                  rtgListCount, pList );
   3139              return;
   3140            }
   3141          #endif  //MT_ZDO_FUNC
   3142          
   3143            if ( Status == ZSuccess )
   3144            {
   3145              for ( x = 0; x < rtgListCount; x++, pList++ )
   3146              {
   3147                // Do something with the results
   3148              }
   3149            }
   3150            else
   3151            {
   3152              // Error
   3153            }
   3154          }
   3155          #endif // ZDO_MGMT_RTG_REQUEST
   3156          
   3157          #if defined ( ZDO_MGMT_BIND_REQUEST )
   3158          /*********************************************************************
   3159           * @fn          ZDApp_MgmtBindRspCB
   3160           *
   3161           * @brief       This function handles Management Binding response for the
   3162           *              Device Object application.
   3163           *
   3164           * @param       SrcAddr - source of the message
   3165           * @param       Status - ZSuccess or other for failure
   3166           * @param       BindingCount - number of possible entries on
   3167           *                       the device
   3168           * @param       StartIndex - where this list start in possible entries
   3169           * @param       BindingListCount - number of entries in this list
   3170           * @param       pList - pointer to the list of Network Discover items.
   3171           * @param       SecurityUse -
   3172           *
   3173           * @return      none
   3174           */
   3175          void ZDApp_MgmtBindRspCB( uint16 SrcAddr, byte Status, byte BindingCount,
   3176                                   byte StartIndex, byte BindingListCount,
   3177                                   apsBindingItem_t *pList )
   3178          {
   3179            byte x;
   3180          
   3181          #if defined ( MT_ZDO_FUNC )
   3182            /* First check if MT has subscribed for this callback. If so , pass it as
   3183            a event to MonitorTest and return control to calling function after that */
   3184            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_BIND_RSP )
   3185            {
   3186              zdo_MTCB_MgmtBindRspCB( SrcAddr, Status, BindingCount, StartIndex,
   3187                                                            BindingListCount, pList );
   3188              return;
   3189            }
   3190          #endif  //MT_ZDO_FUNC
   3191          
   3192            if ( Status == ZSuccess )
   3193            {
   3194              for ( x = 0; x < BindingListCount; x++, pList++ )
   3195              {
   3196                // Do something with the results
   3197              }
   3198            }
   3199            else
   3200            {
   3201              // Error
   3202            }
   3203          }
   3204          #endif // ZDO_MGMT_BIND_REQUEST
   3205          
   3206          #if defined ( ZDO_MGMT_JOINDIRECT_REQUEST )
   3207          /*********************************************************************
   3208           * @fn          ZDApp_MgmtDirectJoinRspCB
   3209           *
   3210           * @brief       This function handles Management Direct Join response for the
   3211           *              Device Object application.
   3212           *
   3213           * @param       SrcAddr - source of the message
   3214           * @param       Status - ZSuccess or other for failure
   3215           * @param       SecurityUse -
   3216           *
   3217           * @return      none
   3218           */
   3219          void ZDApp_MgmtDirectJoinRspCB( uint16 SrcAddr, byte Status, byte SecurityUse )
   3220          {
   3221          #if defined ( MT_ZDO_FUNC )
   3222            /* First check if MT has subscribed for this callback. If so , pass it as
   3223            a event to MonitorTest and return control to calling function after that */
   3224            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_DIRECT_JOIN_RSP )
   3225            {
   3226              zdo_MTCB_MgmtDirectJoinRspCB( SrcAddr, Status, SecurityUse );
   3227              return;
   3228            }
   3229          #endif  //MT_ZDO_FUNC
   3230          
   3231            if ( Status == ZSuccess )
   3232            {
   3233              // Do something with the results
   3234            }
   3235            else
   3236            {
   3237              // Error
   3238            }
   3239          }
   3240          #endif // ZDO_MGMT_JOINDIRECT_REQUEST
   3241          
   3242          #if defined ( ZDO_MGMT_LEAVE_REQUEST )
   3243          /*********************************************************************
   3244           * @fn          ZDApp_MgmtLeaveRspCB
   3245           *
   3246           * @brief       This function handles Management Leave response for the
   3247           *              Device Object application.
   3248           *
   3249           * @param       SrcAddr - source of the message
   3250           * @param       Status - ZSuccess or other for failure
   3251           * @param       SecurityUse -
   3252           *
   3253           * @return      none
   3254           */
   3255          void ZDApp_MgmtLeaveRspCB( uint16 SrcAddr, byte Status, byte SecurityUse )
   3256          {
   3257          #if defined ( MT_ZDO_FUNC )
   3258            /* First check if MT has subscribed for this callback. If so , pass it as
   3259            a event to MonitorTest and return control to calling function after that */
   3260            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_LEAVE_RSP )
   3261            {
   3262              zdo_MTCB_MgmtLeaveRspCB( SrcAddr, Status, SecurityUse );
   3263              return;
   3264            }
   3265          #endif  //MT_ZDO_FUNC
   3266          
   3267            if ( Status == ZSuccess )
   3268            {
   3269              // Do something with the results
   3270            }
   3271            else
   3272            {
   3273              // Error
   3274            }
   3275          }
   3276          #endif // ZDO_MGMT_LEAVE_REQUEST
   3277          
   3278          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && !defined( REFLECTOR )
   3279          /*********************************************************************
   3280           * @fn          ZDApp_MgmtBindReqCB
   3281           *
   3282           * @brief       This function finishes the processing of the Management
   3283           *              Bind Request and generates the response.
   3284           *
   3285           * @param       none
   3286           *
   3287           * @return      none
   3288           */
   3289          void ZDApp_MgmtBindReqCB( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   3290          {
   3291            ZDO_MgmtBindReq_t *pBindReq;
   3292            osal_event_hdr_t *msgPtr;
   3293          
   3294            if ( ZDApp_MgmtBindReq_TaskID )
   3295            {
   3296              // Send the IEEE Address response structure to the registered task
   3297              msgPtr = (osal_event_hdr_t *)osal_msg_allocate( sizeof(osal_event_hdr_t) + sizeof( ZDO_MgmtBindReq_t ) );
   3298              if ( msgPtr )
   3299              {
   3300                msgPtr->event = ZDO_MGMT_BIND_REQ;
   3301                pBindReq = (ZDO_MgmtBindReq_t *)(msgPtr + 1);
   3302          
   3303                // Build the structure
   3304                pBindReq->hdr.srcAddr = SrcAddr->addr.shortAddr;
   3305                pBindReq->hdr.transSeq = TransSeq;
   3306                pBindReq->hdr.SecurityUse = SecurityUse;
   3307          
   3308                pBindReq->startIndex = StartIndex;
   3309                osal_msg_send( ZDApp_MgmtBindReq_TaskID, (uint8 *)msgPtr );
   3310              }
   3311            }
   3312          }
   3313          #endif // ZDO_MGMT_BIND_RESPONSE && !REFLECTOR
   3314          
   3315          #if defined ( ZDO_MGMT_PERMIT_JOIN_REQUEST )
   3316          
   3317          /*********************************************************************
   3318           * @fn          ZDApp_MgmtPermitJoinRspCB
   3319           *
   3320           * @brief       This function handles Management permit join response
   3321           *              for the Device Object application.
   3322           *
   3323           * @param       SrcAddr - source of the message
   3324           * @param       Status - ZSuccess or other for failure
   3325           * @param       SecurityUse -
   3326           *
   3327           * @return      none
   3328           */
   3329          void ZDApp_MgmtPermitJoinRspCB( uint16 SrcAddr, byte Status,
   3330                                          byte SecurityUse )
   3331          {
   3332          #if defined ( MT_ZDO_FUNC )
   3333            /* First check if MT has subscribed for this callback. If so , pass it as
   3334            a event to MonitorTest and return control to calling function after that */
   3335            if ( _zdoCallbackSub & CB_ID_ZDO_MGMT_PERMIT_JOIN_RSP )
   3336            {
   3337              zdo_MTCB_MgmtPermitJoinRspCB( SrcAddr, Status, SecurityUse );
   3338              return;
   3339            }
   3340          #endif  //MT_ZDO_FUNC
   3341          
   3342            if ( Status == ZSuccess )
   3343            {
   3344              // Do something with the results
   3345            }
   3346            else
   3347            {
   3348              // Error
   3349            }
   3350          }
   3351          #endif // ZDO_MGMT_LEAVE_REQUEST
   3352          
   3353          #if defined ( ZDO_USERDESC_REQUEST )
   3354          /*********************************************************************
   3355           * @fn          ZDApp_UserDescRspCB
   3356           *
   3357           * @brief       This function handles User Descriptor response for the
   3358           *              Device Object application.
   3359           *
   3360           * @param       SrcAddr - source of the message
   3361           * @param       Status - ZSuccess or other for failure
   3362           * @param       nwkAddrOfInterest - network address of remote device
   3363           * @param       userDescLen - length of user descriptor
   3364           * @param       userDesc - user descriptor byte string
   3365           * @param       SecurityUse -
   3366           *
   3367           * @return      none
   3368           */
   3369          void ZDApp_UserDescRspCB( uint16 SrcAddr, byte status, uint16 nwkAddrOfInterest,
   3370                                    byte userDescLen, byte *userDesc, byte SecurityUse )
   3371          {
   3372          #if defined ( MT_ZDO_FUNC )
   3373            /* First check if MT has subscribed for this callback. If so , pass it as
   3374            a event to MonitorTest and return control to calling function after that */
   3375            if ( _zdoCallbackSub & CB_ID_ZDO_USER_DESC_RSP )
   3376            {
   3377              zdo_MTCB_UserDescRspCB( SrcAddr, status, nwkAddrOfInterest,
   3378                                      userDescLen, userDesc, SecurityUse );
   3379              return;
   3380            }
   3381          #endif  //MT_ZDO_FUNC
   3382          
   3383            if ( status == ZSuccess )
   3384            {
   3385              // Do something with the results
   3386            }
   3387            else
   3388            {
   3389              // Error
   3390            }
   3391          }
   3392          #endif
   3393          
   3394          #if defined ( ZDO_USERDESCSET_REQUEST )
   3395          /*********************************************************************
   3396           * @fn          ZDApp_UserDescConfCB
   3397           *
   3398           * @brief       This function handles Management Direct Join response for the
   3399           *              Device Object application.
   3400           *
   3401           * @param       SrcAddr - source of the message
   3402           * @param       Status - ZSuccess or other for failure
   3403           * @param       SecurityUse -
   3404           *
   3405           * @return      none
   3406           */
   3407          void ZDApp_UserDescConfCB( uint16 SrcAddr, byte status, byte SecurityUse )
   3408          {
   3409          #if defined ( MT_ZDO_FUNC )
   3410            /* First check if MT has subscribed for this callback. If so , pass it as
   3411            a event to MonitorTest and return control to calling function after that */
   3412            if ( _zdoCallbackSub & CB_ID_ZDO_USER_DESC_CONF )
   3413            {
   3414              zdo_MTCB_UserDescConfCB( SrcAddr, status, SecurityUse );
   3415              return;
   3416            }
   3417          #endif  //MT_ZDO_FUNC
   3418          
   3419            if ( status == ZSuccess )
   3420            {
   3421              // Do something with the results
   3422            }
   3423            else
   3424            {
   3425              // Error
   3426            }
   3427          }
   3428          #endif
   3429          
   3430          #if defined ( ZDO_SERVERDISC_REQUEST )
   3431          /*********************************************************************
   3432           * @fn          ZDApp_ServerDiscRspCB
   3433           *
   3434           * @brief       Handle the Server_Discovery_rsp response.
   3435           *
   3436           * @param       srcAddr     - Source Address of the message.
   3437           * @param       status      - ZSuccess.
   3438           * @param       serverMask  - Bit mask of services matching the req serverMask.
   3439           * @param       securityUse -
   3440           *
   3441           * @return      none
   3442           */
   3443          void ZDApp_ServerDiscRspCB( uint16 srcAddr, byte status,
   3444                                      uint16 serverMask, byte securityUse )
   3445          {
   3446          #if defined ( MT_ZDO_FUNC )
   3447            if ( _zdoCallbackSub & CB_ID_ZDO_SERVERDISC_RSP )
   3448            {
   3449              zdo_MTCB_ServerDiscRspCB( srcAddr, status, serverMask, securityUse );
   3450              return;
   3451            }
   3452          #endif
   3453          
   3454            if ( status == ZSuccess )
   3455            {
   3456              // Do something with the results.
   3457            }
   3458            else
   3459            {
   3460              // Error
   3461            }
   3462          }
   3463          #endif
   3464          
   3465          /*********************************************************************
   3466           * @fn      ZDApp_EndDeviceAnnounceCB()
   3467           *
   3468           * @brief   Received an End Device Announce.
   3469           *
   3470           * @param   SrcAddr - Source of the message
   3471           * @param   nwkAddr - short address of the new device
   3472           * @param   extAddr - IEEE address of the new device
   3473           * @param   capabilities - device capabilities.  This field is only
   3474           *             populated in a v1.1 network so use the following before
   3475           *             using it:
   3476           *                  if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
   3477           *
   3478           * @return  none
   3479           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3480          void ZDApp_EndDeviceAnnounceCB( uint16 SrcAddr, uint16 nwkAddr, uint8 *extAddr,
   \                     ZDApp_EndDeviceAnnounceCB:
   3481                                         uint8 capabilities )
   3482          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   7418         MOV     A,#0x18
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   3483            ZDO_EndDeviceAnnounce_t Announce;
   3484          
   3485            // If it interests you - put your own code here.
   3486          
   3487            if ( ZDApp_EndDeviceAnnounce_TaskID )
   \   000016   90....       MOV     DPTR,#??ZDApp_EndDeviceAnnounce_TaskID
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   6043         JZ      ??ZDApp_EndDeviceAnnounceCB_0
   3488            {
   3489              // Build the structure
   3490              Announce.srcAddr = SrcAddr;
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   EA           MOV     A,R2
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   EB           MOV     A,R3
   \   000025   F0           MOVX    @DPTR,A
   3491              Announce.nwkAddr = nwkAddr;
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   EC           MOV     A,R4
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   ED           MOV     A,R5
   \   00002F   F0           MOVX    @DPTR,A
   3492              osal_cpyExtAddr( Announce.extAddr, extAddr );
   \   000030                ; Setup parameters for call to function osal_cpyExtAddr
   \   000030   E8           MOV     A,R0
   \   000031   FC           MOV     R4,A
   \   000032   E9           MOV     A,R1
   \   000033   FD           MOV     R5,A
   \   000034   7406         MOV     A,#0x6
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   AA82         MOV     R2,DPL
   \   00003B   AB83         MOV     R3,DPH
   \   00003D   90....       MOV     DPTR,#(osal_cpyExtAddr & 0xffff)
   \   000040   74..         MOV     A,#((osal_cpyExtAddr >> 16) & 0xff)
   \   000042   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3493              Announce.capabilities = capabilities;
   \   000045   740E         MOV     A,#0xe
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   EE           MOV     A,R6
   \   00004B   12....       LCALL   ?Subroutine1 & 0xFFFF
   3494          
   3495              ZDApp_SendMsg( ZDApp_EndDeviceAnnounce_TaskID, ZDO_END_DEVICE_ANNOUNCE,
   3496                            sizeof( ZDO_EndDeviceAnnounce_t ), (uint8 *)&Announce );
   \                     ??CrossCallReturnLabel_3:
   \   00004E   AC82         MOV     R4,DPL
   \   000050   AD83         MOV     R5,DPH
   \   000052   7B0F         MOV     R3,#0xf
   \   000054   7AD5         MOV     R2,#-0x2b
   \   000056   90....       MOV     DPTR,#??ZDApp_EndDeviceAnnounce_TaskID
   \   000059   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00005C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3497            }
   3498          }
   \                     ??ZDApp_EndDeviceAnnounceCB_0:
   \   00005F   740F         MOV     A,#0xf
   \   000061   02....       LJMP    ?Subroutine27 & 0xFFFF
   3499          
   3500          /*********************************************************************
   3501           * @fn      ZDApp_ChangeMatchDescRespPermission()
   3502           *
   3503           * @brief   Changes the Match Descriptor Response permission.
   3504           *
   3505           * @param   endpoint - endpoint to allow responses
   3506           * @param   action - true to allow responses, false to not
   3507           *
   3508           * @return  none
   3509           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3510          void ZDApp_ChangeMatchDescRespPermission( uint8 endpoint, uint8 action )
   \                     ZDApp_ChangeMatchDescRespPermission:
   3511          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3512            // Store the action
   3513            afSetMatch( endpoint, action );
   \   000004                ; Setup parameters for call to function afSetMatch
   \   000004   90....       MOV     DPTR,#(afSetMatch & 0xffff)
   \   000007   74..         MOV     A,#((afSetMatch >> 16) & 0xff)
   \   000009   02....       LJMP    ??Subroutine31_0 & 0xFFFF
   3514          }
   3515          
   3516          /*********************************************************************
   3517           * @fn      ZDApp_NetworkInit()
   3518           *
   3519           * @brief   Used to start the network joining process
   3520           *
   3521           * @param   delay - mSec delay to wait before starting
   3522           *
   3523           * @return  none
   3524           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3525          void ZDApp_NetworkInit( uint16 delay )
   \                     ZDApp_NetworkInit:
   3526          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3527            if ( delay )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??ZDApp_NetworkInit_0
   \   000007   EB           MOV     A,R3
   \                     ??ZDApp_NetworkInit_0:
   \   000008   600D         JZ      ??ZDApp_NetworkInit_1
   3528            {
   3529              // Wait awhile before starting the device
   3530              osal_start_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT, delay );
   \   00000A                ; Setup parameters for call to function osal_start_timerEx
   \   00000A   EA           MOV     A,R2
   \   00000B   FC           MOV     R4,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FD           MOV     R5,A
   \   00000E   7A01         MOV     R2,#0x1
   \   000010   7B00         MOV     R3,#0x0
   \   000012   12....       LCALL   ??Subroutine5_1 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000015   8005         SJMP    ??CrossCallReturnLabel_68
   3531            }
   3532            else
   3533            {
   3534              osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   \                     ??ZDApp_NetworkInit_1:
   \   000017                ; Setup parameters for call to function osal_set_event
   \   000017   7A01         MOV     R2,#0x1
   \   000019   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00001C   02....       LJMP    ??Subroutine31_0 & 0xFFFF
   3535            }
   3536          }
   3537          
   3538          #if defined ( ZDO_IEEEADDR_REQUEST )
   3539          /*********************************************************************
   3540           * @fn      ZDApp_RegisterForIEEEAddrRsp()
   3541           *
   3542           * @brief   Register to receive IEEE Addr Response messages
   3543           *
   3544           * @param   TaskID - ID of task to send message
   3545           *
   3546           * @return  none
   3547           */
   3548          void ZDApp_RegisterForIEEEAddrRsp( byte TaskID )
   3549          {
   3550            ZDApp_IEEEAddrRsp_TaskID = TaskID;    // Only 1 task at a time
   3551          }
   3552          #endif // defined ( ZDO_IEEEADDR_REQUEST )
   3553          
   3554          #if defined ( ZDO_NWKADDR_REQUEST )
   3555          /*********************************************************************
   3556           * @fn      ZDApp_RegisterForNwkAddrRsp()
   3557           *
   3558           * @brief   Register to receive NWK Addr Response messages
   3559           *
   3560           * @param   TaskID - ID of task to send message
   3561           *
   3562           * @return  none
   3563           */
   3564          void ZDApp_RegisterForNwkAddrRsp( byte TaskID )
   3565          {
   3566            ZDApp_NwkAddrRsp_TaskID = TaskID;    // Only 1 task at a time
   3567          }
   3568          #endif // defined ( ZDO_NWKADDR_REQUEST )
   3569          
   3570          /*********************************************************************
   3571           * @fn      ZDApp_RegisterForMatchDescRsp()
   3572           *
   3573           * @brief   Register to receive Match Descriptor Response messages
   3574           *
   3575           * @param   TaskID - ID of task to send message
   3576           *
   3577           * @return  none
   3578           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3579          void ZDApp_RegisterForMatchDescRsp( byte TaskID )
   \                     ZDApp_RegisterForMatchDescRsp:
   3580          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3581            ZDApp_MatchDescRsp_TaskID = TaskID;    // Only 1 task at a time
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#??ZDApp_MatchDescRsp_TaskID
   \   000008   F0           MOVX    @DPTR,A
   3582          }
   \   000009   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   3583          
   3584          /*********************************************************************
   3585           * @fn      ZDApp_RegisterForEndDeviceAnnounce()
   3586           *
   3587           * @brief   Register to receive End Device Announce messages
   3588           *
   3589           * @param   TaskID - ID of task to send message
   3590           *
   3591           * @return  none
   3592           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3593          void ZDApp_RegisterForEndDeviceAnnounce( byte TaskID )
   \                     ZDApp_RegisterForEndDeviceAnnounce:
   3594          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3595            ZDApp_EndDeviceAnnounce_TaskID = TaskID;    // Only 1 task at a time
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#??ZDApp_EndDeviceAnnounce_TaskID
   \   000008   F0           MOVX    @DPTR,A
   3596          }
   \   000009   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   3597          
   3598          #if defined ( ZDO_BIND_UNBIND_REQUEST )
   3599          /*********************************************************************
   3600           * @fn      ZDApp_RegisterForBindRsp()
   3601           *
   3602           * @brief   Register to receive Bind_rsp and Unbind_rsp messages
   3603           *
   3604           * @param   TaskID - ID of task to send message
   3605           *
   3606           * @return  none
   3607           */
   3608          void ZDApp_RegisterForBindRsp( byte TaskID )
   3609          {
   3610            ZDApp_BindUnbindRsp_TaskID = TaskID;    // Only 1 task at a time
   3611          }
   3612          #endif // ZDO_BIND_UNBIND_REQUEST
   3613          
   3614          #if defined ( ZDO_BIND_UNBIND_RESPONSE ) && !defined ( REFLECTOR )
   3615          /*********************************************************************
   3616           * @fn      ZDApp_RegisterForBindReq()
   3617           *
   3618           * @brief   Register to receive Bind and Unbind Request messages
   3619           *
   3620           * @param   TaskID - ID of task to send message
   3621           *
   3622           * @return  none
   3623           */
   3624          void ZDApp_RegisterForBindReq( byte TaskID )
   3625          {
   3626            ZDApp_BindReq_TaskID = TaskID;
   3627          }
   3628          #endif
   3629          
   3630          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && !defined ( REFLECTOR )
   3631          /*********************************************************************
   3632           * @fn      ZDApp_RegisterForMgmtBindReq()
   3633           *
   3634           * @brief   Register to receive Mgmt Bind Request messages
   3635           *
   3636           * @param   TaskID - ID of task to send message
   3637           *
   3638           * @return  none
   3639           */
   3640          void ZDApp_RegisterForMgmtBindReq( byte TaskID )
   3641          {
   3642            ZDApp_MgmtBindReq_TaskID = TaskID;
   3643          }
   3644          #endif
   3645          
   3646          /*********************************************************************
   3647           * @fn      ZDApp_StartUpFromApp()
   3648           *
   3649           * @brief   Start the device.  This function will only start a device
   3650           *          that is in the Holding state.
   3651           *
   3652           * @param   mode - ZDAPP_STARTUP_COORD - Start up as coordinator only
   3653           *                 ZDAPP_STARTUP_ROUTER - Start up as router only
   3654           *                 ZDAPP_STARTUP_AUTO - Startup in auto, look for coord,
   3655           *                                       if not found, become coord.
   3656           *
   3657           * @return  TRUE if started, FALSE if in the wrong mode
   3658           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3659          ZStatus_t ZDApp_StartUpFromApp( uint8 mode )
   \                     ZDApp_StartUpFromApp:
   3660          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3661            ZStatus_t ret = ZFailure;
   \   000004   7901         MOV     R1,#0x1
   3662          
   3663            if ( devState == DEV_HOLD )
   \   000006   90....       MOV     DPTR,#devState
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   700E         JNZ     ??ZDApp_StartUpFromApp_0
   3664            {
   3665              // Start the device's joining process
   3666              if ( ZDOInitDevice( 0 ) == ZDO_INITDEV_NEW_NETWORK_STATE )
   \   00000C                ; Setup parameters for call to function ZDOInitDevice
   \   00000C   7A00         MOV     R2,#0x0
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#(ZDOInitDevice & 0xffff)
   \   000013   74..         MOV     A,#((ZDOInitDevice >> 16) & 0xff)
   \   000015   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3667              {
   3668          #if defined( SOFT_START )
   3669                if ( mode == ZDAPP_STARTUP_COORD )
   3670                {
   3671                  devStartMode = MODE_HARD;     // Start as a coordinator
   3672                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   3673                }
   3674                else
   3675                {
   3676                  if ( mode == ZDAPP_STARTUP_ROUTER )
   3677                  {
   3678                    softStartAllowCoord = FALSE;  // Don't allow coord to start
   3679                    continueJoining = TRUE;
   3680                  }
   3681                  devStartMode = MODE_JOIN;     // Assume joining
   3682                }
   3683          #endif  // SOFT_START
   3684              }
   3685              ret = ZSuccess;
   \   000018   7900         MOV     R1,#0x0
   3686            }
   3687          
   3688            return ( ret );
   \                     ??ZDApp_StartUpFromApp_0:
   \   00001A   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   3689          }
   3690          
   3691          /*********************************************************************
   3692           * @fn      ZDApp_StopStartUp()
   3693           *
   3694           * @brief   Stops the joining process of a router.  This will only
   3695           *          work if the router is in the scanning process and
   3696           *          the SOFT_START feature is enabled.
   3697           *
   3698           * @param   none
   3699           *
   3700           * @return  TRUE if SOFT_START is enabled, FALSE if not possible
   3701           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3702          uint8 ZDApp_StopStartUp( void )
   \                     ZDApp_StopStartUp:
   3703          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3704            uint8 ret = FALSE;
   3705          
   3706          #if defined( SOFT_START )
   3707            continueJoining = FALSE;
   3708            ret = TRUE;
   3709          #endif  // SOFT_START
   3710          
   3711            return ( ret );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
   3712          }
   3713          
   3714          /*********************************************************************
   3715           * @fn      ZDApp_StartJoiningCycle()
   3716           *
   3717           * @brief   Starts the joining cycle of a device.  This will only
   3718           *          continue an already started (or stopped) joining cycle.
   3719           *
   3720           * @param   none
   3721           *
   3722           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   3723           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3724          uint8 ZDApp_StartJoiningCycle( void )
   \                     ZDApp_StartJoiningCycle:
   3725          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3726            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   6005         JZ      ??ZDApp_StartJoiningCycle_0
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6402         XRL     A,#0x2
   \   00000F   700F         JNZ     ??ZDApp_StartJoiningCycle_1
   3727            {
   3728              continueJoining = TRUE;
   \                     ??ZDApp_StartJoiningCycle_0:
   \   000011   7401         MOV     A,#0x1
   \   000013   90....       MOV     DPTR,#continueJoining
   \   000016   12....       LCALL   ?Subroutine2 & 0xFFFF
   3729              ZDApp_NetworkInit( 0 );
   \                     ??CrossCallReturnLabel_60:
   \   000019   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   3730          
   3731              return ( TRUE );
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   8002         SJMP    ??ZDApp_StartJoiningCycle_2
   3732            }
   3733            else
   3734              return ( FALSE );
   \                     ??ZDApp_StartJoiningCycle_1:
   \   000020   7900         MOV     R1,#0x0
   \                     ??ZDApp_StartJoiningCycle_2:
   \   000022   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   3735          }
   3736          
   3737          /*********************************************************************
   3738           * @fn      ZDApp_StopJoiningCycle()
   3739           *
   3740           * @brief   Stops the joining or rejoining process of a device.
   3741           *
   3742           * @param   none
   3743           *
   3744           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   3745           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3746          uint8 ZDApp_StopJoiningCycle( void )
   \                     ZDApp_StopJoiningCycle:
   3747          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3748            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   6005         JZ      ??ZDApp_StopJoiningCycle_0
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6402         XRL     A,#0x2
   \   00000F   7009         JNZ     ??ZDApp_StopJoiningCycle_1
   3749            {
   3750              continueJoining = FALSE;
   \                     ??ZDApp_StopJoiningCycle_0:
   \   000011   E4           CLR     A
   \   000012   90....       MOV     DPTR,#continueJoining
   \   000015   F0           MOVX    @DPTR,A
   3751              return ( TRUE );
   \   000016   7901         MOV     R1,#0x1
   \   000018   8002         SJMP    ??ZDApp_StopJoiningCycle_2
   3752            }
   3753            else
   3754              return ( FALSE );
   \                     ??ZDApp_StopJoiningCycle_1:
   \   00001A   7900         MOV     R1,#0x0
   \                     ??ZDApp_StopJoiningCycle_2:
   \   00001C   02....       LJMP    ??Subroutine25_0 & 0xFFFF
   3755          }
   3756          
   3757          #if !defined ( ZDO_COORDINATOR ) || defined ( SOFT_START )
   3758          /*********************************************************************
   3759           * @fn      ZDApp_NodeProfileSync()
   3760           *
   3761           * @brief   Sync node with stack profile.
   3762           *
   3763           * @param   cfm - ZDO_NetworkDiscoveryCfm_t
   3764           *
   3765           * @return  none
   3766           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   3767          void ZDApp_NodeProfileSync( ZDO_NetworkDiscoveryCfm_t* cfm )
   \                     ZDApp_NodeProfileSync:
   3768          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3769            networkDesc_t* desc;
   3770            uint16         panID;
   3771          
   3772            if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_DEVICETYPE_FFD  )
   \   000005   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   000008   E0           MOVX    A,@DPTR
   \   000009   A2E1         MOV     C,0xE0 /* A   */.1
   \   00000B   505E         JNC     ??ZDApp_NodeProfileSync_0
   3773            {
   3774              panID = BUILD_UINT16( cfm->panIdLSB, cfm->panIdMSB );
   3775          
   3776              desc = nwk_getNetworkDesc( cfm->extendedPANID, panID, cfm->logicalChannel );
   \   00000D                ; Setup parameters for call to function nwk_getNetworkDesc
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   8A82         MOV     DPL,R2
   \   000019   8B83         MOV     DPH,R3
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   FE           MOV     R6,A
   \   00001F   8A82         MOV     DPL,R2
   \   000021   8B83         MOV     DPH,R3
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FD           MOV     R5,A
   \   000028   E4           CLR     A
   \   000029   2E           ADD     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   ED           MOV     A,R5
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FD           MOV     R5,A
   \   00002F   EA           MOV     A,R2
   \   000030   2406         ADD     A,#0x6
   \   000032   FA           MOV     R2,A
   \   000033   EB           MOV     A,R3
   \   000034   3400         ADDC    A,#0x0
   \   000036   FB           MOV     R3,A
   \   000037   90....       MOV     DPTR,#(nwk_getNetworkDesc & 0xffff)
   \   00003A   74..         MOV     A,#((nwk_getNetworkDesc >> 16) & 0xff)
   \   00003C   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   3777          
   3778              if (desc != NULL)
   \   000043   E582         MOV     A,DPL
   \   000045   7002         JNZ     ??ZDApp_NodeProfileSync_1
   \   000047   E583         MOV     A,DPH
   \                     ??ZDApp_NodeProfileSync_1:
   \   000049   6020         JZ      ??ZDApp_NodeProfileSync_0
   3779              {
   3780                if ( desc->stackProfile != zgStackProfile )
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FA           MOV     R2,A
   \   000055   90....       MOV     DPTR,#zgStackProfile
   \   000058   E0           MOVX    A,@DPTR
   \   000059   6A           XRL     A,R2
   \   00005A   600F         JZ      ??ZDApp_NodeProfileSync_0
   3781                {
   3782                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_DEVICE;
   \   00005C   90....       MOV     DPTR,#ZDO_Config_Node_Descriptor
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   54F8         ANL     A,#0xf8
   \   000062   4402         ORL     A,#0x2
   \   000064   F0           MOVX    @DPTR,A
   3783                  ZDO_Config_Node_Descriptor.CapabilityFlags = CAPINFO_DEVICETYPE_RFD | CAPINFO_POWER_AC | CAPINFO_RCVR_ON_IDLE;
   \   000065   740C         MOV     A,#0xc
   \   000067   90....       MOV     DPTR,#(ZDO_Config_Node_Descriptor + 2)
   \   00006A   F0           MOVX    @DPTR,A
   3784                }
   3785              }
   3786            }
   3787          }
   \                     ??ZDApp_NodeProfileSync_0:
   \   00006B   02....       LJMP    ??Subroutine26_1 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   EE           MOV     A,R6
   \   000003   2402         ADD     A,#0x2
   \   000005   FA           MOV     R2,A
   \   000006   EF           MOV     A,R7
   \   000007   3400         ADDC    A,#0x0
   \   000009   FB           MOV     R3,A
   \   00000A   90....       MOV     DPTR,#(NLME_RemoveChild & 0xffff)
   \   00000D   74..         MOV     A,#((NLME_RemoveChild >> 16) & 0xff)
   \   00000F   22           RET

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zdoDiscCounter>`:
   \   000000   01           DB 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for continueJoining>`:
   \   000000   01           DB 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for devState>`:
   \   000000   01           DB 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for sPVerList>`:
   \   000000   0201         DB 2, 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDApp_epDesc>`:
   \   000000   00           DB 0
   \   000001   ....0000     DW ZDAppTaskID, 0H
   \   000005   00           DB 0

   \                                 In segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
   3788          #endif
   3789          
   3790          /*********************************************************************
   3791          *********************************************************************/

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     AddrMgrWriteNVRequest              0      0     10
       -> osal_get_timeoutEx            0      0     20
       -> osal_start_timerEx            0      0     20
     ZDAppCheckForHoldKey               4      0      1
       -> HalKeyRead                    4      0      0
     ZDAppDetermineDeviceType           0      0      0
     ZDAppSetupProtoVersion             5      0      2
       -> NLME_GetProtocolVersion       4      0      2
       -> NLME_SetRequest               4      0      2
       -> osal_memset                   4      0      2
     ZDApp_AutoFindDestinationEx        1      0     32
       -> HalLedSet                     0      0     48
       -> afFindEndPointDesc            0      0     48
       -> osal_mem_alloc                0      0     48
       -> osal_memcpy                   0      0     54
       -> ZDP_MatchDescReq              0      0     64
     ZDApp_ChangeMatchDescRespPermission
                                        2      0      0
       -> afSetMatch                    4      0      0
     ZDApp_EndDeviceAnnounceCB          1      0     26
       -> osal_cpyExtAddr               0      0     48
       -> ZDApp_SendMsg                 0      0     48
     ZDApp_EndDeviceBindRsp             2      0      0
       -> HalLedSet                     4      0      0
       -> HalLedSet                     4      0      0
     ZDApp_InMsgCB                      0      0     19
       -> ZDP_GenericRsp                0      0     28
     ZDApp_Init                         2      0      1
       -> NLME_GetExtAddr               4      0      2
       -> ZDAppCheckForHoldKey          4      0      2
       -> ZDO_Init                      4      0      2
       -> afRegister                    4      0      2
       -> ZDAppSetupProtoVersion        4      0      2
       -> NLME_GetRequest               4      0      2
       -> NLME_SetBroadcastFilter       4      0      2
       -> ZDOInitDevice                 4      0      2
       -> HalLedBlink                   4      0      2
     ZDApp_InitUserDesc                 0      0     31
       -> osal_memset                   0      0     54
       -> osal_nv_item_init             0      0     58
       -> osal_nv_read                  0      0     62
     ZDApp_LeaveCtrlBypass              2      0      0
     ZDApp_LeaveCtrlInit                0      0     26
       -> osal_nv_item_init             0      0     24
       -> osal_nv_read                  0      0     28
     ZDApp_LeaveCtrlSet                 2      0     14
       -> osal_nv_write                 0      0     28
     ZDApp_LeaveCtrlStartup             1      0     26
       -> osal_nv_write                 0      0     28
     ZDApp_LeaveReset                   2      0     12
       -> ZDApp_LeaveCtrlSet            4      0      0
       -> ZDApp_ResetTimerStart         4      0      0
     ZDApp_LeaveUpdate                  2      0      0
       -> NLME_RemoveChild              4      0      0
     ZDApp_MatchDescRspCB               1      0     21
       -> osal_msg_allocate             0      0     32
       -> osal_memcpy                   0      0     38
       -> osal_msg_send                 0      0     32
       -> ZDApp_SendNewDstAddr          0      0     38
       -> HalLedSet                     0      0     32
     ZDApp_NetworkInit                  4      0     12
       -> osal_start_timerEx            4      0      0
       -> osal_set_event                4      0      0
     ZDApp_NetworkStartEvt              2      0     10
       -> osal_pwrmgr_device            4      0      0
       -> osal_set_event                4      0      0
       -> NLME_GetEnergyThreshold       4      0      0
       -> NLME_GetEnergyThreshold       4      0      0
       -> NLME_SetEnergyThreshold       4      0      0
       -> osal_set_event                4      0      0
       -> osal_set_event                4      0      0
     ZDApp_NodeProfileSync              0      0     20
       -> nwk_getNetworkDesc            0      0     20
     ZDApp_ProcessNetworkJoin           0      0     22
       -> osal_set_event                0      0     24
       -> NLME_StartRouterRequest       0      0     24
       -> NLME_GetShortAddr             0      0     24
       -> ZMacSetReq                    0      0     24
       -> osal_rand                     0      0     24
       -> ZDApp_NetworkInit             0      0     24
       -> osal_set_event                0      0     24
       -> NLME_SetPollRate              0      0     24
       -> NLME_SetQueuedPollRate        0      0     24
       -> NLME_SetResponseRate          0      0     24
       -> osal_rand                     0      0     24
       -> ZDApp_NetworkInit             0      0     24
     ZDApp_ProcessOSALMsg               0      0     21
       -> ZDP_IncomingData              0      0     20
       -> ZDApp_NodeProfileSync         0      0     20
       -> NLME_JoinRequest              0      0     22
       -> osal_rand                     0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> NLME_ReJoinRequest            0      0     20
       -> osal_rand                     0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> NLME_SetPollRate              0      0     20
       -> NLME_SetQueuedPollRate        0      0     20
       -> NLME_SetResponseRate          0      0     20
       -> osal_rand                     0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> ZDApp_ProcessNetworkJoin      0      0     20
       -> ZDApp_NetworkInit             0      0     20
       -> osal_set_event                0      0     20
     ZDApp_ReadNetworkRestoreState      0      0      9
       -> zgReadStartupOptions          0      0     18
     ZDApp_RegisterForEndDeviceAnnounce
                                        2      0      0
     ZDApp_RegisterForMatchDescRsp      2      0      0
     ZDApp_ResetTimerCancel             2      0      0
       -> osal_stop_timerEx             4      0      0
     ZDApp_ResetTimerStart              4      0      0
       -> osal_start_timerEx            4      0      0
     ZDApp_RestoreNetworkState          0      0      9
       -> NLME_InitNV                   0      0     18
       -> NLME_RestoreFromNV            0      0     18
       -> NLME_GetShortAddr             0      0     18
     ZDApp_SaveNetworkStateEvt          0      0      0
     ZDApp_SendEndDeviceBindReq         1      0     29
       -> HalLedSet                     0      0     40
       -> afFindSimpleDesc              0      0     40
       -> ZDP_EndDeviceBindReq          0      0     58
       -> osal_mem_free                 0      0     40
     ZDApp_SendEventMsg                 2      0      0
       -> ZDApp_SendMsg                 4      0      0
     ZDApp_SendMsg                      3      0     46
       -> osal_msg_allocate             0      0     32
       -> osal_memcpy                   0      0     38
       -> osal_msg_send                 0      0     32
     ZDApp_SendNewDstAddr               1      0     40
       -> osal_msg_allocate             0      0     36
       -> osal_memcpy                   0      0     42
       -> osal_msg_send                 0      0     36
     ZDApp_StartJoiningCycle            2      0      0
       -> ZDApp_NetworkInit             4      0      0
     ZDApp_StartUpFromApp               2      0      0
       -> ZDOInitDevice                 4      0      0
     ZDApp_StopJoiningCycle             2      0      0
     ZDApp_StopStartUp                  0      0      0
     ZDApp_event_loop                   0      0     10
       -> ZDO_StartDevice               0      0     20
       -> ZDApp_ProcessOSALMsg          0      0     20
       -> osal_msg_deallocate           0      0     20
       -> osal_msg_receive              0      0     20
       -> ZDApp_NetworkStartEvt         0      0     20
       -> osal_pwrmgr_device            0      0     20
       -> osal_set_event                0      0     20
       -> ZDO_UpdateNwkStatus           0      0     20
     ZDOInitDevice                      2      0     13
       -> ZDApp_LeaveCtrlInit           0      0     24
       -> ZDApp_LeaveCtrlStartup        0      0     24
       -> osal_rand                     0      0     24
       -> ZDApp_NetworkInit             0      0     24
     ZDO_JoinConfirmCB                  2      0      0
       -> HalLedSet                     4      0      0
       -> HalLedSet                     4      0      0
       -> osal_start_timerEx            4      0      0
       -> HalLedSet                     4      0      0
       -> ZDApp_SendMsg                 4      0      0
     ZDO_JoinIndicationCB               2      0      0
       -> osal_start_timerEx            4      0      0
     ZDO_LeaveCnf                       0      0      9
       -> NLME_GetExtAddr               0      0     18
       -> osal_ExtAddrEqual             0      0     18
       -> ZDApp_LeaveReset              0      0     18
       -> NLME_RemoveChild              0      0     18
     ZDO_LeaveInd                       2      0     12
       -> NLME_LeaveRsp                 0      0     24
       -> NLME_GetCoordShortAddr        4      0     24
       -> ZDApp_LeaveReset              0      0     24
       -> NLME_RemoveChild              0      0     24
     ZDO_NetworkDiscoveryConfirmCB      2      0     27
       -> NLME_GetProtocolVersion       0      0     54
       -> NLME_SetRequest               0      0     54
       -> osal_start_timerEx            0      0     54
       -> osal_cpyExtAddr               0      0     54
       -> ZDApp_SendMsg                 0      0     54
     ZDO_NetworkFormationConfirmCB      0      0      0
     ZDO_PollConfirmCB                  0      0      0
     ZDO_StartRouterConfirmCB           2      0      0
       -> HalLedSet                     4      0      0
       -> HalLedSet                     4      0      0
       -> HalLedSet                     4      0      0
       -> osal_set_event                4      0      0
     ZDO_SyncIndicationCB               0      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     WDCTL                             1
     zdoDiscCounter                    1
     ZDAppNwkAddr                      9
     continueJoining                   1
     _tmpRejoinState                   1
     ZDAppTaskID                       1
     nwkStatus                         1
     ZDApp_AutoFindMode_epDesc         2
     ZDApp_LeaveCtrl                   1
     devState                          1
     devStartMode                      1
     ZDApp_MatchDescRsp_TaskID         1
     ZDApp_EndDeviceAnnounce_TaskID    1
     retryCnt                          1
     sPVerList                         2
     ZDApp_epDesc                      6
     ZDApp_Init                      149
     ?Subroutine25                    15
     ZDApp_event_loop                241
     ?Subroutine26                    10
     ?Subroutine28                    13
     ?Subroutine6                      5
     ZDOInitDevice                   117
     ZDApp_ReadNetworkRestoreState    25
     ?Subroutine27                     8
     ZDAppDetermineDeviceType          3
     ZDApp_NetworkStartEvt            95
     ?Subroutine31                     9
     ZDApp_SaveNetworkStateEvt         3
     ZDApp_RestoreNetworkState        82
     ZDAppSetupProtoVersion           70
     ZDApp_InitUserDesc              136
     ZDAppCheckForHoldKey             25
     ZDApp_ProcessOSALMsg            319
     ?Subroutine14                    11
     ?Subroutine29                     8
     ?Subroutine0                      6
     ?Subroutine12                     9
     ?Subroutine13                    10
     ?Subroutine2                      6
     ZDApp_ProcessNetworkJoin        393
     ?Subroutine1                      8
     ZDApp_SendEndDeviceBindReq      215
     ?Subroutine10                     4
     ?Subroutine20                    10
     ?Subroutine7                      7
     ?Subroutine11                     8
     ?Subroutine21                     4
     ?Subroutine24                     9
     ZDApp_AutoFindDestinationEx     301
     ZDApp_ResetTimerStart            18
     ?Subroutine5                     19
     ZDApp_ResetTimerCancel           21
     ZDApp_LeaveCtrlInit              75
     ?Subroutine3                     14
     ZDApp_LeaveCtrlSet               60
     ZDApp_LeaveCtrlBypass            17
     ZDApp_LeaveCtrlStartup           84
     ZDApp_LeaveReset                 23
     ZDApp_LeaveUpdate                15
     ZDApp_SendNewDstAddr            181
     ?Subroutine30                     5
     ?Subroutine18                     9
     ?Subroutine22                     9
     ZDApp_SendEventMsg                8
     ?Subroutine32                     6
     ?Subroutine8                     11
     ZDApp_SendMsg                   104
     ZDApp_MatchDescRspCB            229
     ?Subroutine4                      7
     ?Subroutine19                     7
     ZDApp_EndDeviceBindRsp           23
     ZDO_NetworkDiscoveryConfirmCB   393
     ?Subroutine16                     5
     ?Subroutine23                    15
     ?Subroutine17                    11
     ZDO_NetworkFormationConfirmCB     3
     ZDO_StartRouterConfirmCB         60
     ZDO_JoinConfirmCB                73
     ZDO_JoinIndicationCB             15
     ZDO_LeaveCnf                     73
     ?Subroutine15                    14
     ZDO_LeaveInd                    151
     ZDO_SyncIndicationCB              3
     ZDO_PollConfirmCB                 3
     AddrMgrWriteNVRequest            41
     ZDApp_InMsgCB                    87
     ZDApp_EndDeviceAnnounceCB       100
     ZDApp_ChangeMatchDescRespPermission
                                      12
     ZDApp_NetworkInit                31
     ZDApp_RegisterForMatchDescRsp    12
     ZDApp_RegisterForEndDeviceAnnounce
                                      12
     ZDApp_StartUpFromApp             29
     ZDApp_StopStartUp                 5
     ZDApp_StartJoiningCycle          37
     ZDApp_StopJoiningCycle           31
     ZDApp_NodeProfileSync           110
     ?Subroutine9                     16
     ?<Initializer for zdoDiscCounter>
                                       1
     ?<Initializer for continueJoining>
                                       1
     ?<Initializer for devState>       1
     ?<Initializer for sPVerList>      2
     ?<Initializer for ZDApp_epDesc>
                                       6
     _A_IEN0                           1

 
 4 621 bytes in segment BANKED_CODE
     2 bytes in segment SFR_AN
    11 bytes in segment XDATA_I
    11 bytes in segment XDATA_ID
    19 bytes in segment XDATA_Z
 
 4 632 bytes of CODE  memory
     0 bytes of DATA  memory (+ 2 bytes shared)
    30 bytes of XDATA memory

Errors: none
Warnings: none
