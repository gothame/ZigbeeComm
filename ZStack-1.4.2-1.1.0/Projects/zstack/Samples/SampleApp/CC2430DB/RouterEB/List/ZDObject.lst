##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   24/Jan/2013  14:47:49 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  xdata reentrant                                   #
#    Constant location  =  data                                              #
#    Dptr setup         =  1,16                                              #
#    Source file        =  D:\Texas Instruments\ZStack-1.4.2-1.1.0\Component #
#                          s\stack\zdo\ZDObject.c                            #
#    Command line       =  -f E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç #
#                          ¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006 #
#                          -´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8 #
#                          wRouter.cfg (-DCPU32MHZ -DFORCE_MAC_NEAR          #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TR #
#                          UE -DRTR_NWK -DBLINK_LEDS "-DCONST=const __code"  #
#                          -DGENERIC=__generic) -f                           #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\Tools\CC2430DB\f8wCo #
#                          nfig.cfg (-DSECURE=0 -DDEFAULT_CHANLIST=0x0000080 #
#                          0 -DZDAPP_CONFIG_PAN_ID=0xFFFF                    #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M #
#                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                    #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P #
#                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           #
#                          -DMAX_RREQ_ENTRIES=10 -DAPSC_MAX_FRAME_RETRIES=3  #
#                          -DNWK_MAX_DATA_RETRIES=2                          #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=20          #
#                          -DNWK_MAX_BINDING_ENTRIES=10                      #
#                          -DMAX_BINDING_CLUSTER_IDS=5                       #
#                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     #
#                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   #
#                          0x0A, 0x0C, 0x0D}" -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100           #
#                          -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440   #
#                          -DTOP_BOOT_PAGES=0) -I "D:\Program Files\IAR      #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\" -I "D:\Program Files\IAR       #
#                          Systems\Embedded Workbench 4.05 Evaluation        #
#                          version\8051\inc\clib\" -I                        #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\ -I                           #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\Source\ -I                 #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\ZMain\TI2430DB\ -I   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mt\ #
#                           -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂ #
#                          ç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee200 #
#                          6-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Sam #
#                          ples\SampleApp\CC2430DB\..\..\..\..\..\Components #
#                          \hal\include\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª· #
#                          ¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2 #
#                          006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projec #
#                          ts\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\ #
#                          ..\Components\hal\target\CC2430EB\ -I             #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\osa #
#                          l\mcu\ccsoc\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢ #
#                          ×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee20 #
#                          06\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Project #
#                          s\zstack\Samples\SampleApp\CC2430DB\..\..\..\..\. #
#                          .\Components\osal\include\ -I                     #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\sta #
#                          ck\af\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\Î #
#                          ÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\Zig #
#                          Bee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zsta #
#                          ck\Samples\SampleApp\CC2430DB\..\..\..\..\..\Comp #
#                          onents\stack\nwk\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC243 #
#                          0¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zig #
#                          Bee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2430DB\..\..\.. #
#                          \..\..\Components\stack\sec\ -I                   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\sta #
#                          ck\sys\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ #
#                          ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\Zi #
#                          gBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zst #
#                          ack\Samples\SampleApp\CC2430DB\..\..\..\..\..\Com #
#                          ponents\stack\zdo\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC24 #
#                          30¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zi #
#                          gBee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\P #
#                          rojects\zstack\Samples\SampleApp\CC2430DB\..\..\. #
#                          .\..\..\Components\zmac\f8w\ -I                   #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\zma #
#                          c\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍ #
#                          øÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2 #
#                          006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\S #
#                          amples\SampleApp\CC2430DB\..\..\..\..\..\Componen #
#                          ts\services\saddr\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC24 #
#                          30¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zi #
#                          gBee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\P #
#                          rojects\zstack\Samples\SampleApp\CC2430DB\..\..\. #
#                          .\..\..\Components\services\sdata\ -I             #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mac #
#                          \include\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁ #
#                          Ï\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ #
#                          ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\z #
#                          stack\Samples\SampleApp\CC2430DB\..\..\..\..\..\C #
#                          omponents\mac\high_level\ -I                      #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\..\..\..\..\..\Components\mac #
#                          \low_level\srf03\ -I E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC243 #
#                          0¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\Zig #
#                          Bee2006\ZigBee2006-´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Pr #
#                          ojects\zstack\Samples\SampleApp\CC2430DB\..\..\.. #
#                          \..\..\Components\mac\low_level\srf03\single_chip #
#                          \ -D CC2430EB -D ZTOOL_P1 -D MT_TASK -lC          #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\ -lA            #
#                          E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\                #
#                          --diag_suppress Pe001,Pa010 --diag_remark pe550   #
#                          -o E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç #
#                          ¿ª·¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006 #
#                          -´®¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samp #
#                          les\SampleApp\CC2430DB\RouterEB\Obj\ -e           #
#                          --require_prototypes -z9 --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                  #
#                          --data_model=large --code_model=banked            #
#                          --calling_convention=xdata_reentrant              #
#                          --place_constants=data --nr_virtual_regs 8        #
#                          "D:\Texas Instruments\ZStack-1.4.2-1.1.0\Componen #
#                          ts\stack\zdo\ZDObject.c"                          #
#    List file          =  E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\List\ZDObject.lst    #
#    Object file        =  E:\ÑÐ¶þÉÏ\CPS\ÊµÑéÆ½Ì¨\CC2430¿ª·¢×ÊÁÏ\ÎÞÏßÍøÂç¿ª· #
#                          ¢Æ½Ì¨\C51RF-3-PKÑÝÊ¾³ÌÐò\ZigBee2006\ZigBee2006-´® #
#                          ¿Ú»¥·¢\ZStack-1.4.2-1.1.0\Projects\zstack\Samples #
#                          \SampleApp\CC2430DB\RouterEB\Obj\ZDObject.r51     #
#                                                                            #
#                                                                            #
##############################################################################

D:\Texas Instruments\ZStack-1.4.2-1.1.0\Components\stack\zdo\ZDObject.c
      1          /*********************************************************************
      2              Filename:       ZDObject.c
      3              Revised:        $Date: 2007-05-14 17:34:18 -0700 (Mon, 14 May 2007) $
      4              Revision:       $Revision: 14296 $
      5          
      6              Description:
      7          
      8                This Zigbee Device Object.
      9          
     10              Notes:
     11          
     12              Copyright (c) 2006 by Texas Instruments, Inc.
     13              All Rights Reserved.  Permission to use, reproduce, copy, prepare
     14              derivative works, modify, distribute, perform, display or sell this
     15              software and/or its documentation for any purpose is prohibited
     16              without the express written consent of Texas Instruments, Inc.
     17          *********************************************************************/
     18          
     19          /*********************************************************************
     20           * INCLUDES
     21           */
     22          #include "ZComdef.h"
     23          #include "OSAL.h"
     24          #include "OSAL_Nv.h"
     25          #include "rtg.h"
     26          #include "NLMEDE.h"
     27          #include "nwk_globals.h"
     28          #include "APS.h"
     29          #include "APSMEDE.h"
     30          #include "AssocList.h"
     31          #include "BindingTable.h"
     32          #include "AddrMgr.h"
     33          #include "AF.h"
     34          #include "ZDObject.h"
     35          #include "ZDProfile.h"
     36          #include "ZDConfig.h"
     37          #include "ZDCache.h"
     38          #include "ZDSecMgr.h"
     39          #include "ZDApp.h"
     40          #include "nwk_util.h"   // NLME_IsAddressBroadcast()
     41          #include "ZGlobals.h"
     42          
     43          #if defined( LCD_SUPPORTED )
     44            #include "OnBoard.h"
     45          #endif
     46          
     47          /* HAL */
     48          #include "hal_lcd.h"
     49          
     50          /*********************************************************************
     51           * MACROS
     52           */
     53          
     54          /*********************************************************************
     55           * CONSTANTS
     56           */
     57          // NLME Stub Implementations
     58          #define ZDO_ProcessMgmtPermitJoinTimeout NLME_PermitJoiningTimeout
     59          
     60          // Status fields used by ZDO_ProcessMgmtRtgReq
     61          #define ZDO_MGMT_RTG_ENTRY_ACTIVE             0x00
     62          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY 0x01
     63          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED   0x02
     64          #define ZDO_MGMT_RTG_ENTRY_INACTIVE           0x03
     65          
     66          /*********************************************************************
     67           * TYPEDEFS
     68           */
     69          #if defined ( REFLECTOR )
     70          typedef struct
     71          {
     72            byte SrcTransSeq;
     73            zAddrType_t SrcAddr;
     74            uint16 LocalCoordinator;
     75            byte epIntf;
     76            uint16 ProfileID;
     77            byte numInClusters;
     78            uint16 *inClusters;
     79            byte numOutClusters;
     80            uint16 *outClusters;
     81            byte SecurityUse;
     82            byte status;
     83          } ZDO_EDBind_t;
     84          #endif // defined ( REFLECTOR )
     85          
     86          #if defined ( ZDO_COORDINATOR )
     87          enum
     88          {
     89            ZDMATCH_INIT,           // Initialized
     90            ZDMATCH_WAIT_REQ,       // Received first request, waiting for second
     91            ZDMATCH_SENDING_BINDS   // Received both requests, sending unbind/binds
     92          };
     93          
     94          enum
     95          {
     96            ZDMATCH_REASON_START,
     97            ZDMATCH_REASON_TIMEOUT,
     98            ZDMATCH_REASON_UNBIND_RSP,
     99            ZDMATCH_REASON_BIND_RSP
    100          };
    101          
    102          enum
    103          {
    104            ZDMATCH_SENDING_NOT,
    105            ZDMATCH_SENDING_UNBIND,
    106            ZDMATCH_SENDING_BIND
    107          };
    108          
    109          typedef struct
    110          {
    111            ZDEndDeviceBind_t ed1;
    112            ZDEndDeviceBind_t ed2;
    113            uint8  state;            // One of the above states
    114            uint8  sending;         // 0 - not sent, 1 - unbind, 2 bind - expecting response
    115            uint8  transSeq;
    116            uint8  ed1numMatched;
    117            uint16 *ed1Matched;
    118            uint8  ed2numMatched;
    119            uint16 *ed2Matched;
    120          } ZDMatchEndDeviceBind_t;
    121          #endif
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
    138          static uint16 ZDOBuildBuf[26];  // temp area to build data without allocation
   \                     ??ZDOBuildBuf:
   \   000000                DS 52
    139          
    140          #if defined ( REFLECTOR )
    141          static ZDO_EDBind_t *ZDO_EDBind;     // Null when not used
    142          #endif
    143          
    144          #if defined ( MANAGED_SCAN )
    145            uint32 managedScanNextChannel = 0;
    146            uint32 managedScanChannelMask = 0;
    147            uint8  managedScanTimesPerChannel = 0;
    148          #endif
    149          
    150          #if defined ( ZDO_COORDINATOR )
    151            ZDMatchEndDeviceBind_t *matchED = (ZDMatchEndDeviceBind_t *)NULL;
    152          #endif
    153          
    154          /*********************************************************************
    155           * LOCAL FUNCTIONS
    156           */
    157          static void ZDODeviceSetup( void );
    158          static uint16 *ZDO_CreateAlignedUINT16List(uint8 num, uint8 *buf);
    159          #if defined ( MANAGED_SCAN )
    160            static void ZDOManagedScan_Next( void );
    161          #endif
    162          #if defined ( REFLECTOR )
    163            static void ZDO_RemoveEndDeviceBind( void );
    164            static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse );
    165          #endif
    166          #if defined ( REFLECTOR ) || defined( ZDO_COORDINATOR )
    167            static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    168                                          byte numList2, uint16 *list2, uint16 *pMatches );
    169          #endif
    170          #if defined ( ZDO_COORDINATOR )
    171            static void ZDO_RemoveMatchMemory( void );
    172            static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq );
    173            static uint8 ZDMatchSendState( uint8 reason, uint8 status, uint8 TransSeq );
    174            static void ZDO_EndDeviceBindMatchTimeoutCB( void );
    175          #endif
    176          
    177          /*********************************************************************
    178           * @fn          ZDO_Init
    179           *
    180           * @brief       ZDObject and ZDProfile initialization.
    181           *
    182           * @param       none
    183           *
    184           * @return      none
    185           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    186          void ZDO_Init( void )
   \                     ZDO_Init:
    187          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    188            // Initialize ZD items
    189            #if defined ( REFLECTOR )
    190            ZDO_EDBind = NULL;
    191            #endif
    192          
    193            // Setup the device - type of device to create.
    194            ZDODeviceSetup();
   \   000004                ; Setup parameters for call to function NLME_DeviceJoiningInit
   \   000004   90....       MOV     DPTR,#(NLME_DeviceJoiningInit & 0xffff)
   \   000007   74..         MOV     A,#((NLME_DeviceJoiningInit >> 16) & 0xff)
   \   000009   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    195          
    196            // Initialize ZigBee Device Security Manager
    197            ZDSecMgrInit();
   \   00000C                ; Setup parameters for call to function ZDSecMgrInit
   \   00000C   90....       MOV     DPTR,#(ZDSecMgrInit & 0xffff)
   \   00000F   74..         MOV     A,#((ZDSecMgrInit >> 16) & 0xff)
   \   000011   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    198          }
   \   000014                REQUIRE ?Subroutine21
   \   000014                ; // Fall through to label ?Subroutine21

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    199          
    200          #if defined ( MANAGED_SCAN )
    201          /*********************************************************************
    202           * @fn      ZDOManagedScan_Next()
    203           *
    204           * @brief   Setup a managed scan.
    205           *
    206           * @param   none
    207           *
    208           * @return  none
    209           */
    210          static void ZDOManagedScan_Next( void )
    211          {
    212            // Is it the first time
    213            if ( managedScanNextChannel == 0 && managedScanTimesPerChannel == 0 )
    214            {
    215              // Setup the defaults
    216              managedScanNextChannel  = 1;
    217          
    218              while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    219                managedScanNextChannel <<= 1;
    220          
    221              managedScanChannelMask = managedScanNextChannel;
    222              managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    223            }
    224            else
    225            {
    226              // Do we need to go to the next channel
    227              if ( managedScanTimesPerChannel == 0 )
    228              {
    229                // Find next active channel
    230                managedScanChannelMask  = managedScanNextChannel;
    231                managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    232              }
    233              else
    234              {
    235                managedScanTimesPerChannel--;
    236          
    237                if ( managedScanTimesPerChannel == 0 )
    238                {
    239                  managedScanNextChannel  <<= 1;
    240                  while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    241                    managedScanNextChannel <<= 1;
    242          
    243                  if ( managedScanNextChannel == 0 )
    244                    zdoDiscCounter  = NUM_DISC_ATTEMPTS + 1; // Stop
    245                }
    246              }
    247            }
    248          }
    249          #endif // MANAGED_SCAN
    250          
    251          /*********************************************************************
    252           * @fn      ZDODeviceSetup()
    253           *
    254           * @brief   Call set functions depending on the type of device compiled.
    255           *
    256           * @param   none
    257           *
    258           * @return  none
    259           */
    260          static void ZDODeviceSetup( void )
    261          {
    262          #if defined( ZDO_COORDINATOR )
    263            NLME_CoordinatorInit();
    264          #endif
    265          
    266          #if defined ( REFLECTOR )
    267            #if defined ( ZDO_COORDINATOR )
    268              APS_ReflectorInit( APS_REFLECTOR_PUBLIC );
    269            #else
    270              APS_ReflectorInit( APS_REFLECTOR_PRIVATE );
    271            #endif
    272          #endif
    273          
    274          #if !defined( ZDO_COORDINATOR ) || defined( SOFT_START )
    275            NLME_DeviceJoiningInit();
    276          #endif
    277          }
    278          
    279          /*********************************************************************
    280           * @fn          ZDO_StartDevice
    281           *
    282           * @brief       This function starts a device in a network.
    283           *
    284           * @param       logicalType     - Device type to start
    285           *              startMode       - indicates mode of device startup
    286           *              beaconOrder     - indicates time betwen beacons
    287           *              superframeOrder - indicates length of active superframe
    288           *
    289           * @return      none
    290           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    291          void ZDO_StartDevice( byte logicalType, devStartModes_t startMode, byte beaconOrder, byte superframeOrder )
   \                     ZDO_StartDevice:
    292          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    293            ZStatus_t ret;
    294          
    295            ret = ZUnsupportedMode;
   \   00000A   7E12         MOV     R6,#0x12
    296          
    297          #if defined(ZDO_COORDINATOR)
    298            if ( logicalType == NODETYPE_COORDINATOR )
    299            {
    300              if ( startMode == MODE_HARD )
    301              {
    302                devState = DEV_COORD_STARTING;
    303                ret = NLME_NetworkFormationRequest( zgConfigPANID, zgDefaultChannelList,
    304                                                    zgDefaultStartingScanDuration, beaconOrder,
    305                                                    superframeOrder, false );
    306              }
    307              else if ( startMode == MODE_RESUME )
    308              {
    309                // Just start the coordinator
    310                devState = DEV_COORD_STARTING;
    311                ret = NLME_StartRouterRequest( beaconOrder, beaconOrder, false );
    312              }
    313              else
    314              {
    315              }
    316            }
    317          #endif  // !ZDO_COORDINATOR
    318          
    319          #if !defined ( ZDO_COORDINATOR ) || defined( SOFT_START )
    320            if ( logicalType == NODETYPE_ROUTER || logicalType == NODETYPE_DEVICE )
   \   00000C   7401         MOV     A,#0x1
   \   00000E   69           XRL     A,R1
   \   00000F   6008         JZ      ??ZDO_StartDevice_0
   \   000011   7402         MOV     A,#0x2
   \   000013   69           XRL     A,R1
   \   000014   6003         JZ      $+5
   \   000016   02....       LJMP    ??ZDO_StartDevice_1 & 0xFFFF
    321            {
    322              if ( (startMode == MODE_JOIN) || (startMode == MODE_REJOIN) )
   \                     ??ZDO_StartDevice_0:
   \   000019   EA           MOV     A,R2
   \   00001A   6005         JZ      ??ZDO_StartDevice_2
   \   00001C   7403         MOV     A,#0x3
   \   00001E   6A           XRL     A,R2
   \   00001F   7017         JNZ     ??ZDO_StartDevice_3
    323              {
    324                devState = DEV_NWK_DISC;
   \                     ??ZDO_StartDevice_2:
   \   000021   7402         MOV     A,#0x2
   \   000023   12....       LCALL   ?Subroutine1 & 0xFFFF
    325          
    326            #if defined( MANAGED_SCAN )
    327                ZDOManagedScan_Next();
    328                ret = NLME_NetworkDiscoveryRequest( managedScanChannelMask, BEACON_ORDER_15_MSEC );
    329            #else
    330                ret = NLME_NetworkDiscoveryRequest( zgDefaultChannelList, zgDefaultStartingScanDuration );
   \                     ??CrossCallReturnLabel_2:
   \   000026   12....       LCALL   ?L_MOV_X
   \   000029   AA..         MOV     R2,?V0 + 0
   \   00002B   AB..         MOV     R3,?V0 + 1
   \   00002D   AC..         MOV     R4,?V0 + 2
   \   00002F   AD..         MOV     R5,?V0 + 3
   \   000031   90....       MOV     DPTR,#(NLME_NetworkDiscoveryRequest & 0xffff)
   \   000034   74..         MOV     A,#((NLME_NetworkDiscoveryRequest >> 16) & 0xff)
   \   000036   8063         SJMP    ??ZDO_StartDevice_4
    331            #endif
    332              }
    333              else if ( startMode == MODE_RESUME )
   \                     ??ZDO_StartDevice_3:
   \   000038   7401         MOV     A,#0x1
   \   00003A   6A           XRL     A,R2
   \   00003B   7063         JNZ     ??ZDO_StartDevice_1
    334              {
    335                if ( logicalType == NODETYPE_ROUTER )
   \   00003D   7401         MOV     A,#0x1
   \   00003F   69           XRL     A,R1
   \   000040   7044         JNZ     ??ZDO_StartDevice_5
    336                {
    337                  ZMacScanCnf_t scanCnf;
    338                  devState = DEV_NWK_ORPHAN;
   \   000042   740A         MOV     A,#0xa
   \   000044   90....       MOV     DPTR,#devState
   \   000047   F0           MOVX    @DPTR,A
    339          
    340                  /* if router and nvram is available, fake successful orphan scan */
    341                  scanCnf.hdr.Status = ZSUCCESS;
   \   000048   7401         MOV     A,#0x1
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   E4           CLR     A
   \   00004E   F0           MOVX    @DPTR,A
    342                  scanCnf.ScanType = ZMAC_ORPHAN_SCAN;
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   7403         MOV     A,#0x3
   \   000056   F0           MOVX    @DPTR,A
    343                  scanCnf.UnscannedChannels = 0;
   \   000057   90....       MOV     DPTR,#__Constant_0
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?L_MOV_X
   \   00005F   7404         MOV     A,#0x4
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   78..         MOV     R0,#?V0 + 0
   \   000066   12....       LCALL   ?L_MOV_TO_X
    344                  scanCnf.ResultListSize = 0;
   \   000069   7408         MOV     A,#0x8
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   E4           CLR     A
   \   00006F   F0           MOVX    @DPTR,A
    345                  nwk_ScanJoiningOrphan(&scanCnf);
   \   000070                ; Setup parameters for call to function nwk_ScanJoiningOrphan
   \   000070   85..82       MOV     DPL,?XSP + 0
   \   000073   85..83       MOV     DPH,?XSP + 1
   \   000076   AA82         MOV     R2,DPL
   \   000078   AB83         MOV     R3,DPH
   \   00007A   90....       MOV     DPTR,#(nwk_ScanJoiningOrphan & 0xffff)
   \   00007D   74..         MOV     A,#((nwk_ScanJoiningOrphan >> 16) & 0xff)
   \   00007F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    346          
    347                  ret = ZSuccess;
   \   000082   7E00         MOV     R6,#0x0
   \   000084   801A         SJMP    ??ZDO_StartDevice_1
    348                }
    349                else
    350                {
    351                  devState = DEV_NWK_ORPHAN;
   \                     ??ZDO_StartDevice_5:
   \   000086   740A         MOV     A,#0xa
   \   000088   12....       LCALL   ?Subroutine1 & 0xFFFF
    352                  ret = NLME_OrphanJoinRequest( zgDefaultChannelList,
    353                                                zgDefaultStartingScanDuration );
   \                     ??CrossCallReturnLabel_3:
   \   00008B   12....       LCALL   ?L_MOV_X
   \   00008E   AA..         MOV     R2,?V0 + 0
   \   000090   AB..         MOV     R3,?V0 + 1
   \   000092   AC..         MOV     R4,?V0 + 2
   \   000094   AD..         MOV     R5,?V0 + 3
   \   000096   90....       MOV     DPTR,#(NLME_OrphanJoinRequest & 0xffff)
   \   000099   74..         MOV     A,#((NLME_OrphanJoinRequest >> 16) & 0xff)
   \                     ??ZDO_StartDevice_4:
   \   00009B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00009E   E9           MOV     A,R1
   \   00009F   FE           MOV     R6,A
    354                }
    355              }
    356              else
    357              {
    358              }
    359            }
    360          #endif  //!ZDO COORDINATOR || SOFT_START
    361          
    362            // configure the Security Manager for type of device
    363            ZDSecMgrConfig();
   \                     ??ZDO_StartDevice_1:
   \   0000A0                ; Setup parameters for call to function ZDSecMgrConfig
   \   0000A0   90....       MOV     DPTR,#(ZDSecMgrConfig & 0xffff)
   \   0000A3   74..         MOV     A,#((ZDSecMgrConfig >> 16) & 0xff)
   \   0000A5   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    364          
    365            if ( ret != ZSuccess )
   \   0000A8   EE           MOV     A,R6
   \   0000A9   6010         JZ      ??ZDO_StartDevice_6
    366              osal_start_timer( ZDO_NETWORK_INIT, NWK_RETRY_DELAY );
   \   0000AB                ; Setup parameters for call to function osal_start_timer
   \   0000AB   7CE8         MOV     R4,#-0x18
   \   0000AD   7D03         MOV     R5,#0x3
   \   0000AF   7A01         MOV     R2,#0x1
   \   0000B1   7B00         MOV     R3,#0x0
   \   0000B3   90....       MOV     DPTR,#(osal_start_timer & 0xffff)
   \   0000B6   74..         MOV     A,#((osal_start_timer >> 16) & 0xff)
   \   0000B8   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    367          }
   \                     ??ZDO_StartDevice_6:
   \   0000BB   740B         MOV     A,#0xb
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C0   02....       LJMP    ?Subroutine22 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   90....       MOV     DPTR,#devState
   \   000003   F0           MOVX    @DPTR,A
   \   000004                ; Setup parameters for call to function NLME_NetworkDiscoveryRequest
   \   000004                ; Setup parameters for call to function NLME_OrphanJoinRequest
   \   000004   90....       MOV     DPTR,#zgDefaultStartingScanDuration
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   90....       MOV     DPTR,#zgDefaultChannelList
   \   00000C   78..         MOV     R0,#?V0 + 0
   \   00000E   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    368          
    369          /*********************************************************************
    370           * @fn      ZDO_UpdateNwkStatus()
    371           *
    372           * @brief
    373           *
    374           *   This function will send an update message to each registered
    375           *   application endpoint/interface about a network status change.
    376           *
    377           * @param   none
    378           *
    379           * @return  none
    380           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    381          void ZDO_UpdateNwkStatus( devStates_t state )
   \                     ZDO_UpdateNwkStatus:
    382          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
    383            // Endpoint/Interface descriptor list.
    384            epList_t *epDesc = epList;
   \   000007   90....       MOV     DPTR,#epList
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FE           MOV     R6,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FF           MOV     R7,A
    385            byte bufLen = sizeof(osal_event_hdr_t);
    386            osal_event_hdr_t *msgPtr;
    387          
    388            ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
   \   00000F                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000F   90....       MOV     DPTR,#(NLME_GetShortAddr & 0xffff)
   \   000012   74..         MOV     A,#((NLME_GetShortAddr >> 16) & 0xff)
   \   000014   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000017   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00001A   EA           MOV     A,R2
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   EB           MOV     A,R3
   \   00001E   F0           MOVX    @DPTR,A
    389            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
   \   00001F                ; Setup parameters for call to function NLME_GetExtAddr
   \   00001F   90....       MOV     DPTR,#(NLME_GetExtAddr & 0xffff)
   \   000022   74..         MOV     A,#((NLME_GetExtAddr >> 16) & 0xff)
   \   000024   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000027   8041         SJMP    ??ZDO_UpdateNwkStatus_0
    390          
    391            while ( epDesc )
    392            {
    393              if ( epDesc->epDesc->endPoint != ZDO_EP )
   \                     ??ZDO_UpdateNwkStatus_1:
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000030   6027         JZ      ??ZDO_UpdateNwkStatus_2
    394              {
    395                msgPtr = (osal_event_hdr_t *)osal_msg_allocate( bufLen );
   \   000032                ; Setup parameters for call to function osal_msg_allocate
   \   000032   7A02         MOV     R2,#0x2
   \   000034   7B00         MOV     R3,#0x0
   \   000036   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000039   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   00003B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    396                if ( msgPtr )
   \   00003E   EA           MOV     A,R2
   \   00003F   7001         JNZ     ??ZDO_UpdateNwkStatus_3
   \   000041   EB           MOV     A,R3
   \                     ??ZDO_UpdateNwkStatus_3:
   \   000042   6015         JZ      ??ZDO_UpdateNwkStatus_2
    397                {
    398                  msgPtr->event = ZDO_STATE_CHANGE; // Command ID
   \   000044   74D1         MOV     A,#-0x2f
   \   000046   8A82         MOV     DPL,R2
   \   000048   8B83         MOV     DPH,R3
   \   00004A   F0           MOVX    @DPTR,A
    399                  msgPtr->status = (byte)state;
   \   00004B   A3           INC     DPTR
   \   00004C   E5..         MOV     A,?V0 + 0
   \   00004E   F0           MOVX    @DPTR,A
    400          
    401                  osal_msg_send( *(epDesc->epDesc->task_id), (byte *)msgPtr );
   \   00004F                ; Setup parameters for call to function osal_msg_send
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000056   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    402                }
    403              }
    404              epDesc = epDesc->nextDesc;
   \                     ??ZDO_UpdateNwkStatus_2:
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FE           MOV     R6,A
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \   000069   FF           MOV     R7,A
    405            }
   \                     ??ZDO_UpdateNwkStatus_0:
   \   00006A   EE           MOV     A,R6
   \   00006B   7001         JNZ     ??ZDO_UpdateNwkStatus_4
   \   00006D   EF           MOV     A,R7
   \                     ??ZDO_UpdateNwkStatus_4:
   \   00006E   70B9         JNZ     ??ZDO_UpdateNwkStatus_1
    406          }
   \   000070   02....       LJMP    ?Subroutine22 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \                     ??Subroutine18_0:
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000003   A3           INC     DPTR
   \   000004   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000007   F9           MOV     R1,A
   \   000008   90....       MOV     DPTR,#(osal_msg_send & 0xffff)
   \   00000B   74..         MOV     A,#((osal_msg_send >> 16) & 0xff)
   \   00000D   22           RET
    407          
    408          #if defined ( REFLECTOR )
    409          /*********************************************************************
    410           * @fn          ZDO_RemoveEndDeviceBind
    411           *
    412           * @brief       Remove the end device bind
    413           *
    414           * @param  none
    415           *
    416           * @return      none
    417           */
    418          static void ZDO_RemoveEndDeviceBind( void )
    419          {
    420            if ( ZDO_EDBind )
    421            {
    422              // Free the RAM
    423              if ( ZDO_EDBind->inClusters )
    424                osal_mem_free( ZDO_EDBind->inClusters );
    425              if ( ZDO_EDBind->outClusters )
    426                osal_mem_free( ZDO_EDBind->outClusters );
    427              osal_mem_free( ZDO_EDBind );
    428              ZDO_EDBind = NULL;
    429            }
    430          }
    431          #endif // REFLECTOR
    432          
    433          #if defined ( REFLECTOR )
    434          /*********************************************************************
    435           * @fn          ZDO_RemoveEndDeviceBind
    436           *
    437           * @brief       Remove the end device bind
    438           *
    439           * @param  none
    440           *
    441           * @return      none
    442           */
    443          static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse )
    444          {
    445            ZDP_EndDeviceBindRsp( TransSeq, dstAddr, Status, secUse );
    446          }
    447          #endif // REFLECTOR
    448          
    449          #if defined ( REFLECTOR ) || defined ( ZDO_COORDINATOR )
    450          /*********************************************************************
    451           * @fn          ZDO_CompareClusterLists
    452           *
    453           * @brief       Compare one list to another list
    454           *
    455           * @param       numList1 - number of items in list 1
    456           * @param       list1 - first list of cluster IDs
    457           * @param       numList2 - number of items in list 2
    458           * @param       list2 - second list of cluster IDs
    459           * @param       pMatches - buffer to put matches
    460           *
    461           * @return      number of matches
    462           */
    463          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    464                                    byte numList2, uint16 *list2, uint16 *pMatches )
    465          {
    466            byte x, y;
    467            uint16 z;
    468            byte numMatches = 0;
    469          
    470            // Check the first in against the seconds out
    471            for ( x = 0; x < numList1; x++ )
    472            {
    473              for ( y = 0; y < numList2; y++ )
    474              {
    475                z = list2[y];
    476                if ( list1[x] == z )
    477                  pMatches[numMatches++] = z;
    478              }
    479            }
    480          
    481            return ( numMatches );
    482          }
    483          #endif // REFLECTOR || ZDO_COORDINATOR
    484          
    485          #if defined ( REFLECTOR )
    486          /*********************************************************************
    487           * @fn          ZDO_DoEndDeviceBind
    488           *
    489           * @brief       Process the End Device Bind Req from ZDApp
    490           *
    491           * @param  bindReq  - Bind Request Information
    492           * @param  SecurityUse - Security enable/disable
    493           *
    494           * @return      none
    495           */
    496          void ZDO_DoEndDeviceBind( ZDEndDeviceBind_t *bindReq )
    497          {
    498            uint8 numMatches;
    499            uint8 Status;
    500            BindingEntry_t *pBind;
    501            AddrMgrEntry_t addrEntry;
    502            zAddrType_t SrcAddr;
    503          
    504            SrcAddr.addrMode = Addr16Bit;
    505            SrcAddr.addr.shortAddr = bindReq->srcAddr;
    506          
    507            // Ask for IEEE address
    508            if ( (bindReq->srcAddr != ZDAppNwkAddr.addr.shortAddr) )
    509            {
    510              addrEntry.user = ADDRMGR_USER_BINDING;
    511              addrEntry.nwkAddr = bindReq->srcAddr;
    512              Status = AddrMgrEntryLookupNwk( &addrEntry );
    513              if ( Status == TRUE)
    514              {
    515                // Add a reference to entry
    516                AddrMgrEntryAddRef( &addrEntry );
    517              }
    518              else
    519              {
    520                // If we have the extended address
    521                if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
    522                {
    523                  osal_cpyExtAddr( addrEntry.extAddr, bindReq->ieeeAddr );
    524                }
    525          
    526                // Not in address manager?
    527                AddrMgrEntryUpdate( &addrEntry );   // Add it
    528              }
    529          
    530              if ( AddrMgrExtAddrValid( addrEntry.extAddr ) == FALSE )
    531              {
    532                ZDP_IEEEAddrReq( bindReq->srcAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, false );
    533              }
    534            }
    535          
    536            if ( ZDO_EDBind )   // End Device Bind in progress
    537            {
    538              Status = ZDP_NO_MATCH;
    539          
    540              if ( bindReq->profileID == ZDO_EDBind->ProfileID )
    541              {
    542                // Check the first in against the seconds out
    543                numMatches = ZDO_CompareClusterLists(
    544                            ZDO_EDBind->numOutClusters, ZDO_EDBind->outClusters,
    545                            bindReq->numInClusters, bindReq->inClusters, ZDOBuildBuf );
    546          
    547                if ( numMatches )
    548                {
    549                  // if existing bind exists, remove it
    550                  pBind = bindFindExisting( &(ZDO_EDBind->SrcAddr), ZDO_EDBind->epIntf,
    551                                &SrcAddr, bindReq->endpoint );
    552                  if ( pBind )
    553                  {
    554                    bindRemoveEntry( pBind );
    555                    Status = ZDP_SUCCESS;
    556                  }
    557                  // else add new binding table entry
    558                  else if ( bindAddEntry( &(ZDO_EDBind->SrcAddr), ZDO_EDBind->epIntf,
    559                                &SrcAddr, bindReq->endpoint, numMatches, ZDOBuildBuf ) )
    560                    Status = ZDP_SUCCESS;
    561                  else
    562                    Status = ZDP_TABLE_FULL;
    563                }
    564          
    565                // Check the second in against the first out
    566                numMatches = ZDO_CompareClusterLists( bindReq->numOutClusters, bindReq->outClusters,
    567                                ZDO_EDBind->numInClusters, ZDO_EDBind->inClusters,
    568                                ZDOBuildBuf );
    569          
    570                if ( numMatches )
    571                {
    572                  // if existing bind exists, remove it
    573                  pBind = bindFindExisting( &SrcAddr, bindReq->endpoint, &(ZDO_EDBind->SrcAddr),
    574                                ZDO_EDBind->epIntf );
    575                  if ( pBind )
    576                  {
    577                    bindRemoveEntry( pBind );
    578                    Status = ZDP_SUCCESS;
    579                  }
    580                  // else add new binding table entry
    581                  else if ( bindAddEntry( &SrcAddr, bindReq->endpoint, &(ZDO_EDBind->SrcAddr),
    582                                ZDO_EDBind->epIntf, numMatches, ZDOBuildBuf ) )
    583                    Status = ZDP_SUCCESS;
    584                  else
    585                    Status = ZDP_TABLE_FULL;
    586                }
    587              }
    588          
    589              if ( Status == ZDP_SUCCESS )
    590              {
    591                // We've found a match, so we don't have to wait for the timeout
    592                APS_SetEndDeviceBindTimeout( 10, ZDO_EndDeviceTimeoutCB );  // psuedo stop end device timeout
    593          
    594                  // Notify to save info into NV
    595                osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
    596              }
    597          
    598              ZDO_EDBind->status = Status;
    599          
    600              // Send the response message to the device sending this message
    601              ZDO_SendEDBindRsp( bindReq->TransSeq, &SrcAddr, Status, bindReq->SecurityUse );
    602            }
    603            else  // Start a new End Device Bind
    604            {
    605              // Copy the info
    606              ZDO_EDBind = osal_mem_alloc( sizeof( ZDO_EDBind_t ) );
    607              if ( ZDO_EDBind )
    608              {
    609                osal_memcpy( &(ZDO_EDBind->SrcAddr), &SrcAddr, sizeof( zAddrType_t ) );
    610                ZDO_EDBind->LocalCoordinator = bindReq->localCoordinator;
    611                ZDO_EDBind->epIntf = bindReq->endpoint;
    612                ZDO_EDBind->ProfileID = bindReq->profileID;
    613                ZDO_EDBind->SrcTransSeq = bindReq->TransSeq;
    614          
    615                ZDO_EDBind->numInClusters = bindReq->numInClusters;
    616                if ( bindReq->numInClusters )
    617                {
    618                  ZDO_EDBind->inClusters = osal_mem_alloc( (short)(bindReq->numInClusters * sizeof(uint16)) );
    619                  if ( ZDO_EDBind->inClusters )
    620                  {
    621                    osal_memcpy( ZDO_EDBind->inClusters, bindReq->inClusters, (bindReq->numInClusters * sizeof( uint16 )) );
    622                  }
    623                  else
    624                  {
    625                    // Force no clusters
    626                    ZDO_EDBind->numInClusters = 0;
    627                  }
    628                }
    629                else
    630                  ZDO_EDBind->inClusters = NULL;
    631          
    632                ZDO_EDBind->numOutClusters = bindReq->numOutClusters;
    633                if ( bindReq->numOutClusters )
    634                {
    635                  ZDO_EDBind->outClusters = osal_mem_alloc( (short)(bindReq->numOutClusters*sizeof(uint16)) );
    636                  if ( ZDO_EDBind->outClusters )
    637                  {
    638                    osal_memcpy( ZDO_EDBind->outClusters, bindReq->outClusters, (bindReq->numOutClusters * sizeof( uint16 )) );
    639                  }
    640                  else
    641                  {
    642                    ZDO_EDBind->numOutClusters = 0;
    643                  }
    644                }
    645                else
    646                  ZDO_EDBind->outClusters = NULL;
    647          
    648                ZDO_EDBind->SecurityUse = bindReq->SecurityUse;
    649                ZDO_EDBind->status = ZDP_TIMEOUT;
    650          
    651                // Setup the timer
    652                APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceTimeoutCB );
    653              }
    654            }
    655          }
    656          #endif // REFLECTOR
    657          
    658          /*********************************************************************
    659           * Utility functions
    660           */
    661          
    662          /*********************************************************************
    663           * @fn          ZDO_CreateAlignedUINT16List
    664           *
    665           * @brief       Creates a list of cluster IDs that is guaranteed to be aligned.
    666           *              according to the needs of the target. If thre device is running
    667           *              Protocol version 1.0 the incoming buffer will have only a single
    668           *              byte for the cluster ID.
    669           *
    670           *              Depends on the malloc taking care of alignment.
    671           *
    672           *              When cluster ID went to 16 bits alignment for cluster IDs became
    673           *              an issue.
    674           *
    675           * @param       num  - number of entries in list
    676           * @param       buf  - pointer to list
    677           *
    678           * @return      pointer to aligned list. Null if can't allocate memory.
    679           *              Caller's responsibility to free memory.
    680           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    681          static uint16 *ZDO_CreateAlignedUINT16List(uint8 num, uint8 *buf)
   \                     ??ZDO_CreateAlignedUINT16List:
    682          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    683            uint16 *ptr;
    684          
    685            if ((ptr=osal_mem_alloc((short)(num*sizeof(uint16)))))  {
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E9           MOV     A,R1
   \   00000C   C3           CLR     C
   \   00000D   33           RLC     A
   \   00000E   FA           MOV     R2,A
   \   00000F   E4           CLR     A
   \   000010   33           RLC     A
   \   000011   FB           MOV     R3,A
   \   000012   90....       MOV     DPTR,#(osal_mem_alloc & 0xffff)
   \   000015   74..         MOV     A,#((osal_mem_alloc >> 16) & 0xff)
   \   000017   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00001A   8A..         MOV     ?V0 + 0,R2
   \   00001C   8B..         MOV     ?V0 + 1,R3
   \   00001E   EA           MOV     A,R2
   \   00001F   7001         JNZ     ??ZDO_CreateAlignedUINT16List_1
   \   000021   EB           MOV     A,R3
   \                     ??ZDO_CreateAlignedUINT16List_1:
   \   000022   605D         JZ      ??ZDO_CreateAlignedUINT16List_2
    686              uint8 i, ubyte, inc;
    687          
    688              inc = (ZB_PROT_V1_1 == NLME_GetProtocolVersion()) ? 2 : 1;
   \   000024                ; Setup parameters for call to function NLME_GetProtocolVersion
   \   000024   90....       MOV     DPTR,#(NLME_GetProtocolVersion & 0xffff)
   \   000027   74..         MOV     A,#((NLME_GetProtocolVersion >> 16) & 0xff)
   \   000029   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00002C   E9           MOV     A,R1
   \   00002D   6402         XRL     A,#0x2
   \   00002F   7004         JNZ     ??ZDO_CreateAlignedUINT16List_3
   \   000031   7B02         MOV     R3,#0x2
   \   000033   8002         SJMP    ??ZDO_CreateAlignedUINT16List_4
   \                     ??ZDO_CreateAlignedUINT16List_3:
   \   000035   7B01         MOV     R3,#0x1
    689          
    690              for (i=0; i<num; ++i)  {
   \                     ??ZDO_CreateAlignedUINT16List_4:
   \   000037   7A00         MOV     R2,#0x0
   \   000039   8031         SJMP    ??ZDO_CreateAlignedUINT16List_5
    691                // set upper byte to 0 if we're talking Version 1.0. otherwise
    692                // the buffer contains 16 bit cluster IDs.
    693                ubyte  = (2 == inc) ? buf[1] : 0;
   \                     ??ZDO_CreateAlignedUINT16List_6:
   \   00003B   75..00       MOV     ?V0 + 3,#0x0
    694                ptr[i] = BUILD_UINT16(buf[0], ubyte);
   \                     ??ZDO_CreateAlignedUINT16List_7:
   \   00003E   8E82         MOV     DPL,R6
   \   000040   8F83         MOV     DPH,R7
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FC           MOV     R4,A
   \   000044   E4           CLR     A
   \   000045   2C           ADD     A,R4
   \   000046   E5..         MOV     A,?V0 + 3
   \   000048   3400         ADDC    A,#0x0
   \   00004A   FD           MOV     R5,A
   \   00004B   EA           MOV     A,R2
   \   00004C   C3           CLR     C
   \   00004D   33           RLC     A
   \   00004E   F8           MOV     R0,A
   \   00004F   E4           CLR     A
   \   000050   33           RLC     A
   \   000051   F9           MOV     R1,A
   \   000052   E5..         MOV     A,?V0 + 0
   \   000054   28           ADD     A,R0
   \   000055   F582         MOV     DPL,A
   \   000057   E5..         MOV     A,?V0 + 1
   \   000059   39           ADDC    A,R1
   \   00005A   F583         MOV     DPH,A
   \   00005C   EC           MOV     A,R4
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   ED           MOV     A,R5
   \   000060   F0           MOVX    @DPTR,A
    695                buf    += inc;
   \   000061   8B..         MOV     ?V0 + 4,R3
   \   000063   EE           MOV     A,R6
   \   000064   25..         ADD     A,?V0 + 4
   \   000066   FE           MOV     R6,A
   \   000067   EF           MOV     A,R7
   \   000068   3400         ADDC    A,#0x0
   \   00006A   FF           MOV     R7,A
   \   00006B   0A           INC     R2
   \                     ??ZDO_CreateAlignedUINT16List_5:
   \   00006C   EA           MOV     A,R2
   \   00006D   C3           CLR     C
   \   00006E   95..         SUBB    A,?V0 + 2
   \   000070   500F         JNC     ??ZDO_CreateAlignedUINT16List_2
   \   000072   7402         MOV     A,#0x2
   \   000074   6B           XRL     A,R3
   \   000075   70C4         JNZ     ??ZDO_CreateAlignedUINT16List_6
   \   000077   8E82         MOV     DPL,R6
   \   000079   8F83         MOV     DPH,R7
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F5..         MOV     ?V0 + 3,A
   \   00007F   80BD         SJMP    ??ZDO_CreateAlignedUINT16List_7
    696              }
    697            }
    698          
    699            return ptr;
   \                     ??ZDO_CreateAlignedUINT16List_2:
   \   000081   AA..         MOV     R2,?V0 + 0
   \   000083   AB..         MOV     R3,?V0 + 1
   \   000085                REQUIRE ?Subroutine24
   \   000085                ; // Fall through to label ?Subroutine24
    700          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    701          
    702          /*********************************************************************
    703           * @fn          ZDO_CompareByteLists
    704           *
    705           * @brief       Compares two lists for matches.
    706           *
    707           * @param       ACnt  - number of entries in list A
    708           * @param       AList  - List A
    709           * @param       BCnt  - number of entries in list B
    710           * @param       BList  - List B
    711           *
    712           * @return      true if a match is found
    713           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    714          byte ZDO_AnyClusterMatches( byte ACnt, uint16 *AList, byte BCnt, uint16 *BList )
   \                     ZDO_AnyClusterMatches:
    715          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8C..         MOV     ?V0 + 1,R4
   \   000009   740C         MOV     A,#0xc
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine13 & 0xFFFF
    716            byte x, y;
    717          
    718            for ( x = 0; x < ACnt; x++ )
   \                     ??CrossCallReturnLabel_32:
   \   000011   75..00       MOV     ?V0 + 3,#0x0
   \   000014   8002         SJMP    ??ZDO_AnyClusterMatches_0
   \                     ??ZDO_AnyClusterMatches_1:
   \   000016   05..         INC     ?V0 + 3
   \                     ??ZDO_AnyClusterMatches_0:
   \   000018   E5..         MOV     A,?V0 + 3
   \   00001A   C3           CLR     C
   \   00001B   95..         SUBB    A,?V0 + 0
   \   00001D   5040         JNC     ??ZDO_AnyClusterMatches_2
    719            {
    720              for ( y = 0; y < BCnt; y++ )
   \   00001F   75..00       MOV     ?V0 + 2,#0x0
   \   000022   8002         SJMP    ??ZDO_AnyClusterMatches_3
   \                     ??ZDO_AnyClusterMatches_4:
   \   000024   05..         INC     ?V0 + 2
   \                     ??ZDO_AnyClusterMatches_3:
   \   000026   E5..         MOV     A,?V0 + 2
   \   000028   C3           CLR     C
   \   000029   95..         SUBB    A,?V0 + 1
   \   00002B   50E9         JNC     ??ZDO_AnyClusterMatches_1
    721              {
    722                if ( AList[x] == BList[y] )
   \   00002D   E5..         MOV     A,?V0 + 3
   \   00002F   C3           CLR     C
   \   000030   33           RLC     A
   \   000031   FC           MOV     R4,A
   \   000032   E4           CLR     A
   \   000033   33           RLC     A
   \   000034   FD           MOV     R5,A
   \   000035   EA           MOV     A,R2
   \   000036   2C           ADD     A,R4
   \   000037   F582         MOV     DPL,A
   \   000039   EB           MOV     A,R3
   \   00003A   3D           ADDC    A,R5
   \   00003B   F583         MOV     DPH,A
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FE           MOV     R6,A
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   FF           MOV     R7,A
   \   000042   E5..         MOV     A,?V0 + 2
   \   000044   C3           CLR     C
   \   000045   33           RLC     A
   \   000046   FC           MOV     R4,A
   \   000047   E4           CLR     A
   \   000048   33           RLC     A
   \   000049   FD           MOV     R5,A
   \   00004A   E8           MOV     A,R0
   \   00004B   2C           ADD     A,R4
   \   00004C   F582         MOV     DPL,A
   \   00004E   E9           MOV     A,R1
   \   00004F   3D           ADDC    A,R5
   \   000050   F583         MOV     DPH,A
   \   000052   E0           MOVX    A,@DPTR
   \   000053   6E           XRL     A,R6
   \   000054   7003         JNZ     ??ZDO_AnyClusterMatches_5
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   6F           XRL     A,R7
   \                     ??ZDO_AnyClusterMatches_5:
   \   000059   70C9         JNZ     ??ZDO_AnyClusterMatches_4
    723                {
    724                  return true;
   \   00005B   7901         MOV     R1,#0x1
   \   00005D   8002         SJMP    ??ZDO_AnyClusterMatches_6
    725                }
    726              }
    727            }
    728          
    729            return false;
   \                     ??ZDO_AnyClusterMatches_2:
   \   00005F   7900         MOV     R1,#0x0
   \                     ??ZDO_AnyClusterMatches_6:
   \   000061   80..         SJMP    ?Subroutine22
    730          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    731          
    732          /*********************************************************************
    733           * Callback functions from ZDProfile
    734           */
    735          
    736          /*********************************************************************
    737           * @fn          ZDO_ProcessNodeDescReq
    738           *
    739           * @brief       This function processes and responds to the
    740           *              Node_Desc_req message.
    741           *
    742           * @param       src  - Source address
    743           * @param       msg - NWKAddrOfInterest
    744           * @param       sty - Security enable/disable
    745           *
    746           * @return      none
    747           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    748          void ZDO_ProcessNodeDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessNodeDescReq:
    749          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740C         MOV     A,#0xc
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine4 & 0xFFFF
    750            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
    751            NodeDescriptorFormat_t *desc = NULL;
    752            byte stat = ZDP_INVALID_REQTYPE;
    753          
    754            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??CrossCallReturnLabel_12:
   \   000011   7004         JNZ     ??ZDO_ProcessNodeDescReq_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   65..         XRL     A,?V0 + 1
   \                     ??ZDO_ProcessNodeDescReq_0:
   \   000017   7026         JNZ     ??ZDO_ProcessNodeDescReq_1
    755            {
    756              desc = &ZDO_Config_Node_Descriptor;
    757            }
    758          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    759            else if ( CACHE_SERVER )
    760            {
    761              desc = (NodeDescriptorFormat_t *)ZDCacheGetDesc( aoi, eNodeDesc, &stat );
    762            }
    763          #endif
    764          
    765            if ( desc != NULL )
    766            {
    767              ZDP_NodeDescMsg( seq, src, aoi, desc, sty );
   \   000019                ; Setup parameters for call to function ZDP_NodeDescMsg
   \   000019   ED           MOV     A,R5
   \   00001A   F5..         MOV     ?V0 + 2,A
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000021   75....       MOV     ?V0 + 2,#(ZDO_Config_Node_Descriptor & 0xff)
   \   000024   75....       MOV     ?V0 + 3,#((ZDO_Config_Node_Descriptor >> 8) & 0xff)
   \   000027   78..         MOV     R0,#?V0 + 2
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   AC..         MOV     R4,?V0 + 0
   \   00002E   AD..         MOV     R5,?V0 + 1
   \   000030   90....       MOV     DPTR,#(ZDP_NodeDescMsg & 0xffff)
   \   000033   74..         MOV     A,#((ZDP_NodeDescMsg >> 16) & 0xff)
   \   000035   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000038   7403         MOV     A,#0x3
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003D   801F         SJMP    ??ZDO_ProcessNodeDescReq_2
    768            }
    769            else
    770            {
    771              ZDP_GenericRsp( seq, src, stat, aoi, Node_Desc_rsp, sty );
   \                     ??ZDO_ProcessNodeDescReq_1:
   \   00003F                ; Setup parameters for call to function ZDP_GenericRsp
   \   00003F   75..02       MOV     ?V0 + 2,#0x2
   \   000042   75..80       MOV     ?V0 + 3,#-0x80
   \   000045   78..         MOV     R0,#?V0 + 2
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7C80         MOV     R4,#-0x80
   \   000051   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   000054   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   000056   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
    772            }
    773          }
   \                     ??ZDO_ProcessNodeDescReq_2:
   \   00005E                REQUIRE ?Subroutine22
   \   00005E                ; // Fall through to label ?Subroutine22

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FD           MOV     R5,A
   \   000002   8E82         MOV     DPL,R6
   \   000004   8F83         MOV     DPH,R7
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0 + 0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FF           MOV     R7,A
   \   00000C   E4           CLR     A
   \   00000D   25..         ADD     A,?V0 + 0
   \   00000F   EF           MOV     A,R7
   \   000010   3400         ADDC    A,#0x0
   \   000012   F5..         MOV     ?V0 + 1,A
   \   000014   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000017   E0           MOVX    A,@DPTR
   \   000018   65..         XRL     A,?V0 + 0
   \   00001A   22           RET
    774          
    775          /*********************************************************************
    776           * @fn          ZDO_ProcessPowerDescReq
    777           *
    778           * @brief       This function processes and responds to the
    779           *              Node_Power_req message.
    780           *
    781           * @param       src  - Source address
    782           * @param       msg - NWKAddrOfInterest
    783           * @param       sty - Security enable/disable
    784           *
    785           * @return      none
    786           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    787          void ZDO_ProcessPowerDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessPowerDescReq:
    788          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740C         MOV     A,#0xc
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ?Subroutine4 & 0xFFFF
    789            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
    790            NodePowerDescriptorFormat_t *desc = NULL;
    791            byte stat = ZDP_INVALID_REQTYPE;
    792          
    793            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??CrossCallReturnLabel_13:
   \   000011   7004         JNZ     ??ZDO_ProcessPowerDescReq_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   65..         XRL     A,?V0 + 1
   \                     ??ZDO_ProcessPowerDescReq_0:
   \   000017   7026         JNZ     ??ZDO_ProcessPowerDescReq_1
    794            {
    795              desc = &ZDO_Config_Power_Descriptor;
    796            }
    797          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    798            else if ( CACHE_SERVER )
    799            {
    800              desc = (NodePowerDescriptorFormat_t *)ZDCacheGetDesc(aoi,ePowerDesc,&stat);
    801            }
    802          #endif
    803          
    804            if ( desc != NULL )
    805            {
    806              ZDP_PowerDescMsg( seq, src, aoi, desc, sty );
   \   000019                ; Setup parameters for call to function ZDP_PowerDescMsg
   \   000019   ED           MOV     A,R5
   \   00001A   F5..         MOV     ?V0 + 2,A
   \   00001C   78..         MOV     R0,#?V0 + 2
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000021   75....       MOV     ?V0 + 2,#(ZDO_Config_Power_Descriptor & 0xff)
   \   000024   75....       MOV     ?V0 + 3,#((ZDO_Config_Power_Descriptor >> 8) & 0xff)
   \   000027   78..         MOV     R0,#?V0 + 2
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   AC..         MOV     R4,?V0 + 0
   \   00002E   AD..         MOV     R5,?V0 + 1
   \   000030   90....       MOV     DPTR,#(ZDP_PowerDescMsg & 0xffff)
   \   000033   74..         MOV     A,#((ZDP_PowerDescMsg >> 16) & 0xff)
   \   000035   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000038   7403         MOV     A,#0x3
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003D   801F         SJMP    ??ZDO_ProcessPowerDescReq_2
    807            }
    808            else
    809            {
    810              ZDP_GenericRsp( seq, src, stat, aoi, Power_Desc_rsp, sty );
   \                     ??ZDO_ProcessPowerDescReq_1:
   \   00003F                ; Setup parameters for call to function ZDP_GenericRsp
   \   00003F   75..03       MOV     ?V0 + 2,#0x3
   \   000042   75..80       MOV     ?V0 + 3,#-0x80
   \   000045   78..         MOV     R0,#?V0 + 2
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7C80         MOV     R4,#-0x80
   \   000051   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   000054   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   000056   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
    811            }
    812          }
   \                     ??ZDO_ProcessPowerDescReq_2:
   \   00005E   80..         SJMP    ?Subroutine22
    813          
    814          /*********************************************************************
    815           * @fn          ZDO_ProcessSimpleDescReq
    816           *
    817           * @brief       This function processes and responds to the
    818           *              Simple_Desc_req message.
    819           *
    820           * @param       src - Source address
    821           * @param       msg - message data
    822           * @param       sty - Security enable/disable
    823           *
    824           * @return      none
    825           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    826          void ZDO_ProcessSimpleDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessSimpleDescReq:
    827          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 0,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   7410         MOV     A,#0x10
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F5..         MOV     ?V0 + 1,A
    828            SimpleDescriptionFormat_t *sDesc = NULL;
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   E4           CLR     A
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   12....       LCALL   ?Subroutine0 & 0xFFFF
    829            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   \                     ??CrossCallReturnLabel_0:
   \   000024   F8           MOV     R0,A
   \   000025   E9           MOV     A,R1
   \   000026   3400         ADDC    A,#0x0
   \   000028   F9           MOV     R1,A
    830            byte endPoint = msg[2];
   \   000029   8C82         MOV     DPL,R4
   \   00002B   8D83         MOV     DPH,R5
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
    831            byte free = false;
   \   000031   75..00       MOV     ?V0 + 5,#0x0
    832            byte stat = ZDP_SUCCESS;
   \   000034   75..00       MOV     ?V0 + 4,#0x0
    833          
    834            if ( (endPoint == ZDO_EP) || (endPoint > MAX_ENDPOINTS) )
   \   000037   6005         JZ      ??ZDO_ProcessSimpleDescReq_0
   \   000039   C3           CLR     C
   \   00003A   94F1         SUBB    A,#-0xf
   \   00003C   4005         JC      ??ZDO_ProcessSimpleDescReq_1
    835            {
    836              stat = ZDP_INVALID_EP;
   \                     ??ZDO_ProcessSimpleDescReq_0:
   \   00003E   75..82       MOV     ?V0 + 4,#-0x7e
   \   000041   8038         SJMP    ??ZDO_ProcessSimpleDescReq_2
    837            }
    838            else if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??ZDO_ProcessSimpleDescReq_1:
   \   000043   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000046   E0           MOVX    A,@DPTR
   \   000047   68           XRL     A,R0
   \   000048   7003         JNZ     ??ZDO_ProcessSimpleDescReq_3
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   69           XRL     A,R1
   \                     ??ZDO_ProcessSimpleDescReq_3:
   \   00004D   7029         JNZ     ??ZDO_ProcessSimpleDescReq_4
    839            {
    840              free = afFindSimpleDesc( &sDesc, endPoint );
   \   00004F                ; Setup parameters for call to function afFindSimpleDesc
   \   00004F   EA           MOV     A,R2
   \   000050   F9           MOV     R1,A
   \   000051   85..82       MOV     DPL,?XSP + 0
   \   000054   85..83       MOV     DPH,?XSP + 1
   \   000057   AA82         MOV     R2,DPL
   \   000059   AB83         MOV     R3,DPH
   \   00005B   90....       MOV     DPTR,#(afFindSimpleDesc & 0xffff)
   \   00005E   74..         MOV     A,#((afFindSimpleDesc >> 16) & 0xff)
   \   000060   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000063   E9           MOV     A,R1
   \   000064   F5..         MOV     ?V0 + 5,A
    841              if ( sDesc == NULL )
   \   000066   85..82       MOV     DPL,?XSP + 0
   \   000069   85..83       MOV     DPH,?XSP + 1
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   7002         JNZ     ??ZDO_ProcessSimpleDescReq_5
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessSimpleDescReq_5:
   \   000071   7008         JNZ     ??ZDO_ProcessSimpleDescReq_2
    842              {
    843                stat = ZDP_NOT_ACTIVE;
   \   000073   75..83       MOV     ?V0 + 4,#-0x7d
   \   000076   8003         SJMP    ??ZDO_ProcessSimpleDescReq_2
    844              }
    845            }
    846          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    847            else if ( CACHE_SERVER )
    848            {
    849              stat = endPoint;
    850              sDesc = (SimpleDescriptionFormat_t *)ZDCacheGetDesc(aoi, eSimpDesc, &stat);
    851            }
    852          #endif
    853            else
    854            {
    855          #if defined ( RTR_NWK )
    856              stat = ZDP_DEVICE_NOT_FOUND;
   \                     ??ZDO_ProcessSimpleDescReq_4:
   \   000078   75..81       MOV     ?V0 + 4,#-0x7f
    857          #else
    858              stat = ZDP_INVALID_REQTYPE;
    859          #endif
    860            }
    861          
    862            ZDP_SimpleDescMsg( seq, src, stat, sDesc, Simple_Desc_rsp, sty );
   \                     ??ZDO_ProcessSimpleDescReq_2:
   \   00007B                ; Setup parameters for call to function ZDP_SimpleDescMsg
   \   00007B   75..04       MOV     ?V0 + 2,#0x4
   \   00007E   75..80       MOV     ?V0 + 3,#-0x80
   \   000081   78..         MOV     R0,#?V0 + 2
   \   000083   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000086   7402         MOV     A,#0x2
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00008E   AD..         MOV     R5,?V0 + 1
   \   000090   AC..         MOV     R4,?V0 + 4
   \   000092   EE           MOV     A,R6
   \   000093   FA           MOV     R2,A
   \   000094   EF           MOV     A,R7
   \   000095   FB           MOV     R3,A
   \   000096   A9..         MOV     R1,?V0 + 0
   \   000098   90....       MOV     DPTR,#(ZDP_SimpleDescMsg & 0xffff)
   \   00009B   74..         MOV     A,#((ZDP_SimpleDescMsg >> 16) & 0xff)
   \   00009D   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000A0   7404         MOV     A,#0x4
   \   0000A2   12....       LCALL   ?DEALLOC_XSTACK8
    863          
    864            if ( free )
   \   0000A5   E5..         MOV     A,?V0 + 5
   \   0000A7   600C         JZ      ??ZDO_ProcessSimpleDescReq_6
    865            {
    866              osal_mem_free( sDesc );
   \   0000A9                ; Setup parameters for call to function osal_mem_free
   \   0000A9   85..82       MOV     DPL,?XSP + 0
   \   0000AC   85..83       MOV     DPH,?XSP + 1
   \   0000AF   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0000B2   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    867            }
    868          }
   \                     ??ZDO_ProcessSimpleDescReq_6:
   \   0000B5   7402         MOV     A,#0x2
   \   0000B7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BA   02....       LJMP    ?Subroutine24 & 0xFFFF

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000003   90....       MOV     DPTR,#(osal_mem_free & 0xffff)
   \   000006   74..         MOV     A,#((osal_mem_free >> 16) & 0xff)
   \   000008   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FA           MOV     R2,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F9           MOV     R1,A
   \   00000A   E4           CLR     A
   \   00000B   2A           ADD     A,R2
   \   00000C   22           RET
    869          
    870          /*********************************************************************
    871           * @fn          ZDO_ProcessActiveEPReq
    872           *
    873           * @brief       This function processes and responds to the
    874           *              Active_EP_req message.
    875           *
    876           * @param       src  - Source address
    877           * @param       sty - Security enable/disable
    878           *
    879           * @return      none
    880           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    881          void ZDO_ProcessActiveEPReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessActiveEPReq:
    882          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 0,R1
   \   000007   8A..         MOV     ?V0 + 6,R2
   \   000009   8B..         MOV     ?V0 + 7,R3
   \   00000B   7410         MOV     A,#0x10
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 1,A
    883            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   \   000013   8C82         MOV     DPL,R4
   \   000015   8D83         MOV     DPH,R5
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E4           CLR     A
   \   00001D   2A           ADD     A,R2
   \   00001E   FE           MOV     R6,A
   \   00001F   E9           MOV     A,R1
   \   000020   3400         ADDC    A,#0x0
   \   000022   FF           MOV     R7,A
    884            byte cnt = CACHE_EP_MAX;
    885            byte stat = ZDP_SUCCESS;
    886          
    887            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \   000023   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000026   E0           MOVX    A,@DPTR
   \   000027   6E           XRL     A,R6
   \   000028   7003         JNZ     ??ZDO_ProcessActiveEPReq_0
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   6F           XRL     A,R7
   \                     ??ZDO_ProcessActiveEPReq_0:
   \   00002D   7063         JNZ     ??ZDO_ProcessActiveEPReq_1
    888            {
    889              cnt = afNumEndPoints() - 1;  // -1 for ZDO endpoint descriptor
   \   00002F                ; Setup parameters for call to function afNumEndPoints
   \   00002F   90....       MOV     DPTR,#(afNumEndPoints & 0xffff)
   \   000032   74..         MOV     A,#((afNumEndPoints >> 16) & 0xff)
   \   000034   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000037   E9           MOV     A,R1
   \   000038   14           DEC     A
   \   000039   F5..         MOV     ?V0 + 2,A
    890              afEndPoints( (uint8 *)ZDOBuildBuf, true );
   \   00003B                ; Setup parameters for call to function afEndPoints
   \   00003B   7901         MOV     R1,#0x1
   \   00003D   7A..         MOV     R2,#(??ZDOBuildBuf & 0xff)
   \   00003F   7B..         MOV     R3,#((??ZDOBuildBuf >> 8) & 0xff)
   \   000041   90....       MOV     DPTR,#(afEndPoints & 0xffff)
   \   000044   74..         MOV     A,#((afEndPoints >> 16) & 0xff)
   \   000046   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
    891            }
    892          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    893            else if ( CACHE_SERVER )
    894            {
    895              cnt = *((byte *)ZDCacheGetDesc(aoi, eActEPDesc, (uint8 *)ZDOBuildBuf));
    896              // If cnt = 0, err code in 1st byte of buf, otherwise EP list is in the buf.
    897              if ( cnt == 0 )
    898              {
    899                stat = ZDOBuildBuf[0];
    900              }
    901            }
    902          #endif
    903            else
    904            {
    905              stat = ZDP_INVALID_REQTYPE;
    906            }
    907          
    908            if ( cnt != CACHE_EP_MAX )
   \   000049   7404         MOV     A,#0x4
   \   00004B   65..         XRL     A,?V0 + 2
   \   00004D   6043         JZ      ??ZDO_ProcessActiveEPReq_1
    909            {
    910              ZDP_ActiveEPRsp( seq, src, stat, aoi, cnt, (uint8 *)ZDOBuildBuf, sty );
   \   00004F                ; Setup parameters for call to function ZDP_EPRsp
   \   00004F   78..         MOV     R0,#?V0 + 1
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000054   75....       MOV     ?V0 + 4,#(??ZDOBuildBuf & 0xff)
   \   000057   75....       MOV     ?V0 + 5,#((??ZDOBuildBuf >> 8) & 0xff)
   \   00005A   78..         MOV     R0,#?V0 + 4
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005F   E5..         MOV     A,?V0 + 2
   \   000061   F5..         MOV     ?V0 + 1,A
   \   000063   78..         MOV     R0,#?V0 + 1
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000068   8E..         MOV     ?V0 + 2,R6
   \   00006A   8F..         MOV     ?V0 + 3,R7
   \   00006C   78..         MOV     R0,#?V0 + 2
   \   00006E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000071   75..00       MOV     ?V0 + 1,#0x0
   \   000074   78..         MOV     R0,#?V0 + 1
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000079   AC..         MOV     R4,?V0 + 6
   \   00007B   AD..         MOV     R5,?V0 + 7
   \   00007D   A9..         MOV     R1,?V0 + 0
   \   00007F   7A05         MOV     R2,#0x5
   \   000081   7B80         MOV     R3,#-0x80
   \   000083   90....       MOV     DPTR,#(ZDP_EPRsp & 0xffff)
   \   000086   74..         MOV     A,#((ZDP_EPRsp >> 16) & 0xff)
   \   000088   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00008B   7407         MOV     A,#0x7
   \   00008D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000090   802B         SJMP    ??ZDO_ProcessActiveEPReq_2
    911            }
    912            else
    913            {
    914              ZDP_GenericRsp( seq, src, ZDP_NOT_SUPPORTED, aoi, Active_EP_rsp, sty );
   \                     ??ZDO_ProcessActiveEPReq_1:
   \   000092                ; Setup parameters for call to function ZDP_GenericRsp
   \   000092   75..05       MOV     ?V0 + 2,#0x5
   \   000095   75..80       MOV     ?V0 + 3,#-0x80
   \   000098   78..         MOV     R0,#?V0 + 2
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009D   8E..         MOV     ?V0 + 2,R6
   \   00009F   8F..         MOV     ?V0 + 3,R7
   \   0000A1   78..         MOV     R0,#?V0 + 2
   \   0000A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A6   AD..         MOV     R5,?V0 + 1
   \   0000A8   7C84         MOV     R4,#-0x7c
   \   0000AA   AA..         MOV     R2,?V0 + 6
   \   0000AC   AB..         MOV     R3,?V0 + 7
   \   0000AE   A9..         MOV     R1,?V0 + 0
   \   0000B0   90....       MOV     DPTR,#(ZDP_GenericRsp & 0xffff)
   \   0000B3   74..         MOV     A,#((ZDP_GenericRsp >> 16) & 0xff)
   \   0000B5   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000B8   7404         MOV     A,#0x4
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
    915            }
    916          }
   \                     ??ZDO_ProcessActiveEPReq_2:
   \   0000BD                REQUIRE ?Subroutine25
   \   0000BD                ; // Fall through to label ?Subroutine25

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    917          
    918          /*********************************************************************
    919           * @fn          ZDO_ProcessMatchDescReq
    920           *
    921           * @brief       This function processes and responds to the
    922           *              Match_Desc_req message.
    923           *
    924           * @param       src  - Source address
    925           * @param       msg - input message containing search material
    926           * @param       sty - Security enable/disable
    927           *
    928           * @return      none
    929           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
    930          void ZDO_ProcessMatchDescReq( byte seq, zAddrType_t *src, byte *msg, byte sty )
   \                     ZDO_ProcessMatchDescReq:
    931          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   740B         MOV     A,#0xb
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   E9           MOV     A,R1
   \   000010   F0           MOVX    @DPTR,A
   \   000011   740C         MOV     A,#0xc
   \   000013   12....       LCALL   ?XSTACK_DISP0_8
   \   000016   EA           MOV     A,R2
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   EB           MOV     A,R3
   \   00001A   F0           MOVX    @DPTR,A
    932            byte epCnt = 0;
   \   00001B   7405         MOV     A,#0x5
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E4           CLR     A
   \   000021   12....       LCALL   ?Subroutine0 & 0xFFFF
    933            byte numInClusters;
    934            uint16 *inClusters;
    935            byte numOutClusters;
    936            uint16 *outClusters;
    937            epList_t *epDesc;
    938            SimpleDescriptionFormat_t *sDesc = NULL;
    939            uint8 allocated;
    940          
    941            // Parse the incoming message
    942            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   \                     ??CrossCallReturnLabel_1:
   \   000024   FE           MOV     R6,A
   \   000025   E9           MOV     A,R1
   \   000026   3400         ADDC    A,#0x0
   \   000028   FF           MOV     R7,A
    943            uint16 profileID = BUILD_UINT16( msg[2], msg[3] );
   \   000029   8C82         MOV     DPL,R4
   \   00002B   8D83         MOV     DPH,R5
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   E4           CLR     A
   \   00003B   2A           ADD     A,R2
   \   00003C   F5..         MOV     ?V0 + 0,A
   \   00003E   E9           MOV     A,R1
   \   00003F   3400         ADDC    A,#0x0
   \   000041   F5..         MOV     ?V0 + 1,A
    944            msg += 4;
   \   000043   EC           MOV     A,R4
   \   000044   2404         ADD     A,#0x4
   \   000046   F5..         MOV     ?V0 + 2,A
   \   000048   ED           MOV     A,R5
   \   000049   3400         ADDC    A,#0x0
    945            numInClusters = *msg++;
   \   00004B   85..82       MOV     DPL,?V0 + 2
   \   00004E   F583         MOV     DPH,A
   \   000050   E0           MOVX    A,@DPTR
   \   000051   F5..         MOV     ?V0 + 7,A
   \   000053   A3           INC     DPTR
   \   000054   8582..       MOV     ?V0 + 2,DPL
   \   000057   8583..       MOV     ?V0 + 3,DPH
    946            inClusters = NULL;
   \   00005A   7406         MOV     A,#0x6
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   E4           CLR     A
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   F0           MOVX    @DPTR,A
    947            if (numInClusters)  {
   \   000063   E5..         MOV     A,?V0 + 7
   \   000065   6023         JZ      ??ZDO_ProcessMatchDescReq_0
    948              if (!(inClusters=ZDO_CreateAlignedUINT16List(numInClusters, msg)))  {
   \   000067                ; Setup parameters for call to function ZDO_CreateAlignedUINT16List
   \   000067   AA..         MOV     R2,?V0 + 2
   \   000069   AB..         MOV     R3,?V0 + 3
   \   00006B   F9           MOV     R1,A
   \   00006C   90....       MOV     DPTR,#(??ZDO_CreateAlignedUINT16List & 0xffff)
   \   00006F   74..         MOV     A,#((??ZDO_CreateAlignedUINT16List >> 16) & 0xff)
   \   000071   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000074   8A..         MOV     ?V0 + 4,R2
   \   000076   8B..         MOV     ?V0 + 5,R3
   \   000078   A8..         MOV     R0,?V0 + 4
   \   00007A   A9..         MOV     R1,?V0 + 5
   \   00007C   7406         MOV     A,#0x6
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000084   E8           MOV     A,R0
   \   000085   7001         JNZ     ??ZDO_ProcessMatchDescReq_1
   \   000087   E9           MOV     A,R1
   \                     ??ZDO_ProcessMatchDescReq_1:
   \   000088   606D         JZ      ??ZDO_ProcessMatchDescReq_2
    949                // can't allocate memory. drop message
    950                return;
    951              }
    952            }
    953            msg += numInClusters*sizeof(uint16);
   \                     ??ZDO_ProcessMatchDescReq_0:
   \   00008A   E5..         MOV     A,?V0 + 7
   \   00008C   C3           CLR     C
   \   00008D   33           RLC     A
   \   00008E   F8           MOV     R0,A
   \   00008F   E4           CLR     A
   \   000090   33           RLC     A
   \   000091   F9           MOV     R1,A
   \   000092   E5..         MOV     A,?V0 + 2
   \   000094   28           ADD     A,R0
   \   000095   F5..         MOV     ?V0 + 2,A
   \   000097   E5..         MOV     A,?V0 + 3
   \   000099   39           ADDC    A,R1
   \   00009A   F5..         MOV     ?V0 + 3,A
    954          
    955            numOutClusters = *msg++;
   \   00009C   85..82       MOV     DPL,?V0 + 2
   \   00009F   F583         MOV     DPH,A
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   85..82       MOV     DPL,?XSP + 0
   \   0000A5   85..83       MOV     DPH,?XSP + 1
   \   0000A8   F0           MOVX    @DPTR,A
    956            outClusters = NULL;
   \   0000A9   7408         MOV     A,#0x8
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   E4           CLR     A
   \   0000AF   F0           MOVX    @DPTR,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   12....       LCALL   ?Subroutine2 & 0xFFFF
    957            if (numOutClusters)  {
   \                     ??CrossCallReturnLabel_4:
   \   0000B4   6049         JZ      ??ZDO_ProcessMatchDescReq_3
    958              if (!(outClusters=ZDO_CreateAlignedUINT16List(numOutClusters, msg)))  {
   \   0000B6                ; Setup parameters for call to function ZDO_CreateAlignedUINT16List
   \   0000B6   85..82       MOV     DPL,?V0 + 2
   \   0000B9   85..83       MOV     DPH,?V0 + 3
   \   0000BC   A3           INC     DPTR
   \   0000BD   AA82         MOV     R2,DPL
   \   0000BF   AB83         MOV     R3,DPH
   \   0000C1   F9           MOV     R1,A
   \   0000C2   90....       MOV     DPTR,#(??ZDO_CreateAlignedUINT16List & 0xffff)
   \   0000C5   74..         MOV     A,#((??ZDO_CreateAlignedUINT16List >> 16) & 0xff)
   \   0000C7   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0000CA   8A..         MOV     ?V0 + 2,R2
   \   0000CC   8B..         MOV     ?V0 + 3,R3
   \   0000CE   A8..         MOV     R0,?V0 + 2
   \   0000D0   A9..         MOV     R1,?V0 + 3
   \   0000D2   7408         MOV     A,#0x8
   \   0000D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D7   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000DA   E8           MOV     A,R0
   \   0000DB   7001         JNZ     ??ZDO_ProcessMatchDescReq_4
   \   0000DD   E9           MOV     A,R1
   \                     ??ZDO_ProcessMatchDescReq_4:
   \   0000DE   701F         JNZ     ??ZDO_ProcessMatchDescReq_3
    959                // can't allocate memory. drop message
    960                if (inClusters) {
   \   0000E0   7406         MOV     A,#0x6
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   7002         JNZ     ??ZDO_ProcessMatchDescReq_5
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_5:
   \   0000EA   600B         JZ      ??ZDO_ProcessMatchDescReq_2
    961                  osal_mem_free(inClusters);
   \   0000EC                ; Setup parameters for call to function osal_mem_free
   \   0000EC   7406         MOV     A,#0x6
   \                     ??ZDO_ProcessMatchDescReq_6:
   \   0000EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F1   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000F4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDO_ProcessMatchDescReq_2:
   \   0000F7   740E         MOV     A,#0xe
   \   0000F9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FC   02....       LJMP    ?Subroutine25 & 0xFFFF
    962                }
    963                return;
    964              }
    965            }
    966            msg += numOutClusters*sizeof(uint16);
    967          
    968            if ( NWK_BROADCAST_SHORTADDR_DEVALL == aoi )
   \                     ??ZDO_ProcessMatchDescReq_3:
   \   0000FF   74FF         MOV     A,#-0x1
   \   000101   6E           XRL     A,R6
   \   000102   7003         JNZ     ??ZDO_ProcessMatchDescReq_7
   \   000104   74FF         MOV     A,#-0x1
   \   000106   6F           XRL     A,R7
   \                     ??ZDO_ProcessMatchDescReq_7:
   \   000107   6052         JZ      ??ZDO_ProcessMatchDescReq_8
    969            {
    970          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    971              if ( CACHE_SERVER )
    972              {
    973                ZDCacheProcessMatchDescReq( seq, src, numInClusters, inClusters,
    974                                      numOutClusters, outClusters, profileID, aoi, sty );
    975              }
    976          #endif
    977            }
    978            else if ( ADDR_BCAST_NOT_ME == NLME_IsAddressBroadcast(aoi) )
   \   000109                ; Setup parameters for call to function NLME_IsAddressBroadcast
   \   000109   EE           MOV     A,R6
   \   00010A   FA           MOV     R2,A
   \   00010B   EF           MOV     A,R7
   \   00010C   FB           MOV     R3,A
   \   00010D   90....       MOV     DPTR,#(NLME_IsAddressBroadcast & 0xffff)
   \   000110   74..         MOV     A,#((NLME_IsAddressBroadcast >> 16) & 0xff)
   \   000112   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000115   E9           MOV     A,R1
   \   000116   6401         XRL     A,#0x1
   \   000118   7029         JNZ     ??ZDO_ProcessMatchDescReq_9
    979            {
    980              ZDP_MatchDescRsp( seq, src, ZDP_INVALID_REQTYPE,
    981                                             ZDAppNwkAddr.addr.shortAddr, 0, NULL, sty );
   \                     ??ZDO_ProcessMatchDescReq_10:
   \   00011A                ; Setup parameters for call to function ZDP_EPRsp
   \   00011A   741E         MOV     A,#0x1e
   \   00011C   12....       LCALL   ?XSTACK_DISP0_8
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F5..         MOV     ?V0 + 0,A
   \   000122   78..         MOV     R0,#?V0 + 0
   \   000124   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000127   75..00       MOV     ?V0 + 0,#0x0
   \   00012A   75..00       MOV     ?V0 + 1,#0x0
   \   00012D   78..         MOV     R0,#?V0 + 0
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000132   78..         MOV     R0,#?V0 + 0
   \   000134   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000137   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00013A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00013D   75..80       MOV     ?V0 + 0,#-0x80
   \   000140   02....       LJMP    ??ZDO_ProcessMatchDescReq_11 & 0xFFFF
    982              if (inClusters)  {
    983                osal_mem_free(inClusters);
    984              }
    985              if (outClusters)  {
    986                osal_mem_free(outClusters);
    987              }
    988              return;
    989            }
    990            else if ( (ADDR_NOT_BCAST == NLME_IsAddressBroadcast(aoi)) && (aoi != ZDAppNwkAddr.addr.shortAddr) )
   \                     ??ZDO_ProcessMatchDescReq_9:
   \   000143                ; Setup parameters for call to function NLME_IsAddressBroadcast
   \   000143   EE           MOV     A,R6
   \   000144   FA           MOV     R2,A
   \   000145   EF           MOV     A,R7
   \   000146   FB           MOV     R3,A
   \   000147   74..         MOV     A,#((NLME_IsAddressBroadcast >> 16) & 0xff)
   \   000149   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00014C   E9           MOV     A,R1
   \   00014D   700C         JNZ     ??ZDO_ProcessMatchDescReq_8
   \   00014F   90....       MOV     DPTR,#ZDAppNwkAddr
   \   000152   E0           MOVX    A,@DPTR
   \   000153   6E           XRL     A,R6
   \   000154   7003         JNZ     ??ZDO_ProcessMatchDescReq_12
   \   000156   A3           INC     DPTR
   \   000157   E0           MOVX    A,@DPTR
   \   000158   6F           XRL     A,R7
   \                     ??ZDO_ProcessMatchDescReq_12:
   \   000159   70BF         JNZ     ??ZDO_ProcessMatchDescReq_10
    991            {
    992          #if defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 )
    993              if ( CACHE_SERVER )
    994              {
    995                ZDCacheProcessMatchDescReq( seq, src, numInClusters, inClusters,
    996                                      numOutClusters, outClusters, profileID, aoi, sty );
    997              }
    998          #else
    999              ZDP_MatchDescRsp( seq, src, ZDP_INVALID_REQTYPE,
   1000                                             ZDAppNwkAddr.addr.shortAddr, 0, NULL, sty );
   1001          #endif
   1002              if (inClusters)  {
   1003                osal_mem_free(inClusters);
   1004              }
   1005              if (outClusters)  {
   1006                osal_mem_free(outClusters);
   1007              }
   1008              return;
   1009            }
   1010          
   1011            // First count the number of endpoints that match.
   1012            epDesc = epList;
   \                     ??ZDO_ProcessMatchDescReq_8:
   \   00015B   90....       MOV     DPTR,#epList
   \   00015E   8062         SJMP    ??ZDO_ProcessMatchDescReq_13
   1013            while ( epDesc )
   1014            {
   1015              // Don't search endpoint 0 and check if response is allowed
   1016              if ( epDesc->epDesc->endPoint != ZDO_EP && (epDesc->flags&eEP_AllowMatch) )
   1017              {
   1018                if ( epDesc->pfnDescCB )
   1019                {
   1020                  sDesc = (SimpleDescriptionFormat_t *)epDesc->pfnDescCB( AF_DESCRIPTOR_SIMPLE, epDesc->epDesc->endPoint );
   1021                  allocated = TRUE;
   1022                }
   1023                else
   1024                {
   1025                  sDesc = epDesc->epDesc->simpleDesc;
   1026                  allocated = FALSE;
   1027                }
   1028          
   1029                if ( sDesc && sDesc->AppProfId == profileID )
   1030                {
   1031                  uint8 *uint8Buf = (uint8 *)ZDOBuildBuf;
   1032          
   1033                  // If there are no search input/ouput clusters - respond
   1034                  if ( ((numInClusters == 0) && (numOutClusters == 0))
   1035                      // Are there matching input clusters?
   1036                       || (ZDO_AnyClusterMatches( numInClusters, inClusters,
   1037                            sDesc->AppNumInClusters, sDesc->pAppInClusterList ))
   1038                      // Are there matching output clusters?
   1039                       || (ZDO_AnyClusterMatches( numOutClusters, outClusters,
   1040                            sDesc->AppNumOutClusters, sDesc->pAppOutClusterList ))     )
   1041                  {
   1042                    // Notify the endpoint of the match.
   1043                    uint8 bufLen = sizeof( ZDO_MatchDescRspSent_t ) + (numOutClusters + numInClusters) * sizeof(uint16);
   1044                    ZDO_MatchDescRspSent_t *pRspSent = (ZDO_MatchDescRspSent_t *) osal_msg_allocate( bufLen );
   1045          
   1046                    if (pRspSent)
   1047                    {
   1048                      pRspSent->hdr.event = ZDO_MATCH_DESC_RSP_SENT;
   1049                      pRspSent->nwkAddr = src->addr.shortAddr;
   1050                      pRspSent->numInClusters = numInClusters;
   1051                      pRspSent->numOutClusters = numOutClusters;
   1052          
   1053                      if (numInClusters)
   1054                      {
   1055                        pRspSent->pInClusters = (uint16*) (pRspSent + 1);
   1056                        osal_memcpy(pRspSent->pInClusters, inClusters, numInClusters * sizeof(uint16));
   1057                      }
   1058                      else
   1059                      {
   1060                        pRspSent->pInClusters = NULL;
   1061                      }
   1062          
   1063                      if (numOutClusters)
   1064                      {
   1065                        pRspSent->pOutClusters = (uint16*)(pRspSent + 1) + numInClusters;
   1066                        osal_memcpy(pRspSent->pOutClusters, outClusters, numOutClusters * sizeof(uint16));
   1067                      }
   1068                      else
   1069                      {
   1070                        pRspSent->pOutClusters = NULL;
   \                     ??ZDO_ProcessMatchDescReq_14:
   \   000160   8E82         MOV     DPL,R6
   \   000162   8F83         MOV     DPH,R7
   \   000164   A3           INC     DPTR
   \   000165   A3           INC     DPTR
   \   000166   A3           INC     DPTR
   \   000167   A3           INC     DPTR
   \   000168   A3           INC     DPTR
   \   000169   A3           INC     DPTR
   \   00016A   A3           INC     DPTR
   \   00016B   A3           INC     DPTR
   \   00016C   E4           CLR     A
   \   00016D   F0           MOVX    @DPTR,A
   \   00016E   A3           INC     DPTR
   \   00016F   F0           MOVX    @DPTR,A
   1071                      }
   1072          
   1073                      osal_msg_send( *epDesc->epDesc->task_id, (uint8 *)pRspSent );
   \                     ??ZDO_ProcessMatchDescReq_15:
   \   000170                ; Setup parameters for call to function osal_msg_send
   \   000170   EE           MOV     A,R6
   \   000171   FA           MOV     R2,A
   \   000172   EF           MOV     A,R7
   \   000173   FB           MOV     R3,A
   \   000174   7401         MOV     A,#0x1
   \   000176   12....       LCALL   ?XSTACK_DISP0_8
   \   000179   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00017C   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00017F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1074                    }
   1075          
   1076                    uint8Buf[epCnt++] = sDesc->EndPoint;
   \                     ??ZDO_ProcessMatchDescReq_16:
   \   000182   7403         MOV     A,#0x3
   \   000184   12....       LCALL   ?XSTACK_DISP0_8
   \   000187   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00018A   C0E0         PUSH    A
   \   00018C   7405         MOV     A,#0x5
   \   00018E   12....       LCALL   ?XSTACK_DISP0_8
   \   000191   E0           MOVX    A,@DPTR
   \   000192   24..         ADD     A,#(??ZDOBuildBuf & 0xff)
   \   000194   F582         MOV     DPL,A
   \   000196   E4           CLR     A
   \   000197   34..         ADDC    A,#((??ZDOBuildBuf >> 8) & 0xff)
   \   000199   F583         MOV     DPH,A
   \   00019B   D0E0         POP     A
   \   00019D   F0           MOVX    @DPTR,A
   \   00019E   7405         MOV     A,#0x5
   \   0001A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   04           INC     A
   \   0001A5   F0           MOVX    @DPTR,A
   1077                  }
   1078                }
   1079          
   1080                if ( allocated )
   \                     ??ZDO_ProcessMatchDescReq_17:
   \   0001A6   740A         MOV     A,#0xa
   \   0001A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AB   E0           MOVX    A,@DPTR
   \   0001AC   600B         JZ      ??ZDO_ProcessMatchDescReq_18
   1081                  osal_mem_free( sDesc );
   \   0001AE                ; Setup parameters for call to function osal_mem_free
   \   0001AE   7403         MOV     A,#0x3
   \   0001B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B3   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   0001B6   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1082              }
   1083              epDesc = epDesc->nextDesc;
   \                     ??ZDO_ProcessMatchDescReq_18:
   \   0001B9   7401         MOV     A,#0x1
   \   0001BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BE   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0001C1   A3           INC     DPTR
   \                     ??ZDO_ProcessMatchDescReq_13:
   \   0001C2   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0001C5   7401         MOV     A,#0x1
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0001CD   7401         MOV     A,#0x1
   \   0001CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D2   E0           MOVX    A,@DPTR
   \   0001D3   7002         JNZ     ??ZDO_ProcessMatchDescReq_19
   \   0001D5   A3           INC     DPTR
   \   0001D6   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_19:
   \   0001D7   7003         JNZ     $+5
   \   0001D9   02....       LJMP    ??ZDO_ProcessMatchDescReq_20 & 0xFFFF
   \   0001DC   7401         MOV     A,#0x1
   \   0001DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E1   E0           MOVX    A,@DPTR
   \   0001E2   F8           MOV     R0,A
   \   0001E3   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   0001E6   60D1         JZ      ??ZDO_ProcessMatchDescReq_18
   \   0001E8   7401         MOV     A,#0x1
   \   0001EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001ED   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001F3   50C4         JNC     ??ZDO_ProcessMatchDescReq_18
   \   0001F5   7401         MOV     A,#0x1
   \   0001F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FA   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   0001FD   E0           MOVX    A,@DPTR
   \   0001FE   FC           MOV     R4,A
   \   0001FF   A3           INC     DPTR
   \   000200   E0           MOVX    A,@DPTR
   \   000201   FD           MOV     R5,A
   \   000202   A3           INC     DPTR
   \   000203   E0           MOVX    A,@DPTR
   \   000204   FE           MOV     R6,A
   \   000205   7900         MOV     R1,#0x0
   \   000207   EC           MOV     A,R4
   \   000208   4D           ORL     A,R5
   \   000209   4E           ORL     A,R6
   \   00020A   602C         JZ      ??ZDO_ProcessMatchDescReq_21
   \   00020C                ; Setup parameters for indirect call
   \   00020C   7401         MOV     A,#0x1
   \   00020E   12....       LCALL   ?XSTACK_DISP0_8
   \   000211   12....       LCALL   ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000214   FA           MOV     R2,A
   \   000215   09           INC     R1
   \   000216   E9           MOV     A,R1
   \   000217   12....       LCALL   ?XSTACK_DISP0_8
   \   00021A   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   00021D   E0           MOVX    A,@DPTR
   \   00021E   8C82         MOV     DPL,R4
   \   000220   8D83         MOV     DPH,R5
   \   000222   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000225   7403         MOV     A,#0x3
   \   000227   12....       LCALL   ?XSTACK_DISP0_8
   \   00022A   EA           MOV     A,R2
   \   00022B   F0           MOVX    @DPTR,A
   \   00022C   A3           INC     DPTR
   \   00022D   EB           MOV     A,R3
   \   00022E   F0           MOVX    @DPTR,A
   \   00022F   740A         MOV     A,#0xa
   \   000231   12....       LCALL   ?XSTACK_DISP0_8
   \   000234   7401         MOV     A,#0x1
   \   000236   801E         SJMP    ??ZDO_ProcessMatchDescReq_22
   \                     ??ZDO_ProcessMatchDescReq_21:
   \   000238   7401         MOV     A,#0x1
   \   00023A   12....       LCALL   ?XSTACK_DISP0_8
   \   00023D   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000240   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000243   A3           INC     DPTR
   \   000244   A3           INC     DPTR
   \   000245   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000248   7403         MOV     A,#0x3
   \   00024A   12....       LCALL   ?XSTACK_DISP0_8
   \   00024D   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000250   740A         MOV     A,#0xa
   \   000252   12....       LCALL   ?XSTACK_DISP0_8
   \   000255   E4           CLR     A
   \                     ??ZDO_ProcessMatchDescReq_22:
   \   000256   F0           MOVX    @DPTR,A
   \   000257   7403         MOV     A,#0x3
   \   000259   12....       LCALL   ?XSTACK_DISP0_8
   \   00025C   E0           MOVX    A,@DPTR
   \   00025D   7002         JNZ     ??ZDO_ProcessMatchDescReq_23
   \   00025F   A3           INC     DPTR
   \   000260   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_23:
   \   000261   7003         JNZ     $+5
   \   000263   02....       LJMP    ??ZDO_ProcessMatchDescReq_17 & 0xFFFF
   \   000266   7403         MOV     A,#0x3
   \   000268   12....       LCALL   ?XSTACK_DISP0_8
   \   00026B   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00026E   E0           MOVX    A,@DPTR
   \   00026F   65..         XRL     A,?V0 + 0
   \   000271   7004         JNZ     ??ZDO_ProcessMatchDescReq_24
   \   000273   A3           INC     DPTR
   \   000274   E0           MOVX    A,@DPTR
   \   000275   65..         XRL     A,?V0 + 1
   \                     ??ZDO_ProcessMatchDescReq_24:
   \   000277   6003         JZ      $+5
   \   000279   02....       LJMP    ??ZDO_ProcessMatchDescReq_17 & 0xFFFF
   \   00027C   E5..         MOV     A,?V0 + 7
   \   00027E   7009         JNZ     ??ZDO_ProcessMatchDescReq_25
   \   000280   85..82       MOV     DPL,?XSP + 0
   \   000283   85..83       MOV     DPH,?XSP + 1
   \   000286   E0           MOVX    A,@DPTR
   \   000287   6069         JZ      ??ZDO_ProcessMatchDescReq_26
   \                     ??ZDO_ProcessMatchDescReq_25:
   \   000289                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   000289   7403         MOV     A,#0x3
   \   00028B   12....       LCALL   ?XSTACK_DISP0_8
   \   00028E   12....       LCALL   ??Subroutine8_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000291   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000294   7405         MOV     A,#0x5
   \   000296   12....       LCALL   ?XSTACK_DISP0_8
   \   000299   12....       LCALL   ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00029C   A3           INC     DPTR
   \   00029D   A3           INC     DPTR
   \   00029E   E0           MOVX    A,@DPTR
   \   00029F   FC           MOV     R4,A
   \   0002A0   7408         MOV     A,#0x8
   \   0002A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A5   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0002A8   A9..         MOV     R1,?V0 + 7
   \   0002AA   90....       MOV     DPTR,#(ZDO_AnyClusterMatches & 0xffff)
   \   0002AD   74..         MOV     A,#((ZDO_AnyClusterMatches >> 16) & 0xff)
   \   0002AF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0002B2   7402         MOV     A,#0x2
   \   0002B4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002B7   E9           MOV     A,R1
   \   0002B8   7038         JNZ     ??ZDO_ProcessMatchDescReq_26
   \   0002BA                ; Setup parameters for call to function ZDO_AnyClusterMatches
   \   0002BA   7403         MOV     A,#0x3
   \   0002BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BF   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0002C2   A3           INC     DPTR
   \   0002C3   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0002C6   7405         MOV     A,#0x5
   \   0002C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CB   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0002CE   E0           MOVX    A,@DPTR
   \   0002CF   FC           MOV     R4,A
   \   0002D0   740A         MOV     A,#0xa
   \   0002D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D5   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0002D8   7402         MOV     A,#0x2
   \   0002DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002DD   E0           MOVX    A,@DPTR
   \   0002DE   F9           MOV     R1,A
   \   0002DF   90....       MOV     DPTR,#(ZDO_AnyClusterMatches & 0xffff)
   \   0002E2   74..         MOV     A,#((ZDO_AnyClusterMatches >> 16) & 0xff)
   \   0002E4   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0002E7   7402         MOV     A,#0x2
   \   0002E9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002EC   E9           MOV     A,R1
   \   0002ED   7003         JNZ     $+5
   \   0002EF   02....       LJMP    ??ZDO_ProcessMatchDescReq_17 & 0xFFFF
   \                     ??ZDO_ProcessMatchDescReq_26:
   \   0002F2                ; Setup parameters for call to function osal_msg_allocate
   \   0002F2   85..82       MOV     DPL,?XSP + 0
   \   0002F5   85..83       MOV     DPH,?XSP + 1
   \   0002F8   E0           MOVX    A,@DPTR
   \   0002F9   25..         ADD     A,?V0 + 7
   \   0002FB   C3           CLR     C
   \   0002FC   33           RLC     A
   \   0002FD   240A         ADD     A,#0xa
   \   0002FF   FA           MOV     R2,A
   \   000300   7B00         MOV     R3,#0x0
   \   000302   90....       MOV     DPTR,#(osal_msg_allocate & 0xffff)
   \   000305   74..         MOV     A,#((osal_msg_allocate >> 16) & 0xff)
   \   000307   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00030A   8A..         MOV     ?V0 + 2,R2
   \   00030C   8B..         MOV     ?V0 + 3,R3
   \   00030E   AE..         MOV     R6,?V0 + 2
   \   000310   AF..         MOV     R7,?V0 + 3
   \   000312   EE           MOV     A,R6
   \   000313   7001         JNZ     ??ZDO_ProcessMatchDescReq_27
   \   000315   EF           MOV     A,R7
   \                     ??ZDO_ProcessMatchDescReq_27:
   \   000316   7003         JNZ     $+5
   \   000318   02....       LJMP    ??ZDO_ProcessMatchDescReq_16 & 0xFFFF
   \   00031B   74DB         MOV     A,#-0x25
   \   00031D   8E82         MOV     DPL,R6
   \   00031F   8F83         MOV     DPH,R7
   \   000321   F0           MOVX    @DPTR,A
   \   000322   740C         MOV     A,#0xc
   \   000324   12....       LCALL   ?XSTACK_DISP0_8
   \   000327   12....       LCALL   ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00032A   F8           MOV     R0,A
   \   00032B   A3           INC     DPTR
   \   00032C   E0           MOVX    A,@DPTR
   \   00032D   F9           MOV     R1,A
   \   00032E   8E82         MOV     DPL,R6
   \   000330   8F83         MOV     DPH,R7
   \   000332   A3           INC     DPTR
   \   000333   A3           INC     DPTR
   \   000334   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000337   8E82         MOV     DPL,R6
   \   000339   8F83         MOV     DPH,R7
   \   00033B   A3           INC     DPTR
   \   00033C   A3           INC     DPTR
   \   00033D   A3           INC     DPTR
   \   00033E   A3           INC     DPTR
   \   00033F   E5..         MOV     A,?V0 + 7
   \   000341   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000344   8E82         MOV     DPL,R6
   \   000346   8F83         MOV     DPH,R7
   \   000348   A3           INC     DPTR
   \   000349   A3           INC     DPTR
   \   00034A   A3           INC     DPTR
   \   00034B   A3           INC     DPTR
   \   00034C   A3           INC     DPTR
   \   00034D   A3           INC     DPTR
   \   00034E   A3           INC     DPTR
   \   00034F   F0           MOVX    @DPTR,A
   \   000350   E5..         MOV     A,?V0 + 7
   \   000352   6040         JZ      ??ZDO_ProcessMatchDescReq_28
   \   000354   EE           MOV     A,R6
   \   000355   2405         ADD     A,#0x5
   \   000357   FA           MOV     R2,A
   \   000358   EF           MOV     A,R7
   \   000359   3400         ADDC    A,#0x0
   \   00035B   FB           MOV     R3,A
   \   00035C   EE           MOV     A,R6
   \   00035D   240A         ADD     A,#0xa
   \   00035F   F8           MOV     R0,A
   \   000360   EF           MOV     A,R7
   \   000361   3400         ADDC    A,#0x0
   \   000363   F9           MOV     R1,A
   \   000364   8A82         MOV     DPL,R2
   \   000366   8B83         MOV     DPH,R3
   \   000368   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   00036B                ; Setup parameters for call to function osal_memcpy
   \   00036B   7406         MOV     A,#0x6
   \   00036D   12....       LCALL   ?XSTACK_DISP0_8
   \   000370   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000373   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000376   E5..         MOV     A,?V0 + 7
   \   000378   C3           CLR     C
   \   000379   33           RLC     A
   \   00037A   FC           MOV     R4,A
   \   00037B   E4           CLR     A
   \   00037C   33           RLC     A
   \   00037D   FD           MOV     R5,A
   \   00037E   8A82         MOV     DPL,R2
   \   000380   8B83         MOV     DPH,R3
   \   000382   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000385   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   000388   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   00038A   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00038D   7403         MOV     A,#0x3
   \   00038F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000392   800D         SJMP    ??ZDO_ProcessMatchDescReq_29
   \                     ??ZDO_ProcessMatchDescReq_28:
   \   000394   8E82         MOV     DPL,R6
   \   000396   8F83         MOV     DPH,R7
   \   000398   A3           INC     DPTR
   \   000399   A3           INC     DPTR
   \   00039A   A3           INC     DPTR
   \   00039B   A3           INC     DPTR
   \   00039C   A3           INC     DPTR
   \   00039D   E4           CLR     A
   \   00039E   F0           MOVX    @DPTR,A
   \   00039F   A3           INC     DPTR
   \   0003A0   F0           MOVX    @DPTR,A
   \                     ??ZDO_ProcessMatchDescReq_29:
   \   0003A1   85..82       MOV     DPL,?XSP + 0
   \   0003A4   85..83       MOV     DPH,?XSP + 1
   \   0003A7   E0           MOVX    A,@DPTR
   \   0003A8   7003         JNZ     $+5
   \   0003AA   02....       LJMP    ??ZDO_ProcessMatchDescReq_14 & 0xFFFF
   \   0003AD   E5..         MOV     A,?V0 + 7
   \   0003AF   C3           CLR     C
   \   0003B0   33           RLC     A
   \   0003B1   F8           MOV     R0,A
   \   0003B2   E4           CLR     A
   \   0003B3   33           RLC     A
   \   0003B4   F9           MOV     R1,A
   \   0003B5   EE           MOV     A,R6
   \   0003B6   28           ADD     A,R0
   \   0003B7   F8           MOV     R0,A
   \   0003B8   EF           MOV     A,R7
   \   0003B9   39           ADDC    A,R1
   \   0003BA   F9           MOV     R1,A
   \   0003BB   740A         MOV     A,#0xa
   \   0003BD   28           ADD     A,R0
   \   0003BE   FA           MOV     R2,A
   \   0003BF   E4           CLR     A
   \   0003C0   39           ADDC    A,R1
   \   0003C1   FB           MOV     R3,A
   \   0003C2   8E82         MOV     DPL,R6
   \   0003C4   8F83         MOV     DPH,R7
   \   0003C6   A3           INC     DPTR
   \   0003C7   A3           INC     DPTR
   \   0003C8   A3           INC     DPTR
   \   0003C9   A3           INC     DPTR
   \   0003CA   A3           INC     DPTR
   \   0003CB   A3           INC     DPTR
   \   0003CC   A3           INC     DPTR
   \   0003CD   A3           INC     DPTR
   \   0003CE   EA           MOV     A,R2
   \   0003CF   F0           MOVX    @DPTR,A
   \   0003D0   A3           INC     DPTR
   \   0003D1   EB           MOV     A,R3
   \   0003D2   F0           MOVX    @DPTR,A
   \   0003D3                ; Setup parameters for call to function osal_memcpy
   \   0003D3   7408         MOV     A,#0x8
   \   0003D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D8   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   0003DB   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0003DE   7403         MOV     A,#0x3
   \   0003E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E3   E0           MOVX    A,@DPTR
   \   0003E4   C3           CLR     C
   \   0003E5   33           RLC     A
   \   0003E6   FC           MOV     R4,A
   \   0003E7   E4           CLR     A
   \   0003E8   33           RLC     A
   \   0003E9   FD           MOV     R5,A
   \   0003EA   90....       MOV     DPTR,#(osal_memcpy & 0xffff)
   \   0003ED   74..         MOV     A,#((osal_memcpy >> 16) & 0xff)
   \   0003EF   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   0003F2   7403         MOV     A,#0x3
   \   0003F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0003F7   02....       LJMP    ??ZDO_ProcessMatchDescReq_15 & 0xFFFF
   1084            }
   1085          
   1086            // Send the message only if at least one match found.
   1087            if ( epCnt )
   \                     ??ZDO_ProcessMatchDescReq_20:
   \   0003FA   7405         MOV     A,#0x5
   \   0003FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FF   E0           MOVX    A,@DPTR
   \   000400   6055         JZ      ??ZDO_ProcessMatchDescReq_30
   1088            {
   1089              if ( ZSuccess == ZDP_MatchDescRsp( seq, src, ZDP_SUCCESS,
   1090                                 ZDAppNwkAddr.addr.shortAddr, epCnt, (uint8 *)ZDOBuildBuf, sty ) )
   \   000402                ; Setup parameters for call to function ZDP_EPRsp
   \   000402   741E         MOV     A,#0x1e
   \   000404   12....       LCALL   ?XSTACK_DISP0_8
   \   000407   E0           MOVX    A,@DPTR
   \   000408   F5..         MOV     ?V0 + 0,A
   \   00040A   78..         MOV     R0,#?V0 + 0
   \   00040C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00040F   75....       MOV     ?V0 + 0,#(??ZDOBuildBuf & 0xff)
   \   000412   75....       MOV     ?V0 + 1,#((??ZDOBuildBuf >> 8) & 0xff)
   \   000415   78..         MOV     R0,#?V0 + 0
   \   000417   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00041A   7408         MOV     A,#0x8
   \   00041C   12....       LCALL   ?XSTACK_DISP0_8
   \   00041F   E0           MOVX    A,@DPTR
   \   000420   F5..         MOV     ?V0 + 0,A
   \   000422   78..         MOV     R0,#?V0 + 0
   \   000424   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000427   90....       MOV     DPTR,#ZDAppNwkAddr
   \   00042A   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00042D   75..00       MOV     ?V0 + 0,#0x0
   \                     ??ZDO_ProcessMatchDescReq_11:
   \   000430   78..         MOV     R0,#?V0 + 0
   \   000432   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000435   7413         MOV     A,#0x13
   \   000437   12....       LCALL   ?XSTACK_DISP0_8
   \   00043A   E0           MOVX    A,@DPTR
   \   00043B   FC           MOV     R4,A
   \   00043C   A3           INC     DPTR
   \   00043D   E0           MOVX    A,@DPTR
   \   00043E   FD           MOV     R5,A
   \   00043F   7412         MOV     A,#0x12
   \   000441   12....       LCALL   ?XSTACK_DISP0_8
   \   000444   E0           MOVX    A,@DPTR
   \   000445   F9           MOV     R1,A
   \   000446   7A06         MOV     R2,#0x6
   \   000448   7B80         MOV     R3,#-0x80
   \   00044A   90....       MOV     DPTR,#(ZDP_EPRsp & 0xffff)
   \   00044D   74..         MOV     A,#((ZDP_EPRsp >> 16) & 0xff)
   \   00044F   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   000452   7407         MOV     A,#0x7
   \   000454   12....       LCALL   ?DEALLOC_XSTACK8
   1091              {
   1092              }
   1093            }
   1094            else
   1095            {
   1096            }
   1097            if (inClusters)  {
   \                     ??ZDO_ProcessMatchDescReq_30:
   \   000457   7406         MOV     A,#0x6
   \   000459   12....       LCALL   ?XSTACK_DISP0_8
   \   00045C   E0           MOVX    A,@DPTR
   \   00045D   7002         JNZ     ??ZDO_ProcessMatchDescReq_31
   \   00045F   A3           INC     DPTR
   \   000460   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_31:
   \   000461   600B         JZ      ??ZDO_ProcessMatchDescReq_32
   \   000463                ; Setup parameters for call to function osal_mem_free
   \   000463   7406         MOV     A,#0x6
   \   000465   12....       LCALL   ?XSTACK_DISP0_8
   \   000468   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   00046B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \                     ??ZDO_ProcessMatchDescReq_32:
   \   00046E   7408         MOV     A,#0x8
   \   000470   12....       LCALL   ?XSTACK_DISP0_8
   \   000473   E0           MOVX    A,@DPTR
   \   000474   7002         JNZ     ??ZDO_ProcessMatchDescReq_33
   \   000476   A3           INC     DPTR
   \   000477   E0           MOVX    A,@DPTR
   \                     ??ZDO_ProcessMatchDescReq_33:
   \   000478   7003         JNZ     $+5
   \   00047A   02....       LJMP    ??ZDO_ProcessMatchDescReq_2 & 0xFFFF
   \   00047D                ; Setup parameters for call to function osal_mem_free
   \   00047D   7408         MOV     A,#0x8
   \   00047F   02....       LJMP    ??ZDO_ProcessMatchDescReq_6 & 0xFFFF
   1098              osal_mem_free(inClusters);
   1099            }
   1100            if (outClusters)  {
   1101              osal_mem_free(outClusters);
   1102            }
   1103          }

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   75..00       MOV     ?V0 + 6,#0x0
   \   00000A   78..         MOV     R0,#?V0 + 4
   \   00000C   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000003   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F583         MOV     DPH,A
   \   000004   8882         MOV     DPL,R0
   \   000006                REQUIRE ?Subroutine23
   \   000006                ; // Fall through to label ?Subroutine23

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   12....       LCALL   ??Subroutine18_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000003   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000006   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \                     ??Subroutine8_0:
   \   000002   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000003   A3           INC     DPTR
   \   000004   80..         SJMP    ?Subroutine23

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
   1104          
   1105          #if defined ( ZDO_COORDINATOR )
   1106          /*********************************************************************
   1107           * @fn          ZDO_ProcessEndDeviceBindReq
   1108           *
   1109           * @brief       This function processes and responds to the
   1110           *              End_Device_Bind_req message.
   1111           *
   1112           * @param       SrcAddr  - Source address
   1113           * @param       msg - input message containing search material
   1114           * @param       SecurityUse - Security enable/disable
   1115           *
   1116           * @return      none
   1117           */
   1118          void ZDO_ProcessEndDeviceBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg,
   1119                                            byte SecurityUse )
   1120          {
   1121            ZDEndDeviceBind_t bindReq;
   1122            uint8  protoVer;
   1123          
   1124            protoVer = NLME_GetProtocolVersion();
   1125          
   1126            // Parse the message
   1127            bindReq.TransSeq = TransSeq;
   1128            bindReq.srcAddr = SrcAddr->addr.shortAddr;
   1129            bindReq.SecurityUse = SecurityUse;
   1130          
   1131            bindReq.localCoordinator = BUILD_UINT16( msg[0], msg[1] );
   1132            msg += 2;
   1133          
   1134            if ( protoVer != ZB_PROT_V1_0 )
   1135            {
   1136              osal_cpyExtAddr( &(bindReq.ieeeAddr), msg );
   1137              msg += Z_EXTADDR_LEN;
   1138            }
   1139          
   1140            bindReq.endpoint = *msg++;
   1141            bindReq.profileID = BUILD_UINT16( msg[0], msg[1] );
   1142            msg += 2;
   1143          
   1144            bindReq.numInClusters = *msg++;
   1145            bindReq.inClusters = NULL;
   1146            if ( bindReq.numInClusters )
   1147            {
   1148              if ( !(bindReq.inClusters = ZDO_CreateAlignedUINT16List( bindReq.numInClusters, msg )) )
   1149              {
   1150                // can't allocate memory. drop message
   1151                return;
   1152              }
   1153            }
   1154            msg += (bindReq.numInClusters * ((protoVer != ZB_PROT_V1_0) ? sizeof ( uint16 ) : sizeof( uint8 )));
   1155          
   1156            bindReq.numOutClusters = *msg++;
   1157            bindReq.outClusters = NULL;
   1158            if ( bindReq.numOutClusters )
   1159            {
   1160              if ( !(bindReq.outClusters=ZDO_CreateAlignedUINT16List( bindReq.numOutClusters, msg )) )
   1161              {
   1162                // can't allocate memory. drop message
   1163                if ( bindReq.inClusters )
   1164                {
   1165                  osal_mem_free( bindReq.inClusters );
   1166                }
   1167                return;
   1168              }
   1169            }
   1170          
   1171            ZDApp_EndDeviceBindReqCB( &bindReq );
   1172          
   1173            if ( bindReq.inClusters )
   1174            {
   1175              osal_mem_free( bindReq.inClusters );
   1176            }
   1177            if ( bindReq.outClusters )
   1178            {
   1179              osal_mem_free( bindReq.outClusters );
   1180            }
   1181          }
   1182          #endif // ZDO_COORDINATOR
   1183          
   1184          #if defined ( REFLECTOR ) || defined ( ZDO_BIND_UNBIND_RESPONSE )
   1185          
   1186          /*********************************************************************
   1187           * @fn          ZDO_ProcessBindUnbindReq
   1188           *
   1189           * @brief       This function processes and responds to the
   1190           *              Bind_req or Unbind_req message.
   1191           *
   1192           * @param       SrcAddr  - Source address
   1193           * @param       msgClusterID - message cluster ID
   1194           * @param       msg - input message containing search material
   1195           * @param       SecurityUse - Security enable/disable
   1196           *
   1197           * @return      none
   1198           */
   1199          void ZDO_ProcessBindUnbindReq( byte TransSeq, zAddrType_t *SrcAddr, uint16 msgClusterID,
   1200                                        byte *msg, byte SecurityUse )
   1201          {
   1202            byte *SrcAddress;
   1203            byte SrcEpIntf;
   1204            uint16 ClusterID;
   1205            zAddrType_t DstAddress;
   1206            byte DstEpIntf;
   1207            uint8 protoVer;
   1208          
   1209            protoVer = NLME_GetProtocolVersion();
   1210          
   1211            SrcAddress = msg;
   1212            msg += Z_EXTADDR_LEN;
   1213            SrcEpIntf = *msg++;
   1214          
   1215            if ( protoVer != ZB_PROT_V1_0 )
   1216            {
   1217              ClusterID = BUILD_UINT16( msg[0], msg[1] );
   1218              msg += 2;
   1219            }
   1220            else
   1221            {
   1222              ClusterID = *msg++;
   1223            }
   1224          
   1225            if ( protoVer != ZB_PROT_V1_0 )
   1226            {
   1227              DstAddress.addrMode = *msg++;
   1228              if ( DstAddress.addrMode == Addr64Bit )
   1229              {
   1230                osal_cpyExtAddr( DstAddress.addr.extAddr, msg );
   1231                msg += Z_EXTADDR_LEN;
   1232                DstEpIntf = *msg;
   1233              }
   1234              else
   1235              {
   1236                DstAddress.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   1237                msg += sizeof ( uint16 );
   1238              }
   1239            }
   1240            else
   1241            {
   1242              DstAddress.addrMode = Addr64Bit;
   1243              osal_cpyExtAddr( DstAddress.addr.extAddr, msg );
   1244              msg += Z_EXTADDR_LEN;
   1245              DstEpIntf = *msg;
   1246            }
   1247          
   1248          
   1249            if ( msgClusterID == Bind_req )
   1250            {
   1251              ZDApp_BindReqCB( TransSeq, SrcAddr, SrcAddress, SrcEpIntf,
   1252                              ClusterID, &DstAddress, DstEpIntf, SecurityUse );
   1253            }
   1254            else
   1255            {
   1256              ZDApp_UnbindReqCB( TransSeq, SrcAddr, SrcAddress, SrcEpIntf,
   1257                              ClusterID, &DstAddress, DstEpIntf, SecurityUse );
   1258            }
   1259          }
   1260          #endif // REFLECTOR || ZDO_BIND_UNBIND_RESPONSE
   1261          
   1262          #if defined ( ZDO_NWKADDR_REQUEST ) || defined ( ZDO_IEEEADDR_REQUEST ) || defined ( REFLECTOR )
   1263          /*********************************************************************
   1264           * @fn      ZDO_ProcessAddrRsp
   1265           *
   1266           * @brief   Process an incoming NWK_addr_rsp or IEEE_addr_rsp message and then
   1267           *          invoke the corresponding CB function.
   1268           *
   1269           * @param   src - Source address of the request.
   1270           * @param   cId - Cluster ID of the request.
   1271           * @param   msg - Incoming request message.
   1272           *
   1273           * @return  none
   1274           */
   1275          void ZDO_ProcessAddrRsp( zAddrType_t *src, uint16 cId, byte *msg, byte msgLen )
   1276          {
   1277          #if defined ( REFLECTOR )
   1278            AddrMgrEntry_t addrEntry;
   1279          #endif
   1280            uint16 aoi;
   1281            uint16 *list = NULL;
   1282            byte idx = 0;
   1283            byte cnt = 0;
   1284          
   1285            byte stat = *msg++;
   1286            byte *ieee = msg;
   1287            msg += Z_EXTADDR_LEN;
   1288            aoi = BUILD_UINT16( msg[0], msg[1] );
   1289          
   1290          #if defined ( REFLECTOR )
   1291            // Add this to the address manager
   1292            addrEntry.user = ADDRMGR_USER_DEFAULT;
   1293            addrEntry.nwkAddr = aoi;
   1294            AddrMgrExtAddrSet( addrEntry.extAddr, ieee );
   1295            AddrMgrEntryUpdate( &addrEntry );
   1296          #endif
   1297          
   1298            // NumAssocDev field is only present on success.
   1299            if ( stat == ZDO_SUCCESS )
   1300            {
   1301              msg += 2;
   1302              cnt = ( msgLen > 1 + Z_EXTADDR_LEN + 2 ) ? *msg++ : 0;   // Single req: msgLen = status + IEEEAddr + NWKAddr
   1303          
   1304              // StartIndex field is only present if NumAssocDev field is non-zero.
   1305              if ( cnt != 0 )
   1306              {
   1307                idx = *msg++;
   1308          
   1309                if ( cnt > idx )
   1310                {
   1311                  list = osal_mem_alloc( (short)(cnt * sizeof( uint16 )) );
   1312          
   1313                  if ( list )
   1314                  {
   1315                    uint16 *pList = list;
   1316                    byte n = cnt - idx;
   1317          
   1318                    while ( n != 0 )
   1319                    {
   1320                      *pList++ = BUILD_UINT16( msg[0], msg[1] );
   1321                      msg += sizeof( uint16 );
   1322                      n--;
   1323                    }
   1324                  }
   1325                }
   1326              }
   1327            }
   1328          
   1329          #if defined ( ZDO_NWKADDR_REQUEST )
   1330            if ( cId == NWK_addr_rsp )
   1331            {
   1332              ZDApp_NwkAddrRspCB( src, stat, ieee, aoi, cnt, idx, list );
   1333            }
   1334          #endif
   1335          
   1336          #if defined ( ZDO_IEEEADDR_REQUEST )
   1337            if ( cId == IEEE_addr_rsp )
   1338            {
   1339              ZDApp_IEEEAddrRspCB( src, stat, ieee, aoi, cnt, idx, list );
   1340            }
   1341          #endif
   1342          
   1343            if ( list )
   1344            {
   1345              osal_mem_free( list );
   1346            }
   1347          }
   1348          #endif // ZDO_NWKADDR_REQUEST ZDO_IEEEADDR_REQUEST
   1349          
   1350          #if defined ( ZDO_NODEDESC_REQUEST )
   1351          /*********************************************************************
   1352           * @fn          ZDO_ProcessNodeDescRsp
   1353           *
   1354           * @brief       This function processes and responds to the
   1355           *              Node_Desc_rsp message.
   1356           *
   1357           * @param       SrcAddr  - Source address
   1358           * @param       msg - input message containing search material
   1359           *
   1360           * @return      none
   1361           */
   1362          void ZDO_ProcessNodeDescRsp( zAddrType_t *SrcAddr, byte *msg )
   1363          {
   1364            byte proVer = NLME_GetProtocolVersion();
   1365            NodeDescriptorFormat_t nodeDesc;
   1366            NodeDescriptorFormat_t *pNodeDesc = NULL;
   1367            byte Status = *msg++;
   1368            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   1369          
   1370            if ( Status == ZDP_SUCCESS )
   1371            {
   1372              msg += 2;
   1373              nodeDesc.LogicalType = *msg & 0x07;
   1374              if ( proVer == ZB_PROT_V1_0 )
   1375              {
   1376                nodeDesc.UserDescAvail = 0;
   1377                nodeDesc.ComplexDescAvail = 0;
   1378              }
   1379              else
   1380              {
   1381                nodeDesc.ComplexDescAvail = ( *msg & 0x08 ) >> 3;
   1382                nodeDesc.UserDescAvail = ( *msg & 0x10 ) >> 4;
   1383              }
   1384              msg++;  // Reserved bits.
   1385              nodeDesc.FrequencyBand = (*msg >> 3) & 0x1f;
   1386              nodeDesc.APSFlags = *msg++ & 0x07;
   1387              nodeDesc.CapabilityFlags = *msg++;
   1388              nodeDesc.ManufacturerCode[0] = *msg++;
   1389              nodeDesc.ManufacturerCode[1] = *msg++;
   1390              nodeDesc.MaxBufferSize = *msg++;
   1391              nodeDesc.MaxTransferSize[0] = *msg++;
   1392              nodeDesc.MaxTransferSize[1] = *msg++;
   1393          
   1394              if ( proVer == ZB_PROT_V1_0)
   1395              {
   1396                nodeDesc.ServerMask = 0;
   1397              }
   1398              else
   1399              {
   1400                nodeDesc.ServerMask = BUILD_UINT16( msg[0], msg[1] );
   1401              }
   1402          
   1403              pNodeDesc = &nodeDesc;
   1404            }
   1405          
   1406            ZDApp_NodeDescRspCB( SrcAddr, Status, aoi, pNodeDesc );
   1407          }
   1408          #endif // ZDO_NODEDESC_REQUEST
   1409          
   1410          #if defined ( ZDO_POWERDESC_REQUEST )
   1411          /*********************************************************************
   1412           * @fn          ZDO_ProcessPowerDescRsp
   1413           *
   1414           * @brief       This function processes and responds to the
   1415           *              Power_Desc_rsp message.
   1416           *
   1417           * @param       SrcAddr  - Source address
   1418           * @param       msg - input message containing search material
   1419           *
   1420           * @return      none
   1421           */
   1422          void ZDO_ProcessPowerDescRsp( zAddrType_t *SrcAddr, byte *msg )
   1423          {
   1424            NodePowerDescriptorFormat_t pwrDesc;
   1425            NodePowerDescriptorFormat_t *pPwrDesc = NULL;
   1426            byte Status = *msg++;
   1427            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   1428          
   1429            if ( Status == ZDP_SUCCESS )
   1430            {
   1431              msg += 2;
   1432              pwrDesc.AvailablePowerSources = *msg >> 4;
   1433              pwrDesc.PowerMode = *msg++ & 0x0F;
   1434              pwrDesc.CurrentPowerSourceLevel = *msg >> 4;
   1435              pwrDesc.CurrentPowerSource = *msg++ & 0x0F;
   1436              pPwrDesc = &pwrDesc;
   1437            }
   1438          
   1439            ZDApp_PowerDescRspCB( SrcAddr, Status, aoi, pPwrDesc );
   1440          }
   1441          #endif // ZDO_POWERDESC_REQUEST
   1442          
   1443          #if defined ( ZDO_SIMPLEDESC_REQUEST )
   1444          /*********************************************************************
   1445           * @fn          ZDO_ProcessSimpleDescRsp
   1446           *
   1447           * @brief       This function processes and responds to the
   1448           *              Simple_Desc_rsp message.
   1449           *
   1450           * @param       SrcAddr  - Source address
   1451           * @param       msg - input message containing search material
   1452           *
   1453           * @return      none
   1454           */
   1455          void ZDO_ProcessSimpleDescRsp( zAddrType_t *SrcAddr, byte *msg )
   1456          {
   1457            byte epIntf = 0;
   1458            SimpleDescriptionFormat_t simpleDesc;
   1459            SimpleDescriptionFormat_t *pSimpleDesc = NULL;
   1460            byte Status = *msg++;
   1461            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   1462          
   1463            if ( Status == ZDP_SUCCESS )
   1464            {
   1465              msg += 3;
   1466              epIntf = *msg;
   1467              pSimpleDesc = &simpleDesc;
   1468              ZDO_ParseSimpleDescBuf( msg, pSimpleDesc );
   1469            }
   1470          
   1471            ZDApp_SimpleDescRspCB( SrcAddr, Status, aoi, epIntf, pSimpleDesc );
   1472          }
   1473          #endif // ZDO_SIMPLEDESC_REQUEST
   1474          
   1475          #if defined ( ZDO_ACTIVEEP_REQUEST ) || defined ( ZDO_MATCH_REQUEST )
   1476          /*********************************************************************
   1477           * @fn          ZDO_ProcessEPListRsp
   1478           *
   1479           * @brief       This function processes and responds to the
   1480           *              Active_EP_rsp or Match_Desc_rsp message.
   1481           *
   1482           * @param       src  - Source address
   1483           * @param       ClusterID - Active_EP_rsp or Match_Desc_rsp
   1484           * @param       msg - input message containing search material
   1485           *
   1486           * @return      none
   1487           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1488          void ZDO_ProcessEPListRsp( zAddrType_t *src, uint16 ClusterID, byte *msg )
   \                     ZDO_ProcessEPListRsp:
   1489          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   740C         MOV     A,#0xc
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine13 & 0xFFFF
   1490            byte Status = *msg++;
   \                     ??CrossCallReturnLabel_35:
   \   00000D   8882         MOV     DPL,R0
   \   00000F   8983         MOV     DPH,R1
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F5..         MOV     ?V0 + 0,A
   \   000014   A3           INC     DPTR
   \   000015   A882         MOV     R0,DPL
   \   000017   A983         MOV     R1,DPH
   1491            byte cnt = msg[2];
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 1,A
   1492            byte *list = msg+3;
   1493          
   1494            src->addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   \   00001E   8882         MOV     DPL,R0
   \   000020   8983         MOV     DPH,R1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 2,A
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FF           MOV     R7,A
   \   000028   E4           CLR     A
   \   000029   25..         ADD     A,?V0 + 2
   \   00002B   FE           MOV     R6,A
   \   00002C   EF           MOV     A,R7
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   FF           MOV     R7,A
   \   000030   8A82         MOV     DPL,R2
   \   000032   8B83         MOV     DPH,R3
   \   000034   EE           MOV     A,R6
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   EF           MOV     A,R7
   \   000038   F0           MOVX    @DPTR,A
   1495          
   1496          #if defined ( ZDO_ACTIVEEP_REQUEST )
   1497            if ( ClusterID == Active_EP_rsp )
   1498              ZDApp_ActiveEPRspCB( src, Status, cnt, list );
   1499          #endif
   1500          
   1501          #if defined ( ZDO_MATCH_REQUEST )
   1502            if ( ClusterID == Match_Desc_rsp )
   \   000039   7406         MOV     A,#0x6
   \   00003B   6C           XRL     A,R4
   \   00003C   7003         JNZ     ??ZDO_ProcessEPListRsp_0
   \   00003E   7480         MOV     A,#-0x80
   \   000040   6D           XRL     A,R5
   \                     ??ZDO_ProcessEPListRsp_0:
   \   000041   7020         JNZ     ??ZDO_ProcessEPListRsp_1
   1503              ZDApp_MatchDescRspCB( src, Status, cnt, list );
   \   000043                ; Setup parameters for call to function ZDApp_MatchDescRspCB
   \   000043   E8           MOV     A,R0
   \   000044   2403         ADD     A,#0x3
   \   000046   F5..         MOV     ?V0 + 2,A
   \   000048   E9           MOV     A,R1
   \   000049   3400         ADDC    A,#0x0
   \   00004B   F5..         MOV     ?V0 + 3,A
   \   00004D   78..         MOV     R0,#?V0 + 2
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000052   AC..         MOV     R4,?V0 + 1
   \   000054   A9..         MOV     R1,?V0 + 0
   \   000056   90....       MOV     DPTR,#(ZDApp_MatchDescRspCB & 0xffff)
   \   000059   74..         MOV     A,#((ZDApp_MatchDescRspCB >> 16) & 0xff)
   \   00005B   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   \   00005E   7402         MOV     A,#0x2
   \   000060   12....       LCALL   ?DEALLOC_XSTACK8
   1504          #endif
   1505          }
   \                     ??ZDO_ProcessEPListRsp_1:
   \   000063   02....       LJMP    ?Subroutine22 & 0xFFFF
   1506          #endif  // ZDO_ACTIVEEP_REQUEST ZDO_MATCH_REQUEST
   1507          
   1508          #if defined ( ZDO_BIND_UNBIND_REQUEST ) || defined ( ZDO_ENDDEVICEBIND_REQUEST ) || defined ( ZDO_COORDINATOR )
   1509          /*********************************************************************
   1510           * @fn          ZDO_ProcessBindUnBindRsp
   1511           *
   1512           * @brief       This function processes and responds to the
   1513           *              End_Device_Bind_rsp message.
   1514           *
   1515           * @param       SrcAddr  - Source address
   1516           * @param       ClusterID - Active_EP_rsp or Match_Desc_rsp
   1517           * @param       msg - input message containing search material
   1518           *
   1519           * @return      none
   1520           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1521          void ZDO_ProcessBindUnbindRsp( zAddrType_t *SrcAddr, uint16 ClusterID, byte Status, uint8 TransSeq )
   \                     ZDO_ProcessBindUnbindRsp:
   1522          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1523          #if defined ( ZDO_COORDINATOR )
   1524            uint8 used = FALSE;
   1525          #endif
   1526          
   1527          #if defined ( ZDO_ENDDEVICEBIND_REQUEST )
   1528            if ( ClusterID == End_Device_Bind_rsp )
   \   000004   7420         MOV     A,#0x20
   \   000006   6C           XRL     A,R4
   \   000007   7003         JNZ     ??ZDO_ProcessBindUnbindRsp_0
   \   000009   7480         MOV     A,#-0x80
   \   00000B   6D           XRL     A,R5
   \                     ??ZDO_ProcessBindUnbindRsp_0:
   \   00000C   7008         JNZ     ??ZDO_ProcessBindUnbindRsp_1
   1529              ZDApp_EndDeviceBindRsp( SrcAddr, Status );
   \   00000E                ; Setup parameters for call to function ZDApp_EndDeviceBindRsp
   \   00000E   90....       MOV     DPTR,#(ZDApp_EndDeviceBindRsp & 0xffff)
   \   000011   74..         MOV     A,#((ZDApp_EndDeviceBindRsp >> 16) & 0xff)
   \   000013   12....       LCALL   ?BCALL               ; Banked call to: DPTR()
   1530          #endif
   1531          
   1532          #if defined ( ZDO_COORDINATOR )
   1533            if ( matchED )
   1534            {
   1535              used = ZDMatchSendState(
   1536                     (uint8)((ClusterID == Bind_rsp) ? ZDMATCH_REASON_BIND_RSP : ZDMATCH_REASON_UNBIND_RSP),
   1537                     Status, TransSeq );
   1538            }
   1539          
   1540            if ( !used )
   1541          #endif
   1542            {
   1543            #if defined ( ZDO_BIND_UNBIND_REQUEST )
   1544              if ( ClusterID == Bind_rsp )
   1545                ZDApp_BindRsp( SrcAddr, Status );
   1546              else
   1547                ZDApp_UnbindRsp( SrcAddr, Status );
   1548            #endif
   1549            }
   1550          }
   \                     ??ZDO_ProcessBindUnbindRsp_1:
   \   000016   02....       LJMP    ?Subroutine21 & 0xFFFF
   1551          #endif // ZDO_BIND_UNBIND_REQUEST ZDO_ENDDEVICEBIND_REQUEST
   1552          
   1553          #if defined ( ZDO_SERVERDISC_REQUEST )
   1554          /*********************************************************************
   1555           * @fn          ZDO_ProcessServerDiscRsp
   1556           *
   1557           * @brief       Process the Server_Discovery_rsp message.
   1558           *
   1559           * @param       srcAddr - Source address.
   1560           * @param       msg - Byte array containing the Server_Discovery_rsp command frame.
   1561           * @param       SecurityUse -
   1562           *
   1563           * @return      none
   1564           */
   1565          void ZDO_ProcessServerDiscRsp(zAddrType_t *srcAddr, byte *msg, byte SecurityUse)
   1566          {
   1567            byte status = *msg++;
   1568            uint16 serverMask = BUILD_UINT16( msg[0], msg[1] );
   1569          
   1570            ZDApp_ServerDiscRspCB( srcAddr->addr.shortAddr, status, serverMask,
   1571                                   SecurityUse );
   1572          }
   1573          #endif
   1574          
   1575          #if defined ( ZDO_SERVERDISC_RESPONSE )
   1576          /*********************************************************************
   1577           * @fn          ZDO_ProcessServerDiscReq
   1578           *
   1579           * @brief       Process the Server_Discovery_req message.
   1580           *
   1581           * @param       transID - Transaction sequence number of request.
   1582           * @param       srcAddr  - Source address
   1583           * @param       msg - Byte array containing the Server_Discovery_req command frame.
   1584           * @param       SecurityUse -
   1585           *
   1586           * @return      none
   1587           */
   1588          void ZDO_ProcessServerDiscReq( byte transID, zAddrType_t *srcAddr, byte *msg,
   1589                                         byte SecurityUse )
   1590          {
   1591            uint16 serverMask = BUILD_UINT16( msg[0], msg[1] );
   1592            uint16 matchMask = serverMask & ZDO_Config_Node_Descriptor.ServerMask;
   1593          
   1594            if ( matchMask )
   1595            {
   1596              ZDP_ServerDiscRsp( transID, srcAddr, ZSUCCESS, ZDAppNwkAddr.addr.shortAddr,
   1597                                 matchMask, SecurityUse );
   1598            }
   1599          }
   1600          #endif
   1601          
   1602          /*********************************************************************
   1603           * Call Back Functions from APS  - API
   1604           */
   1605          
   1606          /*********************************************************************
   1607           * @fn          ZDO_EndDeviceTimeoutCB
   1608           *
   1609           * @brief       This function handles the binding timer for the End
   1610           *              Device Bind command.
   1611           *
   1612           * @param       none
   1613           *
   1614           * @return      none
   1615           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   1616          void ZDO_EndDeviceTimeoutCB( void )
   \                     ZDO_EndDeviceTimeoutCB:
   1617          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1618          #if defined ( REFLECTOR )
   1619            byte stat;
   1620            if ( ZDO_EDBind )
   1621            {
   1622              stat = ZDO_EDBind->status;
   1623          
   1624              // Send the response message to the first sent
   1625              ZDO_SendEDBindRsp( ZDO_EDBind->SrcTransSeq, &(ZDO_EDBind->SrcAddr),
   1626                                  stat, ZDO_EDBind->SecurityUse );
   1627          
   1628              ZDO_RemoveEndDeviceBind();
   1629            }
   1630          #endif  // REFLECTOR
   1631          }
   \   000000   02....       LJMP    ?BRET
   1632          
   1633          /*********************************************************************
   1634           * Optional Management Messages
   1635           */
   1636          
   1637          #if defined( ZDO_MGMT_LQI_RESPONSE ) && defined ( RTR_NWK )
   1638          /*********************************************************************
   1639           * @fn          ZDO_ProcessMgmtLqiReq
   1640           *
   1641           * @brief       This function handles parsing the incoming Management
   1642           *              LQI request and generate the response.
   1643           *
   1644           *   Note:      This function will limit the number of items returned
   1645           *              to ZDO_MAX_LQI_ITEMS items.
   1646           *
   1647           * @param       SrcAddr - source of the request
   1648           * @param       StartIndex - where to start the return list
   1649           * @param       SecurityUse -
   1650           *
   1651           * @return      none
   1652           */
   1653          void ZDO_ProcessMgmtLqiReq( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   1654          {
   1655            byte x;
   1656            byte index;
   1657            byte numItems;
   1658            byte maxItems;
   1659            ZDP_MgmtLqiItem_t* table;
   1660            ZDP_MgmtLqiItem_t* item;
   1661            neighborEntry_t    entry;
   1662            byte aItems;
   1663            associated_devices_t *aDevice;
   1664          
   1665            // Get the number of neighbor items
   1666            NLME_GetRequest( nwkNumNeighborTableEntries, 0, &maxItems );
   1667          
   1668            // Get the number of associated items
   1669            aItems = (uint8)AssocCount( PARENT, CHILD_FFD_RX_IDLE );
   1670            // Total number of items
   1671            maxItems += aItems;
   1672          
   1673            // Start with the supplied index
   1674            numItems = maxItems - StartIndex;
   1675          
   1676            // limit the size of the list
   1677            if ( numItems > ZDO_MAX_LQI_ITEMS )
   1678              numItems = ZDO_MAX_LQI_ITEMS;
   1679          
   1680            // Allocate the memory to build the table
   1681            table = (ZDP_MgmtLqiItem_t*)osal_mem_alloc( (short)
   1682                      ( numItems * sizeof( ZDP_MgmtLqiItem_t ) ) );
   1683          
   1684            if ( table != NULL )
   1685            {
   1686              x = 0;
   1687              item = table;
   1688              index = StartIndex;
   1689          
   1690              // Loop through associated items and build list
   1691              for ( ; x < numItems; x++ )
   1692              {
   1693                if ( index < aItems )
   1694                {
   1695                  // get next associated device
   1696                  aDevice = AssocFindDevice( index++ );
   1697          
   1698                  // set basic fields
   1699                  item->panID   = _NIB.nwkPanId;
   1700                  osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   1701                  item->nwkAddr = aDevice->shortAddr;
   1702                  item->permit  = ZDP_MGMT_BOOL_UNKNOWN;
   1703                  item->depth   = 0xFF;
   1704                  item->lqi     = aDevice->linkInfo.rxCost;
   1705          
   1706                  osal_memset( item->extAddr, 0x00, Z_EXTADDR_LEN );
   1707          
   1708                  // use association info to set other fields
   1709                  if ( aDevice->nodeRelation == PARENT )
   1710                  {
   1711                    if (  aDevice->shortAddr == 0 )
   1712                    {
   1713                      item->devType = ZDP_MGMT_DT_COORD;
   1714                    }
   1715                    else
   1716                    {
   1717                      item->devType = ZDP_MGMT_DT_ROUTER;
   1718                    }
   1719          
   1720                    item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1721                    item->relation = ZDP_MGMT_REL_PARENT;
   1722                  }
   1723                  else
   1724                  {
   1725                    if ( aDevice->nodeRelation < CHILD_FFD )
   1726                    {
   1727                      item->devType = ZDP_MGMT_DT_ENDDEV;
   1728          
   1729                      if ( aDevice->nodeRelation == CHILD_RFD )
   1730                      {
   1731                        item->rxOnIdle = FALSE;
   1732                      }
   1733                      else
   1734                      {
   1735                        item->rxOnIdle = TRUE;
   1736                      }
   1737                    }
   1738                    else
   1739                    {
   1740                      item->devType = ZDP_MGMT_DT_ROUTER;
   1741          
   1742                      if ( aDevice->nodeRelation == CHILD_FFD )
   1743                      {
   1744                        item->rxOnIdle = FALSE;
   1745                      }
   1746                      else
   1747                      {
   1748                        item->rxOnIdle = TRUE;
   1749                      }
   1750                    }
   1751          
   1752                    item->relation = ZDP_MGMT_REL_CHILD;
   1753                  }
   1754          
   1755                  item++;
   1756                }
   1757                else
   1758                {
   1759                  if ( StartIndex <= aItems )
   1760                    // Start with 1st neighbor
   1761                    index = 0;
   1762                  else
   1763                    // Start with >1st neighbor
   1764                    index = StartIndex - aItems;
   1765                  break;
   1766                }
   1767              }
   1768          
   1769              // Loop through neighbor items and finish list
   1770              for ( ; x < numItems; x++ )
   1771              {
   1772                // Add next neighbor table item
   1773                NLME_GetRequest( nwkNeighborTable, index++, &entry );
   1774          
   1775                // set ZDP_MgmtLqiItem_t fields
   1776                item->panID    = entry.panId;
   1777                osal_memset( item->extPanID, 0x00, Z_EXTADDR_LEN);
   1778                osal_memset( item->extAddr, 0x00, Z_EXTADDR_LEN );
   1779                item->nwkAddr  = entry.neighborAddress;
   1780                item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1781                item->relation = ZDP_MGMT_REL_UNKNOWN;
   1782                item->permit   = ZDP_MGMT_BOOL_UNKNOWN;
   1783                item->depth    = 0xFF;
   1784                item->lqi      = entry.linkInfo.rxCost;
   1785          
   1786                if ( item->nwkAddr == 0 )
   1787                {
   1788                  item->devType = ZDP_MGMT_DT_COORD;
   1789                }
   1790                else
   1791                {
   1792                  item->devType = ZDP_MGMT_DT_ROUTER;
   1793                }
   1794          
   1795                item++;
   1796              }
   1797          
   1798              // Send response
   1799              ZDP_MgmtLqiRsp( TransSeq, SrcAddr, ZSuccess, maxItems,
   1800                              StartIndex, numItems, table, false );
   1801          
   1802              osal_mem_free( table );
   1803            }
   1804          }
   1805          #endif // ZDO_MGMT_LQI_RESPONSE && RTR_NWK
   1806          
   1807          #if defined ( ZDO_MGMT_LQI_REQUEST )
   1808          /*********************************************************************
   1809           * @fn          ZDO_ProcessMgmtLqiRsp
   1810           *
   1811           * @brief       This function handles parsing the incoming Management
   1812           *              LQI response and then generates a callback to the ZD
   1813           *              application.
   1814           *
   1815           * @param       SrcAddr - source of the request
   1816           * @param       msg - buffer holding incoming message to parse
   1817           * @param       SecurityUse -
   1818           *
   1819           * @return      none
   1820           */
   1821          void ZDO_ProcessMgmtLqiRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   1822          {
   1823            byte x;
   1824            byte status;
   1825            byte startIndex = 0;
   1826            byte neighborLqiCount = 0;
   1827            byte neighborLqiEntries = 0;
   1828            neighborLqiItem_t *list = NULL;
   1829            byte proVer = NLME_GetProtocolVersion();
   1830          
   1831            status = *msg++;
   1832            if ( status == ZSuccess )
   1833            {
   1834              neighborLqiEntries = *msg++;
   1835              startIndex = *msg++;
   1836              neighborLqiCount = *msg++;
   1837          
   1838              // Allocate a buffer big enough to handle the list.
   1839              list = (neighborLqiItem_t *)osal_mem_alloc( neighborLqiCount *
   1840                                                  sizeof( neighborLqiItem_t ) );
   1841              if ( list )
   1842              {
   1843                neighborLqiItem_t *pList = list;
   1844          
   1845                for ( x = 0; x < neighborLqiCount; x++ )
   1846                {
   1847                  if ( proVer == ZB_PROT_V1_0 )
   1848                  {
   1849                    pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   1850                    msg += 2;
   1851                  }
   1852                  else
   1853                  {
   1854                    osal_cpyExtAddr(pList->extPANId, msg);   //Copy extended PAN ID
   1855                    msg += Z_EXTADDR_LEN;
   1856                  }
   1857          
   1858                  msg += Z_EXTADDR_LEN;  // Throwing away IEEE.
   1859                  pList->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   1860                  if ( proVer == ZB_PROT_V1_0 )
   1861                    msg += 2 + 1 + 1;          // Skip DeviceType, RxOnIdle, Relationship, PermitJoinging and Depth
   1862                  else
   1863                    msg += 2 + 1 + 1 + 1;      // Skip DeviceType, RxOnIdle, Rlationship, PermitJoining and Depth
   1864          
   1865                  pList->rxLqi = *msg++;
   1866                  pList->txQuality = 0;  // This is not specified OTA by ZigBee 1.1.
   1867                  pList++;
   1868                }
   1869              }
   1870            }
   1871          
   1872            // Call the callback to the application.
   1873            ZDApp_MgmtLqiRspCB( SrcAddr->addr.shortAddr, status, neighborLqiEntries,
   1874                                startIndex, neighborLqiCount, list );
   1875          
   1876            if ( list )
   1877            {
   1878              osal_mem_free( list );
   1879            }
   1880          }
   1881          #endif // ZDO_MGMT_LQI_REQUEST
   1882          
   1883          #if defined( ZDO_MGMT_NWKDISC_RESPONSE )
   1884          /*********************************************************************
   1885           * @fn          ZDO_ProcessMgmtNwkDiscReq
   1886           *
   1887           * @brief       This function handles parsing the incoming Management
   1888           *              Network Discover request and starts the request.
   1889           *
   1890           * @param       SrcAddr - source of the request
   1891           * @param       msg - pointer to incoming message
   1892           * @param       SecurityUse -
   1893           *
   1894           * @return      none
   1895           */
   1896          void ZDO_ProcessMgmtNwkDiscReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   1897          {
   1898            NLME_ScanFields_t scan;
   1899            uint8             index;
   1900          
   1901            scan.channels = BUILD_UINT32( msg[0], msg[1], msg[2], msg[3] );
   1902            msg += 4;
   1903            scan.duration = *msg++;
   1904            index         = *msg;
   1905          
   1906            // Save off the information to be used for the response
   1907            zdappMgmtNwkDiscReqInProgress          = true;
   1908            zdappMgmtNwkDiscRspAddr.addrMode       = Addr16Bit;
   1909            zdappMgmtNwkDiscRspAddr.addr.shortAddr = SrcAddr->addr.shortAddr;
   1910            zdappMgmtNwkDiscStartIndex             = index;
   1911            zdappMgmtNwkDiscRspTransSeq            = TransSeq;
   1912          
   1913            if ( NLME_NwkDiscReq2( &scan ) != ZSuccess )
   1914            {
   1915              NLME_NwkDiscTerm();
   1916          
   1917              // zdappMgmtNwkDiscReqInProgress will be reset in the confirm callback
   1918            }
   1919          }
   1920          #endif // ZDO_MGMT_NWKDISC_RESPONSE
   1921          
   1922          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   1923          /*********************************************************************
   1924           * @fn          ZDO_FinishProcessingMgmtNwkDiscReq
   1925           *
   1926           * @brief       This function finishes the processing of the Management
   1927           *              Network Discover Request and generates the response.
   1928           *
   1929           *   Note:      This function will limit the number of items returned
   1930           *              to ZDO_MAX_NWKDISC_ITEMS items.
   1931           *
   1932           * @param       ResultCountSrcAddr - source of the request
   1933           * @param       msg - pointer to incoming message
   1934           * @param       SecurityUse -
   1935           *
   1936           * @return      none
   1937           */
   1938          void ZDO_FinishProcessingMgmtNwkDiscReq( byte ResultCount,
   1939                                                   networkDesc_t *NetworkList )
   1940          {
   1941            byte count;
   1942          
   1943          #if defined ( RTR_NWK )
   1944            networkDesc_t *newDesc, *pList = NetworkList;
   1945          
   1946            // Look for my PanID.
   1947            while ( pList )
   1948            {
   1949              if ( pList->panId == _NIB.nwkPanId )
   1950              {
   1951                break;
   1952              }
   1953          
   1954              if ( !pList->nextDesc )
   1955              {
   1956                break;
   1957              }
   1958              pList = pList->nextDesc;
   1959            }
   1960          
   1961            // If my Pan not present (query to a star network ZC or an isolated ZR?),
   1962            // prepend it.
   1963            if ( !pList || (pList->panId != _NIB.nwkPanId) )
   1964            {
   1965              newDesc = (networkDesc_t *)osal_mem_alloc( sizeof( networkDesc_t ) );
   1966              if ( newDesc )
   1967              {
   1968                byte pJoin;
   1969          
   1970                newDesc->panId = _NIB.nwkPanId;
   1971                newDesc->logicalChannel = _NIB.nwkLogicalChannel;
   1972                newDesc->beaconOrder = _NIB.beaconOrder;
   1973                newDesc->superFrameOrder = _NIB.superFrameOrder;
   1974                newDesc->version = NLME_GetProtocolVersion();
   1975                newDesc->stackProfile = zgStackProfile;
   1976                //Extended PanID
   1977                osal_cpyExtAddr( newDesc->extendedPANID, _NIB.extendedPANID);
   1978          
   1979                ZMacGetReq( ZMacAssociationPermit, &pJoin );
   1980                newDesc->chosenRouter = ((pJoin) ? ZDAppNwkAddr.addr.shortAddr :
   1981                                                   INVALID_NODE_ADDR);
   1982          
   1983                newDesc->nextDesc = NetworkList;
   1984                NetworkList = newDesc;
   1985                ResultCount++;
   1986              }
   1987            }
   1988          #endif
   1989          
   1990            // Calc the count and apply a max count.
   1991            if ( zdappMgmtNwkDiscStartIndex > ResultCount )
   1992            {
   1993              count = 0;
   1994            }
   1995            else
   1996            {
   1997              count = ResultCount - zdappMgmtNwkDiscStartIndex;
   1998              if ( count > ZDO_MAX_NWKDISC_ITEMS )
   1999              {
   2000                count = ZDO_MAX_NWKDISC_ITEMS;
   2001              }
   2002          
   2003              // Move the list pointer up to the start index.
   2004              NetworkList += zdappMgmtNwkDiscStartIndex;
   2005            }
   2006          
   2007            ZDP_MgmtNwkDiscRsp( zdappMgmtNwkDiscRspTransSeq,
   2008                               &zdappMgmtNwkDiscRspAddr, ZSuccess, ResultCount,
   2009                                zdappMgmtNwkDiscStartIndex,
   2010                                count,
   2011                                NetworkList,
   2012                                false );
   2013          
   2014          #if defined ( RTR_NWK )
   2015            if ( newDesc )
   2016            {
   2017              osal_mem_free( newDesc );
   2018            }
   2019          #endif
   2020          
   2021            NLME_NwkDiscTerm();
   2022          }
   2023          #endif
   2024          
   2025          #if defined ( ZDO_MGMT_NWKDISC_REQUEST )
   2026          /*********************************************************************
   2027           * @fn          ZDO_ProcessMgmNwkDiscRsp
   2028           *
   2029           * @brief       This function handles parsing the incoming Management
   2030           *              Network Discover response and then generates a callback
   2031           *              to the ZD application.
   2032           *
   2033           * @param       SrcAddr - source of the request
   2034           * @param       msg - buffer holding incoming message to parse
   2035           * @param       SecurityUse -
   2036           *
   2037           * @return      none
   2038           */
   2039          void ZDO_ProcessMgmNwkDiscRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2040          {
   2041            byte x;
   2042            byte status;
   2043            byte networkCount = 0;
   2044            byte startIndex = 0;
   2045            byte networkListCount = 0;
   2046            mgmtNwkDiscItem_t *list = NULL;
   2047          
   2048            byte proVer = NLME_GetProtocolVersion();
   2049          
   2050            status = *msg++;
   2051            if ( status == ZSuccess )
   2052            {
   2053              networkCount = *msg++;
   2054              startIndex = *msg++;
   2055              networkListCount = *msg++;
   2056          
   2057              // Allocate a buffer big enough to handle the list.
   2058              list = (mgmtNwkDiscItem_t *)osal_mem_alloc( networkListCount *
   2059                                                  sizeof( mgmtNwkDiscItem_t ) );
   2060              if ( list )
   2061              {
   2062                mgmtNwkDiscItem_t *pList = list;
   2063                for ( x = 0; x < networkListCount; x++ )
   2064                {
   2065                  if ( proVer == ZB_PROT_V1_0 )  //Version 1.0
   2066                  {
   2067                    pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   2068                    msg += 2;
   2069                  }
   2070                  else
   2071                  {
   2072                    osal_cpyExtAddr(pList->extendedPANID, msg);   //Copy extended PAN ID
   2073                    pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   2074                    msg += Z_EXTADDR_LEN;
   2075          
   2076                  }
   2077                  pList->logicalChannel = *msg++;
   2078                  pList->stackProfile = (*msg) & 0x0F;
   2079                  pList->version = (*msg++ >> 4) & 0x0F;
   2080                  pList->beaconOrder = (*msg) & 0x0F;
   2081                  pList->superFrameOrder = (*msg++ >> 4) & 0x0F;
   2082                  pList->permitJoining = *msg++;
   2083                  pList++;
   2084                }
   2085              }
   2086            }
   2087          
   2088            // Call the callback to the application.
   2089            ZDApp_MgmtNwkDiscRspCB( SrcAddr->addr.shortAddr, status, networkCount,
   2090                                    startIndex, networkListCount, list );
   2091          
   2092            if ( list )
   2093            {
   2094              osal_mem_free( list );
   2095            }
   2096          }
   2097          #endif // ZDO_MGMT_NWKDISC_REQUEST
   2098          
   2099          #if defined ( ZDO_MGMT_RTG_RESPONSE ) && defined ( RTR_NWK )
   2100          /*********************************************************************
   2101           * @fn          ZDO_ProcessMgmtRtgReq
   2102           *
   2103           * @brief       This function finishes the processing of the Management
   2104           *              Routing Request and generates the response.
   2105           *
   2106           *   Note:      This function will limit the number of items returned
   2107           *              to ZDO_MAX_RTG_ITEMS items.
   2108           *
   2109           * @param       ResultCountSrcAddr - source of the request
   2110           * @param       msg - pointer to incoming message
   2111           * @param       SecurityUse -
   2112           *
   2113           * @return      none
   2114           */
   2115          void ZDO_ProcessMgmtRtgReq( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   2116          {
   2117            byte x;
   2118            byte maxNumItems;
   2119            byte numItems;
   2120            byte *pBuf;
   2121            rtgItem_t *pList;
   2122          
   2123            // Get the number of table items
   2124            NLME_GetRequest( nwkNumRoutingTableEntries, 0, &maxNumItems );
   2125          
   2126            numItems = maxNumItems - StartIndex;    // Start at the passed in index
   2127          
   2128            // limit the size of the list
   2129            if ( numItems > ZDO_MAX_RTG_ITEMS )
   2130              numItems = ZDO_MAX_RTG_ITEMS;
   2131          
   2132            // Allocate the memory to build the table
   2133            pBuf = osal_mem_alloc( (short)(sizeof( rtgItem_t ) * numItems) );
   2134          
   2135            if ( pBuf )
   2136            {
   2137              // Convert buffer to list
   2138              pList = (rtgItem_t *)pBuf;
   2139          
   2140              // Loop through items and build list
   2141              for ( x = 0; x < numItems; x++ )
   2142              {
   2143                NLME_GetRequest( nwkRoutingTable, (uint16)(x + StartIndex), (void*)pList );
   2144          
   2145                // Remap the status to the RoutingTableList Record Format defined in the ZigBee spec
   2146                switch( pList->status )
   2147                {
   2148                  case RT_ACTIVE:
   2149                    pList->status = ZDO_MGMT_RTG_ENTRY_ACTIVE;
   2150                    break;
   2151          
   2152                  case RT_DISC:
   2153                    pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY;
   2154                    break;
   2155          
   2156                  case RT_LINK_FAIL:
   2157                    pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED;
   2158          
   2159                  case RT_INIT:
   2160                  case RT_REPAIR:
   2161                  default:
   2162                    pList->status = ZDO_MGMT_RTG_ENTRY_INACTIVE;
   2163                    break;
   2164                }
   2165          
   2166                // Increment pointer to next record
   2167                pList++;
   2168              }
   2169          
   2170              // Send response
   2171              ZDP_MgmtRtgRsp( TransSeq, SrcAddr, ZSuccess, maxNumItems, StartIndex, numItems,
   2172                                    (rtgItem_t *)pBuf, false );
   2173          
   2174              osal_mem_free( pBuf );
   2175            }
   2176          }
   2177          #endif // defined(ZDO_MGMT_RTG_RESPONSE)  && defined(RTR_NWK)
   2178          
   2179          #if defined ( ZDO_MGMT_RTG_REQUEST )
   2180          /*********************************************************************
   2181           * @fn          ZDO_ProcessMgmtRtgRsp
   2182           *
   2183           * @brief       This function handles parsing the incoming Management
   2184           *              Routing response and then generates a callback
   2185           *              to the ZD application.
   2186           *
   2187           * @param       SrcAddr - source of the request
   2188           * @param       msg - buffer holding incoming message to parse
   2189           * @param       SecurityUse -
   2190           *
   2191           * @return      none
   2192           */
   2193          void ZDO_ProcessMgmtRtgRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2194          {
   2195            byte x;
   2196            byte status;
   2197            byte rtgCount = 0;
   2198            byte startIndex = 0;
   2199            byte rtgListCount = 0;
   2200            byte *pBuf = NULL;
   2201            rtgItem_t *pList = NULL;
   2202          
   2203            status = *msg++;
   2204            if ( status == ZSuccess )
   2205            {
   2206              rtgCount = *msg++;
   2207              startIndex = *msg++;
   2208              rtgListCount = *msg++;
   2209          
   2210              // Allocate a buffer big enough to handle the list
   2211              pBuf = osal_mem_alloc( rtgListCount * sizeof( rtgItem_t ) );
   2212              if ( pBuf )
   2213              {
   2214                pList = (rtgItem_t *)pBuf;
   2215                for ( x = 0; x < rtgListCount; x++ )
   2216                {
   2217                  pList->dstAddress = BUILD_UINT16( msg[0], msg[1] );
   2218                  msg += 2;
   2219                  pList->status = *msg++;
   2220                  pList->nextHopAddress = BUILD_UINT16( msg[0], msg[1] );
   2221                  msg += 2;
   2222                  pList++;
   2223                }
   2224              }
   2225            }
   2226          
   2227            // Call the callback to the application.
   2228            ZDApp_MgmtRtgRspCB( SrcAddr->addr.shortAddr, status, rtgCount,
   2229                                           startIndex, rtgListCount, (rtgItem_t *)pBuf );
   2230          
   2231            if ( pBuf )
   2232            {
   2233              osal_mem_free( pBuf );
   2234            }
   2235          }
   2236          #endif // ZDO_MGMT_RTG_REQUEST
   2237          
   2238          #if defined ( ZDO_MGMT_BIND_RESPONSE )
   2239          /*********************************************************************
   2240           * @fn          ZDO_ProcessMgmtBindReq
   2241           *
   2242           * @brief       This function finishes the processing of the Management
   2243           *              Bind Request and generates the response.
   2244           *
   2245           *   Note:      This function will limit the number of items returned
   2246           *              to ZDO_MAX_BIND_ITEMS items.
   2247           *
   2248           * @param       ResultCountSrcAddr - source of the request
   2249           * @param       msg - pointer to incoming message
   2250           * @param       SecurityUse -
   2251           *
   2252           * @return      none
   2253           */
   2254          void ZDO_ProcessMgmtBindReq( byte TransSeq, zAddrType_t *SrcAddr, byte StartIndex, byte SecurityUse )
   2255          {
   2256          #if defined ( REFLECTOR )
   2257            byte x;
   2258            uint16 maxNumItems;
   2259            uint16 numItems;
   2260            byte *pBuf = NULL;
   2261            apsBindingItem_t *pList;
   2262          
   2263            // Get the number of table items
   2264            APSME_GetRequest( apsNumBindingTableEntries, 0, (byte*)(&maxNumItems) );
   2265          
   2266            if ( maxNumItems > StartIndex )
   2267              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   2268            else
   2269              numItems = 0;
   2270          
   2271            // limit the size of the list
   2272            if ( numItems > ZDO_MAX_BIND_ITEMS )
   2273              numItems = ZDO_MAX_BIND_ITEMS;
   2274          
   2275            // Allocate the memory to build the table
   2276            if ( numItems )
   2277              pBuf = osal_mem_alloc( sizeof( apsBindingItem_t ) * numItems );
   2278          
   2279            if ( pBuf )
   2280            {
   2281              // Convert buffer to list
   2282              pList = (apsBindingItem_t *)pBuf;
   2283          
   2284              // Loop through items and build list
   2285              for ( x = 0; x < numItems; x++ )
   2286              {
   2287                APSME_GetRequest( apsBindingTable, (x + StartIndex), (void*)pList );
   2288                pList++;
   2289              }
   2290            }
   2291          
   2292            // Send response
   2293            ZDP_MgmtBindRsp( TransSeq, SrcAddr, ZSuccess, (byte)maxNumItems, StartIndex, (byte)numItems,
   2294                                  (apsBindingItem_t *)pBuf, false );
   2295          
   2296            if ( pBuf )
   2297            {
   2298              osal_mem_free( pBuf );
   2299            }
   2300          #else  // See if app support is needed
   2301          
   2302            ZDApp_MgmtBindReqCB( TransSeq, SrcAddr, StartIndex, SecurityUse );
   2303          
   2304          #endif
   2305          }
   2306          #endif // ZDO_MGMT_BIND_RESPONSE
   2307          
   2308          #if defined ( ZDO_MGMT_BIND_REQUEST )
   2309          /*********************************************************************
   2310           * @fn          ZDO_ProcessMgmtBindRsp
   2311           *
   2312           * @brief       This function handles parsing the incoming Management
   2313           *              Binding response and then generates a callback
   2314           *              to the ZD application.
   2315           *
   2316           * @param       SrcAddr - source of the request
   2317           * @param       msg - buffer holding incoming message to parse
   2318           * @param       SecurityUse -
   2319           *
   2320           * @return      none
   2321           */
   2322          void ZDO_ProcessMgmtBindRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2323          {
   2324            byte x;
   2325            byte status;
   2326            byte bindingCount = 0;
   2327            byte startIndex = 0;
   2328            byte bindingListCount = 0;
   2329            byte *pBuf = NULL;
   2330            apsBindingItem_t *pList = NULL;
   2331          
   2332            status = *msg++;
   2333            if ( status == ZSuccess )
   2334            {
   2335              bindingCount = *msg++;
   2336              startIndex = *msg++;
   2337              bindingListCount = *msg++;
   2338          
   2339              // Allocate a buffer big enough to handle the list
   2340              if ( bindingListCount )
   2341                pBuf = osal_mem_alloc( (short)(bindingListCount * sizeof( apsBindingItem_t )) );
   2342              if ( pBuf )
   2343              {
   2344                pList = (apsBindingItem_t *)pBuf;
   2345                for ( x = 0; x < bindingListCount; x++ )
   2346                {
   2347                  osal_cpyExtAddr( pList->srcAddr, msg );
   2348                  msg += Z_EXTADDR_LEN;
   2349                  pList->srcEP = *msg++;
   2350          
   2351                  // Get the Cluster ID
   2352                  if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
   2353                  {
   2354                    pList->clusterID = BUILD_UINT16( msg[0], msg[1] );
   2355                    msg += 2;
   2356                    pList->dstAddr.addrMode = *msg++;
   2357                    if ( pList->dstAddr.addrMode == Addr64Bit )
   2358                    {
   2359                      osal_cpyExtAddr( pList->dstAddr.addr.extAddr, msg );
   2360                      msg += Z_EXTADDR_LEN;
   2361                      pList->dstEP = *msg++;
   2362                    }
   2363                    else
   2364                    {
   2365                      pList->dstAddr.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   2366                      msg += 2;
   2367                    }
   2368                  }
   2369                  else
   2370                  {
   2371                    pList->clusterID = *msg++;
   2372          
   2373                    osal_cpyExtAddr( pList->dstAddr.addr.extAddr, msg );
   2374                    msg += Z_EXTADDR_LEN;
   2375                    pList->dstEP = *msg++;
   2376                  }
   2377          
   2378                  pList++;
   2379                }
   2380              }
   2381            }
   2382          
   2383            // Call the callback to the application
   2384            ZDApp_MgmtBindRspCB( SrcAddr->addr.shortAddr, status, bindingCount,
   2385                              startIndex, bindingListCount, (apsBindingItem_t *)pBuf );
   2386          
   2387            if ( pBuf )
   2388                osal_mem_free( pBuf );
   2389          }
   2390          #endif // ZDO_MGMT_BIND_REQUEST
   2391          
   2392          #if defined ( ZDO_MGMT_JOINDIRECT_RESPONSE ) && defined ( RTR_NWK )
   2393          /*********************************************************************
   2394           * @fn          ZDO_ProcessMgmtDirectJoinReq
   2395           *
   2396           * @brief       This function finishes the processing of the Management
   2397           *              Direct Join Request and generates the response.
   2398           *
   2399           * @param       SrcAddr - source of the request
   2400           * @param       msg - pointer to incoming message
   2401           * @param       SecurityUse -
   2402           *
   2403           * @return      none
   2404           */
   2405          void ZDO_ProcessMgmtDirectJoinReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2406          {
   2407            byte *deviceAddr;
   2408            byte capInfo;
   2409            byte stat;
   2410          
   2411            // Parse the message
   2412            deviceAddr = msg;
   2413            capInfo = msg[Z_EXTADDR_LEN];
   2414          
   2415            stat = (byte) NLME_DirectJoinRequest( deviceAddr, capInfo );
   2416          
   2417            ZDP_MgmtDirectJoinRsp( TransSeq, SrcAddr, stat, false );
   2418          }
   2419          #endif // ZDO_MGMT_JOINDIRECT_RESPONSE && RTR_NWK
   2420          
   2421          #if defined ( ZDO_MGMT_JOINDIRECT_REQUEST )
   2422          /*********************************************************************
   2423           * @fn          ZDO_ProcessMgmtDirectJoinRsp
   2424           *
   2425           * @brief       This function handles parsing the incoming Management
   2426           *              Direct Join response and then generates a callback
   2427           *              to the ZD application.
   2428           *
   2429           * @param       SrcAddr - source of the request
   2430           * @param       Status - ZSuccess or other for failure
   2431           * @param       SecurityUse -
   2432           *
   2433           * @return      none
   2434           */
   2435          void ZDO_ProcessMgmtDirectJoinRsp( zAddrType_t *SrcAddr, byte Status, byte SecurityUse )
   2436          {
   2437            // Call the callback to the application
   2438            ZDApp_MgmtDirectJoinRspCB( SrcAddr->addr.shortAddr, Status, SecurityUse );
   2439          }
   2440          #endif // ZDO_MGMT_JOINDIRECT_REQUEST
   2441          
   2442          #if defined ( ZDO_MGMT_LEAVE_RESPONSE )
   2443          /*********************************************************************
   2444           * @fn          ZDO_ProcessMgmtLeaveReq
   2445           *
   2446           * @brief       This function processes a Management Leave Request
   2447           *              and generates the response.
   2448           *
   2449           * @param       SrcAddr - source of the request
   2450           * @param       msg - pointer to incoming message
   2451           * @param       SecurityUse -
   2452           *
   2453           * @return      none
   2454           */
   2455          void ZDO_ProcessMgmtLeaveReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2456          {
   2457            NLME_LeaveReq_t req;
   2458            ZStatus_t       status;
   2459          
   2460          
   2461            if ( ( AddrMgrExtAddrValid( msg ) == FALSE                 ) ||
   2462                 ( osal_ExtAddrEqual( msg, NLME_GetExtAddr() ) == TRUE )    )
   2463            {
   2464              // Remove this device
   2465              req.extAddr = NULL;
   2466            }
   2467            else
   2468            {
   2469              // Remove child device
   2470              req.extAddr = msg;
   2471            }
   2472          
   2473            req.removeChildren = FALSE;
   2474            req.rejoin         = FALSE;
   2475            req.silent         = FALSE;
   2476          
   2477            status = NLME_LeaveReq( &req );
   2478          
   2479            ZDP_MgmtLeaveRsp( TransSeq, SrcAddr, status, FALSE );
   2480          }
   2481          #endif // ZDO_MGMT_LEAVE_RESPONSE
   2482          
   2483          #if defined ( ZDO_MGMT_LEAVE_REQUEST )
   2484          /*********************************************************************
   2485           * @fn          ZDO_ProcessMgmtLeaveRsp
   2486           *
   2487           * @brief       This function handles a Management Leave Response
   2488           *              and generates a callback to the ZD application.
   2489           *
   2490           * @param       SrcAddr - source of the request
   2491           * @param       Status - ZSuccess or other for failure
   2492           * @param       SecurityUse -
   2493           *
   2494           * @return      none
   2495           */
   2496          void ZDO_ProcessMgmtLeaveRsp( zAddrType_t *SrcAddr, byte Status, byte SecurityUse )
   2497          {
   2498            // Call the callback to the application
   2499            ZDApp_MgmtLeaveRspCB( SrcAddr->addr.shortAddr, Status, SecurityUse );
   2500          }
   2501          #endif // ZDO_MGMT_LEAVE_REQUEST
   2502          
   2503          #if defined( ZDO_MGMT_PERMIT_JOIN_RESPONSE ) && defined( RTR_NWK )
   2504          /*********************************************************************
   2505           * @fn          ZDO_ProcessMgmtPermitJoinReq
   2506           *
   2507           * @brief       This function processes a Management Permit Join Request
   2508           *              and generates the response.
   2509           *
   2510           * @param       SrcAddr - source of the request
   2511           * @param       msg - pointer to incoming message
   2512           * @param       SecurityUse -
   2513           *
   2514           * @return      none
   2515           */
   2516          void ZDO_ProcessMgmtPermitJoinReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg,
   2517                                             byte SecurityUse )
   2518          {
   2519            uint8 stat;
   2520            uint8 duration;
   2521            uint8 tcsig;
   2522          
   2523          
   2524            duration = msg[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION];
   2525            tcsig    = msg[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG];
   2526          
   2527            // Set the network layer permit join duration
   2528            stat = (byte) NLME_PermitJoiningRequest( duration );
   2529          
   2530            // Handle the Trust Center Significance
   2531            if ( tcsig == TRUE )
   2532            {
   2533              ZDSecMgrPermitJoining( duration );
   2534            }
   2535          
   2536            // Send a response if unicast
   2537            if (SrcAddr->addr.shortAddr != NWK_BROADCAST_SHORTADDR)
   2538            {
   2539              ZDP_MgmtPermitJoinRsp( TransSeq, SrcAddr, stat, false );
   2540            }
   2541          }
   2542          #endif // ZDO_MGMT_PERMIT_JOIN_RESPONSE && defined( RTR_NWK )
   2543          
   2544          /*
   2545           * This function stub allows the next higher layer to be notified of
   2546           * a permit joining timeout.
   2547           */
   2548          #if defined( RTR_NWK )
   2549          /*********************************************************************
   2550           * @fn          ZDO_ProcessMgmtPermitJoinTimeout
   2551           *
   2552           * @brief       This function stub allows the next higher layer to be
   2553           *              notified of a permit joining timeout. Currently, this
   2554           *              directly bypasses the APS layer.
   2555           *
   2556           * @param       none
   2557           *
   2558           * @return      none
   2559           */

   \                                 In segment BANKED_CODE, align 1, keep-with-next
   2560          void ZDO_ProcessMgmtPermitJoinTimeout( void )
   \                     NLME_PermitJoiningTimeout:
   2561          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2562            #if defined( ZDO_MGMT_PERMIT_JOIN_RESPONSE )
   2563            {
   2564              // Currently, only the ZDSecMgr needs to be notified
   2565              ZDSecMgrPermitJoiningTimeout();
   2566            }
   2567            #endif
   2568          }
   \   000000   02....       LJMP    ?BRET

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0
   2569          #endif // defined( RTR_NWK )
   2570          
   2571          #if defined ( ZDO_MGMT_PERMIT_JOIN_REQUEST )
   2572          /*********************************************************************
   2573           * @fn          ZDO_ProcessMgmtPermitJoinRsp
   2574           *
   2575           * @brief       This function handles a Management Permit Join Response
   2576           *              and generates a callback to the ZD application.
   2577           *
   2578           * @param       SrcAddr - source of the request
   2579           * @param       Status - ZSuccess or other for failure
   2580           * @param       SecurityUse -
   2581           *
   2582           * @return      none
   2583           */
   2584          void ZDO_ProcessMgmtPermitJoinRsp( zAddrType_t *SrcAddr, byte Status, byte SecurityUse )
   2585          {
   2586            // Call the callback to the application
   2587            ZDApp_MgmtPermitJoinRspCB( SrcAddr->addr.shortAddr, Status, SecurityUse );
   2588          }
   2589          #endif // ZDO_MGMT_PERMIT_JOIN_REQUEST
   2590          
   2591          #if defined ( ZDO_USERDESC_REQUEST )
   2592          /*********************************************************************
   2593           * @fn          ZDO_ProcessUserDescRsp
   2594           *
   2595           * @brief       This function handles parsing the incoming User
   2596           *              Descriptor Response and then generates a callback
   2597           *              to the ZD application.
   2598           *
   2599           * @param       SrcAddr - source of the request
   2600           * @param       msg - incoming response message
   2601           * @param       SecurityUse -
   2602           *
   2603           * @return      none
   2604           */
   2605          void ZDO_ProcessUserDescRsp( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2606          {
   2607            ZDApp_UserDescRspCB( SrcAddr->addr.shortAddr,
   2608                                msg[0],                           // Status
   2609                                BUILD_UINT16( msg[1], msg[2] ),   // NWKAddrOfInterest
   2610                                msg[3],                           // Length
   2611                                &msg[4],                          // User Descriptor
   2612                                SecurityUse );
   2613          }
   2614          #endif // ZDO_USERDESC_REQUEST
   2615          
   2616          #if defined ( ZDO_USERDESC_RESPONSE )
   2617          /*********************************************************************
   2618           * @fn          ZDO_ProcessUserDescReq
   2619           *
   2620           * @brief       This function finishes the processing of the User
   2621           *              Descriptor Request and generates the response.
   2622           *
   2623           * @param       SrcAddr - source of the request
   2624           * @param       msg - pointer to incoming message
   2625           * @param       SecurityUse -
   2626           *
   2627           * @return      none
   2628           */
   2629          void ZDO_ProcessUserDescReq( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2630          {
   2631            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   2632            UserDescriptorFormat_t userDesc;
   2633          
   2634            if ( (aoi == ZDAppNwkAddr.addr.shortAddr) && (ZSUCCESS == osal_nv_read(
   2635                       ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc )) )
   2636            {
   2637              ZDP_UserDescRsp( TransSeq, SrcAddr, aoi, &userDesc, false );
   2638            }
   2639            else
   2640            {
   2641          #if defined( ZDO_CACHE )
   2642              (void)aoi;
   2643          #else
   2644              ZDP_GenericRsp(
   2645                 TransSeq, SrcAddr, ZDP_NOT_SUPPORTED, aoi, User_Desc_rsp, SecurityUse );
   2646          #endif
   2647            }
   2648          }
   2649          #endif // ZDO_USERDESC_RESPONSE
   2650          
   2651          #if defined ( ZDO_USERDESCSET_REQUEST )
   2652          /*********************************************************************
   2653           * @fn          ZDO_ProcessUserDescConf
   2654           *
   2655           * @brief       This function handles parsing the incoming User
   2656           *              Descriptor Confirm and then generates a callback
   2657           *              to the ZD application.
   2658           *
   2659           * @param       SrcAddr - source of the request
   2660           * @param       msg - incoming response message
   2661           * @param       SecurityUse -
   2662           *
   2663           * @return      none
   2664           */
   2665          void ZDO_ProcessUserDescConf( zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2666          {
   2667            ZDApp_UserDescConfCB( SrcAddr->addr.shortAddr,
   2668                                  msg[0],                           // Status
   2669                                  SecurityUse );
   2670          }
   2671          #endif // ZDO_USERDESCSET_REQUEST
   2672          
   2673          
   2674          #if defined ( ZDO_USERDESCSET_RESPONSE )
   2675          /*********************************************************************
   2676           * @fn          ZDO_ProcessUserDescSet
   2677           *
   2678           * @brief       This function finishes the processing of the User
   2679           *              Descriptor Set and generates the response.
   2680           *
   2681           * @param       SrcAddr - source of the request
   2682           * @param       msg - pointer to incoming message
   2683           * @param       SecurityUse -
   2684           *
   2685           * @return      none
   2686           */
   2687          void ZDO_ProcessUserDescSet( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2688          {
   2689            uint16 aoi = BUILD_UINT16( msg[0], msg[1] );
   2690            UserDescriptorFormat_t userDesc;
   2691            uint8 outMsg[3];
   2692            uint8 status;
   2693            uint16 nai;
   2694          
   2695            nai = BUILD_UINT16( msg[0], msg[1] );
   2696          
   2697            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   2698            {
   2699              if ( NLME_GetProtocolVersion() == ZB_PROT_V1_0 )
   2700                userDesc.len = AF_MAX_USER_DESCRIPTOR_LEN;
   2701              else
   2702              {
   2703                userDesc.len = (msg[2] < AF_MAX_USER_DESCRIPTOR_LEN) ? msg[2] : AF_MAX_USER_DESCRIPTOR_LEN;
   2704                msg ++;  // increment one for the length field
   2705              }
   2706              osal_memcpy( userDesc.desc, &msg[2], userDesc.len );
   2707              osal_nv_write( ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc );
   2708              if ( userDesc.len != 0 )
   2709              {
   2710                ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   2711              }
   2712              else
   2713              {
   2714                ZDO_Config_Node_Descriptor.UserDescAvail = FALSE;
   2715              }
   2716          
   2717              status = ZDP_SUCCESS;
   2718            }
   2719            else
   2720            {
   2721              status =  ZDP_NOT_SUPPORTED;
   2722            }
   2723          
   2724            outMsg[0] = status;
   2725            outMsg[1] = LO_UINT16( nai );
   2726            outMsg[2] = LO_UINT16( nai );
   2727          
   2728            ZDP_SendData( &TransSeq, SrcAddr, User_Desc_conf, 3, outMsg, SecurityUse );
   2729          }
   2730          #endif // ZDO_USERDESCSET_RESPONSE
   2731          
   2732          #if defined ( ZDO_ENDDEVICE_ANNCE ) && defined(RTR_NWK)
   2733          /*********************************************************************
   2734           * @fn          ZDO_ProcessEndDeviceAnnce
   2735           *
   2736           * @brief       This function processes an end device annouce message.
   2737           *
   2738           * @param       SrcAddr - source of the request
   2739           * @param       msg - pointer to incoming message
   2740           * @param       SecurityUse -
   2741           *
   2742           * @return      none
   2743           */
   2744          void ZDO_ProcessEndDeviceAnnce( byte TransSeq, zAddrType_t *SrcAddr, byte *msg, byte SecurityUse )
   2745          {
   2746            uint16 nwkAddr;
   2747            associated_devices_t *dev;
   2748            AddrMgrEntry_t addrEntry;
   2749            uint8 *ieeeAddr;
   2750            uint8 capabilities;
   2751          
   2752            // Parse incoming message
   2753            nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2754            msg += 2;
   2755            ieeeAddr = msg;
   2756            msg += Z_EXTADDR_LEN;
   2757            if ( NLME_GetProtocolVersion() != ZB_PROT_V1_0 )
   2758            {
   2759              capabilities = *msg;
   2760            }
   2761            else
   2762            {
   2763              capabilities = 0;
   2764            }
   2765          
   2766            addrEntry.user = ADDRMGR_USER_DEFAULT;
   2767            addrEntry.nwkAddr = nwkAddr;
   2768            AddrMgrExtAddrSet( addrEntry.extAddr, ieeeAddr );
   2769            AddrMgrEntryUpdate( &addrEntry );
   2770          
   2771            // find device in device list
   2772            dev = AssocGetWithExt( ieeeAddr );
   2773            if ( dev != NULL )
   2774            {
   2775              // if found and address is different
   2776              if ( dev->shortAddr != nwkAddr )
   2777              {
   2778                // update device list if device is (was) not our child
   2779                if ( dev->nodeRelation == NEIGHBOR || dev->nodeRelation == OTHER )
   2780                {
   2781                  dev->shortAddr = nwkAddr;
   2782                }
   2783              }
   2784            }
   2785          
   2786            // Application notification
   2787            ZDApp_EndDeviceAnnounceCB( SrcAddr->addr.shortAddr, nwkAddr, ieeeAddr, capabilities );
   2788          }
   2789          #endif // ZDO_ENDDEVICE_ANNCE
   2790          
   2791          #if defined( ZDO_SIMPLEDESC_REQUEST ) || ( defined( ZDO_CACHE ) && ( CACHE_DEV_MAX > 0 ) )
   2792          /*********************************************************************
   2793           * @fn          ZDO_BuildSimpleDescBuf
   2794           *
   2795           * @brief       Build a byte sequence representation of a Simple Descriptor.
   2796           *
   2797           * @param       buf  - pointer to a byte array big enough for data.
   2798           * @param       desc - SimpleDescriptionFormat_t *
   2799           *
   2800           * @return      none
   2801           */
   2802          void ZDO_BuildSimpleDescBuf( byte *buf, SimpleDescriptionFormat_t *desc )
   2803          {
   2804            byte proVer = NLME_GetProtocolVersion();
   2805            byte cnt;
   2806            uint16 *ptr;
   2807          
   2808            *buf++ = desc->EndPoint;
   2809            *buf++ = HI_UINT16( desc->AppProfId );
   2810            *buf++ = LO_UINT16( desc->AppProfId );
   2811            *buf++ = HI_UINT16( desc->AppDeviceId );
   2812            *buf++ = LO_UINT16( desc->AppDeviceId );
   2813          
   2814            if ( proVer == ZB_PROT_V1_0 )
   2815            {
   2816              *buf++ = (byte)((desc->AppDevVer << 4) | (desc->Reserved));
   2817            }
   2818            else
   2819            {
   2820              *buf++ = (byte)(desc->AppDevVer << 4);
   2821            }
   2822          
   2823            *buf++ = desc->AppNumInClusters;
   2824            ptr = desc->pAppInClusterList;
   2825            for ( cnt = 0; cnt < desc->AppNumInClusters; ptr++, cnt++ )
   2826            {
   2827              *buf++ = HI_UINT16( *ptr );
   2828              *buf++ = LO_UINT16( *ptr );
   2829            }
   2830          
   2831            *buf++ = desc->AppNumOutClusters;
   2832            ptr = desc->pAppOutClusterList;
   2833            for ( cnt = 0; cnt < desc->AppNumOutClusters; ptr++, cnt++ )
   2834            {
   2835              *buf++ = HI_UINT16( *ptr );
   2836              *buf++ = LO_UINT16( *ptr );
   2837            }
   2838          }
   2839          
   2840          /*********************************************************************
   2841           * @fn          ZDO_ParseSimpleDescBuf
   2842           *
   2843           * @brief       Parse a byte sequence representation of a Simple Descriptor.
   2844           *
   2845           * @param       buf  - pointer to a byte array representing a Simple Desc.
   2846           * @param       desc - SimpleDescriptionFormat_t *
   2847           *
   2848           *              This routine allocates storage for the cluster IDs because
   2849           *              they are 16-bit and need to be aligned to be properly processed.
   2850           *              This routine returns non-zero if an allocation fails.
   2851           *
   2852           *              NOTE: This means that the caller or user of the input structure
   2853           *                    is responsible for freeing the memory
   2854           *
   2855           * @return      0: success
   2856           *              1: failure due to malloc failure.
   2857           */
   2858          uint8 ZDO_ParseSimpleDescBuf( byte *buf, SimpleDescriptionFormat_t *desc )
   2859          {
   2860            byte proVer = NLME_GetProtocolVersion();
   2861            uint8 num, i;
   2862          
   2863            desc->EndPoint = *buf++;
   2864            desc->AppProfId = BUILD_UINT16( buf[0], buf[1] );
   2865            buf += 2;
   2866            desc->AppDeviceId = BUILD_UINT16( buf[0], buf[1] );
   2867            buf += 2;
   2868            desc->AppDevVer = *buf >> 4;
   2869          
   2870            if ( proVer == ZB_PROT_V1_0 )
   2871            {
   2872              desc->Reserved = *buf++ &0x0F;
   2873            }
   2874            else
   2875            {
   2876              desc->Reserved = 0;
   2877              buf++;
   2878            }
   2879          
   2880            // move in input cluster list (if any). allocate aligned memory.
   2881            num = desc->AppNumInClusters = *buf++;
   2882            if (num)  {
   2883              if (!(desc->pAppInClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))  {
   2884                // malloc failed. we're done.
   2885                return 1;
   2886              }
   2887              for (i=0; i<num; ++i)  {
   2888                desc->pAppInClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   2889                buf += 2;
   2890              }
   2891            }
   2892          
   2893            // move in output cluster list (if any). allocate aligned memory.
   2894            num = desc->AppNumOutClusters = *buf++;
   2895            if (num)  {
   2896              if (!(desc->pAppOutClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))  {
   2897                // malloc failed. free input cluster list memory if there is any
   2898                if (desc->pAppInClusterList)  {
   2899                  osal_mem_free(desc->pAppInClusterList);
   2900                }
   2901                return 1;
   2902              }
   2903              for (i=0; i<num; ++i)  {
   2904                desc->pAppOutClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   2905                buf += 2;
   2906              }
   2907            }
   2908            return 0;
   2909          }
   2910          #endif
   2911          
   2912          #if defined ( ZDO_COORDINATOR )
   2913          /*********************************************************************
   2914           * @fn      ZDO_MatchEndDeviceBind()
   2915           *
   2916           * @brief
   2917           *
   2918           *   Called to match end device binding requests
   2919           *
   2920           * @param  bindReq  - binding request information
   2921           * @param  SecurityUse - Security enable/disable
   2922           *
   2923           * @return  none
   2924           */
   2925          void ZDO_MatchEndDeviceBind( ZDEndDeviceBind_t *bindReq )
   2926          {
   2927            zAddrType_t dstAddr;
   2928            uint8 sendRsp = FALSE;
   2929            uint8 status;
   2930          
   2931            // Is this the first request?
   2932            if ( matchED == NULL )
   2933            {
   2934              // Create match info structure
   2935              matchED = (ZDMatchEndDeviceBind_t *)osal_mem_alloc( sizeof ( ZDMatchEndDeviceBind_t ) );
   2936              if ( matchED )
   2937              {
   2938                // Clear the structure
   2939                osal_memset( (uint8 *)matchED, 0, sizeof ( ZDMatchEndDeviceBind_t ) );
   2940          
   2941                // Copy the first request's information
   2942                if ( !ZDO_CopyMatchInfo( &(matchED->ed1), bindReq ) )
   2943                {
   2944          
   2945                  status = ZDP_NO_ENTRY;
   2946                  sendRsp = TRUE;
   2947                }
   2948              }
   2949              else
   2950              {
   2951                status = ZDP_NO_ENTRY;
   2952                sendRsp = TRUE;
   2953              }
   2954          
   2955              if ( !sendRsp )
   2956              {
   2957                // Set into the correct state
   2958                matchED->state = ZDMATCH_WAIT_REQ;
   2959          
   2960                // Setup the timeout
   2961                APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   2962              }
   2963            }
   2964            else
   2965            {
   2966                matchED->state = ZDMATCH_SENDING_BINDS;
   2967          
   2968                // Copy the 2nd request's information
   2969                if ( !ZDO_CopyMatchInfo( &(matchED->ed2), bindReq ) )
   2970                {
   2971                  status = ZDP_NO_ENTRY;
   2972                  sendRsp = TRUE;
   2973                }
   2974          
   2975                // Make a source match for ed1
   2976                matchED->ed1numMatched = ZDO_CompareClusterLists(
   2977                            matchED->ed1.numOutClusters, matchED->ed1.outClusters,
   2978                            matchED->ed2.numInClusters, matchED->ed2.inClusters, ZDOBuildBuf );
   2979                if ( matchED->ed1numMatched )
   2980                {
   2981                  // Save the match list
   2982                  matchED->ed1Matched = osal_mem_alloc( (short)(matchED->ed1numMatched * sizeof ( uint16 )) );
   2983                  if ( matchED->ed1Matched )
   2984                  {
   2985                    osal_memcpy( matchED->ed1Matched, ZDOBuildBuf, (matchED->ed1numMatched * sizeof ( uint16 )) );
   2986                  }
   2987                  else
   2988                  {
   2989                    // Allocation error, stop
   2990                    status = ZDP_NO_ENTRY;
   2991                    sendRsp = TRUE;
   2992                  }
   2993                }
   2994          
   2995                // Make a source match for ed2
   2996                matchED->ed2numMatched = ZDO_CompareClusterLists(
   2997                            matchED->ed2.numOutClusters, matchED->ed2.outClusters,
   2998                            matchED->ed1.numInClusters, matchED->ed1.inClusters, ZDOBuildBuf );
   2999                if ( matchED->ed2numMatched )
   3000                {
   3001                  // Save the match list
   3002                  matchED->ed2Matched = osal_mem_alloc( (short)(matchED->ed2numMatched * sizeof ( uint16 )) );
   3003                  if ( matchED->ed2Matched )
   3004                  {
   3005                    osal_memcpy( matchED->ed2Matched, ZDOBuildBuf, (matchED->ed2numMatched * sizeof ( uint16 )) );
   3006                  }
   3007                  else
   3008                  {
   3009                    // Allocation error, stop
   3010                    status = ZDP_NO_ENTRY;
   3011                    sendRsp = TRUE;
   3012                  }
   3013                }
   3014          
   3015                if ( (sendRsp == FALSE) && (matchED->ed1numMatched || matchED->ed2numMatched) )
   3016                {
   3017                  // Do the first unbind/bind state
   3018                  ZDMatchSendState( ZDMATCH_REASON_START, ZDP_SUCCESS, 0 );
   3019                }
   3020                else
   3021                {
   3022                  status = ZDP_NO_MATCH;
   3023                  sendRsp = TRUE;
   3024                }
   3025            }
   3026          
   3027            if ( sendRsp )
   3028            {
   3029              // send response to this requester
   3030              dstAddr.addrMode = Addr16Bit;
   3031              dstAddr.addr.shortAddr = bindReq->srcAddr;
   3032              ZDP_EndDeviceBindRsp( bindReq->TransSeq, &dstAddr, status, bindReq->SecurityUse );
   3033          
   3034              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   3035              {
   3036                // send response to first requester
   3037                dstAddr.addrMode = Addr16Bit;
   3038                dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   3039                ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, status, matchED->ed1.SecurityUse );
   3040              }
   3041          
   3042              // Process ended - release memory used
   3043              ZDO_RemoveMatchMemory();
   3044            }
   3045          }
   3046          
   3047          static void ZDO_RemoveMatchMemory( void )
   3048          {
   3049            if ( matchED )
   3050            {
   3051              if ( matchED->ed2Matched )
   3052                osal_mem_free( matchED->ed2Matched );
   3053              if ( matchED->ed1Matched )
   3054                osal_mem_free( matchED->ed1Matched );
   3055          
   3056              if ( matchED->ed1.inClusters )
   3057                osal_mem_free( matchED->ed1.inClusters );
   3058          
   3059              if ( matchED->ed1.outClusters )
   3060                osal_mem_free( matchED->ed1.outClusters );
   3061          
   3062              if ( matchED->ed2.inClusters )
   3063                osal_mem_free( matchED->ed2.inClusters );
   3064          
   3065              if ( matchED->ed2.outClusters )
   3066                osal_mem_free( matchED->ed2.outClusters );
   3067          
   3068              osal_mem_free( matchED );
   3069          
   3070              matchED = (ZDMatchEndDeviceBind_t *)NULL;
   3071            }
   3072          }
   3073          
   3074          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq )
   3075          {
   3076            uint8 allOK = TRUE;
   3077          
   3078            // Copy bind information into the match info structure
   3079            osal_memcpy( (uint8 *)destReq, srcReq, sizeof ( ZDEndDeviceBind_t ) );
   3080          
   3081            // Copy input cluster IDs
   3082            if ( srcReq->numInClusters )
   3083            {
   3084              destReq->inClusters = osal_mem_alloc( (short)(srcReq->numInClusters * sizeof ( uint16 )) );
   3085              if ( destReq->inClusters )
   3086              {
   3087                // Copy the clusters
   3088                osal_memcpy( (uint8*)(destReq->inClusters), (uint8 *)(srcReq->inClusters),
   3089                                (srcReq->numInClusters * sizeof ( uint16 )) );
   3090              }
   3091              else
   3092                allOK = FALSE;
   3093            }
   3094          
   3095            // Copy output cluster IDs
   3096            if ( srcReq->numOutClusters )
   3097            {
   3098              destReq->outClusters = osal_mem_alloc( (short)(srcReq->numOutClusters * sizeof ( uint16 )) );
   3099              if ( destReq->outClusters )
   3100              {
   3101                // Copy the clusters
   3102                osal_memcpy( (uint8 *)(destReq->outClusters), (uint8 *)(srcReq->outClusters),
   3103                                (srcReq->numOutClusters * sizeof ( uint16 )) );
   3104              }
   3105              else
   3106                allOK = FALSE;
   3107            }
   3108          
   3109            if ( !allOK )
   3110            {
   3111              if ( destReq->inClusters )
   3112                osal_mem_free( destReq->inClusters );
   3113              if ( destReq->outClusters )
   3114                osal_mem_free( destReq->outClusters );
   3115            }
   3116          
   3117            return ( allOK );
   3118          }
   3119          
   3120          static uint8 ZDMatchSendState( uint8 reason, uint8 status, uint8 TransSeq )
   3121          {
   3122            uint8 *dstIEEEAddr;
   3123            uint8 dstEP;
   3124            zAddrType_t dstAddr;
   3125            zAddrType_t destinationAddr;
   3126            uint16 msgType;
   3127            uint16 clusterID;
   3128            ZDEndDeviceBind_t *ed = NULL;
   3129            uint8 rspStatus = ZDP_SUCCESS;
   3130          
   3131            if ( matchED == NULL )
   3132              return ( FALSE );
   3133          
   3134            // Check sequence number
   3135            if ( reason == ZDMATCH_REASON_BIND_RSP || reason == ZDMATCH_REASON_UNBIND_RSP )
   3136            {
   3137              if ( TransSeq != matchED->transSeq )
   3138                return( FALSE ); // ignore the message
   3139            }
   3140          
   3141            // turn off timer
   3142            APS_SetEndDeviceBindTimeout( 0, ZDO_EndDeviceBindMatchTimeoutCB );
   3143          
   3144            if ( reason == ZDMATCH_REASON_TIMEOUT )
   3145            {
   3146              rspStatus = ZDP_TIMEOUT;    // The process will stop
   3147            }
   3148          
   3149            if ( reason == ZDMATCH_REASON_START || reason == ZDMATCH_REASON_BIND_RSP )
   3150            {
   3151              matchED->sending = ZDMATCH_SENDING_UNBIND;
   3152          
   3153              if ( reason == ZDMATCH_REASON_BIND_RSP && status != ZDP_SUCCESS )
   3154              {
   3155                rspStatus = status;
   3156              }
   3157            }
   3158            else if ( reason == ZDMATCH_REASON_UNBIND_RSP )
   3159            {
   3160              if ( status == ZDP_SUCCESS )
   3161              {
   3162                matchED->sending = ZDMATCH_SENDING_UNBIND;
   3163              }
   3164              else
   3165              {
   3166                matchED->sending = ZDMATCH_SENDING_BIND;
   3167              }
   3168            }
   3169          
   3170            if ( reason != ZDMATCH_REASON_START && matchED->sending == ZDMATCH_SENDING_UNBIND )
   3171            {
   3172              // Move to the next cluster ID
   3173              if ( matchED->ed1numMatched )
   3174                matchED->ed1numMatched--;
   3175              else if ( matchED->ed2numMatched )
   3176                matchED->ed2numMatched--;
   3177            }
   3178          
   3179            // What message do we send now
   3180            if ( matchED->ed1numMatched )
   3181            {
   3182              ed = &(matchED->ed1);
   3183              clusterID = matchED->ed1Matched[matchED->ed1numMatched-1];
   3184              dstIEEEAddr = matchED->ed2.ieeeAddr;
   3185              dstEP = matchED->ed2.endpoint;
   3186            }
   3187            else if ( matchED->ed2numMatched )
   3188            {
   3189              ed = &(matchED->ed2);
   3190              clusterID = matchED->ed2Matched[matchED->ed2numMatched-1];
   3191              dstIEEEAddr = matchED->ed1.ieeeAddr;
   3192              dstEP = matchED->ed1.endpoint;
   3193            }
   3194          
   3195            dstAddr.addrMode = Addr16Bit;
   3196          
   3197            // Send the next message
   3198            if ( rspStatus == ZDP_SUCCESS && ed )
   3199            {
   3200              // Send unbind/bind message to source
   3201              if ( matchED->sending == ZDMATCH_SENDING_UNBIND )
   3202                msgType = Unbind_req;
   3203              else
   3204                msgType = Bind_req;
   3205          
   3206              dstAddr.addr.shortAddr = ed->srcAddr;
   3207          
   3208              // Save off the transaction sequence number
   3209              matchED->transSeq = ZDP_TransID;
   3210          
   3211              destinationAddr.addrMode = Addr64Bit;
   3212              osal_cpyExtAddr( destinationAddr.addr.extAddr, dstIEEEAddr );
   3213          
   3214              ZDP_BindUnbindReq( msgType, &dstAddr, ed->ieeeAddr, ed->endpoint, clusterID,
   3215                  &destinationAddr, dstEP, ed->SecurityUse );
   3216          
   3217              // Set timeout for response
   3218              APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   3219            }
   3220            else
   3221            {
   3222              // Send the response messages to requesting devices
   3223              // send response to first requester
   3224              dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   3225              ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, rspStatus, matchED->ed1.SecurityUse );
   3226          
   3227              // send response to second requester
   3228              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   3229              {
   3230                dstAddr.addr.shortAddr = matchED->ed2.srcAddr;
   3231                ZDP_EndDeviceBindRsp( matchED->ed2.TransSeq, &dstAddr, rspStatus, matchED->ed2.SecurityUse );
   3232              }
   3233          
   3234              // Process ended - release memory used
   3235              ZDO_RemoveMatchMemory();
   3236            }
   3237          
   3238            return ( TRUE );
   3239          }
   3240          
   3241          static void ZDO_EndDeviceBindMatchTimeoutCB( void )
   3242          {
   3243            ZDMatchSendState( ZDMATCH_REASON_TIMEOUT, ZDP_TIMEOUT, 0 );
   3244          }
   3245          
   3246          #endif // ZDO_COORDINATOR
   3247          
   3248          /*********************************************************************
   3249          *********************************************************************/
   3250          
   3251          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     NLME_PermitJoiningTimeout          0      0      0
     ZDO_AnyClusterMatches              0      0     44
     ZDO_CreateAlignedUINT16List        0      0     44
       -> osal_mem_alloc                0      0     28
       -> NLME_GetProtocolVersion       0      0     28
     ZDO_EndDeviceTimeoutCB             0      0      0
     ZDO_Init                           2      0      0
       -> NLME_DeviceJoiningInit        4      0      0
       -> ZDSecMgrInit                  4      0      0
     ZDO_ProcessActiveEPReq             0      0     24
       -> afNumEndPoints                0      0     32
       -> afEndPoints                   0      0     32
       -> ZDP_EPRsp                     0      0     46
       -> ZDP_GenericRsp                0      0     40
     ZDO_ProcessBindUnbindRsp           2      0      1
       -> ZDApp_EndDeviceBindRsp        4      0      0
     ZDO_ProcessEPListRsp               0      0     16
       -> ZDApp_MatchDescRspCB          0      0     28
     ZDO_ProcessMatchDescReq            1      0     38
       -> ZDO_CreateAlignedUINT16List
                                        0      0     60
       -> ZDO_CreateAlignedUINT16List
                                        0      0     60
       -> osal_mem_free                 0      0     60
       -> NLME_IsAddressBroadcast       0      0     60
       -> ZDP_EPRsp                     0      0     74
       -> NLME_IsAddressBroadcast       0      0     60
       -> osal_msg_send                 0      0     60
       -> osal_mem_free                 0      0     60
       -> ZDO_AnyClusterMatches         0      0     64
       -> ZDO_AnyClusterMatches         0      0     64
       -> osal_msg_allocate             0      0     60
       -> osal_memcpy                   0      0     66
       -> osal_memcpy                   0      0     66
       -> ZDP_EPRsp                     0      0     74
       -> osal_mem_free                 0      0     60
       -> osal_mem_free                 0      0     60
     ZDO_ProcessNodeDescReq             0      0     17
       -> ZDP_NodeDescMsg               0      0     30
       -> ZDP_GenericRsp                0      0     32
     ZDO_ProcessPowerDescReq            0      0     17
       -> ZDP_PowerDescMsg              0      0     30
       -> ZDP_GenericRsp                0      0     32
     ZDO_ProcessSimpleDescReq           0      0     21
       -> afFindSimpleDesc              0      0     32
       -> ZDP_SimpleDescMsg             0      0     40
       -> osal_mem_free                 0      0     32
     ZDO_StartDevice                    1      0     23
       -> NLME_NetworkDiscoveryRequest
                                        0      0     46
       -> nwk_ScanJoiningOrphan         0      0     46
       -> NLME_OrphanJoinRequest        0      0     46
       -> ZDSecMgrConfig                0      0     46
       -> osal_start_timer              0      0     46
     ZDO_UpdateNwkStatus                1      0     12
       -> NLME_GetShortAddr             0      0     24
       -> NLME_GetExtAddr               0      0     24
       -> osal_msg_allocate             0      0     24
       -> osal_msg_send                 0      0     24


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     ZDOBuildBuf                      52
     ZDO_Init                         20
     ?Subroutine21                     7
     ZDO_StartDevice                 195
     ?Subroutine1                     15
     ?Subroutine22                     5
     ZDO_UpdateNwkStatus             115
     ?Subroutine18                     9
     ?Subroutine10                     4
     ?Subroutine15                    10
     ?Subroutine5                     14
     ZDO_CreateAlignedUINT16List     133
     ?Subroutine24                     5
     ZDO_AnyClusterMatches            99
     ?Subroutine13                     6
     ZDO_ProcessNodeDescReq           94
     ?Subroutine4                     27
     ZDO_ProcessPowerDescReq          96
     ZDO_ProcessSimpleDescReq        189
     ?Subroutine6                      9
     ?Subroutine19                     6
     ?Subroutine0                     13
     ZDO_ProcessActiveEPReq          189
     ?Subroutine25                     5
     ZDO_ProcessMatchDescReq        1154
     ?Subroutine14                     5
     ?Subroutine12                    13
     ?Subroutine11                     4
     ?Subroutine16                     6
     ?Subroutine20                     6
     ?Subroutine23                     5
     ?Subroutine9                      7
     ?Subroutine8                      8
     ?Subroutine17                     5
     ?Subroutine7                      6
     ?Subroutine3                      6
     ?Subroutine2                      9
     ZDO_ProcessEPListRsp            102
     ZDO_ProcessBindUnbindRsp         25
     ZDO_EndDeviceTimeoutCB            3
     NLME_PermitJoiningTimeout         3
     __Constant_0                      4
     ?<Initializer for __Constant_0>
                                       4

 
 2 632 bytes in segment BANKED_CODE
     4 bytes in segment XDATA_I
     4 bytes in segment XDATA_ID
    52 bytes in segment XDATA_Z
 
 2 632 bytes of CODE  memory (+ 4 bytes shared)
    52 bytes of XDATA memory (+ 4 bytes shared)

Errors: none
Warnings: none
